var Rollup = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var clusterize_min = createCommonjsModule(function (module) {
	(function(q,n){module.exports=n();})("Clusterize",function(){function q(b,a,c){return a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c)}function n(b,a,c){return a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c)}function r(b){return "[object Array]"===Object.prototype.toString.call(b)}function m(b,a){return window.getComputedStyle?window.getComputedStyle(a)[b]:
		a.currentStyle[b]}var l=function(){for(var b=3,a=document.createElement("b"),c=a.all||[];a.innerHTML="\x3c!--[if gt IE "+ ++b+"]><i><![endif]--\x3e",c[0];){ }return 4<b?b:document.documentMode}(),x=navigator.platform.toLowerCase().indexOf("mac")+1,p=function(b){if(!(this instanceof p)){ return new p(b); }var a=this,c={rows_in_block:50,blocks_in_cluster:4,tag:null,show_no_data_row:!0,no_data_class:"clusterize-no-data",no_data_text:"No data",keep_parity:!0,callbacks:{}};a.options={};for(var d="rows_in_block blocks_in_cluster show_no_data_row no_data_class no_data_text keep_parity tag callbacks".split(" "),
		f=0,h;h=d[f];f++){ a.options[h]="undefined"!=typeof b[h]&&null!=b[h]?b[h]:c[h]; }c=["scroll","content"];for(f=0;d=c[f];f++){ if(a[d+"_elem"]=b[d+"Id"]?document.getElementById(b[d+"Id"]):b[d+"Elem"],!a[d+"_elem"]){ throw Error("Error! Could not find "+d+" element"); } }a.content_elem.hasAttribute("tabindex")||a.content_elem.setAttribute("tabindex",0);var e=r(b.rows)?b.rows:a.fetchMarkup(),g={};b=a.scroll_elem.scrollTop;a.insertToDOM(e,g);a.scroll_elem.scrollTop=b;var k=!1,m=0,l=!1,t=function(){x&&(l||(a.content_elem.style.pointerEvents=
		"none"),l=!0,clearTimeout(m),m=setTimeout(function(){a.content_elem.style.pointerEvents="auto";l=!1;},50));k!=(k=a.getClusterNum())&&a.insertToDOM(e,g);a.options.callbacks.scrollingProgress&&a.options.callbacks.scrollingProgress(a.getScrollProgress());},u=0,v=function(){clearTimeout(u);u=setTimeout(a.refresh,100);};q("scroll",a.scroll_elem,t);q("resize",window,v);a.destroy=function(b){n("scroll",a.scroll_elem,t);n("resize",window,v);a.html((b?a.generateEmptyRow():e).join(""));};a.refresh=function(b){(a.getRowsHeight(e)||
		b)&&a.update(e);};a.update=function(b){e=r(b)?b:[];b=a.scroll_elem.scrollTop;e.length*a.options.item_height<b&&(k=a.scroll_elem.scrollTop=0);a.insertToDOM(e,g);a.scroll_elem.scrollTop=b;};a.clear=function(){a.update([]);};a.getRowsAmount=function(){return e.length};a.getScrollProgress=function(){return this.options.scroll_top/(e.length*this.options.item_height)*100||0};var w=function(b,c){var d=r(c)?c:[];d.length&&(e="append"==b?e.concat(d):d.concat(e),a.insertToDOM(e,g));};a.append=function(a){w("append",
		a);};a.prepend=function(a){w("prepend",a);};};p.prototype={constructor:p,fetchMarkup:function(){for(var b=[],a=this.getChildNodes(this.content_elem);a.length;){ b.push(a.shift().outerHTML); }return b},exploreEnvironment:function(b,a){var c=this.options;c.content_tag=this.content_elem.tagName.toLowerCase();b.length&&(l&&9>=l&&!c.tag&&(c.tag=b[0].match(/<([^>\s/]*)/)[1].toLowerCase()),1>=this.content_elem.children.length&&(a.data=this.html(b[0]+b[0]+b[0])),c.tag||(c.tag=this.content_elem.children[0].tagName.toLowerCase()),
		this.getRowsHeight(b));},getRowsHeight:function(b){var a=this.options,c=a.item_height;a.cluster_height=0;if(b.length){b=this.content_elem.children;var d=b[Math.floor(b.length/2)];a.item_height=d.offsetHeight;"tr"==a.tag&&"collapse"!=m("borderCollapse",this.content_elem)&&(a.item_height+=parseInt(m("borderSpacing",this.content_elem),10)||0);"tr"!=a.tag&&(b=parseInt(m("marginTop",d),10)||0,d=parseInt(m("marginBottom",d),10)||0,a.item_height+=Math.max(b,d));a.block_height=a.item_height*a.rows_in_block;
		a.rows_in_cluster=a.blocks_in_cluster*a.rows_in_block;a.cluster_height=a.blocks_in_cluster*a.block_height;return c!=a.item_height}},getClusterNum:function(){this.options.scroll_top=this.scroll_elem.scrollTop;return Math.floor(this.options.scroll_top/(this.options.cluster_height-this.options.block_height))||0},generateEmptyRow:function(){var b=this.options;if(!b.tag||!b.show_no_data_row){ return []; }var a=document.createElement(b.tag),c=document.createTextNode(b.no_data_text),d;a.className=b.no_data_class;
		"tr"==b.tag&&(d=document.createElement("td"),d.colSpan=100,d.appendChild(c));a.appendChild(d||c);return [a.outerHTML]},generate:function(b,a){var c=this.options,d=b.length;if(d<c.rows_in_block){ return {top_offset:0,bottom_offset:0,rows_above:0,rows:d?b:this.generateEmptyRow()}; }var f=Math.max((c.rows_in_cluster-c.rows_in_block)*a,0),h=f+c.rows_in_cluster,e=Math.max(f*c.item_height,0),c=Math.max((d-h)*c.item_height,0),d=[],g=f;for(1>e&&g++;f<h;f++){ b[f]&&d.push(b[f]); }return {top_offset:e,bottom_offset:c,
		rows_above:g,rows:d}},renderExtraTag:function(b,a){var c=document.createElement(this.options.tag);c.className=["clusterize-extra-row","clusterize-"+b].join(" ");a&&(c.style.height=a+"px");return c.outerHTML},insertToDOM:function(b,a){this.options.cluster_height||this.exploreEnvironment(b,a);var c=this.generate(b,this.getClusterNum()),d=c.rows.join(""),f=this.checkChanges("data",d,a),h=this.checkChanges("top",c.top_offset,a),e=this.checkChanges("bottom",c.bottom_offset,a),g=this.options.callbacks,
		k=[];f||h?(c.top_offset&&(this.options.keep_parity&&k.push(this.renderExtraTag("keep-parity")),k.push(this.renderExtraTag("top-space",c.top_offset))),k.push(d),c.bottom_offset&&k.push(this.renderExtraTag("bottom-space",c.bottom_offset)),g.clusterWillChange&&g.clusterWillChange(),this.html(k.join("")),"ol"==this.options.content_tag&&this.content_elem.setAttribute("start",c.rows_above),g.clusterChanged&&g.clusterChanged()):e&&(this.content_elem.lastChild.style.height=c.bottom_offset+"px");},html:function(b){var a=
		this.content_elem;if(l&&9>=l&&"tr"==this.options.tag){var c=document.createElement("div");for(c.innerHTML="<table><tbody>"+b+"</tbody></table>";b=a.lastChild;){ a.removeChild(b); }for(c=this.getChildNodes(c.firstChild.firstChild);c.length;){ a.appendChild(c.shift()); }}else { a.innerHTML=b; }},getChildNodes:function(b){b=b.children;for(var a=[],c=0,d=b.length;c<d;c++){ a.push(b[c]); }return a},checkChanges:function(b,a,c){var d=a!=c[b];c[b]=a;return d}};return p});
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.views.ReportFactory = class ReportFactory extends frappe.views.Factory {
		make(route) {
			var _route = ['List', route[1], 'Report'];

			if (route[2]) {
				// custom report
				_route.push(route[2]);
			}

			frappe.set_route(_route);
		}
	};

	var Sortable = createCommonjsModule(function (module) {
	/**!
	 * Sortable
	 * @author	RubaXa   <trash@rubaxa.org>
	 * @author	owenm    <owen23355@gmail.com>
	 * @license MIT
	 */

	(function sortableModule(factory) {

		{
			module.exports = factory();
		}
	})(function sortableFactory() {

		if (typeof window === "undefined" || !window.document) {
			return function sortableError() {
				throw new Error("Sortable.js requires a window with a document");
			};
		}

		var dragEl,
			parentEl,
			ghostEl,
			cloneEl,
			rootEl,
			nextEl,
			lastDownEl,

			scrollEl,
			scrollParentEl,
			scrollCustomFn,

			oldIndex,
			newIndex,

			activeGroup,
			putSortable,

			autoScrolls = [],
			scrolling = false,

			awaitingDragStarted = false,
			ignoreNextClick = false,
			sortables = [],

			pointerElemChangedInterval,
			lastPointerElemX,
			lastPointerElemY,

			tapEvt,
			touchEvt,

			moved,


			lastTarget,
			lastDirection,
			pastFirstInvertThresh = false,
			isCircumstantialInvert = false,
			lastMode, // 'swap' or 'insert'

			targetMoveDistance,


			forRepaintDummy,
			realDragElRect, // dragEl rect after current animation

			/** @const */
			R_SPACE = /\s+/g,

			expando = 'Sortable' + (new Date).getTime(),

			win = window,
			document = win.document,
			parseInt = win.parseInt,
			setTimeout = win.setTimeout,

			$ = win.jQuery || win.Zepto,
			Polymer = win.Polymer,

			captureMode = {
				capture: false,
				passive: false
			},

			IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
			Edge = !!navigator.userAgent.match(/Edge/i),
			// FireFox = !!navigator.userAgent.match(/firefox/i),

			CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',

			// This will not pass for IE9, because IE9 DnD only works on anchors
			supportDraggable = ('draggable' in document.createElement('div')),

			supportCssPointerEvents = (function() {
				// false when <= IE11
				if (IE11OrLess) {
					return false;
				}
				var el = document.createElement('x');
				el.style.cssText = 'pointer-events:auto';
				return el.style.pointerEvents === 'auto';
			})(),

			_silent = false,
			_alignedSilent = false,

			abs = Math.abs,
			min = Math.min,

			savedInputChecked = [],

			_detectDirection = function(el, options) {
				var elCSS = _css(el),
					elWidth = parseInt(elCSS.width),
					child1 = _getChild(el, 0, options),
					child2 = _getChild(el, 1, options),
					firstChildCSS = child1 && _css(child1),
					secondChildCSS = child2 && _css(child2),
					firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + _getRect(child1).width,
					secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + _getRect(child2).width;
				if (elCSS.display === 'flex') {
					return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse'
					? 'vertical' : 'horizontal';
				}
				if (child1 && firstChildCSS.float !== 'none') {
					var touchingSideChild2 = firstChildCSS.float === 'left' ? 'left' : 'right';

					return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ?
						'vertical' : 'horizontal';
				}
				return (child1 &&
					(
						firstChildCSS.display === 'block' ||
						firstChildCSS.display === 'flex' ||
						firstChildCSS.display === 'table' ||
						firstChildCSS.display === 'grid' ||
						firstChildWidth >= elWidth &&
						elCSS[CSSFloatProperty] === 'none' ||
						child2 &&
						elCSS[CSSFloatProperty] === 'none' &&
						firstChildWidth + secondChildWidth > elWidth
					) ?
					'vertical' : 'horizontal'
				);
			},

			/**
			 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
			 * @param  {Number} x      X position
			 * @param  {Number} y      Y position
			 * @return {HTMLElement}   Element of the first found nearest Sortable
			 */
			_detectNearestEmptySortable = function(x, y) {
				for (var i = 0; i < sortables.length; i++) {
					if (sortables[i].children.length) { continue; }

					var rect = _getRect(sortables[i]),
						threshold = sortables[i][expando].options.emptyInsertThreshold,
						insideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),
						insideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);

					if (insideHorizontally && insideVertically) {
						return sortables[i];
					}
				}
			},

			_isClientInRowColumn = function(x, y, el, axis, options) {
				var targetRect = _getRect(el),
					targetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,
					targetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,
					mouseOnOppAxis = axis === 'vertical' ? x : y;

				return targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;
			},

			_isElInRowColumn = function(el1, el2, axis) {
				var el1Rect = el1 === dragEl && realDragElRect || _getRect(el1),
					el2Rect = el2 === dragEl && realDragElRect || _getRect(el2),
					el1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,
					el1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,
					el1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,
					el2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,
					el2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,
					el2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;

				return (
					el1S1Opp === el2S1Opp ||
					el1S2Opp === el2S2Opp ||
					(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)
				);
			},

			_getParentAutoScrollElement = function(el, includeSelf) {
				// skip to window
				if (!el || !el.getBoundingClientRect) { return win; }

				var elem = el;
				var gotSelf = false;
				do {
					// we don't need to get elem css if it isn't even overflowing in the first place (performance)
					if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
						var elemCSS = _css(elem);
						if (
							elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||
							elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')
						) {
							if (!elem || !elem.getBoundingClientRect || elem === document.body) { return win; }

							if (gotSelf || includeSelf) { return elem; }
							gotSelf = true;
						}
					}
				/* jshint boss:true */
				} while (elem = elem.parentNode);

				return win;
			},

			_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl, /**Boolean*/isFallback) {
				// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
				if (options.scroll) {
					var _this = rootEl ? rootEl[expando] : window,
						sens = options.scrollSensitivity,
						speed = options.scrollSpeed,

						x = evt.clientX,
						y = evt.clientY,

						winWidth = window.innerWidth,
						winHeight = window.innerHeight,

						scrollThisInstance = false;

					// Detect scrollEl
					if (scrollParentEl !== rootEl) {
						_clearAutoScrolls();

						scrollEl = options.scroll;
						scrollCustomFn = options.scrollFn;

						if (scrollEl === true) {
							scrollEl = _getParentAutoScrollElement(rootEl, true);
							scrollParentEl = scrollEl;
						}
					}


					var layersOut = 0;
					var currentParent = scrollEl;
					do {
						var	el = currentParent,
							rect = _getRect(el),

							top = rect.top,
							bottom = rect.bottom,
							left = rect.left,
							right = rect.right,

							width = rect.width,
							height = rect.height,

							scrollWidth,
							scrollHeight,

							css,

							vx,
							vy,

							canScrollX,
							canScrollY,

							scrollPosX,
							scrollPosY;


						if (el !== win) {
							scrollWidth = el.scrollWidth;
							scrollHeight = el.scrollHeight;

							css = _css(el);

							canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll');
							canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll');

							scrollPosX = el.scrollLeft;
							scrollPosY = el.scrollTop;
						} else {
							scrollWidth = document.documentElement.scrollWidth;
							scrollHeight = document.documentElement.scrollHeight;

							css = _css(document.documentElement);

							canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll' || css.overflowX === 'visible');
							canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll' || css.overflowY === 'visible');

							scrollPosX = document.documentElement.scrollLeft;
							scrollPosY = document.documentElement.scrollTop;
						}

						vx = canScrollX && (abs(right - x) <= sens && (scrollPosX + width) < scrollWidth) - (abs(left - x) <= sens && !!scrollPosX);

						vy = canScrollY && (abs(bottom - y) <= sens && (scrollPosY + height) < scrollHeight) - (abs(top - y) <= sens && !!scrollPosY);


						if (!autoScrolls[layersOut]) {
							for (var i = 0; i <= layersOut; i++) {
								if (!autoScrolls[i]) {
									autoScrolls[i] = {};
								}
							}
						}

						if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
							autoScrolls[layersOut].el = el;
							autoScrolls[layersOut].vx = vx;
							autoScrolls[layersOut].vy = vy;

							clearInterval(autoScrolls[layersOut].pid);

							if (el && (vx != 0 || vy != 0)) {
								scrollThisInstance = true;
								/* jshint loopfunc:true */
								autoScrolls[layersOut].pid = setInterval((function () {
									// emulate drag over during autoscroll (fallback), emulating native DnD behaviour
									if (isFallback && this.layer === 0) {
										Sortable.active._emulateDragOver(true);
									}
									var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
									var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

									if ('function' === typeof(scrollCustomFn)) {
										if (scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt, touchEvt, autoScrolls[this.layer].el) !== 'continue') {
											return;
										}
									}
									if (autoScrolls[this.layer].el === win) {
										win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
									} else {
										autoScrolls[this.layer].el.scrollTop += scrollOffsetY;
										autoScrolls[this.layer].el.scrollLeft += scrollOffsetX;
									}
								}).bind({layer: layersOut}), 24);
							}
						}
						layersOut++;
					} while (options.bubbleScroll && currentParent !== win && (currentParent = _getParentAutoScrollElement(currentParent, false)));
					scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
				}
			}, 30),

			_clearAutoScrolls = function () {
				autoScrolls.forEach(function(autoScroll) {
					clearInterval(autoScroll.pid);
				});
				autoScrolls = [];
			},

			_prepareGroup = function (options) {
				function toFn(value, pull) {
					return function(to, from, dragEl, evt) {
						var sameGroup = to.options.group.name &&
										from.options.group.name &&
										to.options.group.name === from.options.group.name;

						if (value == null && (pull || sameGroup)) {
							// Default pull value
							// Default pull and put value if same group
							return true;
						} else if (value == null || value === false) {
							return false;
						} else if (pull && value === 'clone') {
							return value;
						} else if (typeof value === 'function') {
							return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
						} else {
							var otherGroup = (pull ? to : from).options.group.name;

							return (value === true ||
							(typeof value === 'string' && value === otherGroup) ||
							(value.join && value.indexOf(otherGroup) > -1));
						}
					};
				}

				var group = {};
				var originalGroup = options.group;

				if (!originalGroup || typeof originalGroup != 'object') {
					originalGroup = {name: originalGroup};
				}

				group.name = originalGroup.name;
				group.checkPull = toFn(originalGroup.pull, true);
				group.checkPut = toFn(originalGroup.put);
				group.revertClone = originalGroup.revertClone;

				options.group = group;
			},

			_checkAlignment = function(evt) {
				if (!dragEl || !dragEl.parentNode) { return; }
				dragEl.parentNode[expando] && dragEl.parentNode[expando]._computeIsAligned(evt);
			},

			_isTrueParentSortable = function(el, target) {
				var trueParent = target;
				while (!trueParent[expando]) {
					trueParent = trueParent.parentNode;
				}

				return el === trueParent;
			},

			_artificalBubble = function(sortable, originalEvt, method) {
				// Artificial IE bubbling
				var nextParent = sortable.parentNode;
				while (nextParent && !nextParent[expando]) {
					nextParent = nextParent.parentNode;
				}

				if (nextParent) {
					nextParent[expando][method](_extend(originalEvt, {
						artificialBubble: true
					}));
				}
			},

			_hideGhostForTarget = function() {
				if (!supportCssPointerEvents && ghostEl) {
					_css(ghostEl, 'display', 'none');
				}
			},

			_unhideGhostForTarget = function() {
				if (!supportCssPointerEvents && ghostEl) {
					_css(ghostEl, 'display', '');
				}
			};


		// #1184 fix - Prevent click event on fallback if dragged but item not changed position
		document.addEventListener('click', function(evt) {
			if (ignoreNextClick) {
				evt.preventDefault();
				evt.stopPropagation && evt.stopPropagation();
				evt.stopImmediatePropagation && evt.stopImmediatePropagation();
				ignoreNextClick = false;
				return false;
			}
		}, true);

		var nearestEmptyInsertDetectEvent = function(evt) {
			evt = evt.touches ? evt.touches[0] : evt;
			if (dragEl) {
				var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

				if (nearest) {
					nearest[expando]._onDragOver({
						clientX: evt.clientX,
						clientY: evt.clientY,
						target: nearest,
						rootEl: nearest
					});
				}
			}
		};
		// We do not want this to be triggered if completed (bubbling canceled), so only define it here
		_on(document, 'dragover', nearestEmptyInsertDetectEvent);
		_on(document, 'mousemove', nearestEmptyInsertDetectEvent);
		_on(document, 'touchmove', nearestEmptyInsertDetectEvent);

		/**
		 * @class  Sortable
		 * @param  {HTMLElement}  el
		 * @param  {Object}       [options]
		 */
		function Sortable(el, options) {
			if (!(el && el.nodeType && el.nodeType === 1)) {
				throw 'Sortable: `el` must be HTMLElement, not ' + {}.toString.call(el);
			}

			this.el = el; // root element
			this.options = options = _extend({}, options);


			// Export instance
			el[expando] = this;

			// Default options
			var defaults = {
				group: null,
				sort: true,
				disabled: false,
				store: null,
				handle: null,
				scroll: true,
				scrollSensitivity: 30,
				scrollSpeed: 10,
				bubbleScroll: true,
				draggable: /[uo]l/i.test(el.nodeName) ? '>li' : '>*',
				swapThreshold: 1, // percentage; 0 <= x <= 1
				invertSwap: false, // invert always
				invertedSwapThreshold: null, // will be set to same as swapThreshold if default
				removeCloneOnHide: true,
				direction: function() {
					return _detectDirection(el, this.options);
				},
				ghostClass: 'sortable-ghost',
				chosenClass: 'sortable-chosen',
				dragClass: 'sortable-drag',
				ignore: 'a, img',
				filter: null,
				preventOnFilter: true,
				animation: 0,
				easing: null,
				setData: function (dataTransfer, dragEl) {
					dataTransfer.setData('Text', dragEl.textContent);
				},
				dropBubble: false,
				dragoverBubble: false,
				dataIdAttr: 'data-id',
				delay: 0,
				touchStartThreshold: parseInt(window.devicePixelRatio, 10) || 1,
				forceFallback: false,
				fallbackClass: 'sortable-fallback',
				fallbackOnBody: false,
				fallbackTolerance: 0,
				fallbackOffset: {x: 0, y: 0},
				supportPointer: Sortable.supportPointer !== false && (
					('PointerEvent' in window) ||
					window.navigator && ('msPointerEnabled' in window.navigator) // microsoft
				),
				emptyInsertThreshold: 5
			};


			// Set default options
			for (var name in defaults) {
				!(name in options) && (options[name] = defaults[name]);
			}

			_prepareGroup(options);

			// Bind all private methods
			for (var fn in this) {
				if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
					this[fn] = this[fn].bind(this);
				}
			}

			// Setup drag mode
			this.nativeDraggable = options.forceFallback ? false : supportDraggable;

			// Bind events
			if (options.supportPointer) {
				_on(el, 'pointerdown', this._onTapStart);
			} else {
				_on(el, 'mousedown', this._onTapStart);
				_on(el, 'touchstart', this._onTapStart);
			}

			if (this.nativeDraggable) {
				_on(el, 'dragover', this);
				_on(el, 'dragenter', this);
			}

			sortables.push(this.el);

			// Restore sorting
			options.store && options.store.get && this.sort(options.store.get(this) || []);
		}

		Sortable.prototype = /** @lends Sortable.prototype */ {
			constructor: Sortable,

			_computeIsAligned: function(evt) {
				var target;

				if (ghostEl && !supportCssPointerEvents) {
					_hideGhostForTarget();
					target = document.elementFromPoint(evt.clientX, evt.clientY);
					_unhideGhostForTarget();
				} else {
					target = evt.target;
				}

				target = _closest(target, this.options.draggable, this.el, false);
				if (_alignedSilent) { return; }
				if (!dragEl || dragEl.parentNode !== this.el) { return; }

				var children = this.el.children;
				for (var i = 0; i < children.length; i++) {
					// Don't change for target in case it is changed to aligned before onDragOver is fired
					if (_closest(children[i], this.options.draggable, this.el, false) && children[i] !== target) {
						children[i].sortableMouseAligned = _isClientInRowColumn(evt.clientX, evt.clientY, children[i], this._getDirection(evt, null), this.options);
					}
				}
				// Used for nulling last target when not in element, nothing to do with checking if aligned
				if (!_closest(target, this.options.draggable, this.el, true)) {
					lastTarget = null;
				}

				_alignedSilent = true;
				setTimeout(function() {
					_alignedSilent = false;
				}, 30);

			},

			_getDirection: function(evt, target) {
				return (typeof this.options.direction === 'function') ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
			},

			_onTapStart: function (/** Event|TouchEvent */evt) {
				if (!evt.cancelable) { return; }
				var _this = this,
					el = this.el,
					options = this.options,
					preventOnFilter = options.preventOnFilter,
					type = evt.type,
					touch = evt.touches && evt.touches[0],
					target = (touch || evt).target,
					originalTarget = evt.target.shadowRoot && ((evt.path && evt.path[0]) || (evt.composedPath && evt.composedPath()[0])) || target,
					filter = options.filter,
					startIndex;

				_saveInputCheckedState(el);


				// IE: Calls events in capture mode if event element is nested. This ensures only correct element's _onTapStart goes through.
				// This process is also done in _onDragOver
				if (IE11OrLess && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
					return;
				}

				// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
				if (dragEl) {
					return;
				}

				if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
					return; // only left button and enabled
				}

				// cancel dnd if original target is content editable
				if (originalTarget.isContentEditable) {
					return;
				}

				target = _closest(target, options.draggable, el, false);

				if (!target) {
					if (IE11OrLess) {
						_artificalBubble(el, evt, '_onTapStart');
					}
					return;
				}

				if (lastDownEl === target) {
					// Ignoring duplicate `down`
					return;
				}

				// Get the index of the dragged element within its parent
				startIndex = _index(target, options.draggable);

				// Check filter
				if (typeof filter === 'function') {
					if (filter.call(this, evt, target, this)) {
						_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
						preventOnFilter && evt.cancelable && evt.preventDefault();
						return; // cancel dnd
					}
				}
				else if (filter) {
					filter = filter.split(',').some(function (criteria) {
						criteria = _closest(originalTarget, criteria.trim(), el, false);

						if (criteria) {
							_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
							return true;
						}
					});

					if (filter) {
						preventOnFilter && evt.cancelable && evt.preventDefault();
						return; // cancel dnd
					}
				}

				if (options.handle && !_closest(originalTarget, options.handle, el, false)) {
					return;
				}

				// Prepare `dragstart`
				this._prepareDragStart(evt, touch, target, startIndex);
			},


			_handleAutoScroll: function(evt, fallback) {
				if (!dragEl || !this.options.scroll) { return; }
				var x = evt.clientX,
					y = evt.clientY,

					elem = document.elementFromPoint(x, y),
					_this = this;

				// IE does not seem to have native autoscroll,
				// Edge's autoscroll seems too conditional,
				// Firefox and Chrome are good
				if (fallback || Edge || IE11OrLess) {
					_autoScroll(evt, _this.options, elem, fallback);

					// Listener for pointer element change
					var ogElemScroller = _getParentAutoScrollElement(elem, true);
					if (
						scrolling &&
						(
							!pointerElemChangedInterval ||
							x !== lastPointerElemX ||
							y !== lastPointerElemY
						)
					) {

						pointerElemChangedInterval && clearInterval(pointerElemChangedInterval);
						// Detect for pointer elem change, emulating native DnD behaviour
						pointerElemChangedInterval = setInterval(function() {
							if (!dragEl) { return; }
							// could also check if scroll direction on newElem changes due to parent autoscrolling
							var newElem = _getParentAutoScrollElement(document.elementFromPoint(x, y), true);
							if (newElem !== ogElemScroller) {
								ogElemScroller = newElem;
								_clearAutoScrolls();
								_autoScroll(evt, _this.options, ogElemScroller, fallback);
							}
						}, 10);
						lastPointerElemX = x;
						lastPointerElemY = y;
					}

				} else {
					// if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
					if (!_this.options.bubbleScroll || _getParentAutoScrollElement(elem, true) === window) {
						_clearAutoScrolls();
						return;
					}
					_autoScroll(evt, _this.options, _getParentAutoScrollElement(elem, false), false);
				}
			},

			_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
				var _this = this,
					el = _this.el,
					options = _this.options,
					ownerDocument = el.ownerDocument,
					dragStartFn;

				if (target && !dragEl && (target.parentNode === el)) {
					rootEl = el;
					dragEl = target;
					parentEl = dragEl.parentNode;
					nextEl = dragEl.nextSibling;
					lastDownEl = target;
					activeGroup = options.group;
					oldIndex = startIndex;

					tapEvt = {
						target: dragEl,
						clientX: (touch || evt).clientX,
						clientY: (touch || evt).clientY
					};

					this._lastX = (touch || evt).clientX;
					this._lastY = (touch || evt).clientY;

					dragEl.style['will-change'] = 'all';
					// undo animation if needed
					dragEl.style.transition = '';
					dragEl.style.transform = '';

					dragStartFn = function () {
						// Delayed drag has been triggered
						// we can re-enable the events: touchmove/mousemove
						_this._disableDelayedDrag();

						// Make the element draggable
						dragEl.draggable = _this.nativeDraggable;

						// Bind the events: dragstart/dragend
						_this._triggerDragStart(evt, touch);

						// Drag start event
						_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);

						// Chosen item
						_toggleClass(dragEl, options.chosenClass, true);
					};

					// Disable "draggable"
					options.ignore.split(',').forEach(function (criteria) {
						_find(dragEl, criteria.trim(), _disableDraggable);
					});

					if (options.supportPointer) {
						_on(ownerDocument, 'pointerup', _this._onDrop);
					} else {
						_on(ownerDocument, 'mouseup', _this._onDrop);
						_on(ownerDocument, 'touchend', _this._onDrop);
						_on(ownerDocument, 'touchcancel', _this._onDrop);
					}

					if (options.delay) {
						// If the user moves the pointer or let go the click or touch
						// before the delay has been reached:
						// disable the delayed drag
						_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
						_on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
						_on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
						options.supportPointer && _on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);

						_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
					} else {
						dragStartFn();
					}
				}
			},

			_delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/e) {
				var touch = e.touches ? e.touches[0] : e;
				if (min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY))
						>= this.options.touchStartThreshold
				) {
					this._disableDelayedDrag();
				}
			},

			_disableDelayedDrag: function () {
				var ownerDocument = this.el.ownerDocument;

				clearTimeout(this._dragStartTimer);
				_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
				_off(ownerDocument, 'touchend', this._disableDelayedDrag);
				_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
				_off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
				_off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
				_off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
			},

			_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
				touch = touch || (evt.pointerType == 'touch' ? evt : null);

				if (!this.nativeDraggable || touch) {
					if (this.options.supportPointer) {
						_on(document, 'pointermove', this._onTouchMove);
					} else if (touch) {
						_on(document, 'touchmove', this._onTouchMove);
					} else {
						_on(document, 'mousemove', this._onTouchMove);
					}
				} else {
					_on(dragEl, 'dragend', this);
					_on(rootEl, 'dragstart', this._onDragStart);
				}

				try {
					if (document.selection) {
						// Timeout neccessary for IE9
						_nextTick(function () {
							document.selection.empty();
						});
					} else {
						window.getSelection().removeAllRanges();
					}
				} catch (err) {
				}
			},

			_dragStarted: function (fallback) {
				awaitingDragStarted = false;
				if (rootEl && dragEl) {
					if (this.nativeDraggable) {
						_on(document, 'dragover', this._handleAutoScroll);
						_on(document, 'dragover', _checkAlignment);
					}
					var options = this.options;

					// Apply effect
					!fallback && _toggleClass(dragEl, options.dragClass, false);
					_toggleClass(dragEl, options.ghostClass, true);

					// In case dragging an animated element
					_css(dragEl, 'transform', '');

					Sortable.active = this;

					fallback && this._appendGhost();

					// Drag start event
					_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);
				} else {
					this._nulling();
				}
			},

			_emulateDragOver: function (bypassLastTouchCheck) {
				if (touchEvt) {
					if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !bypassLastTouchCheck) {
						return;
					}
					this._lastX = touchEvt.clientX;
					this._lastY = touchEvt.clientY;

					_hideGhostForTarget();

					var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
					var parent = target;

					while (target && target.shadowRoot) {
						target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
						parent = target;
					}

					if (parent) {
						do {
							if (parent[expando]) {
								var inserted;

								inserted = parent[expando]._onDragOver({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});

								if (inserted && !this.options.dragoverBubble) {
									break;
								}
							}

							target = parent; // store last element
						}
						/* jshint boss:true */
						while (parent = parent.parentNode);
					}
					dragEl.parentNode[expando]._computeIsAligned(touchEvt);

					_unhideGhostForTarget();
				}
			},


			_onTouchMove: function (/**TouchEvent*/evt) {
				if (tapEvt) {
					var	options = this.options,
						fallbackTolerance = options.fallbackTolerance,
						fallbackOffset = options.fallbackOffset,
						touch = evt.touches ? evt.touches[0] : evt,
						matrix = ghostEl && _matrix(ghostEl),
						scaleX = ghostEl && matrix && matrix.a,
						scaleY = ghostEl && matrix && matrix.d,
						dx = ((touch.clientX - tapEvt.clientX) + fallbackOffset.x) / (scaleX ? scaleX : 1),
						dy = ((touch.clientY - tapEvt.clientY) + fallbackOffset.y) / (scaleY ? scaleY : 1),
						translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';


					// only set the status to dragging, when we are actually dragging
					if (!Sortable.active && !awaitingDragStarted) {
						if (fallbackTolerance &&
							min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
						) {
							return;
						}
						this._onDragStart(evt, true);
					}

					this._handleAutoScroll(touch, true);


					moved = true;
					touchEvt = touch;


					_css(ghostEl, 'webkitTransform', translate3d);
					_css(ghostEl, 'mozTransform', translate3d);
					_css(ghostEl, 'msTransform', translate3d);
					_css(ghostEl, 'transform', translate3d);

					evt.cancelable && evt.preventDefault();
				}
			},

			_appendGhost: function () {
				if (!ghostEl) {
					var rect = _getRect(dragEl, this.options.fallbackOnBody ? document.body : rootEl, true),
						css = _css(dragEl),
						options = this.options;

					ghostEl = dragEl.cloneNode(true);

					_toggleClass(ghostEl, options.ghostClass, false);
					_toggleClass(ghostEl, options.fallbackClass, true);
					_toggleClass(ghostEl, options.dragClass, true);

					_css(ghostEl, 'box-sizing', 'border-box');
					_css(ghostEl, 'margin', 0);
					_css(ghostEl, 'top', rect.top);
					_css(ghostEl, 'left', rect.left);
					_css(ghostEl, 'width', rect.width);
					_css(ghostEl, 'height', rect.height);
					_css(ghostEl, 'opacity', '0.8');
					_css(ghostEl, 'position', 'fixed');
					_css(ghostEl, 'zIndex', '100000');
					_css(ghostEl, 'pointerEvents', 'none');

					options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
				}
			},

			_onDragStart: function (/**Event*/evt, /**boolean*/fallback) {
				var _this = this;
				var dataTransfer = evt.dataTransfer;
				var options = _this.options;

				// Setup clone
				cloneEl = _clone(dragEl);

				cloneEl.draggable = false;
				cloneEl.style['will-change'] = '';

				this._hideClone();

				_toggleClass(cloneEl, _this.options.chosenClass, false);


				// #1143: IFrame support workaround
				_this._cloneId = _nextTick(function () {
					if (!_this.options.removeCloneOnHide) {
						rootEl.insertBefore(cloneEl, dragEl);
					}
					_dispatchEvent(_this, rootEl, 'clone', dragEl);
				});


				!fallback && _toggleClass(dragEl, options.dragClass, true);

				// Set proper drop events
				if (fallback) {
					ignoreNextClick = true;
					_this._loopId = setInterval(_this._emulateDragOver, 50);
				} else {
					// Undo what was set in _prepareDragStart before drag started
					_off(document, 'mouseup', _this._onDrop);
					_off(document, 'touchend', _this._onDrop);
					_off(document, 'touchcancel', _this._onDrop);

					if (dataTransfer) {
						dataTransfer.effectAllowed = 'move';
						options.setData && options.setData.call(_this, dataTransfer, dragEl);
					}

					_on(document, 'drop', _this);

					// #1276 fix:
					_css(dragEl, 'transform', 'translateZ(0)');
				}

				awaitingDragStarted = true;

				_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback));
				_on(document, 'selectstart', _this);
			},

			// Returns true - if no further action is needed (either inserted or another condition)
			_onDragOver: function (/**Event*/evt) {
				var el = this.el,
					target = evt.target,
					dragRect,
					targetRect,
					revert,
					options = this.options,
					group = options.group,
					activeSortable = Sortable.active,
					isOwner = (activeGroup === group),
					canSort = options.sort,
					_this = this;

				if (_silent) { return; }

				// IE event order fix
				if (IE11OrLess && !evt.rootEl && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
					return;
				}

				// Return invocation when no further action is needed in another sortable
				function completed() {
					if (activeSortable) {
						// Set ghost class to new sortable's ghost class
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
						_toggleClass(dragEl, options.ghostClass, true);
					}

					if (putSortable !== _this && _this !== Sortable.active) {
						putSortable = _this;
					} else if (_this === Sortable.active) {
						putSortable = null;
					}


					// Null lastTarget if it is not inside a previously swapped element
					if ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {
						lastTarget = null;
					}
					// no bubbling and not fallback
					if (!options.dragoverBubble && !evt.rootEl && target !== document) {
						_this._handleAutoScroll(evt);
						dragEl.parentNode[expando]._computeIsAligned(evt);
					}

					!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();

					return true;
				}

				// Call when dragEl has been inserted
				function changed() {
					_dispatchEvent(_this, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl, options.draggable), evt);
				}


				if (evt.preventDefault !== void 0) {
					evt.cancelable && evt.preventDefault();
				}


				moved = true;

				target = _closest(target, options.draggable, el, true);

				// target is dragEl or target is animated
				if (!!_closest(evt.target, null, dragEl, true) || target.animated) {
					return completed();
				}

				if (target !== dragEl) {
					ignoreNextClick = false;
				}

				if (activeSortable && !options.disabled &&
					(isOwner
						? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
						: (
							putSortable === this ||
							(
								(this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
								group.checkPut(this, activeSortable, dragEl, evt)
							)
						)
					)
				) {
					var axis = this._getDirection(evt, target);

					dragRect = _getRect(dragEl);

					if (revert) {
						this._hideClone();
						parentEl = rootEl; // actualization

						if (nextEl) {
							rootEl.insertBefore(dragEl, nextEl);
						} else {
							rootEl.appendChild(dragEl);
						}

						return completed();
					}

					if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
						_ghostIsLast(evt, axis, el) && !dragEl.animated
					) {
						//assign target only if condition is true
						if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
							target = _lastChild(el);
						}

						if (target) {
							targetRect = _getRect(target);
						}

						if (isOwner) {
							activeSortable._hideClone();
						} else {
							activeSortable._showClone(this);
						}

						if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
							realDragElRect = null;

							changed();
							this._animate(dragRect, dragEl);
							target && this._animate(targetRect, target);
							return completed();
						}
					}
					else if (target && target !== dragEl && target.parentNode === el) {
						var direction = 0,
							targetBeforeFirstSwap,
							aligned = target.sortableMouseAligned,
							differentLevel = dragEl.parentNode !== el,
							scrolledPastTop = _isScrolledPast(target, axis === 'vertical' ? 'top' : 'left');

						if (lastTarget !== target) {
							lastMode = null;
							targetBeforeFirstSwap = _getRect(target)[axis === 'vertical' ? 'top' : 'left'];
							pastFirstInvertThresh = false;
						}

						// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0
						if (
							_isElInRowColumn(dragEl, target, axis) && aligned ||
							differentLevel ||
							scrolledPastTop ||
							options.invertSwap ||
							lastMode === 'insert' ||
							// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside
							// and lastMode will change to 'insert', but we must swap
							lastMode === 'swap'
						) {
							// New target that we will be inside
							if (lastMode !== 'swap') {
								isCircumstantialInvert = options.invertSwap || differentLevel || scrolling || scrolledPastTop;
							}

							direction = _getSwapDirection(evt, target, axis,
								options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,
								isCircumstantialInvert,
								lastTarget === target);
							lastMode = 'swap';
						} else {
							// Insert at position
							direction = _getInsertDirection(target, options);
							lastMode = 'insert';
						}
						if (direction === 0) { return completed(); }

						realDragElRect = null;
						lastTarget = target;

						lastDirection = direction;

						targetRect = _getRect(target);

						var nextSibling = target.nextElementSibling,
							after = false;

						after = direction === 1;

						var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

						if (moveVector !== false) {
							if (moveVector === 1 || moveVector === -1) {
								after = (moveVector === 1);
							}

							_silent = true;
							setTimeout(_unsilent, 30);

							if (isOwner) {
								activeSortable._hideClone();
							} else {
								activeSortable._showClone(this);
							}

							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
							}

							parentEl = dragEl.parentNode; // actualization

							// must be done before animation
							if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
								targetMoveDistance = abs(targetBeforeFirstSwap - _getRect(target)[axis === 'vertical' ? 'top' : 'left']);
							}
							changed();
							!differentLevel && this._animate(targetRect, target);
							this._animate(dragRect, dragEl);

							return completed();
						}
					}

					if (el.contains(dragEl)) {
						return completed();
					}
				}

				if (IE11OrLess && !evt.rootEl) {
					_artificalBubble(el, evt, '_onDragOver');
				}

				return false;
			},

			_animate: function (prevRect, target) {
				var ms = this.options.animation;

				if (ms) {
					var currentRect = _getRect(target);

					if (target === dragEl) {
						realDragElRect = currentRect;
					}

					if (prevRect.nodeType === 1) {
						prevRect = _getRect(prevRect);
					}

					// Check if actually moving position
					if ((prevRect.left + prevRect.width / 2) !== (currentRect.left + currentRect.width / 2)
						|| (prevRect.top + prevRect.height / 2) !== (currentRect.top + currentRect.height / 2)
					) {
						var matrix = _matrix(this.el),
							scaleX = matrix && matrix.a,
							scaleY = matrix && matrix.d;

						_css(target, 'transition', 'none');
						_css(target, 'transform', 'translate3d('
							+ (prevRect.left - currentRect.left) / (scaleX ? scaleX : 1) + 'px,'
							+ (prevRect.top - currentRect.top) / (scaleY ? scaleY : 1) + 'px,0)'
						);

						forRepaintDummy = target.offsetWidth; // repaint
						_css(target, 'transition', 'transform ' + ms + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
						_css(target, 'transform', 'translate3d(0,0,0)');
					}

					(typeof target.animated === 'number') && clearTimeout(target.animated);
					target.animated = setTimeout(function () {
						_css(target, 'transition', '');
						_css(target, 'transform', '');
						target.animated = false;
					}, ms);
				}
			},

			_offUpEvents: function () {
				var ownerDocument = this.el.ownerDocument;

				_off(document, 'touchmove', this._onTouchMove);
				_off(document, 'pointermove', this._onTouchMove);
				_off(ownerDocument, 'mouseup', this._onDrop);
				_off(ownerDocument, 'touchend', this._onDrop);
				_off(ownerDocument, 'pointerup', this._onDrop);
				_off(ownerDocument, 'touchcancel', this._onDrop);
				_off(document, 'selectstart', this);
			},

			_onDrop: function (/**Event*/evt) {
				var el = this.el,
					options = this.options;
				awaitingDragStarted = false;
				scrolling = false;
				isCircumstantialInvert = false;
				pastFirstInvertThresh = false;

				clearInterval(this._loopId);

				clearInterval(pointerElemChangedInterval);
				_clearAutoScrolls();
				_cancelThrottle();

				clearTimeout(this._dragStartTimer);

				_cancelNextTick(this._cloneId);
				_cancelNextTick(this._dragStartId);

				// Unbind events
				_off(document, 'mousemove', this._onTouchMove);


				if (this.nativeDraggable) {
					_off(document, 'drop', this);
					_off(el, 'dragstart', this._onDragStart);
					_off(document, 'dragover', this._handleAutoScroll);
					_off(document, 'dragover', _checkAlignment);
				}

				this._offUpEvents();

				if (evt) {
					if (moved) {
						evt.cancelable && evt.preventDefault();
						!options.dropBubble && evt.stopPropagation();
					}

					ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

					if (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {
						// Remove clone
						cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
					}

					if (dragEl) {
						if (this.nativeDraggable) {
							_off(dragEl, 'dragend', this);
						}

						_disableDraggable(dragEl);
						dragEl.style['will-change'] = '';

						// Remove class's
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
						_toggleClass(dragEl, this.options.chosenClass, false);

						// Drag stop event
						_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, evt);

						if (rootEl !== parentEl) {
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// Add event
								_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

								// Remove event
								_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

								// drag from one list and drop into another
								_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
							}

							putSortable && putSortable.save();
						}
						else {
							if (dragEl.nextSibling !== nextEl) {
								// Get the index of the dragged element within its parent
								newIndex = _index(dragEl, options.draggable);

								if (newIndex >= 0) {
									// drag & drop within the same list
									_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
									_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								}
							}
						}

						if (Sortable.active) {
							/* jshint eqnull:true */
							if (newIndex == null || newIndex === -1) {
								newIndex = oldIndex;
							}

							_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

							// Save sorting
							this.save();
						}
					}

				}
				this._nulling();
			},

			_nulling: function() {
				rootEl =
				dragEl =
				parentEl =
				ghostEl =
				nextEl =
				cloneEl =
				lastDownEl =

				scrollEl =
				scrollParentEl =
				autoScrolls.length =

				pointerElemChangedInterval =
				lastPointerElemX =
				lastPointerElemY =

				tapEvt =
				touchEvt =

				moved =
				newIndex =
				oldIndex =

				lastTarget =
				lastDirection =

				forRepaintDummy =
				realDragElRect =

				putSortable =
				activeGroup =
				Sortable.active = null;

				savedInputChecked.forEach(function (el) {
					el.checked = true;
				});

				savedInputChecked.length = 0;
			},

			handleEvent: function (/**Event*/evt) {
				switch (evt.type) {
					case 'drop':
					case 'dragend':
						this._onDrop(evt);
						break;

					case 'dragenter':
					case 'dragover':
						if (dragEl) {
							this._onDragOver(evt);
							_globalDragOver(evt);
						}
						break;

					case 'selectstart':
						evt.preventDefault();
						break;
				}
			},


			/**
			 * Serializes the item into an array of string.
			 * @returns {String[]}
			 */
			toArray: function () {
				var order = [],
					el,
					children = this.el.children,
					i = 0,
					n = children.length,
					options = this.options;

				for (; i < n; i++) {
					el = children[i];
					if (_closest(el, options.draggable, this.el, false)) {
						order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
					}
				}

				return order;
			},


			/**
			 * Sorts the elements according to the array.
			 * @param  {String[]}  order  order of the items
			 */
			sort: function (order) {
				var items = {}, rootEl = this.el;

				this.toArray().forEach(function (id, i) {
					var el = rootEl.children[i];

					if (_closest(el, this.options.draggable, rootEl, false)) {
						items[id] = el;
					}
				}, this);

				order.forEach(function (id) {
					if (items[id]) {
						rootEl.removeChild(items[id]);
						rootEl.appendChild(items[id]);
					}
				});
			},


			/**
			 * Save the current sorting
			 */
			save: function () {
				var store = this.options.store;
				store && store.set && store.set(this);
			},


			/**
			 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
			 * @param   {HTMLElement}  el
			 * @param   {String}       [selector]  default: `options.draggable`
			 * @returns {HTMLElement|null}
			 */
			closest: function (el, selector) {
				return _closest(el, selector || this.options.draggable, this.el, false);
			},


			/**
			 * Set/get option
			 * @param   {string} name
			 * @param   {*}      [value]
			 * @returns {*}
			 */
			option: function (name, value) {
				var options = this.options;

				if (value === void 0) {
					return options[name];
				} else {
					options[name] = value;

					if (name === 'group') {
						_prepareGroup(options);
					}
				}
			},


			/**
			 * Destroy
			 */
			destroy: function () {
				var el = this.el;

				el[expando] = null;

				_off(el, 'mousedown', this._onTapStart);
				_off(el, 'touchstart', this._onTapStart);
				_off(el, 'pointerdown', this._onTapStart);

				if (this.nativeDraggable) {
					_off(el, 'dragover', this);
					_off(el, 'dragenter', this);
				}
				// Remove draggable attributes
				Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
					el.removeAttribute('draggable');
				});

				this._onDrop();

				sortables.splice(sortables.indexOf(this.el), 1);

				this.el = el = null;
			},

			_hideClone: function() {
				if (!cloneEl.cloneHidden) {
					_css(cloneEl, 'display', 'none');
					cloneEl.cloneHidden = true;
					if (cloneEl.parentNode && this.options.removeCloneOnHide) {
						cloneEl.parentNode.removeChild(cloneEl);
					}
				}
			},

			_showClone: function(putSortable) {
				if (putSortable.lastPutMode !== 'clone') {
					this._hideClone();
					return;
				}

				if (cloneEl.cloneHidden) {
					// show clone at dragEl or original position
					if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
						rootEl.insertBefore(cloneEl, dragEl);
					} else if (nextEl) {
						rootEl.insertBefore(cloneEl, nextEl);
					} else {
						rootEl.appendChild(cloneEl);
					}

					if (this.options.group.revertClone) {
						this._animate(dragEl, cloneEl);
					}
					_css(cloneEl, 'display', '');
					cloneEl.cloneHidden = false;
				}
			}
		};

		function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
			if (el) {
				ctx = ctx || document;

				do {
					if (
						selector != null &&
						(
							selector[0] === '>' && el.parentNode === ctx && _matches(el, selector.substring(1)) ||
							_matches(el, selector)
						) ||
						includeCTX && el === ctx
					) {
						return el;
					}

					if (el === ctx) { break; }
					/* jshint boss:true */
				} while (el = _getParentOrHost(el));
			}

			return null;
		}


		function _getParentOrHost(el) {
			return (el.host && el !== document && el.host.nodeType)
				? el.host
				: el.parentNode;
		}


		function _globalDragOver(/**Event*/evt) {
			if (evt.dataTransfer) {
				evt.dataTransfer.dropEffect = 'move';
			}
			evt.cancelable && evt.preventDefault();
		}


		function _on(el, event, fn) {
			el.addEventListener(event, fn, captureMode);
		}


		function _off(el, event, fn) {
			el.removeEventListener(event, fn, captureMode);
		}


		function _toggleClass(el, name, state) {
			if (el && name) {
				if (el.classList) {
					el.classList[state ? 'add' : 'remove'](name);
				}
				else {
					var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
					el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
				}
			}
		}


		function _css(el, prop, val) {
			var style = el && el.style;

			if (style) {
				if (val === void 0) {
					if (document.defaultView && document.defaultView.getComputedStyle) {
						val = document.defaultView.getComputedStyle(el, '');
					}
					else if (el.currentStyle) {
						val = el.currentStyle;
					}

					return prop === void 0 ? val : val[prop];
				}
				else {
					if (!(prop in style) && prop.indexOf('webkit') === -1) {
						prop = '-webkit-' + prop;
					}

					style[prop] = val + (typeof val === 'string' ? '' : 'px');
				}
			}
		}

		function _matrix(el) {
			var appliedTransforms = '';
			do {
				var transform = _css(el, 'transform');

				if (transform && transform !== 'none') {
					appliedTransforms = transform + ' ' + appliedTransforms;
				}
				/* jshint boss:true */
			} while (el = el.parentNode);

			if (window.DOMMatrix) {
				return new DOMMatrix(appliedTransforms);
			} else if (window.WebKitCSSMatrix) {
				return new WebKitCSSMatrix(appliedTransforms);
			} else if (window.CSSMatrix) {
				return new CSSMatrix(appliedTransforms);
			}
		}


		function _find(ctx, tagName, iterator) {
			if (ctx) {
				var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

				if (iterator) {
					for (; i < n; i++) {
						iterator(list[i], i);
					}
				}

				return list;
			}

			return [];
		}



		function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex, originalEvt) {
			sortable = (sortable || rootEl[expando]);
			var evt,
				options = sortable.options,
				onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
			// Support for new CustomEvent feature
			if (window.CustomEvent && !IE11OrLess && !Edge) {
				evt = new CustomEvent(name, {
					bubbles: true,
					cancelable: true
				});
			} else {
				evt = document.createEvent('Event');
				evt.initEvent(name, true, true);
			}

			evt.to = toEl || rootEl;
			evt.from = fromEl || rootEl;
			evt.item = targetEl || rootEl;
			evt.clone = cloneEl;

			evt.oldIndex = startIndex;
			evt.newIndex = newIndex;

			evt.originalEvent = originalEvt;

			if (rootEl) {
				rootEl.dispatchEvent(evt);
		        }

			if (options[onName]) {
				options[onName].call(sortable, evt);
			}
		}


		function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
			var evt,
				sortable = fromEl[expando],
				onMoveFn = sortable.options.onMove,
				retVal;
			// Support for new CustomEvent feature
			if (window.CustomEvent && !IE11OrLess && !Edge) {
				evt = new CustomEvent('move', {
					bubbles: true,
					cancelable: true
				});
			} else {
				evt = document.createEvent('Event');
				evt.initEvent('move', true, true);
			}

			evt.to = toEl;
			evt.from = fromEl;
			evt.dragged = dragEl;
			evt.draggedRect = dragRect;
			evt.related = targetEl || toEl;
			evt.relatedRect = targetRect || _getRect(toEl);
			evt.willInsertAfter = willInsertAfter;

			evt.originalEvent = originalEvt;

			fromEl.dispatchEvent(evt);

			if (onMoveFn) {
				retVal = onMoveFn.call(sortable, evt, originalEvt);
			}

			return retVal;
		}

		function _disableDraggable(el) {
			el.draggable = false;
		}

		function _unsilent() {
			_silent = false;
		}

		/**
		 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
		 * and non-draggable elements
		 * @param  {HTMLElement} el       The parent element
		 * @param  {Number} childNum      The index of the child
		 * @param  {Object} options       Parent Sortable's options
		 * @return {HTMLElement}          The child at index childNum, or null if not found
		 */
		function _getChild(el, childNum, options) {
			var currentChild = 0,
				i = 0,
				children = el.children;

			while (i < children.length) {
				if (
					children[i].style.display !== 'none' &&
					children[i] !== ghostEl &&
					children[i] !== dragEl &&
					_closest(children[i], options.draggable, el, false)
				) {
					if (currentChild === childNum) {
						return children[i];
					}
					currentChild++;
				}

				i++;
			}
			return null;
		}

		/**
		 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
		 * @param  {HTMLElement} el       Parent element
		 * @return {HTMLElement}          The last child, ignoring ghostEl
		 */
		function _lastChild(el) {
			var last = el.lastElementChild;

			while (last === ghostEl || last.style.display === 'none') {
				last = last.previousElementSibling;

				if (!last) { break; }
			}

			return last || null;
		}

		function _ghostIsLast(evt, axis, el) {
			var elRect = _getRect(_lastChild(el)),
				mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
				mouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,
				targetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,
				targetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,
				targetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,
				spacer = 10;

			return (
				axis === 'vertical' ?
					(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :
					(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)
			);
		}

		function _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
			var targetRect = _getRect(target),
				mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
				targetLength = axis === 'vertical' ? targetRect.height : targetRect.width,
				targetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,
				targetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,
				dragRect = _getRect(dragEl),
				invert = false;


			if (!invertSwap) {
				// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
				if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
					// check if past first invert threshold on side opposite of lastDirection
					if (!pastFirstInvertThresh &&
						(lastDirection === 1 ?
							(
								mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2
							) :
							(
								mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2
							)
						)
					)
					{
						// past first invert threshold, do not restrict inverted threshold to dragEl shadow
						pastFirstInvertThresh = true;
					}

					if (!pastFirstInvertThresh) {
						var dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,
							dragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;
						// dragEl shadow (target move distance shadow)
						if (
							lastDirection === 1 ?
							(
								mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
							) :
							(
								mouseOnAxis > targetS2 - targetMoveDistance
							)
						)
						{
							return lastDirection * -1;
						}
					} else {
						invert = true;
					}
				} else {
					// Regular
					if (
						mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&
						mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)
					) {
						return ((mouseOnAxis > targetS1 + targetLength / 2) ? -1 : 1);
					}
				}
			}

			invert = invert || invertSwap;

			if (invert) {
				// Invert of regular
				if (
					mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||
					mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)
				)
				{
					return ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);
				}
			}

			return 0;
		}

		/**
		 * Gets the direction dragEl must be swapped relative to target in order to make it
		 * seem that dragEl has been "inserted" into that element's position
		 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
		 * @param  {Object} options           options of the parent sortable
		 * @return {Number}                   Direction dragEl must be swapped
		 */
		function _getInsertDirection(target, options) {
			var dragElIndex = _index(dragEl, options.draggable),
				targetIndex = _index(target, options.draggable);

			if (dragElIndex < targetIndex) {
				return 1;
			} else {
				return -1;
			}
		}


		/**
		 * Generate id
		 * @param   {HTMLElement} el
		 * @returns {String}
		 * @private
		 */
		function _generateId(el) {
			var str = el.tagName + el.className + el.src + el.href + el.textContent,
				i = str.length,
				sum = 0;

			while (i--) {
				sum += str.charCodeAt(i);
			}

			return sum.toString(36);
		}

		/**
		 * Returns the index of an element within its parent for a selected set of
		 * elements
		 * @param  {HTMLElement} el
		 * @param  {selector} selector
		 * @return {number}
		 */
		function _index(el, selector) {
			var index = 0;

			if (!el || !el.parentNode) {
				return -1;
			}

			while (el && (el = el.previousElementSibling)) {
				if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== cloneEl) {
					index++;
				}
			}

			return index;
		}

		function _matches(/**HTMLElement*/el, /**String*/selector) {
			if (el) {
				try {
					if (el.matches) {
						return el.matches(selector);
					} else if (el.msMatchesSelector) {
						return el.msMatchesSelector(selector);
					} else if (el.webkitMatchesSelector) {
						return el.webkitMatchesSelector(selector);
					}
				} catch(_) {
					return false;
				}
			}

			return false;
		}

		var _throttleTimeout;
		function _throttle(callback, ms) {
			return function () {
				if (!_throttleTimeout) {
					var args = arguments,
						_this = this;

					_throttleTimeout = setTimeout(function () {
						if (args.length === 1) {
							callback.call(_this, args[0]);
						} else {
							callback.apply(_this, args);
						}

						_throttleTimeout = void 0;
					}, ms);
				}
			};
		}

		function _cancelThrottle() {
			clearTimeout(_throttleTimeout);
			_throttleTimeout = void 0;
		}

		function _extend(dst, src) {
			if (dst && src) {
				for (var key in src) {
					if (src.hasOwnProperty(key)) {
						dst[key] = src[key];
					}
				}
			}

			return dst;
		}

		function _clone(el) {
			if (Polymer && Polymer.dom) {
				return Polymer.dom(el).cloneNode(true);
			}
			else if ($) {
				return $(el).clone(true)[0];
			}
			else {
				return el.cloneNode(true);
			}
		}

		function _saveInputCheckedState(root) {
			savedInputChecked.length = 0;

			var inputs = root.getElementsByTagName('input');
			var idx = inputs.length;

			while (idx--) {
				var el = inputs[idx];
				el.checked && savedInputChecked.push(el);
			}
		}

		function _nextTick(fn) {
			return setTimeout(fn, 0);
		}

		function _cancelNextTick(id) {
			return clearTimeout(id);
		}


		/**
		 * Returns the "bounding client rect" of given element
		 * @param  {HTMLElement} el                The element whose boundingClientRect is wanted
		 * @param  {[HTMLElement]} container       the parent the element will be placed in
		 * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform
		 * (used for fixed positioning on el)
		 * @return {Object}                        The boundingClientRect of el
		 */
		function _getRect(el, container, adjustForTransform) {
			if (!el.getBoundingClientRect && el !== win) { return; }

			var elRect,
				top,
				left,
				bottom,
				right,
				height,
				width;

			if (el !== win) {
				elRect = el.getBoundingClientRect();
				top = elRect.top;
				left = elRect.left;
				bottom = elRect.bottom;
				right = elRect.right;
				height = elRect.height;
				width = elRect.width;
			} else {
				top = 0;
				left = 0;
				bottom = window.innerHeight;
				right = window.innerWidth;
				height = window.innerHeight;
				width = window.innerWidth;
			}

			if (adjustForTransform && el !== win) {
				// Adjust for translate()
				container = container || el.parentNode;

				// solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
				// Not needed on <= IE11
				if (!IE11OrLess) {
					do {
						if (container && container.getBoundingClientRect && _css(container, 'transform') !== 'none') {
							var containerRect = container.getBoundingClientRect();

							// Set relative to edges of padding box of container
							top -= containerRect.top + parseInt(_css(container, 'border-top-width'));
							left -= containerRect.left + parseInt(_css(container, 'border-left-width'));
							bottom = top + elRect.height;
							right = left + elRect.width;

							break;
						}
						/* jshint boss:true */
					} while (container = container.parentNode);
				}

				// Adjust for scale()
				var matrix = _matrix(el),
					scaleX = matrix && matrix.a,
					scaleY = matrix && matrix.d;

				if (matrix) {
					top /= scaleY;
					left /= scaleX;

					width /= scaleX;
					height /= scaleY;

					bottom = top + height;
					right = left + width;
				}
			}

			return {
				top: top,
				left: left,
				bottom: bottom,
				right: right,
				width: width,
				height: height
			};
		}


		/**
		 * Checks if a side of an element is scrolled past a side of it's parents
		 * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question
		 * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')
		 * @return {Boolean}               Whether the element is overflowing the viewport on the given side of it's parent
		 */
		function _isScrolledPast(el, side) {
			var parent = _getParentAutoScrollElement(parent, true),
				elSide = _getRect(el)[side];

			/* jshint boss:true */
			while (parent) {
				var parentSide = _getRect(parent)[side],
					visible;

				if (side === 'top' || side === 'left') {
					visible = elSide >= parentSide;
				} else {
					visible = elSide <= parentSide;
				}

				if (!visible) { return true; }

				if (parent === win) { break; }

				parent = _getParentAutoScrollElement(parent, false);
			}

			return false;
		}

		// Fixed #973:
		_on(document, 'touchmove', function(evt) {
			if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
				evt.preventDefault();
			}
		});


		// Export utils
		Sortable.utils = {
			on: _on,
			off: _off,
			css: _css,
			find: _find,
			is: function (el, selector) {
				return !!_closest(el, selector, el, false);
			},
			extend: _extend,
			throttle: _throttle,
			closest: _closest,
			toggleClass: _toggleClass,
			clone: _clone,
			index: _index,
			nextTick: _nextTick,
			cancelNextTick: _cancelNextTick,
			detectDirection: _detectDirection,
			getChild: _getChild
		};


		/**
		 * Create sortable instance
		 * @param {HTMLElement}  el
		 * @param {Object}      [options]
		 */
		Sortable.create = function (el, options) {
			return new Sortable(el, options);
		};


		// Export
		Sortable.version = '1.8.3';
		return Sortable;
	});
	});

	var Sortable$1 = /*#__PURE__*/Object.freeze({
		default: Sortable,
		__moduleExports: Sortable
	});

	var require$$0 = ( Sortable$1 && Sortable ) || Sortable$1;

	var frappeDatatable_cjs = createCommonjsModule(function (module) {

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var Sortable = _interopDefault(require$$0);

	function $(expr, con) {
	    return typeof expr === 'string' ?
	        (con || document).querySelector(expr) :
	        expr || null;
	}

	$.each = function (expr, con) {
	    return typeof expr === 'string' ?
	        Array.from((con || document).querySelectorAll(expr)) :
	        expr || null;
	};

	$.create = function (tag, o) {
	    var element = document.createElement(tag);

	    var loop = function ( i ) {
	        var val = o[i];

	        if (i === 'inside') {
	            $(val).appendChild(element);
	        } else
	        if (i === 'around') {
	            var ref = $(val);
	            ref.parentNode.insertBefore(element, ref);
	            element.appendChild(ref);
	        } else
	        if (i === 'styles') {
	            if (typeof val === 'object') {
	                Object.keys(val).map(function (prop) {
	                    element.style[prop] = val[prop];
	                });
	            }
	        } else
	        if (i in element) {
	            element[i] = val;
	        } else {
	            element.setAttribute(i, val);
	        }
	    };

	    for (var i in o) loop( i );

	    return element;
	};

	$.on = function (element, event, selector, callback) {
	    if (!callback) {
	        callback = selector;
	        $.bind(element, event, callback);
	    } else {
	        $.delegate(element, event, selector, callback);
	    }
	};

	$.off = function (element, event, handler) {
	    element.removeEventListener(event, handler);
	};

	$.bind = function (element, event, callback) {
	    event.split(/\s+/).forEach(function (event) {
	        element.addEventListener(event, callback);
	    });
	};

	$.delegate = function (element, event, selector, callback) {
	    element.addEventListener(event, function (e) {
	        var delegatedTarget = e.target.closest(selector);
	        if (delegatedTarget) {
	            e.delegatedTarget = delegatedTarget;
	            callback.call(this, e, delegatedTarget);
	        }
	    });
	};

	$.unbind = function (element, o) {
	    if (element) {
	        var loop = function ( event ) {
	            var callback = o[event];

	            event.split(/\s+/).forEach(function (event) {
	                element.removeEventListener(event, callback);
	            });
	        };

	        for (var event in o) loop( event );
	    }
	};

	$.fire = function (target, type, properties) {
	    var evt = document.createEvent('HTMLEvents');

	    evt.initEvent(type, true, true);

	    for (var j in properties) {
	        evt[j] = properties[j];
	    }

	    return target.dispatchEvent(evt);
	};

	$.data = function (element, attrs) { // eslint-disable-line
	    if (!attrs) {
	        return element.dataset;
	    }

	    for (var attr in attrs) {
	        element.dataset[attr] = attrs[attr];
	    }
	};

	$.style = function (elements, styleMap) { // eslint-disable-line

	    if (typeof styleMap === 'string') {
	        return $.getStyle(elements, styleMap);
	    }

	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    elements.map(function (element) {
	        for (var prop in styleMap) {
	            element.style[prop] = styleMap[prop];
	        }
	    });
	};

	$.removeStyle = function (elements, styleProps) {
	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    if (!Array.isArray(styleProps)) {
	        styleProps = [styleProps];
	    }

	    elements.map(function (element) {
	        for (var i = 0, list = styleProps; i < list.length; i += 1) {
	            var prop = list[i];

	          element.style[prop] = '';
	        }
	    });
	};

	$.getStyle = function (element, prop) {
	    if (!prop) {
	        return getComputedStyle(element);
	    }

	    var val = getComputedStyle(element)[prop];

	    if (['width', 'height'].includes(prop)) {
	        val = parseFloat(val);
	    }

	    return val;
	};

	$.closest = function (selector, element) {
	    if (!element) { return null; }

	    if (element.matches(selector)) {
	        return element;
	    }

	    return $.closest(selector, element.parentNode);
	};

	$.inViewport = function (el, parentEl) {
	    var ref = el.getBoundingClientRect();
	    var top = ref.top;
	    var left = ref.left;
	    var bottom = ref.bottom;
	    var right = ref.right;
	    var ref$1 = parentEl.getBoundingClientRect();
	    var pTop = ref$1.top;
	    var pLeft = ref$1.left;
	    var pBottom = ref$1.bottom;
	    var pRight = ref$1.right;

	    return top >= pTop && left >= pLeft && bottom <= pBottom && right <= pRight;
	};

	$.scrollTop = function scrollTop(element, pixels) {
	    requestAnimationFrame(function () {
	        element.scrollTop = pixels;
	    });
	};

	$.scrollbarSize = function scrollbarSize() {
	    if (!$.scrollBarSizeValue) {
	        $.scrollBarSizeValue = getScrollBarSize();
	    }
	    return $.scrollBarSizeValue;
	};

	function getScrollBarSize() {
	    // assume scrollbar width and height would be the same

	    // Create the measurement node
	    var scrollDiv = document.createElement('div');
	    $.style(scrollDiv, {
	        width: '100px',
	        height: '100px',
	        overflow: 'scroll',
	        position: 'absolute',
	        top: '-9999px'
	    });
	    document.body.appendChild(scrollDiv);

	    // Get the scrollbar width
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

	    // Delete the DIV
	    document.body.removeChild(scrollDiv);

	    return scrollbarWidth;
	}

	$.hasVerticalOverflow = function (element) {
	    return element.scrollHeight > element.offsetHeight + 10;
	};

	$.hasHorizontalOverflow = function (element) {
	    return element.scrollWidth > element.offsetWidth + 10;
	};

	$.measureTextWidth = function (text) {
	    var div = document.createElement('div');
	    div.style.position = 'absolute';
	    div.style.visibility = 'hidden';
	    div.style.height = 'auto';
	    div.style.width = 'auto';
	    div.style.whiteSpace = 'nowrap';
	    div.innerText = text;
	    document.body.appendChild(div);
	    return div.clientWidth + 1;
	};

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	var commonjsGlobal$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return _root.Date.now();
	};

	var now_1 = now;

	/** Built-in value references. */
	var Symbol = _root.Symbol;

	var _Symbol = Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol_1(value)) {
	    return NAN;
	  }
	  if (isObject_1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject_1(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	var toNumber_1 = toNumber;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber_1(wait) || 0;
	  if (isObject_1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now_1();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now_1());
	  }

	  function debounced() {
	    var time = now_1(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	var debounce_1 = debounce;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  if (isObject_1(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce_1(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	var throttle_1 = throttle;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _baseFindIndex = baseFindIndex;

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	var _baseIsNaN = baseIsNaN;

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _strictIndexOf = strictIndexOf;

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? _strictIndexOf(array, value, fromIndex)
	    : _baseFindIndex(array, _baseIsNaN, fromIndex);
	}

	var _baseIndexOf = baseIndexOf;

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && _baseIndexOf(array, value, 0) > -1;
	}

	var _arrayIncludes = arrayIncludes;

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arrayIncludesWith = arrayIncludesWith;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/* Built-in method references that are verified to be native. */
	var Set = _getNative(_root, 'Set');

	var _Set = Set;

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	var noop_1 = noop;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY) ? noop_1 : function(values) {
	  return new _Set(values);
	};

	var _createSet = createSet;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = _arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = _arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : _createSet(array);
	    if (set) {
	      return _setToArray(set);
	    }
	    isCommon = false;
	    includes = _cacheHas;
	    seen = new _SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	var _baseUniq = baseUniq;

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length) ? _baseUniq(array) : [];
	}

	var uniq_1 = uniq;

	function camelCaseToDash(str) {
	    return str.replace(/([A-Z])/g, function (g) { return ("-" + (g[0].toLowerCase())); });
	}

	function makeDataAttributeString(props) {
	    var keys = Object.keys(props);

	    return keys
	        .map(function (key) {
	            var _key = camelCaseToDash(key);
	            var val = props[key];

	            if (val === undefined) { return ''; }
	            return ("data-" + _key + "=\"" + val + "\" ");
	        })
	        .join('')
	        .trim();
	}

	function copyTextToClipboard(text) {
	    // https://stackoverflow.com/a/30810322/5353542
	    var textArea = document.createElement('textarea');

	    //
	    // *** This styling is an extra step which is likely not required. ***
	    //
	    // Why is it here? To ensure:
	    // 1. the element is able to have focus and selection.
	    // 2. if element was to flash render it has minimal visual impact.
	    // 3. less flakyness with selection and copying which **might** occur if
	    //    the textarea element is not visible.
	    //
	    // The likelihood is the element won't even render, not even a flash,
	    // so some of these are just precautions. However in IE the element
	    // is visible whilst the popup box asking the user for permission for
	    // the web page to copy to the clipboard.
	    //

	    // Place in top-left corner of screen regardless of scroll position.
	    textArea.style.position = 'fixed';
	    textArea.style.top = 0;
	    textArea.style.left = 0;

	    // Ensure it has a small width and height. Setting to 1px / 1em
	    // doesn't work as this gives a negative w/h on some browsers.
	    textArea.style.width = '2em';
	    textArea.style.height = '2em';

	    // We don't need padding, reducing the size if it does flash render.
	    textArea.style.padding = 0;

	    // Clean up any borders.
	    textArea.style.border = 'none';
	    textArea.style.outline = 'none';
	    textArea.style.boxShadow = 'none';

	    // Avoid flash of white box if rendered for any reason.
	    textArea.style.background = 'transparent';

	    textArea.value = text;

	    document.body.appendChild(textArea);

	    textArea.select();

	    try {
	        document.execCommand('copy');
	    } catch (err) {
	        console.log('Oops, unable to copy');
	    }

	    document.body.removeChild(textArea);
	}

	function isNumeric(val) {
	    return !isNaN(val);
	}

	var throttle$1 = throttle_1;

	var debounce$1 = debounce_1;

	function nextTick(fn, context) {
	    if ( context === void 0 ) context = null;

	    return function () {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        return new Promise(function (resolve) {
	            var execute = function () {
	                var out = fn.apply(context, args);
	                resolve(out);
	            };
	            setTimeout(execute);
	        });
	    };
	}
	function linkProperties(target, source, properties) {
	    var props = properties.reduce(function (acc, prop) {
	        acc[prop] = {
	            get: function get() {
	                return source[prop];
	            }
	        };
	        return acc;
	    }, {});
	    Object.defineProperties(target, props);
	}
	function isSet(val) {
	    return val !== undefined || val !== null;
	}

	function notSet(val) {
	    return !isSet(val);
	}

	function isNumber(val) {
	    return !isNaN(val);
	}

	function ensureArray(val) {
	    if (!Array.isArray(val)) {
	        return [val];
	    }
	    return val;
	}

	function uniq$1(arr) {
	    return uniq_1(arr);
	}

	function numberSortAsc(a, b) {
	    return a - b;
	}
	function stripHTML(html) {
	    return html.replace(/<[^>]*>/g, '');
	}

	class DataManager {
	    constructor(options) {
	        this.options = options;
	        this.sortRows = nextTick(this.sortRows, this);
	        this.switchColumn = nextTick(this.switchColumn, this);
	        this.removeColumn = nextTick(this.removeColumn, this);
	        this.options.filterRows = nextTick(this.options.filterRows, this);
	    }

	    init(data, columns) {
	        if (!data) {
	            data = this.options.data;
	        }
	        if (columns) {
	            this.options.columns = columns;
	        }

	        this.data = data;

	        this.rowCount = 0;
	        this.columns = [];
	        this.rows = [];

	        this.prepareColumns();
	        this.prepareRows();
	        this.prepareTreeRows();
	        this.prepareRowView();
	        this.prepareNumericColumns();
	    }

	    // computed property
	    get currentSort() {
	        var col = this.columns.find(function (col) { return col.sortOrder !== 'none'; });
	        return col || {
	            colIndex: -1,
	            sortOrder: 'none'
	        };
	    }

	    prepareColumns() {
	        this.columns = [];
	        this.validateColumns();
	        this.prepareDefaultColumns();
	        this.prepareHeader();
	    }

	    prepareDefaultColumns() {
	        if (this.options.checkboxColumn && !this.hasColumnById('_checkbox')) {
	            var cell = {
	                id: '_checkbox',
	                content: this.getCheckboxHTML(),
	                editable: false,
	                resizable: false,
	                sortable: false,
	                focusable: false,
	                dropdown: false,
	                width: 32
	            };
	            this.columns.push(cell);
	        }

	        if (this.options.serialNoColumn && !this.hasColumnById('_rowIndex')) {
	            var cell$1 = {
	                id: '_rowIndex',
	                content: '',
	                align: 'center',
	                editable: false,
	                resizable: false,
	                focusable: false,
	                dropdown: false
	            };

	            this.columns.push(cell$1);
	        }
	    }

	    prepareHeader() {
	        var this$1 = this;

	        var columns = this.columns.concat(this.options.columns);
	        var baseCell = {
	            isHeader: 1,
	            editable: true,
	            sortable: true,
	            resizable: true,
	            focusable: true,
	            dropdown: true,
	            width: null,
	            format: function (value) {
	                if (value === null || value === undefined) {
	                    return '';
	                }
	                return value + '';
	            }
	        };

	        this.columns = columns
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (col) { return Object.assign({}, baseCell, col); })
	            .map(function (col) {
	                col.content = col.content || col.name || '';
	                col.id = col.id || col.content;
	                return col;
	            });
	    }

	    prepareCell(content, i) {
	        var cell = {
	            content: '',
	            sortOrder: 'none',
	            colIndex: i,
	            column: this.columns[i]
	        };

	        if (content !== null && typeof content === 'object') {
	            // passed as column/header
	            Object.assign(cell, content);
	        } else {
	            cell.content = content;
	        }

	        return cell;
	    }

	    prepareNumericColumns() {
	        var row0 = this.getRow(0);
	        if (!row0) { return; }
	        this.columns = this.columns.map(function (column, i) {

	            var cellValue = row0[i].content;
	            if (!column.align && isNumeric(cellValue)) {
	                column.align = 'right';
	            }

	            return column;
	        });
	    }

	    prepareRows() {
	        var this$1 = this;

	        this.validateData(this.data);

	        this.rows = this.data.map(function (d, i) {
	            var index = this$1._getNextRowCount();

	            var row = [];
	            var meta = {
	                rowIndex: index
	            };

	            if (Array.isArray(d)) {
	                // row is an array
	                if (this$1.options.checkboxColumn) {
	                    row.push(this$1.getCheckboxHTML());
	                }
	                if (this$1.options.serialNoColumn) {
	                    row.push((index + 1) + '');
	                }
	                row = row.concat(d);

	                while (row.length < this$1.columns.length) {
	                    row.push('');
	                }

	            } else {
	                // row is an object
	                for (var i$1 = 0, list = this$1.columns; i$1 < list.length; i$1 += 1) {
	                    var col = list[i$1];

	                  if (col.id === '_checkbox') {
	                        row.push(this$1.getCheckboxHTML());
	                    } else if (col.id === '_rowIndex') {
	                        row.push((index + 1) + '');
	                    } else {
	                        row.push(d[col.id]);
	                    }
	                }

	                meta.indent = d.indent || 0;
	            }

	            return this$1.prepareRow(row, meta);
	        });
	    }

	    prepareTreeRows() {
	        var this$1 = this;

	        this.rows.forEach(function (row, i) {
	            if (isNumber(row.meta.indent)) {
	                // if (i === 36) debugger;
	                var nextRow = this$1.getRow(i + 1);
	                row.meta.isLeaf = !nextRow ||
	                    notSet(nextRow.meta.indent) ||
	                    nextRow.meta.indent <= row.meta.indent;
	                row.meta.isTreeNodeClose = false;
	            }
	        });
	    }

	    prepareRowView() {
	        // This is order in which rows will be rendered in the table.
	        // When sorting happens, only this.rowViewOrder will change
	        // and not the original this.rows
	        this.rowViewOrder = this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    prepareRow(row, meta) {
	        var this$1 = this;

	        var baseRowCell = {
	            rowIndex: meta.rowIndex,
	            indent: meta.indent
	        };

	        row = row
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (cell) { return Object.assign({}, baseRowCell, cell); });

	        // monkey patched in array object
	        row.meta = meta;
	        return row;
	    }

	    validateColumns() {
	        var columns = this.options.columns;
	        if (!Array.isArray(columns)) {
	            throw new DataError('`columns` must be an array');
	        }

	        columns.forEach(function (column, i) {
	            if (typeof column !== 'string' && typeof column !== 'object') {
	                throw new DataError(("column \"" + i + "\" must be a string or an object"));
	            }
	        });
	    }

	    validateData(data) {
	        if (Array.isArray(data) &&
	            (data.length === 0 || Array.isArray(data[0]) || typeof data[0] === 'object')) {
	            return true;
	        }
	        throw new DataError('`data` must be an array of arrays or objects');
	    }

	    appendRows(rows) {
	        var ref;

	        this.validateData(rows);

	        (ref = this.rows).push.apply(ref, this.prepareRows(rows));
	    }

	    sortRows(colIndex, sortOrder) {
	        if ( sortOrder === void 0 ) sortOrder = 'none';

	        colIndex = +colIndex;

	        // reset sortOrder and update for colIndex
	        this.getColumns()
	            .map(function (col) {
	                if (col.colIndex === colIndex) {
	                    col.sortOrder = sortOrder;
	                } else {
	                    col.sortOrder = 'none';
	                }
	            });

	        this._sortRows(colIndex, sortOrder);
	    }

	    _sortRows(colIndex, sortOrder) {
	        var this$1 = this;


	        if (this.currentSort.colIndex === colIndex) {
	            // reverse the array if only sortOrder changed
	            if (
	                (this.currentSort.sortOrder === 'asc' && sortOrder === 'desc') ||
	                (this.currentSort.sortOrder === 'desc' && sortOrder === 'asc')
	            ) {
	                this.reverseArray(this.rowViewOrder);
	                this.currentSort.sortOrder = sortOrder;
	                return;
	            }
	        }

	        this.rowViewOrder.sort(function (a, b) {
	            var aIndex = a;
	            var bIndex = b;

	            var aContent = this$1.getCell(colIndex, a).content;
	            var bContent = this$1.getCell(colIndex, b).content;
	            aContent = aContent == null ? '' : aContent;
	            bContent = bContent == null ? '' : bContent;

	            if (sortOrder === 'none') {
	                return aIndex - bIndex;
	            } else if (sortOrder === 'asc') {
	                if (aContent < bContent) { return -1; }
	                if (aContent > bContent) { return 1; }
	                if (aContent === bContent) { return 0; }
	            } else if (sortOrder === 'desc') {
	                if (aContent < bContent) { return 1; }
	                if (aContent > bContent) { return -1; }
	                if (aContent === bContent) { return 0; }
	            }
	            return 0;
	        });

	        if (this.hasColumnById('_rowIndex')) {
	            // update row index
	            var srNoColIndex = this.getColumnIndexById('_rowIndex');
	            this.rows.forEach(function (row, index) {
	                var viewIndex = this$1.rowViewOrder.indexOf(index);
	                var cell = row[srNoColIndex];
	                cell.content = (viewIndex + 1) + '';
	            });
	        }
	    }

	    reverseArray(array) {
	        var left = null;
	        var right = null;
	        var length = array.length;

	        for (left = 0, right = length - 1; left < right; left += 1, right -= 1) {
	            var temporary = array[left];

	            array[left] = array[right];
	            array[right] = temporary;
	        }
	    }

	    switchColumn(index1, index2) {
	        // update columns
	        var temp = this.columns[index1];
	        this.columns[index1] = this.columns[index2];
	        this.columns[index2] = temp;

	        this.columns[index1].colIndex = index1;
	        this.columns[index2].colIndex = index2;

	        // update rows
	        this.rows.forEach(function (row) {
	            var newCell1 = Object.assign({}, row[index1], {
	                colIndex: index2
	            });
	            var newCell2 = Object.assign({}, row[index2], {
	                colIndex: index1
	            });

	            row[index2] = newCell1;
	            row[index1] = newCell2;
	        });
	    }

	    removeColumn(index) {
	        index = +index;
	        var filter = function (cell) { return cell.colIndex !== index; };
	        var map = function (cell, i) { return Object.assign({}, cell, {
	            colIndex: i
	        }); };
	        // update columns
	        this.columns = this.columns
	            .filter(filter)
	            .map(map);

	        // update rows
	        this.rows.forEach(function (row) {
	            // remove cell
	            row.splice(index, 1);
	            // update colIndex
	            row.forEach(function (cell, i) {
	                cell.colIndex = i;
	            });
	        });
	    }

	    updateRow(row, rowIndex) {
	        if (row.length < this.columns.length) {
	            if (this.hasColumnById('_rowIndex')) {
	                var val = (rowIndex + 1) + '';

	                row = [val].concat(row);
	            }

	            if (this.hasColumnById('_checkbox')) {
	                var val$1 = '<input type="checkbox" />';

	                row = [val$1].concat(row);
	            }
	        }

	        var _row = this.prepareRow(row, {rowIndex: rowIndex});
	        var index = this.rows.findIndex(function (row) { return row[0].rowIndex === rowIndex; });
	        this.rows[index] = _row;

	        return _row;
	    }

	    updateCell(colIndex, rowIndex, options) {
	        var cell;
	        if (typeof colIndex === 'object') {
	            // cell object was passed,
	            // must have colIndex, rowIndex
	            cell = colIndex;
	            colIndex = cell.colIndex;
	            rowIndex = cell.rowIndex;
	            // the object passed must be merged with original cell
	            options = cell;
	        }
	        cell = this.getCell(colIndex, rowIndex);

	        // mutate object directly
	        for (var key in options) {
	            var newVal = options[key];
	            if (newVal !== undefined) {
	                cell[key] = newVal;
	            }
	        }

	        return cell;
	    }

	    updateColumn(colIndex, keyValPairs) {
	        var column = this.getColumn(colIndex);
	        for (var key in keyValPairs) {
	            var newVal = keyValPairs[key];
	            if (newVal !== undefined) {
	                column[key] = newVal;
	            }
	        }
	        return column;
	    }

	    filterRows(filters) {
	        var this$1 = this;

	        return this.options.filterRows(this.rows, filters)
	            .then(function (result) {
	                if (!result) {
	                    result = this$1.getAllRowIndices();
	                }

	                if (!result.then) {
	                    result = Promise.resolve(result);
	                }

	                return result.then(function (rowsToShow) {
	                    this$1._filteredRows = rowsToShow;

	                    var rowsToHide = this$1.getAllRowIndices()
	                        .filter(function (index) { return !rowsToShow.includes(index); });

	                    return {
	                        rowsToHide: rowsToHide,
	                        rowsToShow: rowsToShow
	                    };
	                });
	            });
	    }

	    getFilteredRowIndices() {
	        return this._filteredRows || this.getAllRowIndices();
	    }

	    getAllRowIndices() {
	        return this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    getRowCount() {
	        return this.rowCount;
	    }

	    _getNextRowCount() {
	        var val = this.rowCount;

	        this.rowCount++;
	        return val;
	    }

	    getRows(start, end) {
	        return this.rows.slice(start, end);
	    }

	    getRowsForView(start, end) {
	        var this$1 = this;

	        var rows = this.rowViewOrder.map(function (i) { return this$1.rows[i]; });
	        return rows.slice(start, end);
	    }

	    getColumns(skipStandardColumns) {
	        var columns = this.columns;

	        if (skipStandardColumns) {
	            columns = columns.slice(this.getStandardColumnCount());
	        }

	        return columns;
	    }

	    getStandardColumnCount() {
	        if (this.options.checkboxColumn && this.options.serialNoColumn) {
	            return 2;
	        }

	        if (this.options.checkboxColumn || this.options.serialNoColumn) {
	            return 1;
	        }

	        return 0;
	    }

	    getColumnCount(skipStandardColumns) {
	        var val = this.columns.length;

	        if (skipStandardColumns) {
	            val = val - this.getStandardColumnCount();
	        }

	        return val;
	    }

	    getColumn(colIndex) {
	        colIndex = +colIndex;

	        if (colIndex < 0) {
	            // negative indexes
	            colIndex = this.columns.length + colIndex;
	        }

	        return this.columns.find(function (col) { return col.colIndex === colIndex; });
	    }

	    getColumnById(id) {
	        return this.columns.find(function (col) { return col.id === id; });
	    }

	    getRow(rowIndex) {
	        rowIndex = +rowIndex;
	        return this.rows[rowIndex];
	    }

	    getCell(colIndex, rowIndex) {
	        rowIndex = +rowIndex;
	        colIndex = +colIndex;
	        return this.getRow(rowIndex)[colIndex];
	    }

	    getChildren(parentRowIndex) {
	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this.getRow(i);
	            if (isNaN(row.meta.indent)) { continue; }

	            if (row.meta.indent > parentIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    getImmediateChildren(parentRowIndex) {
	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];
	        var childIndent = parentIndent + 1;

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this.getRow(i);
	            if (isNaN(row.meta.indent) || row.meta.indent > childIndent) { continue; }

	            if (row.meta.indent === childIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    get() {
	        return {
	            columns: this.columns,
	            rows: this.rows
	        };
	    }

	    /**
	     * Returns the original data which was passed
	     * based on rowIndex
	     * @param {Number} rowIndex
	     * @returns Array|Object
	     * @memberof DataManager
	     */
	    getData(rowIndex) {
	        return this.data[rowIndex];
	    }

	    hasColumn(name) {
	        return Boolean(this.columns.find(function (col) { return col.content === name; }));
	    }

	    hasColumnById(id) {
	        return Boolean(this.columns.find(function (col) { return col.id === id; }));
	    }

	    getColumnIndex(name) {
	        return this.columns.findIndex(function (col) { return col.content === name; });
	    }

	    getColumnIndexById(id) {
	        return this.columns.findIndex(function (col) { return col.id === id; });
	    }

	    getCheckboxHTML() {
	        return '<input type="checkbox" />';
	    }
	}

	// Custom Errors
	class DataError extends TypeError {}

	/* eslint-disable max-len */

	// Icons from https://feathericons.com/

	var icons = {
	    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>',
	    chevronRight: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>'
	};

	class CellManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'wrapper',
	            'options',
	            'style',
	            'header',
	            'bodyScrollable',
	            'columnmanager',
	            'rowmanager',
	            'datamanager',
	            'keyboard'
	        ]);

	        this.bindEvents();
	    }

	    bindEvents() {
	        this.bindFocusCell();
	        this.bindEditCell();
	        this.bindKeyboardSelection();
	        this.bindCopyCellContents();
	        this.bindMouseEvents();
	        this.bindTreeEvents();
	    }

	    bindFocusCell() {
	        this.bindKeyboardNav();
	    }

	    bindEditCell() {
	        var this$1 = this;

	        this.$editingCell = null;

	        $.on(this.bodyScrollable, 'dblclick', '.dt-cell', function (e, cell) {
	            this$1.activateEditing(cell);
	        });

	        this.keyboard.on('enter', function () {
	            if (this$1.$focusedCell && !this$1.$editingCell) {
	                // enter keypress on focused cell
	                this$1.activateEditing(this$1.$focusedCell);
	            } else if (this$1.$editingCell) {
	                // enter keypress on editing cell
	                this$1.deactivateEditing();
	            }
	        });
	    }

	    bindKeyboardNav() {
	        var this$1 = this;

	        var focusLastCell = function (direction) {
	            if (!this$1.$focusedCell || this$1.$editingCell) {
	                return false;
	            }

	            var $cell = this$1.$focusedCell;
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var colIndex = ref.colIndex;

	            if (direction === 'left') {
	                $cell = this$1.getLeftMostCell$(rowIndex);
	            } else if (direction === 'right') {
	                $cell = this$1.getRightMostCell$(rowIndex);
	            } else if (direction === 'up') {
	                $cell = this$1.getTopMostCell$(colIndex);
	            } else if (direction === 'down') {
	                $cell = this$1.getBottomMostCell$(colIndex);
	            }

	            this$1.focusCell($cell);
	            return true;
	        };

	        ['left', 'right', 'up', 'down', 'tab', 'shift+tab']
	            .map(function (direction) { return this$1.keyboard.on(direction, function () { return this$1.focusCellInDirection(direction); }); });

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("ctrl+" + direction), function () { return focusLastCell(direction); }); });

	        this.keyboard.on('esc', function () {
	            this$1.deactivateEditing(false);
	            this$1.columnmanager.toggleFilter(false);
	        });

	        if (this.options.inlineFilters) {
	            this.keyboard.on('ctrl+f', function (e) {
	                var $cell = $.closest('.dt-cell', e.target);
	                var ref = $.data($cell);
	                var colIndex = ref.colIndex;

	                this$1.activateFilter(colIndex);
	                return true;
	            });

	            $.on(this.header, 'focusin', '.dt-filter', function () {
	                this$1.unfocusCell(this$1.$focusedCell);
	            });
	        }
	    }

	    bindKeyboardSelection() {
	        var this$1 = this;

	        var getNextSelectionCursor = function (direction) {
	            var $selectionCursor = this$1.getSelectionCursor();

	            if (direction === 'left') {
	                $selectionCursor = this$1.getLeftCell$($selectionCursor);
	            } else if (direction === 'right') {
	                $selectionCursor = this$1.getRightCell$($selectionCursor);
	            } else if (direction === 'up') {
	                $selectionCursor = this$1.getAboveCell$($selectionCursor);
	            } else if (direction === 'down') {
	                $selectionCursor = this$1.getBelowCell$($selectionCursor);
	            }

	            return $selectionCursor;
	        };

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("shift+" + direction), function () { return this$1.selectArea(getNextSelectionCursor(direction)); }); });
	    }

	    bindCopyCellContents() {
	        var this$1 = this;

	        this.keyboard.on('ctrl+c', function () {
	            var noOfCellsCopied = this$1.copyCellContents(this$1.$focusedCell, this$1.$selectionCursor);
	            var message = noOfCellsCopied + " cell" + (noOfCellsCopied > 1 ? 's' : '') + " copied";
	            if (noOfCellsCopied) {
	                this$1.instance.showToastMessage(message, 2);
	            }
	        });

	        if (this.options.pasteFromClipboard) {
	            this.keyboard.on('ctrl+v', function (e) {
	                // hack
	                // https://stackoverflow.com/a/2177059/5353542
	                this$1.instance.pasteTarget.focus();

	                setTimeout(function () {
	                    var data = this$1.instance.pasteTarget.value;
	                    this$1.instance.pasteTarget.value = '';
	                    this$1.pasteContentInCell(data);
	                }, 10);

	                return false;
	            });
	        }
	    }

	    bindMouseEvents() {
	        var this$1 = this;

	        var mouseDown = null;

	        $.on(this.bodyScrollable, 'mousedown', '.dt-cell', function (e) {
	            mouseDown = true;
	            this$1.focusCell($(e.delegatedTarget));
	        });

	        $.on(this.bodyScrollable, 'mouseup', function () {
	            mouseDown = false;
	        });

	        var selectArea = function (e) {
	            if (!mouseDown) { return; }
	            this$1.selectArea($(e.delegatedTarget));
	        };

	        $.on(this.bodyScrollable, 'mousemove', '.dt-cell', throttle$1(selectArea, 50));
	    }

	    bindTreeEvents() {
	        var this$1 = this;

	        $.on(this.bodyScrollable, 'click', '.dt-tree-node__toggle', function (e, $toggle) {
	            var $cell = $.closest('.dt-cell', $toggle);
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;

	            if ($cell.classList.contains('dt-cell--tree-close')) {
	                this$1.rowmanager.openSingleNode(rowIndex);
	            } else {
	                this$1.rowmanager.closeSingleNode(rowIndex);
	            }
	        });
	    }

	    focusCell($cell, ref) {
	        if ( ref === void 0 ) ref = {};
	        var skipClearSelection = ref.skipClearSelection; if ( skipClearSelection === void 0 ) skipClearSelection = 0;
	        var skipDOMFocus = ref.skipDOMFocus; if ( skipDOMFocus === void 0 ) skipDOMFocus = 0;
	        var skipScrollToCell = ref.skipScrollToCell; if ( skipScrollToCell === void 0 ) skipScrollToCell = 0;

	        if (!$cell) { return; }

	        // don't focus if already editing cell
	        if ($cell === this.$editingCell) { return; }

	        var ref$1 = $.data($cell);
	        var colIndex = ref$1.colIndex;
	        var isHeader = ref$1.isHeader;
	        if (isHeader) {
	            return;
	        }

	        var column = this.columnmanager.getColumn(colIndex);
	        if (column.focusable === false) {
	            return;
	        }

	        if (!skipScrollToCell) {
	            this.scrollToCell($cell);
	        }

	        this.deactivateEditing();
	        if (!skipClearSelection) {
	            this.clearSelection();
	        }

	        if (this.$focusedCell) {
	            this.$focusedCell.classList.remove('dt-cell--focus');
	        }

	        this.$focusedCell = $cell;
	        $cell.classList.add('dt-cell--focus');

	        if (!skipDOMFocus) {
	            // so that keyboard nav works
	            $cell.focus();
	        }

	        this.highlightRowColumnHeader($cell);
	    }

	    unfocusCell($cell) {
	        if (!$cell) { return; }

	        // remove cell border
	        $cell.classList.remove('dt-cell--focus');
	        this.$focusedCell = null;

	        // reset header background
	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header && header.classList.remove('dt-cell--highlight'); });
	        }
	    }

	    highlightRowColumnHeader($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var srNoColIndex = this.datamanager.getColumnIndexById('_rowIndex');
	        var colHeaderSelector = ".dt-cell--header-" + colIndex;
	        var rowHeaderSelector = ".dt-cell--" + srNoColIndex + "-" + rowIndex;

	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header && header.classList.remove('dt-cell--highlight'); });
	        }

	        var colHeader = $(colHeaderSelector, this.wrapper);
	        var rowHeader = $(rowHeaderSelector, this.wrapper);

	        this.lastHeaders = [colHeader, rowHeader];
	        this.lastHeaders.forEach(function (header) { return header && header.classList.add('dt-cell--highlight'); });
	    }

	    selectAreaOnClusterChanged() {
	        if (!(this.$focusedCell && this.$selectionCursor)) { return; }
	        var ref = $.data(this.$selectionCursor);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell || $cell === this.$selectionCursor) { return; }

	        // selectArea needs $focusedCell
	        var fCell = $.data(this.$focusedCell);
	        this.$focusedCell = this.getCell$(fCell.colIndex, fCell.rowIndex);

	        this.selectArea($cell);
	    }

	    focusCellOnClusterChanged() {
	        if (!this.$focusedCell) { return; }

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell) { return; }
	        // this function is called after hyperlist renders the rows after scroll,
	        // focusCell calls clearSelection which resets the area selection
	        // so a flag to skip it
	        // we also skip DOM focus and scroll to cell
	        // because it fights with the user scroll
	        this.focusCell($cell, {
	            skipClearSelection: 1,
	            skipDOMFocus: 1,
	            skipScrollToCell: 1
	        });
	    }

	    selectArea($selectionCursor) {
	        if (!this.$focusedCell) { return; }

	        if (this._selectArea(this.$focusedCell, $selectionCursor)) {
	            // valid selection
	            this.$selectionCursor = $selectionCursor;
	        }
	    }

	    _selectArea($cell1, $cell2) {
	        var this$1 = this;

	        if ($cell1 === $cell2) { return false; }

	        var cells = this.getCellsInRange($cell1, $cell2);
	        if (!cells) { return false; }

	        this.clearSelection();
	        this._selectedCells = cells.map(function (index) {
	          var ref;

	          return (ref = this$1).getCell$.apply(ref, index);
	        });
	        requestAnimationFrame(function () {
	            this$1._selectedCells.map(function ($cell) { return $cell.classList.add('dt-cell--highlight'); });
	        });
	        return true;
	    }

	    getCellsInRange($cell1, $cell2) {
	        var assign, assign$1, assign$2;

	        var colIndex1, rowIndex1, colIndex2, rowIndex2;

	        if (typeof $cell1 === 'number') {
	            (assign = arguments, colIndex1 = assign[0], rowIndex1 = assign[1], colIndex2 = assign[2], rowIndex2 = assign[3]);
	        } else
	        if (typeof $cell1 === 'object') {
	            if (!($cell1 && $cell2)) {
	                return false;
	            }

	            var cell1 = $.data($cell1);
	            var cell2 = $.data($cell2);

	            colIndex1 = +cell1.colIndex;
	            rowIndex1 = +cell1.rowIndex;
	            colIndex2 = +cell2.colIndex;
	            rowIndex2 = +cell2.rowIndex;
	        }

	        if (rowIndex1 > rowIndex2) {
	            (assign$1 = [rowIndex2, rowIndex1], rowIndex1 = assign$1[0], rowIndex2 = assign$1[1]);
	        }

	        if (colIndex1 > colIndex2) {
	            (assign$2 = [colIndex2, colIndex1], colIndex1 = assign$2[0], colIndex2 = assign$2[1]);
	        }

	        if (this.isStandardCell(colIndex1) || this.isStandardCell(colIndex2)) {
	            return false;
	        }

	        var cells = [];
	        var colIndex = colIndex1;
	        var rowIndex = rowIndex1;
	        var rowIndices = [];

	        while (rowIndex <= rowIndex2) {
	            rowIndices.push(rowIndex);
	            rowIndex += 1;
	        }

	        rowIndices.map(function (rowIndex) {
	            while (colIndex <= colIndex2) {
	                cells.push([colIndex, rowIndex]);
	                colIndex++;
	            }
	            colIndex = colIndex1;
	        });

	        return cells;
	    }

	    clearSelection() {
	        (this._selectedCells || [])
	            .forEach(function ($cell) { return $cell.classList.remove('dt-cell--highlight'); });

	        this._selectedCells = [];
	        this.$selectionCursor = null;
	    }

	    getSelectionCursor() {
	        return this.$selectionCursor || this.$focusedCell;
	    }

	    activateEditing($cell) {
	        this.focusCell($cell);
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;

	        var col = this.columnmanager.getColumn(colIndex);
	        if (col && (col.editable === false || col.focusable === false)) {
	            return;
	        }

	        var cell = this.getCell(colIndex, rowIndex);
	        if (cell && cell.editable === false) {
	            return;
	        }

	        if (this.$editingCell) {
	            var ref$1 = $.data(this.$editingCell);
	            var _rowIndex = ref$1._rowIndex;
	            var _colIndex = ref$1._colIndex;

	            if (rowIndex === _rowIndex && colIndex === _colIndex) {
	                // editing the same cell
	                return;
	            }
	        }

	        this.$editingCell = $cell;
	        $cell.classList.add('dt-cell--editing');

	        var $editCell = $('.dt-cell__edit', $cell);
	        $editCell.innerHTML = '';

	        var editor = this.getEditor(colIndex, rowIndex, cell.content, $editCell);

	        if (editor) {
	            this.currentCellEditor = editor;
	            // initialize editing input with cell value
	            editor.initValue(cell.content, rowIndex, col);
	        }
	    }

	    deactivateEditing(submitValue) {
	        if ( submitValue === void 0 ) submitValue = true;

	        if (submitValue) {
	            this.submitEditing();
	        }
	        // keep focus on the cell so that keyboard navigation works
	        if (this.$focusedCell) { this.$focusedCell.focus(); }

	        if (!this.$editingCell) { return; }
	        this.$editingCell.classList.remove('dt-cell--editing');
	        this.$editingCell = null;
	    }

	    getEditor(colIndex, rowIndex, value, parent) {
	        var column = this.datamanager.getColumn(colIndex);
	        var row = this.datamanager.getRow(rowIndex);
	        var data = this.datamanager.getData(rowIndex);
	        var editor = this.options.getEditor ?
	            this.options.getEditor(colIndex, rowIndex, value, parent, column, row, data) :
	            this.getDefaultEditor(parent);

	        if (editor === false) {
	            // explicitly returned false
	            return false;
	        }
	        if (editor === undefined) {
	            // didn't return editor, fallback to default
	            editor = this.getDefaultEditor(parent);
	        }

	        return editor;
	    }

	    getDefaultEditor(parent) {
	        var $input = $.create('input', {
	            class: 'dt-input',
	            type: 'text',
	            inside: parent
	        });

	        return {
	            initValue: function initValue(value) {
	                $input.focus();
	                $input.value = value;
	            },
	            getValue: function getValue() {
	                return $input.value;
	            },
	            setValue: function setValue(value) {
	                $input.value = value;
	            }
	        };
	    }

	    submitEditing() {
	        var this$1 = this;

	        var promise = Promise.resolve();
	        if (!this.$editingCell) { return promise; }

	        var $cell = this.$editingCell;
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;
	        var col = this.datamanager.getColumn(colIndex);

	        if ($cell) {
	            var editor = this.currentCellEditor;

	            if (editor) {
	                var valuePromise = editor.getValue();

	                // convert to stubbed Promise
	                if (!valuePromise.then) {
	                    valuePromise = Promise.resolve(valuePromise);
	                }

	                promise = valuePromise.then(function (value) {
	                    var done = editor.setValue(value, rowIndex, col);
	                    var oldValue = this$1.getCell(colIndex, rowIndex).content;

	                    // update cell immediately
	                    this$1.updateCell(colIndex, rowIndex, value);
	                    $cell.focus();

	                    if (done && done.then) {
	                        // revert to oldValue if promise fails
	                        done.catch(function (e) {
	                            console.log(e);
	                            this$1.updateCell(colIndex, rowIndex, oldValue);
	                        });
	                    }
	                    return done;
	                });
	            }
	        }

	        this.currentCellEditor = null;
	        return promise;
	    }

	    copyCellContents($cell1, $cell2) {
	        var this$1 = this;

	        if (!$cell2 && $cell1) {
	            // copy only focusedCell
	            var ref = $.data($cell1);
	            var colIndex = ref.colIndex;
	            var rowIndex = ref.rowIndex;
	            var cell = this.getCell(colIndex, rowIndex);
	            copyTextToClipboard(cell.content);
	            return 1;
	        }
	        var cells = this.getCellsInRange($cell1, $cell2);

	        if (!cells) { return 0; }

	        var rows = cells
	            // get cell objects
	            .map(function (index) {
	              var ref;

	              return (ref = this$1).getCell.apply(ref, index);
	        })
	            // convert to array of rows
	            .reduce(function (acc, curr) {
	                var rowIndex = curr.rowIndex;

	                acc[rowIndex] = acc[rowIndex] || [];
	                acc[rowIndex].push(curr.content);

	                return acc;
	            }, []);

	        var values = rows
	            // join values by tab
	            .map(function (row) { return row.join('\t'); })
	            // join rows by newline
	            .join('\n');

	        copyTextToClipboard(values);

	        // return no of cells copied
	        return rows.reduce(function (total, row) { return total + row.length; }, 0);
	    }

	    pasteContentInCell(data) {
	        var this$1 = this;

	        if (!this.$focusedCell) { return; }

	        var matrix = data
	            .split('\n')
	            .map(function (row) { return row.split('\t'); })
	            .filter(function (row) { return row.length && row.every(function (it) { return it; }); });

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var focusedCell = {
	            colIndex: +colIndex,
	            rowIndex: +rowIndex
	        };

	        matrix.forEach(function (row, i) {
	            var rowIndex = i + focusedCell.rowIndex;
	            row.forEach(function (cell, j) {
	                var colIndex = j + focusedCell.colIndex;
	                this$1.updateCell(colIndex, rowIndex, cell);
	            });
	        });
	    }

	    activateFilter(colIndex) {
	        this.columnmanager.toggleFilter();
	        this.columnmanager.focusFilter(colIndex);

	        if (!this.columnmanager.isFilterShown) {
	            // put focus back on cell
	            this.$focusedCell && this.$focusedCell.focus();
	        }
	    }

	    updateCell(colIndex, rowIndex, value) {
	        var cell = this.datamanager.updateCell(colIndex, rowIndex, {
	            content: value
	        });
	        this.refreshCell(cell);
	    }

	    refreshCell(cell) {
	        var $cell = $(this.selector(cell.colIndex, cell.rowIndex), this.bodyScrollable);
	        $cell.innerHTML = this.getCellContent(cell);
	    }

	    toggleTreeButton(rowIndex, flag) {
	        var colIndex = this.columnmanager.getFirstColumnIndex();
	        var $cell = this.getCell$(colIndex, rowIndex);
	        if ($cell) {
	            $cell.classList[flag ? 'remove' : 'add']('dt-cell--tree-close');
	        }
	    }

	    isStandardCell(colIndex) {
	        // Standard cells are in Sr. No and Checkbox column
	        return colIndex < this.columnmanager.getFirstColumnIndex();
	    }

	    focusCellInDirection(direction) {
	        if (!this.$focusedCell) {
	            return false;
	        } else if (this.$editingCell && ['tab', 'shift+tab'].includes(direction)) {
	            this.deactivateEditing();
	        }

	        var $cell = this.$focusedCell;

	        if (direction === 'left' || direction === 'shift+tab') {
	            $cell = this.getLeftCell$($cell);
	        } else if (direction === 'right' || direction === 'tab') {
	            $cell = this.getRightCell$($cell);
	        } else if (direction === 'up') {
	            $cell = this.getAboveCell$($cell);
	        } else if (direction === 'down') {
	            $cell = this.getBelowCell$($cell);
	        }

	        if (!$cell) {
	            return false;
	        }

	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var column = this.columnmanager.getColumn(colIndex);

	        if (!column.focusable) {
	            var $prevFocusedCell = this.$focusedCell;
	            this.unfocusCell($prevFocusedCell);
	            this.$focusedCell = $cell;
	            var ret = this.focusCellInDirection(direction);
	            if (!ret) {
	                this.focusCell($prevFocusedCell);
	            }
	            return ret;
	        }

	        this.focusCell($cell);
	        return true;
	    }

	    getCell$(colIndex, rowIndex) {
	        return $(this.selector(colIndex, rowIndex), this.bodyScrollable);
	    }

	    getAboveCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $aboveRow = $cell.parentElement.previousElementSibling;
	        while ($aboveRow && $aboveRow.classList.contains('dt-row--hide')) {
	            $aboveRow = $aboveRow.previousElementSibling;
	        }

	        if (!$aboveRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $aboveRow);
	    }

	    getBelowCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $belowRow = $cell.parentElement.nextElementSibling;
	        while ($belowRow && $belowRow.classList.contains('dt-row--hide')) {
	            $belowRow = $belowRow.nextElementSibling;
	        }

	        if (!$belowRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $belowRow);
	    }

	    getLeftCell$($cell) {
	        return $cell.previousElementSibling;
	    }

	    getRightCell$($cell) {
	        return $cell.nextElementSibling;
	    }

	    getLeftMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getFirstColumnIndex(), rowIndex);
	    }

	    getRightMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getLastColumnIndex(), rowIndex);
	    }

	    getTopMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getFirstRowIndex());
	    }

	    getBottomMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getLastRowIndex());
	    }

	    getCell(colIndex, rowIndex) {
	        return this.instance.datamanager.getCell(colIndex, rowIndex);
	    }

	    getRowHeight() {
	        return $.style($('.dt-row', this.bodyScrollable), 'height');
	    }

	    scrollToCell($cell) {
	        if ($.inViewport($cell, this.bodyScrollable)) { return false; }

	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        this.rowmanager.scrollToRow(rowIndex);
	        return false;
	    }

	    getRowCountPerPage() {
	        return Math.ceil(this.instance.getViewportHeight() / this.getRowHeight());
	    }

	    getCellHTML(cell) {
	        var rowIndex = cell.rowIndex;
	        var colIndex = cell.colIndex;
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var isTotalRow = cell.isTotalRow;
	        var dataAttr = makeDataAttributeString({
	            rowIndex: rowIndex,
	            colIndex: colIndex,
	            isHeader: isHeader,
	            isFilter: isFilter,
	            isTotalRow: isTotalRow
	        });

	        var row = this.datamanager.getRow(rowIndex);

	        var isBodyCell = !(isHeader || isFilter || isTotalRow);

	        var className = [
	            'dt-cell',
	            'dt-cell--col-' + colIndex,
	            isBodyCell ? ("dt-cell--" + colIndex + "-" + rowIndex) : '',
	            isBodyCell ? 'dt-cell--row-' + rowIndex : '',
	            isHeader ? 'dt-cell--header' : '',
	            isHeader ? ("dt-cell--header-" + colIndex) : '',
	            isFilter ? 'dt-cell--filter' : '',
	            isBodyCell && (row && row.meta.isTreeNodeClose) ? 'dt-cell--tree-close' : ''
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\" " + dataAttr + " tabindex=\"0\">\n                " + (this.getCellContent(cell)) + "\n            </div>\n        ");
	    }

	    getCellContent(cell) {
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var colIndex = cell.colIndex;

	        var editable = !isHeader && cell.editable !== false;
	        var editCellHTML = editable ? this.getEditCellHTML(colIndex) : '';

	        var sortable = isHeader && cell.sortable !== false;
	        var sortIndicator = sortable ?
	            ("<span class=\"sort-indicator\">\n                " + (this.options.sortIndicator[cell.sortOrder]) + "\n            </span>") :
	            '';

	        var resizable = isHeader && cell.resizable !== false;
	        var resizeColumn = resizable ? '<span class="dt-cell__resize-handle"></span>' : '';

	        var hasDropdown = isHeader && cell.dropdown !== false;
	        var dropdown = hasDropdown ? this.columnmanager.getDropdownHTML() : '';

	        var customFormatter = cell.format || (cell.column && cell.column.format) || null;

	        var contentHTML;
	        if (isHeader || isFilter || !customFormatter) {
	            contentHTML = cell.content;
	        } else {
	            var row = this.datamanager.getRow(cell.rowIndex);
	            var data = this.datamanager.getData(cell.rowIndex);
	            contentHTML = customFormatter(cell.content, row, cell.column, data);
	        }

	        cell.html = contentHTML;

	        if (this.options.treeView && !(isHeader || isFilter) && cell.indent !== undefined) {
	            var nextRow = this.datamanager.getRow(cell.rowIndex + 1);
	            var addToggle = nextRow && nextRow.meta.indent > cell.indent;
	            var leftPadding = 20;
	            var unit = 'px';

	            // Add toggle and indent in the first column
	            var firstColumnIndex = this.datamanager.getColumnIndexById('_rowIndex') + 1;
	            if (firstColumnIndex === cell.colIndex) {
	                var padding = ((cell.indent || 0)) * leftPadding;
	                var toggleHTML = addToggle ?
	                    ("<span class=\"dt-tree-node__toggle\" style=\"left: " + (padding - leftPadding) + unit + "\">\n                        <span class=\"icon-open\">" + (icons.chevronDown) + "</span>\n                        <span class=\"icon-close\">" + (icons.chevronRight) + "</span>\n                    </span>") : '';
	                contentHTML = "<span class=\"dt-tree-node\" style=\"padding-left: " + padding + unit + "\">\n                    " + toggleHTML + "\n                    <span>" + contentHTML + "</span>\n                </span>";
	            }
	        }

	        var className = [
	            'dt-cell__content',
	            isHeader ? ("dt-cell__content--header-" + colIndex) : ("dt-cell__content--col-" + colIndex)
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\">\n                " + contentHTML + "\n                " + sortIndicator + "\n                " + resizeColumn + "\n                " + dropdown + "\n            </div>\n            " + editCellHTML + "\n        ");
	    }

	    getEditCellHTML(colIndex) {
	        return ("<div class=\"dt-cell__edit dt-cell__edit--col-" + colIndex + "\"></div>");
	    }

	    selector(colIndex, rowIndex) {
	        return (".dt-cell--" + colIndex + "-" + rowIndex);
	    }
	}

	class ColumnManager {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'header',
	            'datamanager',
	            'cellmanager',
	            'style',
	            'wrapper',
	            'rowmanager',
	            'bodyScrollable',
	            'bodyRenderer'
	        ]);

	        this.bindEvents();
	    }

	    renderHeader() {
	        this.header.innerHTML = '<div></div>';
	        this.refreshHeader();
	    }

	    refreshHeader() {
	        var columns = this.datamanager.getColumns();

	        // refresh html
	        $('div', this.header).innerHTML = this.getHeaderHTML(columns);

	        this.$filterRow = $('.dt-row-filter', this.header);
	        if (this.$filterRow) {
	            $.style(this.$filterRow, { display: 'none' });
	        }
	        // reset columnMap
	        this.$columnMap = [];
	        this.bindMoveColumn();
	    }

	    getHeaderHTML(columns) {
	        var html = this.rowmanager.getRowHTML(columns, {
	            isHeader: 1
	        });
	        if (this.options.inlineFilters) {
	            html += this.rowmanager.getRowHTML(columns, {
	                isFilter: 1
	            });
	        }
	        return html;
	    }

	    bindEvents() {
	        this.bindDropdown();
	        this.bindResizeColumn();
	        this.bindPerfectColumnWidth();
	        this.bindFilter();
	    }

	    bindDropdown() {
	        var this$1 = this;

	        var toggleClass = '.dt-dropdown__toggle';
	        var dropdownClass = '.dt-dropdown__list';

	        // attach the dropdown list to container
	        this.instance.dropdownContainer.innerHTML = this.getDropdownListHTML();
	        this.$dropdownList = this.instance.dropdownContainer.firstElementChild;

	        $.on(this.header, 'click', toggleClass, function (e) {
	            this$1.openDropdown(e);
	        });

	        var deactivateDropdownOnBodyClick = function (e) {
	            var selector = [
	                toggleClass, toggleClass + ' *',
	                dropdownClass, dropdownClass + ' *'
	            ].join(',');
	            if (e.target.matches(selector)) { return; }
	            deactivateDropdown();
	        };
	        $.on(document.body, 'click', deactivateDropdownOnBodyClick);
	        document.addEventListener('scroll', deactivateDropdown, true);

	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'click', deactivateDropdownOnBodyClick);
	            $.off(document, 'scroll', deactivateDropdown);
	        });

	        $.on(this.$dropdownList, 'click', '.dt-dropdown__list-item', function (e, $item) {
	            if (!this$1._dropdownActiveColIndex) { return; }
	            var dropdownItems = this$1.options.headerDropdown;
	            var ref = $.data($item);
	            var index = ref.index;
	            var colIndex = this$1._dropdownActiveColIndex;
	            var callback = dropdownItems[index].action;

	            callback && callback.call(this$1.instance, this$1.getColumn(colIndex));
	            this$1.hideDropdown();
	        });

	        var _this = this;
	        function deactivateDropdown(e) {
	            _this.hideDropdown();
	        }

	        this.hideDropdown();
	    }

	    openDropdown(e) {
	        if (!this._dropdownWidth) {
	            $.style(this.$dropdownList, { display: '' });
	            this._dropdownWidth = $.style(this.$dropdownList, 'width');
	        }
	        $.style(this.$dropdownList, {
	            display: '',
	            left: (e.clientX - this._dropdownWidth + 4) + 'px',
	            top: (e.clientY + 4) + 'px'
	        });
	        var $cell = $.closest('.dt-cell', e.target);
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        this._dropdownActiveColIndex = colIndex;
	    }

	    hideDropdown() {
	        $.style(this.$dropdownList, {
	            display: 'none'
	        });
	        this._dropdownActiveColIndex = null;
	    }

	    bindResizeColumn() {
	        var this$1 = this;

	        var isDragging = false;
	        var $resizingCell, startWidth, startX;

	        $.on(this.header, 'mousedown', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            document.body.classList.add('dt-resize');
	            var $cell = $handle.parentNode.parentNode;
	            $resizingCell = $cell;
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            var col = this$1.getColumn(colIndex);

	            if (col && col.resizable === false) {
	                return;
	            }

	            isDragging = true;
	            startWidth = $.style($('.dt-cell__content', $resizingCell), 'width');
	            startX = e.pageX;
	        });

	        var onMouseup = function (e) {
	            document.body.classList.remove('dt-resize');
	            if (!$resizingCell) { return; }
	            isDragging = false;

	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            this$1.setColumnWidth(colIndex);
	            this$1.style.setBodyStyle();
	            $resizingCell = null;
	        };
	        $.on(document.body, 'mouseup', onMouseup);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mouseup', onMouseup);
	        });

	        var onMouseMove = function (e) {
	            if (!isDragging) { return; }
	            var finalWidth = startWidth + (e.pageX - startX);
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;

	            var columnMinWidth = this$1.options.minimumColumnWidth;
	            if (columnMinWidth > finalWidth) {
	                // don't resize past 30 pixels
	                return;
	            }
	            this$1.datamanager.updateColumn(colIndex, {
	                width: finalWidth
	            });
	            this$1.setColumnHeaderWidth(colIndex);
	        };
	        $.on(document.body, 'mousemove', onMouseMove);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mousemove', onMouseMove);
	        });
	    }

	    bindPerfectColumnWidth() {
	        var this$1 = this;

	        $.on(this.header, 'dblclick', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            var $cell = $handle.parentNode.parentNode;
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;

	            var longestCell = this$1.bodyRenderer.visibleRows
	                .map(function (d) { return d[colIndex]; })
	                .reduce(function (acc, curr) { return acc.content.length > curr.content.length ? acc : curr; });

	            var $longestCellHTML = this$1.cellmanager.getCellHTML(longestCell);
	            var $div = document.createElement('div');
	            $div.innerHTML = $longestCellHTML;
	            var cellText = $div.querySelector('.dt-cell__content').textContent;

	            var ref$1 = $.getStyle(this$1.bodyScrollable.querySelector('.dt-cell__content'));
	            var borderLeftWidth = ref$1.borderLeftWidth;
	            var borderRightWidth = ref$1.borderRightWidth;
	            var paddingLeft = ref$1.paddingLeft;
	            var paddingRight = ref$1.paddingRight;

	            var padding = [borderLeftWidth, borderRightWidth, paddingLeft, paddingRight]
	                .map(parseFloat)
	                .reduce(function (sum, val) { return sum + val; });

	            var width = $.measureTextWidth(cellText) + padding;
	            this$1.datamanager.updateColumn(colIndex, { width: width });
	            this$1.setColumnHeaderWidth(colIndex);
	            this$1.setColumnWidth(colIndex);
	        });
	    }

	    bindMoveColumn() {
	        var this$1 = this;

	        if (this.options.disableReorderColumn) { return; }

	        var $parent = $('.dt-row', this.header);

	        this.sortable = Sortable.create($parent, {
	            onEnd: function (e) {
	                var oldIndex = e.oldIndex;
	                var newIndex = e.newIndex;
	                var $draggedCell = e.item;
	                var ref = $.data($draggedCell);
	                var colIndex = ref.colIndex;
	                if (+colIndex === newIndex) { return; }

	                this$1.switchColumn(oldIndex, newIndex);
	            },
	            preventOnFilter: false,
	            filter: '.dt-cell__resize-handle, .dt-dropdown',
	            chosenClass: 'dt-cell--dragging',
	            animation: 150
	        });
	    }

	    sortColumn(colIndex, nextSortOrder) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.sortRows(colIndex, nextSortOrder)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onSortColumn', this$1.getColumn(colIndex));
	            });
	    }

	    removeColumn(colIndex) {
	        var this$1 = this;

	        var removedCol = this.getColumn(colIndex);
	        this.instance.freeze();
	        this.datamanager.removeColumn(colIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onRemoveColumn', removedCol);
	            });
	    }

	    switchColumn(oldIndex, newIndex) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.datamanager.switchColumn(oldIndex, newIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () {
	                this$1.setColumnWidth(oldIndex);
	                this$1.setColumnWidth(newIndex);
	                this$1.instance.unfreeze();
	            })
	            .then(function () {
	                this$1.fireEvent('onSwitchColumn',
	                    this$1.getColumn(oldIndex), this$1.getColumn(newIndex)
	                );
	            });
	    }

	    toggleFilter(flag) {
	        if (!this.options.inlineFilters) { return; }

	        var showFilter;
	        if (flag === undefined) {
	            showFilter = !this.isFilterShown;
	        } else {
	            showFilter = flag;
	        }

	        if (showFilter) {
	            $.style(this.$filterRow, { display: '' });
	        } else {
	            $.style(this.$filterRow, { display: 'none' });
	        }

	        this.isFilterShown = showFilter;
	        this.style.setBodyStyle();
	    }

	    focusFilter(colIndex) {
	        if (!this.isFilterShown) { return; }

	        var $filterInput = $((".dt-cell--col-" + colIndex + " .dt-filter"), this.$filterRow);
	        $filterInput.focus();
	    }

	    bindFilter() {
	        var this$1 = this;

	        if (!this.options.inlineFilters) { return; }
	        var handler = function (e) {
	            this$1.applyFilter(this$1.getAppliedFilters());
	        };
	        $.on(this.header, 'keydown', '.dt-filter', debounce$1(handler, 300));
	    }

	    applyFilter(filters) {
	        var this$1 = this;

	        this.datamanager.filterRows(filters)
	            .then(function (ref) {
	                var rowsToShow = ref.rowsToShow;

	                this$1.rowmanager.showRows(rowsToShow);
	            });
	    }

	    getAppliedFilters() {
	        var filters = {};
	        $.each('.dt-filter', this.header).map(function (input) {
	            var value = input.value;
	            if (value) {
	                filters[input.dataset.colIndex] = value;
	            }
	        });
	        return filters;
	    }

	    applyDefaultSortOrder() {
	        // sort rows if any 1 column has a default sortOrder set
	        var columnsToSort = this.getColumns().filter(function (col) { return col.sortOrder !== 'none'; });

	        if (columnsToSort.length === 1) {
	            var column = columnsToSort[0];
	            this.sortColumn(column.colIndex, column.sortOrder);
	        }
	    }

	    sortRows(colIndex, sortOrder) {
	        return this.datamanager.sortRows(colIndex, sortOrder);
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    setColumnWidth(colIndex, width) {
	        colIndex = +colIndex;

	        var columnWidth = width || this.getColumn(colIndex).width;

	        var selector = [
	            (".dt-cell__content--col-" + colIndex),
	            (".dt-cell__edit--col-" + colIndex)
	        ].join(', ');

	        var styles = {
	            width: columnWidth + 'px'
	        };

	        this.style.setStyle(selector, styles);
	    }

	    setColumnHeaderWidth(colIndex) {
	        colIndex = +colIndex;
	        this.$columnMap = this.$columnMap || [];
	        var selector = ".dt-cell__content--header-" + colIndex;
	        var ref = this.getColumn(colIndex);
	        var width = ref.width;

	        var $column = this.$columnMap[colIndex];
	        if (!$column) {
	            $column = this.header.querySelector(selector);
	            this.$columnMap[colIndex] = $column;
	        }

	        $column.style.width = width + 'px';
	    }

	    getColumnMinWidth(colIndex) {
	        colIndex = +colIndex;
	        return this.getColumn(colIndex).minWidth || 24;
	    }

	    getFirstColumnIndex() {
	        return this.datamanager.getColumnIndexById('_rowIndex') + 1;
	    }

	    getHeaderCell$(colIndex) {
	        return $((".dt-cell--header-" + colIndex), this.header);
	    }

	    getLastColumnIndex() {
	        return this.datamanager.getColumnCount() - 1;
	    }

	    getDropdownHTML() {
	        var ref = this.options;
	        var dropdownButton = ref.dropdownButton;

	        return ("\n            <div class=\"dt-dropdown\">\n                <div class=\"dt-dropdown__toggle\">" + dropdownButton + "</div>\n            </div>\n      ");
	    }

	    getDropdownListHTML() {
	        var ref = this.options;
	        var dropdownItems = ref.headerDropdown;

	        return ("\n            <div class=\"dt-dropdown__list\">\n            " + (dropdownItems.map(function (d, i) { return ("\n                <div class=\"dt-dropdown__list-item\" data-index=\"" + i + "\">" + (d.label) + "</div>\n            "); }).join('')) + "\n            </div>\n        ");
	    }
	}

	class RowManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'wrapper',
	            'bodyScrollable',
	            'bodyRenderer',
	            'style'
	        ]);

	        this.bindEvents();
	        this.refreshRows = nextTick(this.refreshRows, this);
	    }

	    get datamanager() {
	        return this.instance.datamanager;
	    }

	    get cellmanager() {
	        return this.instance.cellmanager;
	    }

	    bindEvents() {
	        this.bindCheckbox();
	    }

	    bindCheckbox() {
	        var this$1 = this;

	        if (!this.options.checkboxColumn) { return; }

	        // map of checked rows
	        this.checkMap = [];

	        $.on(this.wrapper, 'click', '.dt-cell--col-0 [type="checkbox"]', function (e, $checkbox) {
	            var $cell = $checkbox.closest('.dt-cell');
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var isHeader = ref.isHeader;
	            var checked = $checkbox.checked;

	            if (isHeader) {
	                this$1.checkAll(checked);
	            } else {
	                this$1.checkRow(rowIndex, checked);
	            }
	        });
	    }

	    refreshRows() {
	        this.instance.renderBody();
	        this.instance.setDimensions();
	    }

	    refreshRow(row, rowIndex) {
	        var this$1 = this;

	        var _row = this.datamanager.updateRow(row, rowIndex);

	        _row.forEach(function (cell) {
	            this$1.cellmanager.refreshCell(cell);
	        });
	    }

	    getCheckedRows() {
	        if (!this.checkMap) {
	            return [];
	        }

	        var out = [];
	        for (var rowIndex in this.checkMap) {
	            var checked = this.checkMap[rowIndex];
	            if (checked === 1) {
	                out.push(rowIndex);
	            }
	        }

	        return out;
	    }

	    highlightCheckedRows() {
	        var this$1 = this;

	        this.getCheckedRows()
	            .map(function (rowIndex) { return this$1.checkRow(rowIndex, true); });
	    }

	    checkRow(rowIndex, toggle) {
	        var value = toggle ? 1 : 0;
	        var selector = function (rowIndex) { return (".dt-cell--0-" + rowIndex + " [type=\"checkbox\"]"); };
	        // update internal map
	        this.checkMap[rowIndex] = value;
	        // set checkbox value explicitly
	        $.each(selector(rowIndex), this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight row
	        this.highlightRow(rowIndex, toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow', this.datamanager.getRow(rowIndex));
	    }

	    checkAll(toggle) {
	        var value = toggle ? 1 : 0;

	        // update internal map
	        if (toggle) {
	            this.checkMap = Array.from(Array(this.getTotalRows())).map(function (c) { return value; });
	        } else {
	            this.checkMap = [];
	        }
	        // set checkbox value
	        $.each('.dt-cell--col-0 [type="checkbox"]', this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight all
	        this.highlightAll(toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow');
	    }

	    showCheckStatus() {
	        if (!this.options.checkedRowStatus) { return; }
	        var checkedRows = this.getCheckedRows();
	        var count = checkedRows.length;
	        if (count > 0) {
	            this.bodyRenderer.showToastMessage((count + " row" + (count > 1 ? 's' : '') + " selected"));
	        } else {
	            this.bodyRenderer.clearToastMessage();
	        }
	    }

	    highlightRow(rowIndex, toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        var $row = this.getRow$(rowIndex);
	        if (!$row) { return; }

	        if (!toggle && this.bodyScrollable.classList.contains('dt-scrollable--highlight-all')) {
	            $row.classList.add('dt-row--unhighlight');
	            return;
	        }

	        if (toggle && $row.classList.contains('dt-row--unhighlight')) {
	            $row.classList.remove('dt-row--unhighlight');
	        }

	        this._highlightedRows = this._highlightedRows || {};

	        if (toggle) {
	            $row.classList.add('dt-row--highlight');
	            this._highlightedRows[rowIndex] = $row;
	        } else {
	            $row.classList.remove('dt-row--highlight');
	            delete this._highlightedRows[rowIndex];
	        }
	    }

	    highlightAll(toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        if (toggle) {
	            this.bodyScrollable.classList.add('dt-scrollable--highlight-all');
	        } else {
	            this.bodyScrollable.classList.remove('dt-scrollable--highlight-all');
	            for (var rowIndex in this._highlightedRows) {
	                var $row = this._highlightedRows[rowIndex];
	                $row.classList.remove('dt-row--highlight');
	            }
	            this._highlightedRows = {};
	        }
	    }

	    showRows(rowIndices) {
	        var this$1 = this;

	        rowIndices = ensureArray(rowIndices);
	        var rows = rowIndices.map(function (rowIndex) { return this$1.datamanager.getRow(rowIndex); });
	        this.bodyRenderer.renderRows(rows);
	    }

	    showAllRows() {
	        var rowIndices = this.datamanager.getAllRowIndices();
	        this.showRows(rowIndices);
	    }

	    getChildrenToShowForNode(rowIndex) {
	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = false;

	        return this.datamanager.getImmediateChildren(rowIndex);
	    }

	    openSingleNode(rowIndex) {
	        var childrenToShow = this.getChildrenToShowForNode(rowIndex);
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    getChildrenToHideForNode(rowIndex) {
	        var this$1 = this;

	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = true;

	        var rowsToHide = this.datamanager.getChildren(rowIndex);
	        rowsToHide.forEach(function (rowIndex) {
	            var row = this$1.datamanager.getRow(rowIndex);
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });

	        return rowsToHide;
	    }

	    closeSingleNode(rowIndex) {
	        var rowsToHide = this.getChildrenToHideForNode(rowIndex);
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    expandAllNodes() {
	        var this$1 = this;

	        var rows = this.datamanager.getRows();
	        var rootNodes = rows.filter(function (row) { return !row.meta.isLeaf; });

	        var childrenToShow = rootNodes.map(function (row) { return this$1.getChildrenToShowForNode(row.meta.rowIndex); }).flat();
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    collapseAllNodes() {
	        var this$1 = this;

	        var rows = this.datamanager.getRows();
	        var rootNodes = rows.filter(function (row) { return row.meta.indent === 0; });

	        var rowsToHide = rootNodes.map(function (row) { return this$1.getChildrenToHideForNode(row.meta.rowIndex); }).flat();
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    setTreeDepth(depth) {
	        var rows = this.datamanager.getRows();

	        var rowsToOpen = rows.filter(function (row) { return row.meta.indent < depth; });
	        var rowsToClose = rows.filter(function (row) { return row.meta.indent >= depth; });
	        var rowsToHide = rowsToClose.filter(function (row) { return row.meta.indent > depth; });

	        rowsToClose.forEach(function (row) {
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });
	        rowsToOpen.forEach(function (row) {
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = false;
	            }
	        });

	        var rowsToShow = rows
	            .filter(function (row) { return !rowsToHide.includes(row); })
	            .map(function (row) { return row.meta.rowIndex; })
	            .sort(numberSortAsc);
	        this.showRows(rowsToShow);
	    }

	    getRow$(rowIndex) {
	        return $(this.selector(rowIndex), this.bodyScrollable);
	    }

	    getTotalRows() {
	        return this.datamanager.getRowCount();
	    }

	    getFirstRowIndex() {
	        return 0;
	    }

	    getLastRowIndex() {
	        return this.datamanager.getRowCount() - 1;
	    }

	    scrollToRow(rowIndex) {
	        rowIndex = +rowIndex;
	        this._lastScrollTo = this._lastScrollTo || 0;
	        var $row = this.getRow$(rowIndex);
	        if ($.inViewport($row, this.bodyScrollable)) { return; }

	        var ref = $row.getBoundingClientRect();
	        var height = ref.height;
	        var ref$1 = this.bodyScrollable.getBoundingClientRect();
	        var top = ref$1.top;
	        var bottom = ref$1.bottom;
	        var rowsInView = Math.floor((bottom - top) / height);

	        var offset = 0;
	        if (rowIndex > this._lastScrollTo) {
	            offset = height * ((rowIndex + 1) - rowsInView);
	        } else {
	            offset = height * ((rowIndex + 1) - 1);
	        }

	        this._lastScrollTo = rowIndex;
	        $.scrollTop(this.bodyScrollable, offset);
	    }

	    getRowHTML(row, props) {
	        var this$1 = this;

	        var dataAttr = makeDataAttributeString(props);
	        var rowIdentifier = props.rowIndex;

	        if (props.isFilter) {
	            row = row.map(function (cell) { return (Object.assign({}, cell, {
	                content: this$1.getFilterInput({
	                    colIndex: cell.colIndex
	                }),
	                isFilter: 1,
	                isHeader: undefined,
	                editable: false
	            })); });

	            rowIdentifier = 'filter';
	        }

	        if (props.isHeader) {
	            rowIdentifier = 'header';
	        }

	        return ("\n            <div class=\"dt-row dt-row-" + rowIdentifier + "\" " + dataAttr + ">\n                " + (row.map(function (cell) { return this$1.cellmanager.getCellHTML(cell); }).join('')) + "\n            </div>\n        ");
	    }

	    getFilterInput(props) {
	        var dataAttr = makeDataAttributeString(props);
	        return ("<input class=\"dt-filter dt-input\" type=\"text\" " + dataAttr + " tabindex=\"1\" />");
	    }

	    selector(rowIndex) {
	        return (".dt-row-" + rowIndex);
	    }
	}

	var hyperlist = createCommonjsModule(function (module, exports) {
	(function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a){ return a(o,!0); }if(i){ return i(o,!0); }var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++){ s(r[o]); }return s})({1:[function(_dereq_,module,exports){

	// Default configuration.

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaultConfig = {
	  width: '100%',
	  height: '100%'
	};

	// Check for valid number.
	var isNumber = function isNumber(input) {
	  return Number(input) === Number(input);
	};

	/**
	 * Creates a HyperList instance that virtually scrolls very large amounts of
	 * data effortlessly.
	 */

	var HyperList = function () {
	  _createClass(HyperList, null, [{
	    key: 'create',
	    value: function create(element, userProvidedConfig) {
	      return new HyperList(element, userProvidedConfig);
	    }

	    /**
	     * Merge given css style on an element
	     * @param {DOMElement} element
	     * @param {Object} style
	     */

	  }, {
	    key: 'mergeStyle',
	    value: function mergeStyle(element, style) {
	      for (var i in style) {
	        if (element.style[i] !== style[i]) {
	          element.style[i] = style[i];
	        }
	      }
	    }
	  }, {
	    key: 'getMaxBrowserHeight',
	    value: function getMaxBrowserHeight() {
	      // Create two elements, the wrapper is `1px` tall and is transparent and
	      // positioned at the top of the page. Inside that is an element that gets
	      // set to 1 billion pixels. Then reads the max height the browser can
	      // calculate.
	      var wrapper = document.createElement('div');
	      var fixture = document.createElement('div');

	      // As said above, these values get set to put the fixture elements into the
	      // right visual state.
	      HyperList.mergeStyle(wrapper, { position: 'absolute', height: '1px', opacity: 0 });
	      HyperList.mergeStyle(fixture, { height: '1e7px' });

	      // Add the fixture into the wrapper element.
	      wrapper.appendChild(fixture);

	      // Apply to the page, the values won't kick in unless this is attached.
	      document.body.appendChild(wrapper);

	      // Get the maximum element height in pixels.
	      var maxElementHeight = fixture.offsetHeight;

	      // Remove the element immediately after reading the value.
	      document.body.removeChild(wrapper);

	      return maxElementHeight;
	    }
	  }]);

	  function HyperList(element, userProvidedConfig) {
	    var _this = this;

	    _classCallCheck(this, HyperList);

	    this._config = {};
	    this._lastRepaint = null;
	    this._maxElementHeight = HyperList.getMaxBrowserHeight();

	    this.refresh(element, userProvidedConfig);

	    var config = this._config;

	    // Create internal render loop.
	    var render = function render() {
	      var scrollTop = _this._getScrollPosition();
	      var lastRepaint = _this._lastRepaint;

	      _this._renderAnimationFrame = window.requestAnimationFrame(render);

	      if (scrollTop === lastRepaint) {
	        return;
	      }

	      if (!lastRepaint || Math.abs(scrollTop - lastRepaint) > _this._averageHeight) {
	        var rendered = _this._renderChunk();

	        _this._lastRepaint = scrollTop;

	        if (rendered !== false && typeof config.afterRender === 'function') {
	          config.afterRender();
	        }
	      }
	    };

	    render();
	  }

	  _createClass(HyperList, [{
	    key: 'destroy',
	    value: function destroy() {
	      window.cancelAnimationFrame(this._renderAnimationFrame);
	    }
	  }, {
	    key: 'refresh',
	    value: function refresh(element, userProvidedConfig) {
	      var _this2 = this;

	      Object.assign(this._config, defaultConfig, userProvidedConfig);

	      if (!element || element.nodeType !== 1) {
	        throw new Error('HyperList requires a valid DOM Node container');
	      }

	      this._element = element;

	      var config = this._config;

	      var scroller = this._scroller || config.scroller || document.createElement(config.scrollerTagName || 'tr');

	      // Default configuration option `useFragment` to `true`.
	      if (typeof config.useFragment !== 'boolean') {
	        this._config.useFragment = true;
	      }

	      if (!config.generate) {
	        throw new Error('Missing required `generate` function');
	      }

	      if (!isNumber(config.total)) {
	        throw new Error('Invalid required `total` value, expected number');
	      }

	      if (!Array.isArray(config.itemHeight) && !isNumber(config.itemHeight)) {
	        throw new Error('\n        Invalid required `itemHeight` value, expected number or array\n      '.trim());
	      } else if (isNumber(config.itemHeight)) {
	        this._itemHeights = Array(config.total).fill(config.itemHeight);
	      } else {
	        this._itemHeights = config.itemHeight;
	      }

	      // Width and height should be coerced to string representations. Either in
	      // `%` or `px`.
	      Object.keys(defaultConfig).filter(function (prop) {
	        return prop in config;
	      }).forEach(function (prop) {
	        var value = config[prop];
	        var isValueNumber = isNumber(value);
	        var isValuePercent = isValueNumber ? false : value.slice(-1) === '%';

	        if (value && typeof value !== 'string' && typeof value !== 'number') {
	          var msg = 'Invalid optional `' + prop + '`, expected string or number';
	          throw new Error(msg);
	        } else if (isValueNumber) {
	          config[prop] = value + 'px';
	        }

	        if (prop !== 'height') {
	          return;
	        }

	        // Compute the containerHeight as number
	        var numberValue = isValueNumber ? value : parseInt(value.replace(/px|%/, ''), 10);

	        if (isValuePercent) {
	          _this2._containerHeight = window.innerHeight * numberValue / 100;
	        } else {
	          _this2._containerHeight = isNumber(value) ? value : numberValue;
	        }
	      });

	      // Decorate the container element with styles that will match
	      // the user supplied configuration.
	      var elementStyle = {
	        width: '' + config.width,
	        height: '' + config.height,
	        overflow: 'auto',
	        position: 'relative'
	      };

	      HyperList.mergeStyle(element, elementStyle);

	      var scrollerHeight = config.itemHeight * config.total;
	      var maxElementHeight = this._maxElementHeight;

	      if (scrollerHeight > maxElementHeight) {
	        console.warn(['HyperList: The maximum element height', maxElementHeight + 'px has', 'been exceeded; please reduce your item height.'].join(' '));
	      }

	      var scrollerStyle = {
	        opacity: '0',
	        position: 'absolute',
	        width: '1px',
	        height: scrollerHeight + 'px'
	      };

	      HyperList.mergeStyle(scroller, scrollerStyle);

	      // Only append the scroller element once.
	      if (!this._scroller) {
	        element.appendChild(scroller);
	      }

	      // Set the scroller instance.
	      this._scroller = scroller;
	      this._scrollHeight = this._computeScrollHeight();

	      // Reuse the item positions if refreshed, otherwise set to empty array.
	      this._itemPositions = this._itemPositions || Array(config.total).fill(0);

	      // Each index in the array should represent the position in the DOM.
	      this._computePositions(0);

	      // Render after refreshing. Force render if we're calling refresh manually.
	      this._renderChunk(this._lastRepaint !== null);

	      if (typeof config.afterRender === 'function') {
	        config.afterRender();
	      }
	    }
	  }, {
	    key: '_getRow',
	    value: function _getRow(i) {
	      var config = this._config;
	      var item = config.generate(i);
	      var height = item.height;

	      if (height !== undefined && isNumber(height)) {
	        item = item.element;

	        // The height isn't the same as predicted, compute positions again
	        if (height !== this._itemHeights) {
	          this._itemHeights[i] = height;
	          this._computePositions(i);
	          this._scrollHeight = this._computeScrollHeight(i);
	        }
	      } else {
	        height = this._itemHeights[i];
	      }

	      if (!item || item.nodeType !== 1) {
	        throw new Error('Generator did not return a DOM Node for index: ' + i);
	      }

	      var oldClass = item.getAttribute('class') || '';
	      item.setAttribute('class', oldClass + ' ' + (config.rowClassName || 'vrow'));

	      var top = this._itemPositions[i];

	      HyperList.mergeStyle(item, {
	        position: 'absolute',
	        top: top + 'px'
	      });

	      return item;
	    }
	  }, {
	    key: '_getScrollPosition',
	    value: function _getScrollPosition() {
	      var config = this._config;

	      if (typeof config.overrideScrollPosition === 'function') {
	        return config.overrideScrollPosition();
	      }

	      return this._element.scrollTop;
	    }
	  }, {
	    key: '_renderChunk',
	    value: function _renderChunk(force) {
	      var config = this._config;
	      var element = this._element;
	      var scrollTop = this._getScrollPosition();
	      var total = config.total;

	      var from = config.reverse ? this._getReverseFrom(scrollTop) : this._getFrom(scrollTop) - 1;

	      if (from < 0 || from - this._screenItemsLen < 0) {
	        from = 0;
	      }

	      if (!force && this._lastFrom === from) {
	        return false;
	      }

	      this._lastFrom = from;

	      var to = from + this._cachedItemsLen;

	      if (to > total || to + this._cachedItemsLen > total) {
	        to = total;
	      }

	      // Append all the new rows in a document fragment that we will later append
	      // to the parent node
	      var fragment = config.useFragment ? document.createDocumentFragment() : []
	      // Sometimes you'll pass fake elements to this tool and Fragments require
	      // real elements.


	      // The element that forces the container to scroll.
	      ;var scroller = this._scroller;

	      // Keep the scroller in the list of children.
	      fragment[config.useFragment ? 'appendChild' : 'push'](scroller);

	      for (var i = from; i < to; i++) {
	        var row = this._getRow(i);

	        fragment[config.useFragment ? 'appendChild' : 'push'](row);
	      }

	      if (config.applyPatch) {
	        return config.applyPatch(element, fragment);
	      }

	      element.innerHTML = '';
	      element.appendChild(fragment);
	    }
	  }, {
	    key: '_computePositions',
	    value: function _computePositions() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

	      var config = this._config;
	      var total = config.total;
	      var reverse = config.reverse;

	      if (from < 1 && !reverse) {
	        from = 1;
	      }

	      for (var i = from; i < total; i++) {
	        if (reverse) {
	          if (i === 0) {
	            this._itemPositions[0] = this._scrollHeight - this._itemHeights[0];
	          } else {
	            this._itemPositions[i] = this._itemPositions[i - 1] - this._itemHeights[i];
	          }
	        } else {
	          this._itemPositions[i] = this._itemHeights[i - 1] + this._itemPositions[i - 1];
	        }
	      }
	    }
	  }, {
	    key: '_computeScrollHeight',
	    value: function _computeScrollHeight() {
	      var _this3 = this;

	      var config = this._config;
	      var total = config.total;
	      var scrollHeight = this._itemHeights.reduce(function (a, b) {
	        return a + b;
	      }, 0);

	      HyperList.mergeStyle(this._scroller, {
	        opacity: 0,
	        position: 'absolute',
	        width: '1px',
	        height: scrollHeight + 'px'
	      });

	      // Calculate the height median
	      var sortedItemHeights = this._itemHeights.slice(0).sort(function (a, b) {
	        return a - b;
	      });
	      var middle = Math.floor(total / 2);
	      var averageHeight = total % 2 === 0 ? (sortedItemHeights[middle] + sortedItemHeights[middle - 1]) / 2 : sortedItemHeights[middle];

	      var containerHeight = this._element.clientHeight ? this._element.clientHeight : this._containerHeight;
	      this._screenItemsLen = Math.ceil(containerHeight / averageHeight);
	      this._containerHeight = containerHeight;

	      // Cache 3 times the number of items that fit in the container viewport.
	      this._cachedItemsLen = Math.max(this._cachedItemsLen || 0, this._screenItemsLen * 3);
	      this._averageHeight = averageHeight;

	      if (config.reverse) {
	        window.requestAnimationFrame(function () {
	          _this3._element.scrollTop = scrollHeight;
	        });
	      }

	      return scrollHeight;
	    }
	  }, {
	    key: '_getFrom',
	    value: function _getFrom(scrollTop) {
	      var i = 0;

	      while (this._itemPositions[i] < scrollTop) {
	        i++;
	      }

	      return i;
	    }
	  }, {
	    key: '_getReverseFrom',
	    value: function _getReverseFrom(scrollTop) {
	      var i = this._config.total - 1;

	      while (i > 0 && this._itemPositions[i] < scrollTop + this._containerHeight) {
	        i--;
	      }

	      return i;
	    }
	  }]);

	  return HyperList;
	}();

	exports.default = HyperList;
	module.exports = exports['default'];

	},{}]},{},[1])(1)
	});
	});

	var HyperList = unwrapExports(hyperlist);

	class BodyRenderer {
	    constructor(instance) {
	        this.instance = instance;
	        this.options = instance.options;
	        this.datamanager = instance.datamanager;
	        this.rowmanager = instance.rowmanager;
	        this.cellmanager = instance.cellmanager;
	        this.bodyScrollable = instance.bodyScrollable;
	        this.footer = this.instance.footer;
	        this.log = instance.log;
	    }

	    renderRows(rows) {
	        var this$1 = this;

	        this.visibleRows = rows;
	        this.visibleRowIndices = rows.map(function (row) { return row.meta.rowIndex; });

	        if (rows.length === 0) {
	            this.bodyScrollable.innerHTML = this.getNoDataHTML();
	            return;
	        }

	        var rowViewOrder = this.datamanager.rowViewOrder.map(function (index) {
	            if (this$1.visibleRowIndices.includes(index)) {
	                return index;
	            }
	            return null;
	        }).filter(function (index) { return index !== null; });

	        var computedStyle = getComputedStyle(this.bodyScrollable);

	        var config = {
	            width: computedStyle.width,
	            height: computedStyle.height,
	            itemHeight: this.options.cellHeight,
	            total: rows.length,
	            generate: function (index) {
	                var el = document.createElement('div');
	                var rowIndex = rowViewOrder[index];
	                var row = this$1.datamanager.getRow(rowIndex);
	                var rowHTML = this$1.rowmanager.getRowHTML(row, row.meta);
	                el.innerHTML = rowHTML;
	                return el.children[0];
	            },
	            afterRender: function () {
	                this$1.restoreState();
	            }
	        };

	        if (!this.hyperlist) {
	            this.hyperlist = new HyperList(this.bodyScrollable, config);
	        } else {
	            this.hyperlist.refresh(this.bodyScrollable, config);
	        }

	        this.renderFooter();
	    }

	    render() {
	        var rows = this.datamanager.getRowsForView();
	        this.renderRows(rows);
	        // setDimensions requires atleast 1 row to exist in dom
	        this.instance.setDimensions();
	    }

	    renderFooter() {
	        if (!this.options.showTotalRow) { return; }

	        var totalRow = this.getTotalRow();
	        var html = this.rowmanager.getRowHTML(totalRow, { isTotalRow: 1, rowIndex: 'totalRow' });

	        this.footer.innerHTML = html;
	    }

	    getTotalRow() {
	        var this$1 = this;

	        var columns = this.datamanager.getColumns();
	        var totalRowTemplate = columns.map(function (col) {
	            var content = null;
	            if (['_rowIndex', '_checkbox'].includes(col.id)) {
	                content = '';
	            }
	            return {
	                content: content,
	                isTotalRow: 1,
	                colIndex: col.colIndex,
	                column: col
	            };
	        });

	        var totalRow = totalRowTemplate.map(function (cell, i) {
	            if (cell.content === '') { return cell; }

	            if (this$1.options.hooks.columnTotal) {
	                var columnValues = this$1.visibleRows.map(function (row) { return row[i].content; });
	                var result = this$1.options.hooks.columnTotal.call(this$1.instance, columnValues, cell);
	                if (result != null) {
	                    cell.content = result;
	                    return cell;
	                }
	            }

	            cell.content = this$1.visibleRows.reduce(function (acc, prevRow) {
	                var prevCell = prevRow[i];
	                if (typeof prevCell.content === 'number') {
	                    if (acc == null) { acc = 0; }
	                    return acc + prevCell.content;
	                }
	                return acc;
	            }, cell.content);

	            return cell;
	        });

	        return totalRow;
	    }

	    restoreState() {
	        this.rowmanager.highlightCheckedRows();
	        this.cellmanager.selectAreaOnClusterChanged();
	        this.cellmanager.focusCellOnClusterChanged();
	    }

	    showToastMessage(message, hideAfter) {
	        var this$1 = this;

	        this.instance.toastMessage.innerHTML = this.getToastMessageHTML(message);

	        if (hideAfter) {
	            setTimeout(function () {
	                this$1.clearToastMessage();
	            }, hideAfter * 1000);
	        }
	    }

	    clearToastMessage() {
	        this.instance.toastMessage.innerHTML = '';
	    }

	    getNoDataHTML() {
	        return ("<div class=\"dt-scrollable__no-data\">" + (this.options.noDataMessage) + "</div>");
	    }

	    getToastMessageHTML(message) {
	        return ("<span class=\"dt-toast__message\">" + message + "</span>");
	    }
	}

	class Style {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options', 'datamanager', 'columnmanager',
	            'header', 'footer', 'bodyScrollable', 'datatableWrapper',
	            'getColumn', 'bodyRenderer'
	        ]);

	        this.scopeClass = 'dt-instance-' + instance.constructor.instances;
	        instance.datatableWrapper.classList.add(this.scopeClass);

	        var styleEl = document.createElement('style');
	        instance.wrapper.insertBefore(styleEl, instance.datatableWrapper);
	        this.styleEl = styleEl;

	        this.bindResizeWindow();
	        this.bindScrollHeader();
	    }

	    get stylesheet() {
	        return this.styleEl.sheet;
	    }

	    bindResizeWindow() {
	        this.onWindowResize = this.onWindowResize.bind(this);
	        this.onWindowResize = throttle$1(this.onWindowResize, 300);

	        if (this.options.layout === 'fluid') {
	            $.on(window, 'resize', this.onWindowResize);
	        }
	    }

	    bindScrollHeader() {
	        var this$1 = this;

	        this._settingHeaderPosition = false;

	        $.on(this.bodyScrollable, 'scroll', function (e) {
	            if (this$1._settingHeaderPosition) { return; }

	            this$1._settingHeaderPosition = true;

	            requestAnimationFrame(function () {
	                var left = -e.target.scrollLeft;

	                $.style(this$1.header, {
	                    transform: ("translateX(" + left + "px)")
	                });
	                $.style(this$1.footer, {
	                    transform: ("translateX(" + left + "px)")
	                });
	                this$1._settingHeaderPosition = false;
	            });
	        });
	    }

	    onWindowResize() {
	        this.distributeRemainingWidth();
	        this.refreshColumnWidth();
	        this.setBodyStyle();
	    }

	    destroy() {
	        this.styleEl.remove();
	        $.off(window, 'resize', this.onWindowResize);
	    }

	    setStyle(selector, styleObject) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.setStyle(selector, styleObject);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        this._styleRulesMap = this._styleRulesMap || {};
	        var prefixedSelector = this._getPrefixedSelector(selector);

	        if (this._styleRulesMap[prefixedSelector]) {
	            this.removeStyle(selector);

	            // merge with old styleobject
	            styleObject = Object.assign({}, this._styleRulesMap[prefixedSelector], styleObject);
	        }

	        var styleString = this._getRuleString(styleObject);
	        var ruleString = prefixedSelector + " { " + styleString + " }";

	        this._styleRulesMap[prefixedSelector] = styleObject;
	        this.stylesheet.insertRule(ruleString);
	    }

	    removeStyle(selector) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.removeStyle(selector);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        // find and remove
	        var prefixedSelector = this._getPrefixedSelector(selector);
	        var index = Array.from(this.stylesheet.cssRules)
	            .findIndex(function (rule) { return rule.selectorText === prefixedSelector; });

	        if (index === -1) { return; }
	        this.stylesheet.deleteRule(index);
	    }

	    _getPrefixedSelector(selector) {
	        return ("." + (this.scopeClass) + " " + selector);
	    }

	    _getRuleString(styleObject) {
	        return Object.keys(styleObject)
	            .map(function (prop) {
	                var dashed = prop;
	                if (!prop.includes('-')) {
	                    dashed = camelCaseToDash(prop);
	                }
	                return (dashed + ":" + (styleObject[prop]) + ";");
	            })
	            .join('');
	    }

	    setDimensions() {
	        this.setCellHeight();
	        this.setupMinWidth();
	        this.setupNaturalColumnWidth();
	        this.setupColumnWidth();
	        this.distributeRemainingWidth();
	        this.setColumnStyle();
	        this.setBodyStyle();
	    }

	    setCellHeight() {
	        this.setStyle('.dt-cell', {
	            height: this.options.cellHeight + 'px'
	        });
	    }

	    setupMinWidth() {
	        var this$1 = this;

	        $.each('.dt-cell--header', this.header).map(function (col) {
	            var ref = $.data(col);
	            var colIndex = ref.colIndex;
	            var column = this$1.getColumn(colIndex);

	            if (!column.minWidth) {
	                var width = $.style($('.dt-cell__content', col), 'width');
	                // only set this once
	                column.minWidth = width;
	            }
	        });
	    }

	    setupNaturalColumnWidth() {
	        var this$1 = this;

	        if (!$('.dt-row')) { return; }

	        $.each('.dt-row-header .dt-cell', this.header).map(function ($headerCell) {
	            var ref = $.data($headerCell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);
	            var width = $.style($('.dt-cell__content', $headerCell), 'width');
	            if (typeof width === 'number' && width >= this$1.options.minimumColumnWidth) {
	                column.naturalWidth = width;
	            } else {
	                column.naturalWidth = this$1.options.minimumColumnWidth;
	            }
	        });

	        // set initial width as naturally calculated by table's first row
	        $.each('.dt-row-0 .dt-cell', this.bodyScrollable).map(function ($cell) {
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);

	            var naturalWidth = $.style($('.dt-cell__content', $cell), 'width');

	            if (typeof naturalWidth === 'number' && naturalWidth >= column.naturalWidth) {
	                column.naturalWidth = naturalWidth;
	            } else {
	                column.naturalWidth = column.naturalWidth;
	            }
	        });
	    }

	    setupColumnWidth() {
	        var this$1 = this;

	        if (this.options.layout === 'ratio') {
	            var totalWidth = $.style(this.datatableWrapper, 'width');

	            if (this.options.serialNoColumn) {
	                var rowIndexColumn = this.datamanager.getColumnById('_rowIndex');
	                totalWidth = totalWidth - rowIndexColumn.width - 1;
	            }

	            if (this.options.checkboxColumn) {
	                var rowIndexColumn$1 = this.datamanager.getColumnById('_checkbox');
	                totalWidth = totalWidth - rowIndexColumn$1.width - 1;
	            }

	            var totalParts = this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') {
	                        return 0;
	                    }
	                    if (!column.width) {
	                        column.width = 1;
	                    }
	                    column.ratioWidth = parseInt(column.width, 10);
	                    return column.ratioWidth;
	                })
	                .reduce(function (a, c) { return a + c; });

	            var onePart = totalWidth / totalParts;

	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') { return; }
	                    column.width = Math.floor(onePart * column.ratioWidth) - 1;
	                });
	        } else {
	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (!column.width) {
	                        column.width = column.naturalWidth;
	                    }
	                    if (column.id === '_rowIndex') {
	                        column.width = this$1.getRowIndexColumnWidth();
	                    }
	                    if (column.width < this$1.options.minimumColumnWidth) {
	                        column.width = this$1.options.minimumColumnWidth;
	                    }
	                });
	        }
	    }

	    distributeRemainingWidth() {
	        var this$1 = this;

	        if (this.options.layout !== 'fluid') { return; }

	        var wrapperWidth = $.style(this.instance.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        var firstRowWidth = wrapperWidth;
	        if (!firstRow) {
	            var headerRow = $('.dt-row', this.instance.header);
	            var cellWidths = Array.from(headerRow.children)
	                .map(function (cell) { return cell.offsetWidth; });
	            firstRowWidth = cellWidths.reduce(function (sum, a) { return sum + a; }, 0);
	        } else {
	            firstRowWidth = $.style(firstRow, 'width');
	        }
	        var resizableColumns = this.datamanager.getColumns().filter(function (col) { return col.resizable; });
	        var deltaWidth = (wrapperWidth - firstRowWidth) / resizableColumns.length;

	        resizableColumns.map(function (col) {
	            var width = $.style(this$1.getColumnHeaderElement(col.colIndex), 'width');
	            var finalWidth = Math.floor(width + deltaWidth) - 2;

	            this$1.datamanager.updateColumn(col.colIndex, {
	                width: finalWidth
	            });
	        });
	    }

	    setColumnStyle() {
	        var this$1 = this;

	        // align columns
	        this.datamanager.getColumns()
	            .map(function (column) {
	                // alignment
	                if (!column.align) {
	                    column.align = 'left';
	                }
	                if (!['left', 'center', 'right'].includes(column.align)) {
	                    column.align = 'left';
	                }
	                this$1.setStyle((".dt-cell--col-" + (column.colIndex)), {
	                    'text-align': column.align
	                });

	                // width
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    refreshColumnWidth() {
	        var this$1 = this;

	        this.datamanager.getColumns()
	            .map(function (column) {
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    setBodyStyle() {
	        var bodyWidth = $.style(this.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        if (!firstRow) { return; }
	        var rowWidth = $.style(firstRow, 'width');

	        var width = bodyWidth > rowWidth ? rowWidth : bodyWidth;
	        $.style(this.bodyScrollable, {
	            width: width + 'px'
	        });

	        // remove the body height, so that it resets to it's original
	        $.removeStyle(this.bodyScrollable, 'height');

	        // when there are less rows than the container
	        // adapt the container height
	        var bodyHeight = $.getStyle(this.bodyScrollable, 'height');
	        var scrollHeight = (this.bodyRenderer.hyperlist || {})._scrollHeight || Infinity;
	        var hasHorizontalOverflow = $.hasHorizontalOverflow(this.bodyScrollable);

	        var height;

	        if (scrollHeight < bodyHeight) {
	            height = scrollHeight;

	            // account for scrollbar size when
	            // there is horizontal overflow
	            if (hasHorizontalOverflow) {
	                height += $.scrollbarSize();
	            }

	            $.style(this.bodyScrollable, {
	                height: height + 'px'
	            });
	        }

	        var verticalOverflow = this.bodyScrollable.scrollHeight - this.bodyScrollable.offsetHeight;
	        if (verticalOverflow < $.scrollbarSize()) {
	            // if verticalOverflow is less than scrollbar size
	            // then most likely scrollbar is causing the scroll
	            // which is not needed
	            $.style(this.bodyScrollable, {
	                overflowY: 'hidden'
	            });
	        }

	        if (this.options.layout === 'fluid') {
	            $.style(this.bodyScrollable, {
	                overflowX: 'hidden'
	            });
	        }
	    }

	    getColumnHeaderElement(colIndex) {
	        colIndex = +colIndex;
	        if (colIndex < 0) { return null; }
	        return $((".dt-cell--col-" + colIndex), this.header);
	    }

	    getRowIndexColumnWidth() {
	        var rowCount = this.datamanager.getRowCount();
	        var padding = 22;
	        return $.measureTextWidth(rowCount + '') + padding;
	    }
	}

	var KEYCODES = {
	    13: 'enter',
	    91: 'meta',
	    16: 'shift',
	    17: 'ctrl',
	    18: 'alt',
	    37: 'left',
	    38: 'up',
	    39: 'right',
	    40: 'down',
	    9: 'tab',
	    27: 'esc',
	    67: 'c',
	    70: 'f',
	    86: 'v'
	};

	class Keyboard {
	    constructor(element) {
	        this.listeners = {};
	        $.on(element, 'keydown', this.handler.bind(this));
	    }

	    handler(e) {
	        var key = KEYCODES[e.keyCode];

	        if (e.shiftKey && key !== 'shift') {
	            key = 'shift+' + key;
	        }

	        if ((e.ctrlKey && key !== 'ctrl') || (e.metaKey && key !== 'meta')) {
	            key = 'ctrl+' + key;
	        }

	        var listeners = this.listeners[key];

	        if (listeners && listeners.length > 0) {
	            for (var i = 0, list = listeners; i < list.length; i += 1) {
	                var listener = list[i];

	              var preventBubbling = listener(e);
	                if (preventBubbling === undefined || preventBubbling === true) {
	                    e.preventDefault();
	                }
	            }
	        }
	    }

	    on(key, listener) {
	        var this$1 = this;

	        var keys = key.split(',').map(function (k) { return k.trim(); });

	        keys.map(function (key) {
	            this$1.listeners[key] = this$1.listeners[key] || [];
	            this$1.listeners[key].push(listener);
	        });
	    }
	}

	function filterRows(rows, filters) {
	    var filteredRowIndices = [];

	    if (Object.keys(filters).length === 0) {
	        return rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    var loop = function ( colIndex ) {
	        var keyword = filters[colIndex];

	        var filteredRows = filteredRowIndices.length ?
	            filteredRowIndices.map(function (i) { return rows[i]; }) :
	            rows;

	        var cells = filteredRows.map(function (row) { return row[colIndex]; });

	        var filter = guessFilter(keyword);
	        var filterMethod = getFilterMethod(filter);

	        if (filterMethod) {
	            filteredRowIndices = filterMethod(filter.text, cells);
	        } else {
	            filteredRowIndices = cells.map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    for (var colIndex in filters) loop( colIndex );

	    return filteredRowIndices;
	}
	function getFilterMethod(filter) {
	    var stringCompareValue = function (cell) { return String(stripHTML(cell.html || '') || cell.content || '').toLowerCase(); };

	    var numberCompareValue = function (cell) { return parseFloat(cell.content); };

	    var getCompareValues = function (cell, keyword) {
	        if (cell.column.compareValue) {
	            var compareValues = cell.column.compareValue(cell, keyword);
	            if (compareValues && Array.isArray(compareValues)) { return compareValues; }
	        }

	        // check if it can be converted to number
	        var float = numberCompareValue(cell);
	        if (!isNaN(float)) {
	            return [float, keyword];
	        }

	        return [stringCompareValue(cell), keyword];
	    };

	    var filterMethodMap = {
	        contains: function contains(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var hay = stringCompareValue(cell);
	                    var needle = (keyword || '').toLowerCase();
	                    return !needle || hay.includes(needle);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        greaterThan: function greaterThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue > keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        lessThan: function lessThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue < keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        equals: function equals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value === keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        notEquals: function notEquals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value !== keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        range: function range(rangeValues, cells) {
	            return cells
	                .filter(function (cell) {
	                    var values1 = getCompareValues(cell, rangeValues[0]);
	                    var values2 = getCompareValues(cell, rangeValues[1]);
	                    var value = values1[0];
	                    return value >= values1[1] && value <= values2[1];
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        containsNumber: function containsNumber(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var number = parseFloat(keyword, 10);
	                    var string = keyword;
	                    var hayNumber = numberCompareValue(cell);
	                    var hayString = stringCompareValue(cell);

	                    return number === hayNumber || hayString.includes(string);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    return filterMethodMap[filter.type];
	}

	function guessFilter(keyword) {
	    if ( keyword === void 0 ) keyword = '';

	    if (keyword.length === 0) { return {}; }

	    var compareString = keyword;

	    if (['>', '<', '='].includes(compareString[0])) {
	        compareString = keyword.slice(1);
	    } else if (compareString.startsWith('!=')) {
	        compareString = keyword.slice(2);
	    }

	    if (keyword.startsWith('>')) {
	        if (compareString) {
	            return {
	                type: 'greaterThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('<')) {
	        if (compareString) {
	            return {
	                type: 'lessThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'equals',
	                text: Number(keyword.slice(1).trim())
	            };
	        }
	    }

	    if (isNumber(compareString)) {
	        return {
	            type: 'containsNumber',
	            text: compareString
	        };
	    }

	    if (keyword.startsWith('!=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'notEquals',
	                text: Number(keyword.slice(2).trim())
	            };
	        }
	    }

	    if (keyword.split(':').length === 2) {
	        compareString = keyword.split(':');
	        return {
	            type: 'range',
	            text: compareString.map(function (v) { return v.trim(); })
	        };
	    }

	    return {
	        type: 'contains',
	        text: compareString.toLowerCase()
	    };
	}

	var DEFAULT_OPTIONS = {
	    columns: [],
	    data: [],
	    dropdownButton: icons.chevronDown,
	    headerDropdown: [
	        {
	            label: 'Sort Ascending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'asc');
	            }
	        },
	        {
	            label: 'Sort Descending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'desc');
	            }
	        },
	        {
	            label: 'Reset sorting',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'none');
	            }
	        },
	        {
	            label: 'Remove column',
	            action: function (column) {
	                this.removeColumn(column.colIndex);
	            }
	        }
	    ],
	    events: {
	        onRemoveColumn: function onRemoveColumn(column) {},
	        onSwitchColumn: function onSwitchColumn(column1, column2) {},
	        onSortColumn: function onSortColumn(column) {},
	        onCheckRow: function onCheckRow(row) {},
	        onDestroy: function onDestroy() {}
	    },
	    hooks: {
	        columnTotal: null
	    },
	    sortIndicator: {
	        asc: '↑',
	        desc: '↓',
	        none: ''
	    },
	    overrideComponents: {
	        // ColumnManager: CustomColumnManager
	    },
	    filterRows: filterRows,
	    freezeMessage: '',
	    getEditor: null,
	    serialNoColumn: true,
	    checkboxColumn: false,
	    clusterize: true,
	    logs: false,
	    layout: 'fixed', // fixed, fluid, ratio
	    noDataMessage: 'No Data',
	    cellHeight: 40,
	    minimumColumnWidth: 30,
	    inlineFilters: false,
	    treeView: false,
	    checkedRowStatus: true,
	    dynamicRowHeight: false,
	    pasteFromClipboard: false,
	    showTotalRow: false,
	    direction: 'ltr',
	    disableReorderColumn: false
	};

	var defaultComponents = {
	    DataManager: DataManager,
	    CellManager: CellManager,
	    ColumnManager: ColumnManager,
	    RowManager: RowManager,
	    BodyRenderer: BodyRenderer,
	    Style: Style,
	    Keyboard: Keyboard
	};

	class DataTable {
	    constructor(wrapper, options) {
	        DataTable.instances++;

	        if (typeof wrapper === 'string') {
	            // css selector
	            wrapper = document.querySelector(wrapper);
	        }
	        this.wrapper = wrapper;
	        if (!(this.wrapper instanceof HTMLElement)) {
	            throw new Error('Invalid argument given for `wrapper`');
	        }

	        this.buildOptions(options);
	        this.prepare();
	        this.initializeComponents();

	        if (this.options.data) {
	            this.refresh();
	            this.columnmanager.applyDefaultSortOrder();
	        }
	    }

	    buildOptions(options) {
	        this.options = this.options || {};

	        this.options = Object.assign(
	            {}, DEFAULT_OPTIONS,
	            this.options || {}, options
	        );

	        options.headerDropdown = options.headerDropdown || [];
	        this.options.headerDropdown = DEFAULT_OPTIONS.headerDropdown.concat( options.headerDropdown
	        );

	        // custom user events
	        this.events = Object.assign(
	            {}, DEFAULT_OPTIONS.events,
	            this.options.events || {},
	            options.events || {}
	        );
	        this.fireEvent = this.fireEvent.bind(this);
	    }

	    prepare() {
	        this.prepareDom();
	        this.unfreeze();
	    }

	    initializeComponents() {
	        var components = Object.assign({}, defaultComponents, this.options.overrideComponents);
	        var Style$$1 = components.Style;
	        var Keyboard$$1 = components.Keyboard;
	        var DataManager$$1 = components.DataManager;
	        var RowManager$$1 = components.RowManager;
	        var ColumnManager$$1 = components.ColumnManager;
	        var CellManager$$1 = components.CellManager;
	        var BodyRenderer$$1 = components.BodyRenderer;

	        this.style = new Style$$1(this);
	        this.keyboard = new Keyboard$$1(this.wrapper);
	        this.datamanager = new DataManager$$1(this.options);
	        this.rowmanager = new RowManager$$1(this);
	        this.columnmanager = new ColumnManager$$1(this);
	        this.cellmanager = new CellManager$$1(this);
	        this.bodyRenderer = new BodyRenderer$$1(this);
	    }

	    prepareDom() {
	        this.wrapper.innerHTML = "\n            <div class=\"datatable\" dir=\"" + (this.options.direction) + "\">\n                <div class=\"dt-header\"></div>\n                <div class=\"dt-scrollable\"></div>\n                <div class=\"dt-footer\"></div>\n                <div class=\"dt-freeze\">\n                    <span class=\"dt-freeze__message\">\n                        " + (this.options.freezeMessage) + "\n                    </span>\n                </div>\n                <div class=\"dt-toast\"></div>\n                <div class=\"dt-dropdown-container\"></div>\n                <textarea class=\"dt-paste-target\"></textarea>\n            </div>\n        ";

	        this.datatableWrapper = $('.datatable', this.wrapper);
	        this.header = $('.dt-header', this.wrapper);
	        this.footer = $('.dt-footer', this.wrapper);
	        this.bodyScrollable = $('.dt-scrollable', this.wrapper);
	        this.freezeContainer = $('.dt-freeze', this.wrapper);
	        this.toastMessage = $('.dt-toast', this.wrapper);
	        this.pasteTarget = $('.dt-paste-target', this.wrapper);
	        this.dropdownContainer = $('.dt-dropdown-container', this.wrapper);
	    }

	    refresh(data, columns) {
	        this.datamanager.init(data, columns);
	        this.render();
	        this.setDimensions();
	    }

	    destroy() {
	        this.wrapper.innerHTML = '';
	        this.style.destroy();
	        this.fireEvent('onDestroy');
	    }

	    appendRows(rows) {
	        this.datamanager.appendRows(rows);
	        this.rowmanager.refreshRows();
	    }

	    refreshRow(row, rowIndex) {
	        this.rowmanager.refreshRow(row, rowIndex);
	    }

	    render() {
	        this.renderHeader();
	        this.renderBody();
	    }

	    renderHeader() {
	        this.columnmanager.renderHeader();
	    }

	    renderBody() {
	        this.bodyRenderer.render();
	    }

	    setDimensions() {
	        this.style.setDimensions();
	    }

	    showToastMessage(message, hideAfter) {
	        this.bodyRenderer.showToastMessage(message, hideAfter);
	    }

	    clearToastMessage() {
	        this.bodyRenderer.clearToastMessage();
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    getRows() {
	        return this.datamanager.getRows();
	    }

	    getCell(colIndex, rowIndex) {
	        return this.datamanager.getCell(colIndex, rowIndex);
	    }

	    getColumnHeaderElement(colIndex) {
	        return this.columnmanager.getColumnHeaderElement(colIndex);
	    }

	    getViewportHeight() {
	        if (!this.viewportHeight) {
	            this.viewportHeight = $.style(this.bodyScrollable, 'height');
	        }

	        return this.viewportHeight;
	    }

	    sortColumn(colIndex, sortOrder) {
	        this.columnmanager.sortColumn(colIndex, sortOrder);
	    }

	    removeColumn(colIndex) {
	        this.columnmanager.removeColumn(colIndex);
	    }

	    scrollToLastColumn() {
	        this.datatableWrapper.scrollLeft = 9999;
	    }

	    freeze() {
	        $.style(this.freezeContainer, {
	            display: ''
	        });
	    }

	    unfreeze() {
	        $.style(this.freezeContainer, {
	            display: 'none'
	        });
	    }

	    updateOptions(options) {
	        this.buildOptions(options);
	    }

	    fireEvent(eventName) {
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        // fire internalEventHandlers if any
	        // and then user events
	        var handlers = (this._internalEventHandlers[eventName] || []).concat( [this.events[eventName]]
	        ).filter(Boolean);

	        for (var i = 0, list = handlers; i < list.length; i += 1) {
	            var handler = list[i];

	          handler.apply(this, args);
	        }
	    }

	    on(event, handler) {
	        this._internalEventHandlers = this._internalEventHandlers || {};
	        this._internalEventHandlers[event] = this._internalEventHandlers[event] || [];
	        this._internalEventHandlers[event].push(handler);
	    }

	    log() {
	        if (this.options.logs) {
	            console.log.apply(console, arguments);
	        }
	    }
	}

	DataTable.instances = 0;

	var name = "frappe-datatable";
	var version = "0.0.0-development";
	var description = "A modern datatable library for the web";
	var main = "dist/frappe-datatable.cjs.js";
	var unpkg = "dist/frappe-datatable.min.js";
	var jsdelivr = "dist/frappe-datatable.min.js";
	var scripts = {"start":"yarn run dev","build":"rollup -c && NODE_ENV=production rollup -c","dev":"rollup -c -w","cy:server":"http-server -p 8989","cy:open":"cypress open","cy:run":"cypress run","test":"start-server-and-test cy:server http://localhost:8989 cy:run","test-local":"start-server-and-test cy:server http://localhost:8989 cy:open","travis-deploy-once":"travis-deploy-once","semantic-release":"semantic-release","lint":"eslint src","commit":"npx git-cz"};
	var files = ["dist","src"];
	var devDependencies = {"autoprefixer":"^9.0.0","chai":"3.5.0","cypress":"3.0.1","cz-conventional-changelog":"^2.1.0","deepmerge":"^2.0.1","eslint":"^5.0.1","eslint-config-airbnb":"^16.1.0","eslint-config-airbnb-base":"^12.1.0","eslint-plugin-import":"^2.11.0","http-server":"^0.11.1","mocha":"3.3.0","postcss-custom-properties":"^7.0.0","postcss-nested":"^3.0.0","rollup":"^0.59.4","rollup-plugin-commonjs":"^8.3.0","rollup-plugin-eslint":"^4.0.0","rollup-plugin-json":"^2.3.0","rollup-plugin-node-resolve":"^3.0.3","rollup-plugin-postcss":"^1.2.8","rollup-plugin-uglify-es":"^0.0.1","semantic-release":"^17.1.1","start-server-and-test":"^1.4.1","travis-deploy-once":"^5.0.1"};
	var repository = {"type":"git","url":"https://github.com/frappe/datatable.git"};
	var keywords = ["datatable","data","grid","table"];
	var author = "Faris Ansari";
	var license = "MIT";
	var bugs = {"url":"https://github.com/frappe/datatable/issues"};
	var homepage = "https://frappe.github.io/datatable";
	var dependencies = {"hyperlist":"^1.0.0-beta","lodash":"^4.17.5","sortablejs":"^1.7.0"};
	var config = {"commitizen":{"path":"cz-conventional-changelog"}};
	var packageJson = {
		name: name,
		version: version,
		description: description,
		main: main,
		unpkg: unpkg,
		jsdelivr: jsdelivr,
		scripts: scripts,
		files: files,
		devDependencies: devDependencies,
		repository: repository,
		keywords: keywords,
		author: author,
		license: license,
		bugs: bugs,
		homepage: homepage,
		dependencies: dependencies,
		config: config
	};

	DataTable.__version__ = packageJson.version;

	module.exports = DataTable;
	});

	var DataTable = unwrapExports(frappeDatatable_cjs);

	/**
	 * frappe.views.ReportView
	 */

	frappe.provide('frappe.views');

	frappe.views.ReportView = class ReportView extends frappe.views.ListView {
		get view_name() {
			return 'Report';
		}

		render_header() {
			// Override List View Header
		}

		setup_defaults() {
			var this$1 = this;

			super.setup_defaults();
			this.page_title = __('Report:') + ' ' + this.page_title;
			this.menu_items = this.report_menu_items();
			this.view = 'Report';

			var route = frappe.get_route();
			if (route.length === 4) {
				this.report_name = route[3];
			}

			if (this.report_name) {
				return this.get_report_doc()
					.then(function (doc) {
						this$1.report_doc = doc;
						this$1.report_doc.json = JSON.parse(this$1.report_doc.json);

						this$1.filters = this$1.report_doc.json.filters;
						this$1.order_by = this$1.report_doc.json.order_by;
						this$1.add_totals_row = this$1.report_doc.json.add_totals_row;
						this$1.page_title = this$1.report_name;
						this$1.page_length = this$1.report_doc.json.page_length || 20;
						this$1.order_by = this$1.report_doc.json.order_by || 'modified desc';
						this$1.chart_args = this$1.report_doc.json.chart_args;
					});
			} else {
				this.add_totals_row = this.view_user_settings.add_totals_row || 0;
				this.chart_args = this.view_user_settings.chart_args;
			}
		}

		setup_view() {
			this.setup_columns();
			super.setup_new_doc_event();
			this.page.main.addClass('report-view');
			this.page.body[0].style.setProperty('--report-filter-height', this.page.page_form.css('height'));
			this.page.body.parent().css('margin-bottom', 'unset');
		}

		toggle_side_bar() {
			super.toggle_side_bar();
			// refresh datatable when sidebar is toggled to accomodate extra space
			this.render(true);
		}

		setup_result_area() {
			super.setup_result_area();
			this.setup_charts_area();
			this.$datatable_wrapper = $('<div class="datatable-wrapper">');
			this.$result.append(this.$datatable_wrapper);
		}

		setup_charts_area() {
			var this$1 = this;

			this.$charts_wrapper = $("<div class=\"charts-wrapper hidden\">\n\t\t\t<div class=\"text-right\"><button class=\"btn btn-default btn-xs btn-chart-configure\"\n\t\t\t\tstyle=\"margin-right: 15px; margin-top: 15px\">Configure</button></div>\n\t\t\t<div class=\"charts-inner-wrapper\"></div>\n\t\t</div>");
			this.$result.append(this.$charts_wrapper);
			this.$charts_wrapper.find('.btn-chart-configure').on('click', function () {
				this$1.setup_charts();
			});
		}

		setup_paging_area() {
			super.setup_paging_area();
			var message = __('For comparison, use >5, <10 or =324. For ranges, use 5:10 (for values between 5 & 10).');
			this.$paging_area.find('.level-left').append(
				("<span class=\"comparison-message text-muted\">" + message + "</span>")
			);
		}

		setup_sort_selector() {
			this.sort_selector = new frappe.ui.SortSelector({
				parent: this.filter_area.$filter_list_wrapper,
				doctype: this.doctype,
				args: this.order_by,
				onchange: this.on_sort_change.bind(this)
			});

			//Setup groupby for reports
			this.group_by_control = new frappe.ui.GroupBy(this);
			if (this.report_doc && this.report_doc.json.group_by) {
				this.group_by_control.apply_settings(this.report_doc.json.group_by);
			}
			if (this.view_user_settings && this.view_user_settings.group_by) {
				this.group_by_control.apply_settings(this.view_user_settings.group_by);
			}

		}

		get_args() {
			var args = super.get_args();
			this.group_by_control.set_args(args);

			return args;
		}

		before_refresh() {
			if (this.report_doc) {
				// don't parse frappe.route_options if this is a Custom Report
				return Promise.resolve();
			}
			return super.before_refresh();
		}

		after_render() {
			if (this.report_doc) {
				this.set_dirty_state_for_custom_report();
			} else {
				this.save_report_settings();
			}
			if (!this.group_by) {
				this.init_chart();
			}
		}

		set_dirty_state_for_custom_report() {
			var current_settings = {
				filters: this.filter_area.get(),
				fields: this.fields,
				order_by: this.sort_selector.get_sql_string(),
				add_totals_row: this.add_totals_row,
				page_length: this.page_length,
				column_widths: this.get_column_widths(),
				group_by: this.group_by_control.get_settings(),
				chart_args: this.get_chart_settings()
			};

			var report_settings = {
				filters: this.report_doc.json.filters,
				fields: this.report_doc.json.fields,
				order_by: this.report_doc.json.order_by,
				add_totals_row: this.report_doc.json.add_totals_row,
				page_length: this.report_doc.json.page_length,
				column_widths: this.report_doc.json.column_widths,
				group_by: this.report_doc.json.group_by,
				chart_args: this.report_doc.json.chart_args
			};

			if (!frappe.utils.deep_equal(current_settings, report_settings)) {
				this.page.set_indicator(__('Not Saved'), 'orange');
			} else {
				this.page.clear_indicator();
			}
		}

		save_report_settings() {
			frappe.model.user_settings.save(this.doctype, 'last_view', this.view_name);

			if (!this.report_name) {
				this.save_view_user_settings({
					fields: this.fields,
					filters: this.filter_area.get(),
					order_by: this.sort_selector.get_sql_string(),
					group_by: this.group_by_control.get_settings(),
					chart_args: this.get_chart_settings(),
					add_totals_row: this.add_totals_row
				});
			}
		}

		prepare_data(r) {
			var data = r.message || {};
			data = frappe.utils.dict(data.keys, data.values);

			if (this.start === 0) {
				this.data = data;
			} else {
				this.data = this.data.concat(data);
			}
		}

		render(force) {
			if (this.data.length === 0) { return; }
			this.render_count();
			this.setup_columns();

			if (this.group_by) {
				this.$charts_wrapper.addClass('hidden');
			} else if (this.chart) {
				this.refresh_charts();
			}

			if (this.datatable && !force) {
				this.datatable.refresh(this.get_data(this.data), this.columns);
				return;
			}
			this.setup_datatable(this.data);
		}

		render_count() {
			var $list_count = this.$paging_area.find('.list-count');
			if (!$list_count.length) {
				$list_count = $('<span>')
					.addClass('text-muted list-count')
					.prependTo(this.$paging_area.find('.level-right'));
			}
			this.get_count_str()
				.then(function (str) {
					$list_count.text(str);
				});
		}

		on_update(data) {
			var this$1 = this;

			if (this.doctype === data.doctype && data.name) {
				// flash row when doc is updated by some other user
				var flash_row = data.user !== frappe.session.user;
				if (this.data.find(function (d) { return d.name === data.name; })) {
					// update existing
					frappe.db.get_doc(data.doctype, data.name)
						.then(function (doc) { return this$1.update_row(doc, flash_row); });
				} else {
					// refresh
					this.refresh();
				}
			}
		}

		update_row(doc, flash_row) {
			var this$1 = this;

			var to_refresh = [];

			this.data = this.data.map(function (d, i) {
				if (d.name === doc.name) {
					for (var fieldname in d) {
						if (fieldname.includes(':')) {
							// child table field
							var ref = fieldname.split(':');
							var cdt = ref[0];
							var _field = ref[1];
							var cdt_row = Object.keys(doc)
								.filter(function (key) { return Array.isArray(doc[key])
									&& doc[key].length
									&& doc[key][0].doctype === cdt; }
								)
								.map(function (key) { return doc[key]; })
								.map(function (a) { return a[0]; })
								.filter(function (cdoc) { return cdoc.name === d[cdt + ':name']; })[0];
							if (cdt_row) {
								d[fieldname] = cdt_row[_field];
							}
						} else {
							d[fieldname] = doc[fieldname];
						}
					}
					to_refresh.push([d, i]);
				}
				return d;
			});

			// indicate row update
			var _flash_row = function (rowIndex) {
				if (!flash_row) { return; }
				var $row = this$1.$result.find((".dt-row[data-row-index=\"" + rowIndex + "\"]"));
				$row.addClass('row-update');
				setTimeout(function () { return $row.removeClass('row-update'); }, 500);
			};

			to_refresh.forEach(function (ref) {
				var data = ref[0];
				var rowIndex = ref[1];

				var new_row = this$1.build_row(data);
				this$1.datatable.refreshRow(new_row, rowIndex);
				_flash_row(rowIndex);
			});
		}

		setup_datatable(values) {
			var this$1 = this;

			this.$datatable_wrapper.empty();
			this.datatable = new DataTable(this.$datatable_wrapper[0], {
				columns: this.columns,
				data: this.get_data(values),
				getEditor: this.get_editing_object.bind(this),
				checkboxColumn: true,
				inlineFilters: true,
				cellHeight: 35,
				direction: frappe.utils.is_rtl() ? 'rtl' : 'ltr',
				events: {
					onRemoveColumn: function (column) {
						this$1.remove_column_from_datatable(column);
					},
					onSwitchColumn: function (column1, column2) {
						this$1.switch_column(column1, column2);
					},
					onCheckRow: function () {
						var checked_items = this$1.get_checked_items();
						this$1.toggle_actions_menu_button(checked_items.length > 0);
					}
				},
				hooks: {
					columnTotal: frappe.utils.report_column_total
				},
				headerDropdown: [{
					label: __('Add Column'),
					action: function (datatabe_col) {
						var columns_in_picker = [];
						var columns = this$1.get_columns_for_picker();

						columns_in_picker = columns[this$1.doctype]
							.filter(function (df) { return !this$1.is_column_added(df); })
							.map(function (df) { return ({
								label: __(df.label),
								value: df.fieldname
							}); });

						delete columns[this$1.doctype];

						var loop = function ( cdt ) {
							columns[cdt]
								.filter(function (df) { return !this$1.is_column_added(df); })
								.map(function (df) { return ({
									label: __(df.label) + " (" + cdt + ")",
									value: df.fieldname + ',' + cdt
								}); })
								.forEach(function (df) { return columns_in_picker.push(df); });
						};

						for (var cdt in columns) loop( cdt );

						var d = new frappe.ui.Dialog({
							title: __('Add Column'),
							fields: [
								{
									label: __('Select Column'),
									fieldname: 'column',
									fieldtype: 'Autocomplete',
									options: columns_in_picker
								},
								{
									label: __('Insert Column Before {0}', [datatabe_col.docfield.label.bold()]),
									fieldname: 'insert_before',
									fieldtype: 'Check'
								}
							],
							primary_action: function (ref) {
								var assign;

								var column = ref.column;
								var insert_before = ref.insert_before;
								if (!columns_in_picker.map(function (col) { return col.value; }).includes(column)) {
									frappe.show_alert({message: __('Invalid column'), indicator: 'orange'});
									d.hide();
									return;
								}

								var doctype = this$1.doctype;
								if (column.includes(',')) {
									(assign = column.split(','), column = assign[0], doctype = assign[1]);
								}


								var index = datatabe_col.colIndex;
								if (insert_before) {
									index = index - 1;
								}

								this$1.add_column_to_datatable(column, doctype, index);
								d.hide();
							}
						});

						d.show();
					}
				}]
			});
		}

		toggle_charts() {
			// add
			if (!this.chart) {
				this.setup_charts();
				return;
			}

			if (this.$charts_wrapper.hasClass('hidden')) {
				// reload chart
				this.$charts_wrapper.removeClass('hidden');
				this.refresh_charts();
			} else {
				// remove chart
				this.$charts_wrapper.addClass('hidden');
				this.save_view_user_settings(
					{ chart_args: null });
			}
		}

		init_chart() {
			// show chart if saved via report or user settings
			if (!this.chart) {
				if (this.chart_args) {
					this.build_chart_args(this.chart_args.x_axis,
						this.chart_args.y_axes,
						this.chart_args.chart_type);

					this.make_chart();
				}
			}
		}

		setup_charts() {
			var this$1 = this;

			// get fields from columns
			var x_fields = [], y_fields = [];
			for (var i = 0, list = this.columns; i < list.length; i += 1) {
				// all options in x
				var col = list[i];

				x_fields.push({
					label: col.content,
					fieldname: col.id,
					value: col.id,
				});

				// numeric values in y
				if (col.docfield && frappe.model.numeric_fieldtypes.includes(col.docfield.fieldtype)) {
					y_fields.push({
						label: col.content,
						fieldname: col.id,
						value: col.id
					});
				}
			}

			var defaults = this.chart_args || {};

			var dialog = new frappe.ui.Dialog({
				title: __('Configure Chart'),
				fields: [
					{
						label: __('X Axis Field'),
						fieldtype: 'Select',
						fieldname: 'x_axis',
						options: x_fields,
						default: defaults.x_axis
					},
					{
						label: __('Y Axis Fields'),
						fieldtype: 'MultiSelect',
						fieldname: 'y_axes',
						options: y_fields,
						description: __('Showing only Numeric fields from Report'),
						default: defaults.y_axes ? defaults.y_axes.join(', ') : null
					},
					{
						label: __('Chart Type'),
						fieldtype: 'Select',
						options: ['Bar', 'Line', 'Pie', 'Percentage', 'Donut'],
						fieldname: 'chart_type',
						default: defaults.chart_type ?
							frappe.utils.to_title_case(defaults.chart_type) :
							'Bar'
					}
				],
				primary_action: function (data) {
					data.y_axes = data.y_axes.split(',').map(function (d) { return d.trim(); }).filter(Boolean);

					this$1.build_chart_args(data.x_axis, data.y_axes, data.chart_type);
					this$1.make_chart();
					dialog.hide();
				}
			});

			dialog.show();
		}

		build_chart_args(x_axis, y_axes, chart_type) {
			var this$1 = this;

			var datasets = y_axes.map(function (y_axis) { return ({
				name: this$1.columns_map[y_axis].content,
				values: this$1.data.map(function (d) { return d[y_axis]; })
			}); });

			this.chart_args = {
				chart_type: chart_type.toLowerCase(),
				x_axis: x_axis,
				y_axes: y_axes,
				labels: this.data.map(function (d) { return d[x_axis]; }),
				datasets: datasets
			};

			this.save_view_user_settings(
				{ chart_args: this.get_chart_settings() });
		}

		get_chart_settings() {
			if (this.chart_args) {
				return {
					chart_type: this.chart_args.chart_type,
					x_axis: this.chart_args.x_axis,
					y_axes: this.chart_args.y_axes,
				};
			}
		}

		make_chart() {
			var this$1 = this;

			var args = this.chart_args;
			var data = {
				labels: args.labels,
				datasets: args.datasets
			};

			this.last_chart_type = args.chart_type;

			var get_df = function (field) { return this$1.columns_map[field].docfield; };
			var get_doc = function (value, field) { return this$1.data.find(function (d) { return d[field] === value; }); };

			this.$charts_wrapper.removeClass('hidden');

			this.chart = new frappe.Chart(this.$charts_wrapper.find('.charts-inner-wrapper')[0], {
				title: __("{0} Chart", [this.doctype]),
				data: data,
				type: args.chart_type,
				truncateLegends: 1,
				colors: ['#70E078', 'light-blue', 'orange', 'red'],
				axisOptions: {
					shortenYAxisNumbers: 1
				},
				tooltipOptions: {
					formatTooltipY: function (value) { return frappe.format(value, get_df(this$1.chart_args.y_axes[0]), { always_show_decimals: true, inline: true }, get_doc(value.doc)); }
				}
			});
		}

		refresh_charts() {
			if (!this.chart || !this.chart_args) { return; }
			this.$charts_wrapper.removeClass('hidden');
			var ref = this.chart_args;
			var x_axis = ref.x_axis;
			var y_axes = ref.y_axes;
			var chart_type = ref.chart_type;
			this.build_chart_args(x_axis, y_axes, chart_type);
			this.chart.update(this.chart_args);
		}

		get_editing_object(colIndex, rowIndex, value, parent) {
			var this$1 = this;

			var control = this.render_editing_input(colIndex, value, parent);
			if (!control) { return false; }

			control.df.change = function () { return control.set_focus(); };

			return {
				initValue: function (value) {
					return control.set_value(value);
				},
				setValue: function (value) {
					var cell = this$1.datatable.getCell(colIndex, rowIndex);
					var fieldname = this$1.datatable.getColumn(colIndex).docfield.fieldname;
					var docname = cell.name;
					var doctype = cell.doctype;

					control.set_value(value);
					return this$1.set_control_value(doctype, docname, fieldname, value)
						.then(function (updated_doc) {
							var _data = this$1.data
								.filter(function (b) { return b.name === updated_doc.name; })
								.find(function (a) { return (doctype != updated_doc.doctype && a[doctype + ":name"] == docname)
									|| doctype == updated_doc.doctype; }
								);

							for (var field in _data) {
								if (field.includes(':')) {
									// child table field
									var ref = field.split(':');
									var cdt = ref[0];
									var _field = ref[1];
									var cdt_row = Object.keys(updated_doc)
										.filter(function (key) { return Array.isArray(updated_doc[key])
											&& updated_doc[key].length
											&& updated_doc[key][0].doctype === cdt; }
										)
										.map(function (key) { return updated_doc[key]; })[0]
										.filter(function (cdoc) { return cdoc.name === _data[cdt + ':name']; })[0];
									if (cdt_row) {
										_data[field] = cdt_row[_field];
									}
								} else {
									_data[field] = updated_doc[field];
								}
							}
						})
						.then(function () { return this$1.refresh_charts(); });
				},
				getValue: function () {
					return control.get_value();
				}
			};
		}

		set_control_value(doctype, docname, fieldname, value) {
			this.last_updated_doc = docname;
			return new Promise(function (resolve, reject) {
				var obj;

				frappe.db.set_value(doctype, docname, ( obj = {}, obj[fieldname] = value, obj ))
					.then(function (r) {
						if (r.message) {
							resolve(r.message);
						} else {
							reject();
						}
					})
					.fail(reject);
			});
		}

		render_editing_input(colIndex, value, parent) {
			var this$1 = this;

			var col = this.datatable.getColumn(colIndex);
			var control = null;

			if (col.docfield.fieldtype === 'Text Editor') {
				var d = new frappe.ui.Dialog({
					title: __('Edit {0}', [col.docfield.label]),
					fields: [col.docfield],
					primary_action: function () {
						this$1.datatable.cellmanager.submitEditing();
						this$1.datatable.cellmanager.deactivateEditing();
						d.hide();
					}
				});
				d.show();
				control = d.fields_dict[col.docfield.fieldname];
			} else {
				// make control
				control = frappe.ui.form.make_control({
					df: col.docfield,
					parent: parent,
					render_input: true
				});
				control.set_value(value);
				control.toggle_label(false);
				control.toggle_description(false);
			}

			return control;
		}

		is_editable(df, data) {
			if (df
				&& frappe.model.can_write(this.doctype)
				// not a submitted doc or field is allowed to edit after submit
				&& (data.docstatus !== 1 || df.allow_on_submit)
				// not a cancelled doc
				&& data.docstatus !== 2
				&& !df.read_only
				&& !df.hidden
				// not a standard field i.e., owner, modified_by, etc.
				&& !frappe.model.std_fields_list.includes(df.fieldname))
				{ return true; }
			return false;
		}

		get_data(values) {
			return this.build_rows(values);
		}

		set_fields() {
			var this$1 = this;

			// default fields
			['name', 'docstatus'].map(function (f) { return this$1._add_field(f); });

			if (this.report_name && this.report_doc.json.fields) {
				var fields = this.report_doc.json.fields.slice();
				fields.forEach(function (f) { return this$1._add_field(f[0], f[1]); });
				return;
			} else if (this.view_user_settings.fields) {
				// get from user_settings
				var fields$1 = this.view_user_settings.fields;
				fields$1.forEach(function (f) { return this$1._add_field(f[0], f[1]); });
				return;
			}

			this.set_default_fields();
		}

		set_default_fields() {
			var this$1 = this;

			// get fields from meta
			this.fields = this.fields || [];
			var add_field = function (f) { return this$1._add_field(f); };

			// default fields
			[
				this.meta.title_field,
				this.meta.image_field
			].map(add_field);

			// fields in_list_view or in_standard_filter
			var fields = this.meta.fields.filter(function (df) {
				return (df.in_list_view || df.in_standard_filter)
					&& frappe.perm.has_perm(this$1.doctype, df.permlevel, 'read')
					&& frappe.model.is_value_type(df.fieldtype)
					&& !df.report_hide;
			});

			fields.map(add_field);

			// currency fields
			fields.filter(
				function (df) { return df.fieldtype === 'Currency' && df.options; }
			).map(function (df) {
				if (df.options.includes(':')) {
					add_field(df.options.split(':')[1]);
				} else {
					add_field(df.options);
				}
			});

			// fields in listview_settings
			(this.settings.add_fields || []).map(add_field);
		}

		build_fields() {
			super.build_fields();
		}

		reorder_fields() {
			var this$1 = this;

			// generate table fields in the required format ["name", "DocType"]
			// these are fields in the column before adding new fields
			var table_fields = this.columns.map(function (df) { return [df.field, df.docfield.parent]; });

			// filter fields that are already in table
			// iterate over table_fields to preserve the existing order of fields
			// The filter will ensure the unchecked fields are removed
			var fields_already_in_table = table_fields.filter(function (df) {
				return this$1.fields.find(function (field) {
					return df[0] == field[0] && df[1] == field[1]
				})
			});

			// find new fields that didn't already exists
			// This will be appended to the end of the table
			var fields_to_add = this.fields.filter(function (df) {
				return !table_fields.find(function (field) {
					return df[0] == field[0] && df[1] == field[1];
				});
			});

			// rebuild fields
			this.fields = fields_already_in_table.concat( fields_to_add);
		}

		get_fields() {
			var this$1 = this;

			var fields = this.fields.map(function (f) {
				var column_name = frappe.model.get_full_column_name(f[0], f[1]);
				if (f[1] !== this$1.doctype) {
					// child table field
					column_name = column_name + ' as ' + "'" + (f[1]) + ":" + (f[0]) + "'";
				}
				return column_name;
			});
			var cdt_name_fields =
				this.get_unique_cdt_in_view()
					.map(function (cdt) { return frappe.model.get_full_column_name('name', cdt) + ' as ' + "'" + cdt + ":name'"; });
			fields = fields.concat(cdt_name_fields);

			return fields;
		}

		get_unique_cdt_in_view() {
			var this$1 = this;

			return this.fields
				.filter(function (f) { return f[1] !== this$1.doctype; })
				.map(function (f) { return f[1]; })
				.uniqBy(function (d) { return d; });
		}

		add_column_to_datatable(fieldname, doctype, col_index) {
			var field = [fieldname, doctype];
			this.fields.splice(col_index, 0, field);

			this.add_currency_column(fieldname, doctype, col_index);

			this.build_fields();
			this.setup_columns();

			if (this.datatable) { this.datatable.destroy(); }
			this.datatable = null;
			this.refresh();
		}

		add_currency_column(fieldname, doctype, col_index) {
			// Adds dependent currency field if required
			var df = frappe.meta.get_docfield(doctype, fieldname);
			if (df && df.fieldtype === 'Currency' && df.options &&
				!df.options.includes(':') && frappe.meta.has_field(doctype, df.options)
			) {
				var field = [df.options, doctype];
				if (col_index === undefined) {
					this.fields.push(field);
				} else {
					this.fields.splice(col_index, 0, field);
				}
				frappe.show_alert(__('Also adding the dependent currency field {0}', [field[0].bold()]));
			}
		}

		add_status_dependency_column(col, doctype) {
			// Adds dependent column from which status is derived if required
			if (!this.fields.find(function (f) { return f[0] === col; })) {
				var field = [col, doctype];
				this.fields.push(field);
				this.refresh();
				frappe.show_alert(__('Also adding the status dependency field {0}', [field[0].bold()]));
			}
		}

		remove_column_from_datatable(column) {
			var index = this.fields.findIndex(function (f) { return column.field === f[0]; });
			if (index === -1) { return; }
			var field = this.fields[index];

			if (field[0] === 'name') {
				this.refresh();
				frappe.throw(__('Cannot remove ID field'));
			}

			this.fields.splice(index, 1);
			this.build_fields();
			this.setup_columns();
			this.refresh();
		}

		switch_column(col1, col2) {
			var index1 = this.fields.findIndex(function (f) { return col1.field === f[0]; });
			var index2 = this.fields.findIndex(function (f) { return col2.field === f[0]; });
			var _fields = this.fields.slice();

			var temp = _fields[index1];
			_fields[index1] = _fields[index2];
			_fields[index2] = temp;

			this.fields = _fields;
			this.build_fields();
			this.setup_columns();
			this.refresh();
		}

		get_columns_for_picker() {
			var out = {};

			var standard_fields_filter = function (df) { return !in_list(frappe.model.no_value_type, df.fieldtype); };

			var doctype_fields = frappe.meta.get_docfields(this.doctype).filter(standard_fields_filter);

			// filter out docstatus field from picker
			var std_fields = frappe.model.std_fields.filter( function (df) { return df.fieldname !== 'docstatus'; });

			// add status field derived from docstatus, if status is not a standard field
			var has_status_values = false;

			if (this.data) {
				has_status_values = frappe.get_indicator(this.data[0], this.doctype);
			}

			if (!frappe.meta.has_field(this.doctype, 'status') && has_status_values) {
				doctype_fields = [{
					label: __('Status'),
					fieldname: 'docstatus',
					fieldtype: 'Data'
				}].concat(doctype_fields);
			}

			doctype_fields = [{
				label: __('ID'),
				fieldname: 'name',
				fieldtype: 'Data',
				reqd: 1
			}].concat(doctype_fields, std_fields);

			out[this.doctype] = doctype_fields;

			var table_fields = frappe.meta.get_table_fields(this.doctype);

			table_fields.forEach(function (df) {
				var cdt = df.options;
				var child_table_fields = frappe.meta.get_docfields(cdt).filter(standard_fields_filter);

				out[cdt] = child_table_fields;

				// add index column for child tables
				out[cdt].push({
					label: __('Index'),
					fieldname: 'idx',
					fieldtype: 'Int',
					parent: cdt
				});
			});
			return out;
		}

		get_dialog_fields() {
			var this$1 = this;

			var dialog_fields = [];
			var columns = this.get_columns_for_picker();

			dialog_fields.push({
				label: __(this.doctype),
				fieldname: this.doctype,
				fieldtype: 'MultiCheck',
				columns: 2,
				options: columns[this.doctype]
					.filter(function (df) {
						return !df.hidden && df.fieldname !== 'name';
					})
					.map(function (df) { return ({
						label: __(df.label),
						value: df.fieldname,
						checked: this$1.fields.find(function (f) { return f[0] === df.fieldname && f[1] === this$1.doctype; })
					}); })
			});

			delete columns[this.doctype];

			var table_fields = frappe.meta.get_table_fields(this.doctype)
				.filter(function (df) { return !df.hidden; });

			table_fields.forEach(function (df) {
				var cdt = df.options;

				dialog_fields.push({
					label: __(df.label) + " (" + (__(cdt)) + ")",
					fieldname: df.options,
					fieldtype: 'MultiCheck',
					columns: 2,
					options: columns[cdt]
						.filter(function (df) {
							return !df.hidden;
						})
						.map(function (df) { return ({
							label: __(df.label),
							value: df.fieldname,
							checked: this$1.fields.find(function (f) { return f[0] === df.fieldname && f[1] === cdt; })
						}); })
				});
			});

			return dialog_fields;
		}

		is_column_added(df) {
			return Boolean(
				this.fields.find(function (f) { return f[0] === df.fieldname && df.parent === f[1]; })
			);
		}

		setup_columns() {
			// apply previous column width
			var column_widths = null;
			if (this.columns) {
				column_widths = this.get_column_widths();
			}

			this.columns = [];
			this.columns_map = {};

			for (var i = 0, list = this.fields; i < list.length; i += 1) {
				var f = list[i];

				var column = (void 0);
				if (f[0]!=='docstatus') {
					column = this.build_column(f);
				} else {
					// if status is not in fields append status column derived from docstatus
					if (!this.fields.includes(['status', this.doctype]) && !frappe.meta.has_field(this.doctype, 'status')) {
						column = this.build_column(['docstatus', this.doctype]);
					}
				}

				if (column) {
					if (column_widths) {
						column.width = column_widths[column.id] || column.width || 120;
					}
					this.columns.push(column);
					this.columns_map[column.id] = column;
				}
			}
		}

		build_column(c) {

			var fieldname = c[0];
			var doctype = c[1];
			var docfield = frappe.meta.docfield_map[doctype || this.doctype][fieldname];

			// group by column
			if (fieldname === '_aggregate_column') {
				docfield = this.group_by_control.get_group_by_docfield();
			}

			// child table index column
			if (fieldname === 'idx' && doctype !== this.doctype) {
				docfield = {
					label: "Index",
					fieldtype: "Int",
					parent: doctype,
				};
			}

			if (!docfield) {
				docfield = frappe.model.get_std_field(fieldname, true);

				if (docfield) {
					if(!docfield.label) {
						docfield.label = toTitle(fieldname);
						if(docfield.label.includes('_')) {
							docfield.label = docfield.label.replace('_',' ');
						}
					}
					docfield.parent = this.doctype;
					if (fieldname == 'name') {
						docfield.options = this.doctype;
					}
					if (fieldname == 'docstatus' && !frappe.meta.has_field(this.doctype, 'status')) {
						docfield.label = 'Status';
						docfield.fieldtype = 'Data';
						docfield.name = 'status';
					}
				}
			}
			if (!docfield || docfield.report_hide) { return; }

			var title = __(docfield ? docfield.label : toTitle(fieldname));
			if (doctype !== this.doctype) {
				title += " (" + (__(doctype)) + ")";
			}

			var editable = frappe.model.is_non_std_field(fieldname) && !docfield.read_only;

			var align = (function () {
				var is_numeric = frappe.model.is_numeric_field(docfield);
				if (is_numeric) {
					return 'right';
				}
				return docfield.fieldtype === 'Date' ? 'right' : 'left';
			})();

			var id = fieldname;

			// child table column
			if (doctype !== this.doctype && fieldname !== '_aggregate_column') {
				id = doctype + ":" + fieldname;
			}

			var width = (docfield ? cint(docfield.width) : null) || null;
			if (this.report_doc) {
				// load the user saved column width
				var saved_column_widths = this.report_doc.json.column_widths || {};
				width = saved_column_widths[id] || width;
			}

			var compareFn = null;
			if (docfield.fieldtype === 'Date') {
				compareFn = function (cell, keyword) {
					if (!cell.content) { return null; }
					if (keyword.length !== 'YYYY-MM-DD'.length) { return null; }

					var keywordValue = frappe.datetime.user_to_obj(keyword);
					var cellValue = frappe.datetime.str_to_obj(cell.content);
					return [+cellValue, +keywordValue];
				};
			}


			return {
				id: id,
				field: fieldname,
				name: title,
				content: title,
				docfield: docfield,
				width: width,
				editable: editable,
				align: align,
				compareValue: compareFn,
				format: function (value, row, column, data) {
					var doc = null;
					if (Array.isArray(row)) {
						doc = row.reduce(function (acc, curr) {
							if (!curr.column.docfield) { return acc; }
							acc[curr.column.docfield.fieldname] = curr.content;
							return acc;
						}, {});
					} else {
						doc = row;
					}

					return frappe.format(value, column.docfield, { always_show_decimals: true }, doc);
				}
			};
		}

		build_rows(data) {
			var this$1 = this;

			var out = data.map(function (d) { return this$1.build_row(d); });

			if (this.add_totals_row) {
				var totals = this.get_columns_totals(data);
				var totals_row = this.columns.map(function (col, i) {
					return {
						name: __('Totals Row'),
						content: totals[col.id],
						format: function (value) {
							var formatted_value = frappe.format(value, col.docfield, {
								always_show_decimals: true
							}, data[0]);
							if (i === 0) {
								return this$1.format_total_cell(formatted_value, col);
							}
							return formatted_value;
						}
					};
				});

				out.push(totals_row);
			}
			return out;
		}

		format_total_cell(formatted_value, df) {
			var cell_value = __('Totals').bold();
			if (frappe.model.is_numeric_field(df.docfield)) {
				cell_value = "<span class=\"flex justify-between\">\n\t\t\t\t" + cell_value + " " + ($(formatted_value).text()) + "\n\t\t\t</span>";
			}
			return cell_value;
		}

		build_row(d) {
			var this$1 = this;

			return this.columns.map(function (col) {
				if (col.docfield.parent !== this$1.doctype) {
					// child table field
					var cdt_field = function (f) { return ((col.docfield.parent) + ":" + f); };
					var name = d[cdt_field('name')];

					return {
						name: name,
						doctype: col.docfield.parent,
						content: d[cdt_field(col.field)] || d[col.field],
						editable: Boolean(name && this$1.is_editable(col.docfield, d)),
						format: function (value) {
							return frappe.format(value, col.docfield, { always_show_decimals: true }, d);
						}
					};
				}
				if (col.field === 'docstatus' && !frappe.meta.has_field(this$1.doctype, 'status')) {
					// get status from docstatus
					var status = frappe.get_indicator(d, this$1.doctype);
					if (status) {
						if (!status[0]) {
							// get_indicator returns the dependent field's condition as the 3rd parameter
							var dependent_col = status[2].split(',')[0];
							// add status dependency column
							this$1.add_status_dependency_column(dependent_col, this$1.doctype);
						}
						return {
							name: d.name,
							doctype: col.docfield.parent,
							content: status[0],
							editable: false
						};
					} else {
						// no status values found
						this$1.remove_column_from_datatable(col);
					}
				} else if (col.field in d) {
					var value = d[col.field];
					return {
						name: d.name,
						doctype: col.docfield.parent,
						content: value,
						editable: this$1.is_editable(col.docfield, d)
					};
				}
				return {
					content: ''
				};
			});
		}

		get_checked_items(only_docnames) {
			var this$1 = this;

			var indexes = this.datatable.rowmanager.getCheckedRows();
			var items = indexes.map(function (i) { return this$1.data[i]; }).filter(function (i) { return i != undefined; });

			if (only_docnames) {
				return items.map(function (d) { return d.name; });
			}

			return items;
		}

		save_report(save_type) {
			var this$1 = this;

			var _save_report = function (name) {
				// callback
				var report_settings = {
					filters: this$1.filter_area.get(),
					fields: this$1.fields,
					order_by: this$1.sort_selector.get_sql_string(),
					add_totals_row: this$1.add_totals_row,
					page_length: this$1.page_length,
					column_widths: this$1.get_column_widths(),
					group_by: this$1.group_by_control.get_settings(),
					chart_args: this$1.get_chart_settings()
				};

				return frappe.call({
					method: 'frappe.desk.reportview.save_report',
					args: {
						name: name,
						doctype: this$1.doctype,
						json: JSON.stringify(report_settings)
					},
					callback:function (r) {
						if(r.exc) {
							frappe.msgprint(__("Report was not saved (there were errors)"));
							return;
						}
						if(r.message != this$1.report_name) {
							// Rerender the reports dropdown,
							// so that this report is included in the dropdown as well.
							frappe.boot.user.all_reports[r.message] = {
								ref_doctype: this$1.doctype,
								report_type: "Report Builder",
								title: r.message,
							};

							frappe.set_route('List', this$1.doctype, 'Report', r.message);
							return;
						}

						// update state
						this$1.report_doc.json = report_settings;
						this$1.set_dirty_state_for_custom_report();
					}
				});

			};

			if(this.report_name && save_type == "save") {
				_save_report(this.report_name);
			} else {
				frappe.prompt({fieldname: 'name', label: __('New Report name'), reqd: 1, fieldtype: 'Data'}, function (data) {
					_save_report(data.name);
				}, __('Save As'));
			}
		}

		get_column_widths() {
			if (this.datatable) {
				return this.datatable
					.datamanager
					.getColumns(true)
					.reduce(function (acc, curr) {
						acc[curr.id] = parseInt(curr.width);
						return acc;
					}, {});
			}

			return {};
		}

		get_report_doc() {
			var this$1 = this;

			return new Promise(function (resolve) {
				frappe.model.with_doc('Report', this$1.report_name, function () {
					resolve(frappe.get_doc('Report', this$1.report_name));
				});
			});
		}

		get_filters_html_for_print() {
			var filters = this.filter_area.get();

			return filters.map(function (f) {
				var doctype = f[0];
				var fieldname = f[1];
				var condition = f[2];
				var value = f[3];
				if (condition !== '=') { return ''; }

				var label = frappe.meta.get_label(doctype, fieldname);
				return ("<h6>" + (__(label)) + ": " + value + "</h6>");
			}).join('');
		}

		get_columns_totals(data) {
			if (!this.add_totals_row) {
				return [];
			}

			var row_totals = {};

			this.columns.forEach(function (col, i) {
				var totals = data.reduce(function (totals, d) {
					if (col.id in d && frappe.model.is_numeric_field(col.docfield)) {
						totals += flt(d[col.id]);
						return totals;
					}
				}, 0);

				row_totals[col.id] = totals;
			});

			return row_totals;
		}

		report_menu_items() {
			var this$1 = this;

			var items = [
				{
					label: __('Show Totals'),
					action: function () {
						this$1.add_totals_row = !this$1.add_totals_row;
						this$1.save_view_user_settings({
							add_totals_row: this$1.add_totals_row
						});
						this$1.datatable.refresh(this$1.get_data(this$1.data));
					}
				},
				{
					label: __('Print'),
					action: function () {
						// prepare rows in their current state, sorted and filtered
						var rows_in_order = this$1.datatable.datamanager.rowViewOrder.map(function (index) {
							if (this$1.datatable.bodyRenderer.visibleRowIndices.includes(index)) {
								return this$1.data[index];
							}
						}).filter(Boolean);

						if (this$1.add_totals_row) {
							var total_data = this$1.get_columns_totals(this$1.data);

							total_data['name'] = __('Totals').bold();
							rows_in_order.push(total_data);
						}

						frappe.ui.get_print_settings(false, function (print_settings) {
							var title =  this$1.report_name || __(this$1.doctype);
							frappe.render_grid({
								title: title,
								subtitle: this$1.get_filters_html_for_print(),
								print_settings: print_settings,
								columns: this$1.columns,
								data: rows_in_order
							});
						});
					}
				},
				{
					label: __('Toggle Chart'),
					action: function () { return this$1.toggle_charts(); }
				},
				{
					label: __('Toggle Sidebar'),
					action: function () { return this$1.toggle_side_bar(); },
					shortcut: 'Ctrl+K',
				},
				{
					label: __('Pick Columns'),
					action: function () {
						var d = new frappe.ui.Dialog({
							title: __('Pick Columns'),
							fields: this$1.get_dialog_fields(),
							primary_action: function (values) {
								// doctype fields
								var fields = values[this$1.doctype].map(function (f) { return [f, this$1.doctype]; });
								delete values[this$1.doctype];

								// child table fields
								var loop = function ( cdt ) {
									fields = fields.concat(values[cdt].map(function (f) { return [f, cdt]; }));
								};

								for (var cdt in values) loop( cdt );

								// always keep name (ID) column
								this$1.fields = [["name", this$1.doctype] ].concat( fields);

								this$1.fields.map(function (f) { return this$1.add_currency_column(f[0], f[1]); });

								this$1.reorder_fields();
								this$1.build_fields();
								this$1.setup_columns();

								this$1.datatable.destroy();
								this$1.datatable = null;
								this$1.refresh();

								d.hide();
							}
						});

						d.$body.prepend(("\n\t\t\t\t\t\t<div class=\"columns-search\">\n\t\t\t\t\t\t\t<input type=\"text\" placeholder=\"" + (__('Search')) + "\" data-element=\"search\" class=\"form-control input-xs\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t"));

						frappe.utils.setup_search(d.$body, '.unit-checkbox', '.label-area');
						d.show();
					}
				}
			];

			if (frappe.model.can_export(this.doctype)) {
				items.push({
					label: __('Export'),
					action: function () {
						var args = this$1.get_args();
						var selected_items = this$1.get_checked_items(true);
						var fields = [
							{
								fieldtype: 'Select',
								label: __('Select File Type'),
								fieldname:'file_format_type',
								options: ['Excel', 'CSV'],
								default: 'Excel'
							}
						];

						if (this$1.total_count > this$1.count_without_children || args.page_length) {
							fields.push({
								fieldtype: 'Check',
								fieldname: 'export_all_rows',
								label: __('Export All {0} rows?', [(this$1.total_count + "").bold()])
							});
						}

						var d = new frappe.ui.Dialog({
							title: __("Export Report: {0}",[__(this$1.doctype)]),
							fields: fields,
							primary_action_label: __('Download'),
							primary_action: function (data) {
								args.cmd = 'frappe.desk.reportview.export_query';
								args.file_format_type = data.file_format_type;
								args.title = this$1.report_name || this$1.doctype;

								if(this$1.add_totals_row) {
									args.add_totals_row = 1;
								}

								if(selected_items.length > 0) {
									args.selected_items = selected_items;
								}

								if (!data.export_all_rows) {
									args.start = 0;
									args.page_length = this$1.data.length;
								} else {
									delete args.start;
									delete args.page_length;
								}

								open_url_post(frappe.request.url, args);

								d.hide();
							},
						});

						d.show();
					}
				});
			}

			items.push({
				label: __("Setup Auto Email"),
				action: function () {
					if(this$1.report_name) {
						frappe.set_route('List', 'Auto Email Report', {'report' : this$1.report_name});
					} else {
						frappe.msgprint(__('Please save the report first'));
					}
				}
			});

			// save buttons
			if(frappe.user.is_report_manager()) {
				items = items.concat([
					{ label: __('Save'), action: function () { return this$1.save_report('save'); } },
					{ label: __('Save As'), action: function () { return this$1.save_report('save_as'); } }
				]);
			}

			// user permissions
			if(this.report_name && frappe.model.can_set_user_permissions("Report")) {
				items.push({
					label: __("User Permissions"),
					action: function () {
						var args = {
							doctype: "Report",
							name: this$1.report_name
						};
						frappe.set_route('List', 'User Permission', args);
					}
				});
			}

			return items.map(function (i) { return Object.assign(i, { standard: true }); });
		}

	};

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.widget.utils');
	frappe.provide('frappe.views');
	frappe.provide('frappe.query_reports');

	frappe.standard_pages['query-report'] = function() {
		var wrapper = frappe.container.add_page('query-report');

		frappe.ui.make_app_page({
			parent: wrapper,
			title: __('Query Report'),
			single_column: true,
		});

		frappe.query_report = new frappe.views.QueryReport({
			parent: wrapper,
		});

		$(wrapper).bind('show', function() {
			frappe.query_report.show();
		});
	};

	frappe.views.QueryReport = class QueryReport extends frappe.views.BaseList {
		show() {
			var this$1 = this;

			this.init().then(function () { return this$1.load(); });
		}

		init() {
			var this$1 = this;

			if (this.init_promise) {
				return this.init_promise;
			}

			var tasks = [
				this.setup_defaults,
				this.setup_page,
				this.setup_report_wrapper,
				this.setup_events
			].map(function (fn) { return fn.bind(this$1); });
			this.init_promise = frappe.run_serially(tasks);
			return this.init_promise;
		}

		setup_defaults() {
			this.route = frappe.get_route();
			this.page_name = frappe.get_route_str();

			// Setup buttons
			this.primary_action = null;

			// throttle refresh for 300ms
			this.refresh = frappe.utils.throttle(this.refresh, 300);

			this.menu_items = [];
		}

		set_default_secondary_action() {
			var this$1 = this;

			this.refresh_button && this.refresh_button.remove();
			this.refresh_button = this.page.add_action_icon("refresh", function () {
				this$1.setup_progress_bar();
				this$1.refresh();
			});
		}

		get_no_result_message() {
			return ("<div class=\"msg-box no-border\">\n\t\t\t<div>\n\t\t\t\t<img src=\"/assets/frappe/images/ui-states/list-empty-state.svg\" alt=\"Generic Empty State\" class=\"null-state\">\n\t\t\t</div>\n\t\t\t<p>" + (__('Nothing to show')) + "</p>\n\t\t</div>");
		}

		setup_events() {
			var this$1 = this;

			frappe.realtime.on("report_generated", function (data) {
				this$1.toggle_primary_button_disabled(false);
				if(data.report_name) {
					this$1.prepared_report_action = "Rebuild";
					// If generated report and currently active Prepared Report has same fiters
					// then refresh the Prepared Report
					// Otherwise show alert with the link to the Prepared Report
					if(data.name == this$1.prepared_report_doc_name) {
						this$1.refresh();
					} else {
						var alert_message = "Report " + (this$1.report_name) + " generated.\n\t\t\t\t\t\t<a href=\"#query-report/" + (this$1.report_name) + "/?prepared_report_name=" + (data.name) + "\">View</a>";
						frappe.show_alert({message: alert_message, indicator: 'orange'});
					}
				}
			});
			this.page.wrapper.on('click', '[data-action]', function (e) {
				var action_name = $(e.currentTarget).data('action');
				var action = this$1[action_name];
				if (action.call) {
					action.call(this$1, e);
				}
			});
		}

		load() {
			if (frappe.get_route().length < 2) {
				this.toggle_nothing_to_show(true);
				return;
			}

			if (this.report_name !== frappe.get_route()[1]) {
				// this.toggle_loading(true);
				// different report
				this.load_report();
			}
			else if (frappe.has_route_options()) {
				// filters passed through routes
				// so refresh report again
				this.refresh_report();
			}
		}

		load_report() {
			var this$1 = this;

			this.page.clear_inner_toolbar();
			this.route = frappe.get_route();
			this.page_name = frappe.get_route_str();
			this.report_name = this.route[1];
			this.page_title = __(this.report_name);
			this.show_save = false;
			this.menu_items = this.get_menu_items();
			this.datatable = null;
			this.prepared_report_action = "New";

			frappe.run_serially([
				function () { return this$1.get_report_doc(); },
				function () { return this$1.get_report_settings(); },
				function () { return this$1.setup_progress_bar(); },
				function () { return this$1.setup_page_head(); },
				function () { return this$1.refresh_report(); },
				function () { return this$1.add_chart_buttons_to_toolbar(true); },
				function () { return this$1.add_card_button_to_toolbar(true); } ]);
		}

		add_card_button_to_toolbar() {
			var this$1 = this;

			this.page.add_inner_button(__("Create Card"), function () {
				this$1.add_card_to_dashboard();
			});
		}

		add_chart_buttons_to_toolbar(show) {
			var this$1 = this;

			if (show) {
				this.create_chart_button && this.create_chart_button.remove();
				this.create_chart_button = this.page.add_button(__("Set Chart"), function () {
					this$1.open_create_chart_dialog();
				});

				if (this.chart_fields || this.chart_options) {
					this.add_to_dashboard_button && this.add_to_dashboard_button.remove();
					this.add_to_dashboard_button = this.page.add_button(__("Add Chart to Dashboard"), function () {
						this$1.add_chart_to_dashboard();
					});
				}
			} else {
				this.create_chart_button && this.create_chart_button.remove();
				this.add_to_dashboard_button && this.add_to_dashboard_button.remove();
			}
		}

		add_card_to_dashboard() {
			var this$1 = this;

			var field_options = frappe.report_utils.get_field_options_from_report(this.columns, this.raw_data);
			var dashboard_field = frappe.dashboard_utils.get_dashboard_link_field();
			var set_standard = frappe.boot.developer_mode;

			var dialog = new frappe.ui.Dialog({
				title: __('Create Card'),
				fields: [
					{
						fieldname: 'report_field',
						label: __('Field'),
						fieldtype: 'Select',
						options: field_options.numeric_fields,
					},
					{
						fieldname: 'cb_1',
						fieldtype: 'Column Break'
					},
					{
						fieldname: 'report_function',
						label: __('Function'),
						options: ['Sum', 'Average', 'Minimum', 'Maximum'],
						fieldtype: 'Select'
					},
					{
						fieldname: 'sb_1',
						label: __('Add to Dashboard'),
						fieldtype: 'Section Break'
					},
					dashboard_field,
					{
						fieldname: 'cb_2',
						fieldtype: 'Column Break'
					},
					{
						fieldname: 'label',
						label: __('Card Label'),
						fieldtype: 'Data',
					}
				],
				primary_action_label: __('Add'),
				primary_action: function (values) {
					if (!values.label) {
						values.label = (values.report_function) + " of " + (toTitle(values.report_field));
					}
					this$1.create_number_card(values, values.dashboard, values.label, set_standard);
					dialog.hide();
				}
			});

			dialog.show();

		}

		add_chart_to_dashboard() {
			var this$1 = this;

			if (this.chart_fields || this.chart_options) {
				var dashboard_field = frappe.dashboard_utils.get_dashboard_link_field();
				var set_standard = frappe.boot.developer_mode;

				var dialog = new frappe.ui.Dialog({
					title: __('Create Chart'),
					fields: [
						{
							fieldname: 'dashboard_chart_name',
							label: 'Chart Name',
							fieldtype: 'Data',
						},
						dashboard_field ],
					primary_action_label: __('Add'),
					primary_action: function (values) {
						this$1.create_dashboard_chart(
							this$1.chart_fields || this$1.chart_options,
							values.dashboard,
							values.dashboard_chart_name,
							set_standard
						);
						dialog.hide();
					}
				});

				dialog.show();
			} else {
				frappe.msgprint(__('Please Set Chart'));
			}
		}

		create_number_card(values, dashboard_name, card_name, set_standard) {
			var args = {
				'dashboard': dashboard_name || null,
				'type': 'Report',
				'report_name': this.report_name,
				'filters_json': JSON.stringify(this.get_filter_values()),
				set_standard: set_standard,
			};
			Object.assign(args, values);

			this.add_to_dashboard(
				'frappe.desk.doctype.number_card.number_card.create_report_number_card',
				args,
				dashboard_name,
				card_name,
				'Number Card'
			);
		}

		create_dashboard_chart(chart_args, dashboard_name, chart_name, set_standard) {
			var args = {
				'dashboard': dashboard_name || null,
				'chart_type': 'Report',
				'report_name': this.report_name,
				'type': chart_args.chart_type || frappe.model.unscrub(chart_args.type),
				'color': chart_args.color,
				'filters_json': JSON.stringify(this.get_filter_values()),
				'custom_options': {},
				'set_standard': set_standard,
			};

			for (var key in chart_args) {
				if (key != "data") {
					args['custom_options'][key] = chart_args[key];
				}
			}

			if (this.chart_fields) {
				var x_field_title = toTitle(chart_args.x_field);
				var y_field_title = toTitle(chart_args.y_fields[0]);
				chart_name = chart_name || (((this.report_name) + ": " + x_field_title + " vs " + y_field_title));

				Object.assign(args,
					{
						'chart_name': chart_name,
						'x_field': chart_args.x_field,
						'y_axis': chart_args.y_axis_fields.map(function (f) {
							return {'y_field': f.y_field, 'color': f.color};
						}),
						'use_report_chart': 0
					}
				);
			} else {
				chart_name = chart_name || this.report_name;
				Object.assign(args,
					{
						'chart_name': chart_name,
						'use_report_chart': 1
					}
				);
			}

			this.add_to_dashboard(
				'frappe.desk.doctype.dashboard_chart.dashboard_chart.create_report_chart',
				args,
				dashboard_name,
				chart_name,
				'Dashboard Chart'
			);
		}

		add_to_dashboard(method, args, dashboard_name, name, doctype) {
			frappe.xcall(
				method,
				{args: args}
			).then(function () {
				var message;
				if (dashboard_name) {
					var dashboard_route_html = "<a href=\"#dashboard-view/" + dashboard_name + "\">" + dashboard_name + "</a>";
					message = __("New {0} {1} added to Dashboard {2}", [__(doctype), name, dashboard_route_html]);
				} else {
					message = __("New {0} {1} created", [__(doctype), name]);
				}

				frappe.msgprint(message, __("New {0} Created", [__(doctype)]));
			});
		}

		refresh_report() {
			var this$1 = this;

			this.toggle_message(true);
			this.toggle_report(false);

			return frappe.run_serially([
				function () { return this$1.setup_filters(); },
				function () { return this$1.set_route_filters(); },
				function () { return this$1.page.clear_custom_actions(); },
				function () { return this$1.report_settings.onload && this$1.report_settings.onload(this$1); },
				function () { return this$1.refresh(); }
			]);
		}

		get_report_doc() {
			var this$1 = this;

			return frappe.model.with_doc('Report', this.report_name)
				.then(function (doc) {
					this$1.report_doc = doc;
				})
				.then(function () { return frappe.model.with_doctype(this$1.report_doc.ref_doctype); });
		}

		get_report_settings() {
			var this$1 = this;

			return new Promise(function (resolve, reject) {
				if (frappe.query_reports[this$1.report_name]) {
					this$1.report_settings = frappe.query_reports[this$1.report_name];
					resolve();
				} else {
					frappe.xcall('frappe.desk.query_report.get_script', {
						report_name: this$1.report_name
					}).then(function (settings) {
						frappe.dom.eval(settings.script || '');
						frappe.after_ajax(function () {
							this$1.report_settings = this$1.get_local_report_settings();
							this$1.report_settings.html_format = settings.html_format;
							this$1.report_settings.execution_time = settings.execution_time || 0;
							frappe.query_reports[this$1.report_name] = this$1.report_settings;

							if (this$1.report_doc.filters && !this$1.report_settings.filters) {
								// add configured filters
								this$1.report_settings.filters = this$1.report_doc.filters;
							}

							resolve();
						});
					}).catch(reject);
				}
			});
		}

		get_local_report_settings() {
			var report_script_name = this.report_doc.report_type === 'Custom Report'
				? this.report_doc.reference_report
				: this.report_name;
			return frappe.query_reports[report_script_name] || {};
		}

		setup_progress_bar() {
			var seconds_elapsed = 0;
			var execution_time = this.report_settings.execution_time || 0;

			if (execution_time < 5) { return; }

			this.interval = setInterval(function()  {
				seconds_elapsed += 1;
				frappe.show_progress(__('Preparing Report'), seconds_elapsed, execution_time);
			}, 1000);
		}

		refresh_filters_dependency() {
			var this$1 = this;

			this.filters.forEach(function (filter) {
				filter.guardian_has_value = true;

				if (filter.df.depends_on) {
					filter.guardian_has_value =
						this$1.evaluate_depends_on_value(filter.df.depends_on, filter.df.label);

					if (filter.guardian_has_value) {
						if (filter.df.hidden_due_to_dependency) {
							filter.df.hidden_due_to_dependency = false;
							this$1.toggle_filter_display(filter.df.fieldname, false);
						}
					} else {
						if (!filter.df.hidden_due_to_dependency) {
							filter.df.hidden_due_to_dependency = true;
							this$1.toggle_filter_display(filter.df.fieldname, true);
							filter.set_value(filter.df.default || null);
						}
					}
				}

			});
		}

		evaluate_depends_on_value(expression, filter_label) {
			var out = null;
			var doc = this.get_filter_values();
			if (doc) {
				if (typeof expression === 'boolean') {
					out = expression;
				} else if (expression.substr(0, 5) == 'eval:') {
					try {
						out = eval(expression.substr(5));
					} catch (e) {
						frappe.throw(__('Invalid "depends_on" expression set in filter {0}', [filter_label]));
					}
				} else {
					var value = doc[expression];
					if ($.isArray(value)) {
						out = !!value.length;
					} else {
						out = !!value;
					}
				}
			}
			return out;
		}

		setup_filters() {
			var this$1 = this;

			this.clear_filters();
			var ref = this.report_settings;
			var filters = ref.filters; if ( filters === void 0 ) filters = [];

			var filter_area = this.page.page_form;

			this.filters = filters.map(function (df) {
				if (df.fieldtype === 'Break') { return; }

				var f = this$1.page.add_field(df, filter_area);

				if (df.default) {
					f.set_input(df.default);
				}

				if (df.get_query) { f.get_query = df.get_query; }
				if (df.on_change) { f.on_change = df.on_change; }

				df.onchange = function () {
					this$1.refresh_filters_dependency();

					var current_filters = this$1.get_filter_values();
					if (this$1.previous_filters
						&& (JSON.stringify(this$1.previous_filters) === JSON.stringify(current_filters))) {
						// filter values have not changed
						return;
					}

					// clear previous_filters after 10 seconds, to allow refresh for new data
					this$1.previous_filters = current_filters;
					setTimeout(function () { return this$1.previous_filters = null; }, 10000);

					if (f.on_change) {
						f.on_change(this$1);
					} else {
						if (this$1.prepared_report) {
							this$1.reset_report_view();
						}
						else if (!this$1._no_refresh) {
							this$1.refresh();
						}
					}
				};

				f = Object.assign(f, df);

				return f;

			}).filter(Boolean);

			this.refresh_filters_dependency();
			if (this.filters.length === 0) {
				// hide page form if no filters
				this.page.hide_form();
			} else {
				this.page.show_form();
			}

			this.page.body[0].style.setProperty('--report-filter-height', this.page.page_form.css('height'));
			this.page.body.parent().css('margin-bottom', 'unset');
		}

		set_filters(filters) {
			this.filters.map(function (f) {
				f.set_input(filters[f.fieldname]);
			});
		}

		set_route_filters() {
			if(frappe.route_options) {
				var fields = Object.keys(frappe.route_options);

				var filters_to_set = this.filters.filter(function (f) { return fields.includes(f.df.fieldname); });

				var promises = filters_to_set.map(function (f) {
					return function () {
						var value = frappe.route_options[f.df.fieldname];
						f.set_value(value);
					};
				});
				promises.push(function () {
					frappe.route_options = null;
				});

				return frappe.run_serially(promises);
			}
		}

		clear_filters() {
			this.page.clear_fields();
		}

		refresh() {
			var this$1 = this;

			this.toggle_message(true);
			this.toggle_report(false);
			var filters = this.get_filter_values(true);

			// only one refresh at a time
			if (this.last_ajax) {
				this.last_ajax.abort();
			}

			var query_params = this.get_query_params();

			if (query_params.prepared_report_name) {
				filters.prepared_report_name = query_params.prepared_report_name;
			}

			return new Promise(function (resolve) {
				this$1.last_ajax = frappe.call({
					method: 'frappe.desk.query_report.run',
					type: 'GET',
					args: {
						report_name: this$1.report_name,
						filters: filters,
					},
					callback: resolve,
					always: function () { return this$1.page.btn_secondary.prop('disabled', false); }
				});
			}).then(function (r) {
				var data = r.message;
				this$1.hide_status();
				clearInterval(this$1.interval);

				this$1.execution_time = data.execution_time || 0.1;

				if (data.prepared_report) {
					this$1.prepared_report = true;
					// If query_string contains prepared_report_name then set filters
					// to match the mentioned prepared report doc and disable editing
					if (query_params.prepared_report_name) {
						this$1.prepared_report_action = "Edit";
						var filters_from_report = JSON.parse(data.doc.filters);
						Object.values(this$1.filters).forEach(function(field) {
							if (filters_from_report[field.fieldname]) {
								field.set_input(filters_from_report[field.fieldname]);
							}
							if (field.input) {
								field.input.disabled = true;
							}
						});
					}
					this$1.add_prepared_report_buttons(data.doc);
				}

				if (data.report_summary) {
					this$1.$summary.empty();
					this$1.render_summary(data.report_summary);
				}

				if (data.message && !data.prepared_report) { this$1.show_status(data.message); }

				this$1.toggle_message(false);
				if (data.result && data.result.length) {
					this$1.prepare_report_data(data);
					this$1.chart_options = this$1.get_chart_options(data);

					this$1.$chart.empty();
					if (this$1.chart_options) {
						this$1.render_chart(this$1.chart_options);
					}
					else {
						this$1.$chart.empty();
						if (this$1.chart_fields) {
							this$1.chart_options =
								frappe.report_utils.make_chart_options(
									this$1.columns,
									this$1.raw_data,
									this$1.chart_fields
								);
							this$1.chart_options && this$1.render_chart(this$1.chart_options);
						}
					}
					this$1.render_datatable();
					this$1.add_chart_buttons_to_toolbar(true);
					this$1.add_card_button_to_toolbar();
				} else {
					this$1.data = [];
					this$1.toggle_nothing_to_show(true);
					this$1.add_chart_buttons_to_toolbar(false);
				}

				this$1.show_footer_message();
				frappe.hide_progress();
			});
		}

		render_summary(data) {
			var this$1 = this;

			data.forEach(function (summary) {
				frappe.utils.build_summary_item(summary).appendTo(this$1.$summary);
			});

			this.$summary.show();
		}

		get_query_params() {
			var query_string = frappe.utils.get_query_string(frappe.get_route_str());
			var query_params = frappe.utils.get_query_params(query_string);
			return query_params;
		}

		add_prepared_report_buttons(doc) {
			var this$1 = this;

			if (doc) {
				this.page.add_inner_button(__("Download Report"), function (){
					window.open(
						frappe.urllib.get_full_url(
							"/api/method/frappe.core.doctype.prepared_report.prepared_report.download_attachment?"
							+"dn="+encodeURIComponent(doc.name)));
				});

				var part1 = __('This report was generated {0}.', [frappe.datetime.comment_when(doc.report_end_time)]);
				var part2 = __('To get the updated report, click on {0}.', [__('Rebuild')]);
				var part3 = __('See all past reports.');

				this.show_status(("\n\t\t\t\t<div class=\"indicator orange\">\n\t\t\t\t\t<span>\n\t\t\t\t\t\t" + part1 + "\n\t\t\t\t\t\t" + part2 + "\n\t\t\t\t\t\t<a href=\"/app/List/Prepared%20Report?report_name=" + (this.report_name) + "\"> " + part3 + "</a>\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t"));
			}
			// Three cases
			// 1. First time with given filters, no data.
			// 2. Showing data from specific report
			// 3. Showing data from an old report without specific report name
			this.primary_action_map = {
				"New": {
					label: __("Generate New Report"),
					click: function () {
						this$1.show_warning_or_generate_report();
					},
				},
				"Edit": {
					label: __("Edit"),
					click: function () {
						frappe.set_route(frappe.get_route());
					}
				},
				"Rebuild": {
					label:	__("Rebuild"),
					click: function () {
						this$1.show_warning_or_generate_report();
					}
				}
			};

			var primary_action = this.primary_action_map[this.prepared_report_action];

			if (!this.primary_button || this.primary_button.text() !== primary_action.label) {
				this.primary_button = this.page.set_primary_action(
					primary_action.label,
					primary_action.click
				);
			}
		}

		toggle_primary_button_disabled(disable) {
			this.primary_button.prop('disabled', disable);
		}

		show_warning_or_generate_report() {
			var this$1 = this;

			frappe.xcall(
				'frappe.core.doctype.prepared_report.prepared_report.get_reports_in_queued_state',
				{
					filters: this.get_filter_values(),
					report_name: this.report_name,
				}
			).then(function (reports) {
				this$1.queued_prepared_reports = reports;

				if (reports.length) {
					var message = this$1.get_queued_prepared_reports_warning_message(reports);
					this$1.prepared_report_dialog = frappe.warn(
						__('Reports already in Queue'),
						message,
						function () { return this$1.generate_background_report(); },
						__('Proceed Anyway'),
						true
					);

					this$1.prepared_report_dialog.footer.prepend(("\n\t\t\t\t\t<button type=\"button\" class=\"btn btn-sm btn-default pull-left\" data-action=\"delete_old_queued_reports\">\n\t\t\t\t\t\t" + (__('Delete and Generate New')) + "\n\t\t\t\t\t</button>"));

					frappe.utils.bind_actions_with_object(this$1.prepared_report_dialog.wrapper, this$1);
				} else {
					this$1.generate_background_report();
				}
			});
		}

		get_queued_prepared_reports_warning_message(reports) {
			var route = "/app/List/Prepared Report/List?status=Queued&report_name=" + (this.report_name);
			var report_link_html = reports.length == 1
				? ("<a class=\"underline\" href=\"" + route + "\">" + (__('1 Report')) + "</a>")
				: ("<a class=\"underline\" href=\"" + route + "\">" + (__("{0} Reports", [reports.length])) + "</a>");

			var no_of_reports_html = reports.length == 1
				? ("" + (__('There is {0} with the same filters already in the queue:', [report_link_html])))
				: ("" + (__('There are {0} with the same filters already in the queue:', [report_link_html])));

			var warning_message = "\n\t\t\t<p>\n\t\t\t\t" + (__("Are you sure you want to generate a new report?")) + "\n\t\t\t\t" + no_of_reports_html + "\n\t\t\t</p>";

			var get_item_html = function (item) { return ("<a class=\"underline\" href=\"/app/prepared-report/" + (item.name) + "\">" + (item.name) + "</a>"); };

			warning_message += reports.map(get_item_html).join(', ');

			return warning_message;
		}

		delete_old_queued_reports() {
			var this$1 = this;

			this.prepared_report_dialog.hide();
			frappe.xcall(
				'frappe.core.doctype.prepared_report.prepared_report.delete_prepared_reports',
				{
					reports: this.queued_prepared_reports,
				}
			).then(function () { return this$1.generate_background_report(); });
		}

		generate_background_report() {
			var this$1 = this;

			this.toggle_primary_button_disabled(true);
			var mandatory = this.filters.filter(function (f) { return f.df.reqd; });
			var missing_mandatory = mandatory.filter(function (f) { return !f.get_value(); });
			if (!missing_mandatory.length) {
				var filters = this.get_filter_values(true);
				return new Promise(function (resolve) { return frappe.call({
					method: 'frappe.desk.query_report.background_enqueue_run',
					type: 'GET',
					args: {
						report_name: this$1.report_name,
						filters: filters
					},
					callback: resolve
				}); }).then(function (r) {
					var data = r.message;
					// Rememeber the name of Prepared Report doc
					this$1.prepared_report_doc_name = data.name;
					var alert_message = "<a href='/app/prepared-report/" + (data.name) + "'>" +
						__('Report initiated, click to view status') + "</a>";
					frappe.show_alert({message: alert_message, indicator: 'orange'}, 10);
					this$1.toggle_nothing_to_show(true);
				});
			}
		}

		prepare_report_data(data) {
			this.raw_data = data;
			this.columns = this.prepare_columns(data.columns);
			this.custom_columns = [];
			this.data = this.prepare_data(data.result);
			this.linked_doctypes = this.get_linked_doctypes();
			this.tree_report = this.data.some(function (d) { return 'indent' in d; });
		}

		render_datatable() {
			var data = this.data;
			var columns = this.columns.filter(function (col) { return !col.hidden; });

			if (this.raw_data.add_total_row) {
				data = data.slice();
				data.splice(-1, 1);
				this.$page.find('.layout-main-section')[0].style.setProperty('--report-total-height', '310px');
			}

			this.$report.show();
			if (this.datatable && this.datatable.options
				&& (this.datatable.options.showTotalRow ===this.raw_data.add_total_row)) {
				this.datatable.options.treeView = this.tree_report;
				this.datatable.refresh(data, columns);
			} else {
				var datatable_options = {
					columns: columns,
					data: data,
					inlineFilters: true,
					treeView: this.tree_report,
					layout: 'fixed',
					cellHeight: 33,
					showTotalRow: this.raw_data.add_total_row,
					direction: frappe.utils.is_rtl() ? 'rtl' : 'ltr',
					hooks: {
						columnTotal: frappe.utils.report_column_total
					}
				};

				if (this.report_settings.get_datatable_options) {
					datatable_options = this.report_settings.get_datatable_options(datatable_options);
				}
				this.datatable = new DataTable(this.$report[0], datatable_options);
			}

			if (typeof this.report_settings.initial_depth == "number") {
				this.datatable.rowmanager.setTreeDepth(this.report_settings.initial_depth);
			}
			if (this.report_settings.after_datatable_render) {
				this.report_settings.after_datatable_render(this.datatable);
			}
		}

		get_chart_options(data) {
			var options = this.report_settings.get_chart_data
				? this.report_settings.get_chart_data(data.columns, data.result)
				: data.chart
					? data.chart
					: undefined;

			if (!(options && options.data && options.data.labels && options.data.labels.length > 0)) { return; }

			if (options.fieldtype) {
				options.tooltipOptions = {
					formatTooltipY: function (d) { return frappe.format(d, {
						fieldtype: options.fieldtype,
						options: options.options
					}); }
				};
			}
			options.axisOptions = {
				shortenYAxisNumbers: 1
			};
			options.height = 280;

			return options;
		}

		render_chart(options) {
			this.$chart.empty();
			this.$chart.show();
			this.chart = new frappe.Chart(this.$chart[0], options);
		}

		open_create_chart_dialog() {
			var this$1 = this;

			var me = this;
			var field_options = frappe.report_utils.get_field_options_from_report(this.columns, this.raw_data);

			function set_chart_values(values) {
				values.y_fields = [];
				values.colors = [];
				if (values.y_axis_fields) {
					values.y_axis_fields.map(function (f) {
						values.y_fields.push(f.y_field);
						values.colors.push(f.color);
					});
				}

				values.y_fields =
					values.y_fields
						.map(function (d) { return d.trim(); })
						.filter(Boolean);

				return values;
			}

			function preview_chart() {
				var wrapper = $(dialog.fields_dict["chart_preview"].wrapper);
				var values = dialog.get_values(true);
				values = set_chart_values(values);

				if (values.x_field && values.y_fields.length) {
					var options = frappe.report_utils.make_chart_options(me.columns, me.raw_data, values);
					me.chart_fields = values;
					wrapper.empty();
					new frappe.Chart(wrapper[0], options);
					wrapper.find('.chart-container .title, .chart-container .sub-title').hide();
					wrapper.show();

					dialog.fields_dict['create_dashoard_chart'].df.hidden = 0;
					dialog.refresh();
				}
				else {
					wrapper[0].innerHTML =
					"<div class=\"flex justify-center align-center text-muted\" style=\"height: 120px; display: flex;\">\n\t\t\t\t\t<div>" + (__("Please select X and Y fields")) + "</div>\n\t\t\t\t</div>";
				}
			}

			var dialog = new frappe.ui.Dialog({
				title: __('Create Chart'),
				fields: [
					{
						fieldname: 'x_field',
						label: 'X Field',
						fieldtype: 'Select',
						default: me.chart_fields? me.chart_fields.x_field: null,
						options: field_options.non_numeric_fields,
					},
					{
						fieldname: 'cb_1',
						fieldtype: 'Column Break'
					},
					{
						fieldname: 'chart_type',
						label: 'Type of Chart',
						fieldtype: 'Select',
						options: ['Bar', 'Line', 'Percentage', 'Pie', 'Donut'],
						default: me.chart_fields? me.chart_fields.chart_type: 'Bar',
					},
					{
						fieldname: 'sb_1',
						fieldtype: 'Section Break',
						label: 'Y axis'
					},
					{
						fieldname: 'y_axis_fields', fieldtype: 'Table',
						fields: [
							{
								fieldtype: 'Select',
								fieldname: 'y_field',
								name: 'y_field',
								label: __('Y Field'),
								options: field_options.numeric_fields,
								in_list_view: 1,
							},
							{
								fieldtype: 'Color',
								fieldname: 'color',
								name: 'color',
								label: __('Color'),
								in_list_view: 1,
							} ],
					},
					{
						fieldname: 'preview_chart_button',
						fieldtype: 'Button',
						label: 'Preview Chart',
						click: preview_chart
					},
					{
						fieldname: 'sb_2',
						fieldtype: 'Section Break',
						label: 'Chart Preview'
					},
					{
						fieldname: 'chart_preview',
						label: 'Chart Preview',
						fieldtype: 'HTML',
					},
					{
						fieldname: 'create_dashoard_chart',
						label: 'Add Chart to Dashboard',
						fieldtype: 'Button',
						hidden: 1,
						click: function () {
							dialog.hide();
							this$1.add_chart_to_dashboard();
						}
					}
				],
				primary_action_label: __('Create'),
				primary_action: function (values) {
					values = set_chart_values(values);

					var options =
						frappe.report_utils.make_chart_options(
							this$1.columns,
							this$1.raw_data,
							values
						);
					me.chart_fields = values;

					var x_field_label =
						field_options.numeric_fields.filter(function (field) { return field.value == values.y_fields[0]; }
						)[0].label;
					var y_field_label =
						field_options.non_numeric_fields.filter(function (field) { return field.value == values.x_field; }
						)[0].label;

					options.title = __("{0}: {1} vs {2}", [this$1.report_name, x_field_label, y_field_label]);

					this$1.render_chart(options);
					this$1.add_chart_buttons_to_toolbar(true);

					dialog.hide();
				}
			});

			dialog.show();

			// load preview after dialog animation
			setTimeout(preview_chart, 500);
		}

		prepare_columns(columns) {
			var this$1 = this;

			return columns.map(function (column) {
				column = frappe.report_utils.prepare_field_from_column(column);

				var format_cell = function (value, row, column, data) {
					if (column.isHeader && !data && this$1.data) {
						// totalRow doesn't have a data object
						// proxy it using the first data object
						// applied to Float, Currency fields, needed only for currency formatting.
						// make first data column have value 'Total'
						var index = 1;

						if (this$1.report_settings.get_datatable_options) {
							var datatable = this$1.report_settings.get_datatable_options({});
							if (datatable && datatable.checkboxColumn) { index = 2; }
						}

						if (column.colIndex === index && !value) {
							value = "Total";
							column = { fieldtype: "Data" }; // avoid type issues for value if Date column
						} else if (in_list(["Currency", "Float"], column.fieldtype)) {
							// proxy for currency and float
							data = this$1.data[0];
						}
					}
					return frappe.format(value, column,
						{for_print: false, always_show_decimals: true}, data);
				};

				var compareFn = null;
				if (column.fieldtype === 'Date') {
					compareFn = function (cell, keyword) {
						if (!cell.content) { return null; }
						if (keyword.length !== 'YYYY-MM-DD'.length) { return null; }

						var keywordValue = frappe.datetime.user_to_obj(keyword);
						var cellValue = frappe.datetime.str_to_obj(cell.content);
						return [+cellValue, +keywordValue];
					};
				}

				return Object.assign(column, {
					id: column.fieldname,
					name: __(column.label, null, ("Column of report '" + (this$1.report_name) + "'")), // context has to match context in   get_messages_from_report in translate.py
					width: parseInt(column.width) || null,
					editable: false,
					compareValue: compareFn,
					format: function (value, row, column, data) {
						if (this$1.report_settings.formatter) {
							return this$1.report_settings.formatter(value, row, column, data, format_cell);
						}
						return format_cell(value, row, column, data);
					}
				});
			});
		}

		prepare_data(data) {
			var this$1 = this;

			return data.map(function (row) {
				var row_obj = {};
				if (Array.isArray(row)) {
					this$1.columns.forEach(function (column, i) {
						row_obj[column.id] = row[i];
					});

					return row_obj;
				}
				return row;
			});
		}

		get_visible_columns() {
			var this$1 = this;

			var visible_column_ids = this.datatable.datamanager.getColumns(true).map(function (col) { return col.id; });

			return visible_column_ids
				.map(function (id) { return this$1.columns.find(function (col) { return col.id === id; }); })
				.filter(Boolean);
		}

		get_filter_values(raise) {

			// check for mandatory property for filters added via UI
			var mandatory = this.filters.filter(function (f) { return (f.df.reqd || f.df.mandatory); });
			var missing_mandatory = mandatory.filter(function (f) { return !f.get_value(); });
			if (raise && missing_mandatory.length > 0) {
				var message = __('Please set filters');
				this.toggle_message(raise, message);
				throw "Filter missing";
			}

			var filters = this.filters
				.filter(function (f) { return f.get_value(); })
				.map(function (f) {
					var obj;

					var v = f.get_value();
					// hidden fields dont have $input
					if (f.df.hidden) { v = f.value; }
					if (v === '%') { v = null; }
					if (f.df.wildcard_filter) {
						v = "%" + v + "%";
					}
					return ( obj = {}, obj[f.df.fieldname] = v, obj );
				})
				.reduce(function (acc, f) {
					Object.assign(acc, f);
					return acc;
				}, {});
			return filters;
		}

		get_filter(fieldname) {
			var field = (this.filters || []).find(function (f) { return f.df.fieldname === fieldname; });
			if (!field) {
				console.warn(("[Query Report] Invalid filter: " + fieldname));
			}
			return field;
		}

		get_filter_value(fieldname) {
			var field = this.get_filter(fieldname);
			return field ? field.get_value() : null;
		}

		set_filter_value(fieldname, value) {
			var this$1 = this;

			var field_value_map = {};
			if (typeof fieldname === 'string') {
				field_value_map[fieldname] = value;
			} else {
				field_value_map = fieldname;
			}

			this._no_refresh = true;
			Object.keys(field_value_map)
				.forEach(function (fieldname, i, arr) {
					var value = field_value_map[fieldname];

					if (i === arr.length - 1) {
						this$1._no_refresh = false;
					}

					this$1.get_filter(fieldname).set_value(value);
				});
		}

		set_breadcrumbs() {
			if (!this.report_doc || !this.report_doc.ref_doctype) { return; }
			var ref_doctype = frappe.get_meta(this.report_doc.ref_doctype);
			frappe.breadcrumbs.add(ref_doctype.module);
		}

		make_access_log (method, file_format) {
			frappe.call("frappe.core.doctype.access_log.access_log.make_access_log",
				{
					doctype: this.doctype || '',
					report_name: this.report_name,
					filters: this.get_filter_values(),
					file_type: file_format,
					method: method
				});
		}

		print_report(print_settings) {
			var custom_format = this.report_settings.html_format || null;
			var filters_html = this.get_filters_html_for_print();
			var landscape = print_settings.orientation == 'Landscape';

			this.make_access_log('Print', 'PDF');
			frappe.render_grid({
				template: print_settings.columns ? 'print_grid' : custom_format,
				title: __(this.report_name),
				subtitle: filters_html,
				print_settings: print_settings,
				landscape: landscape,
				filters: this.get_filter_values(),
				data: this.get_data_for_print(),
				columns: this.get_columns_for_print(print_settings, custom_format),
				original_data: this.data,
				report: this
			});
		}

		pdf_report(print_settings) {
			var base_url = frappe.urllib.get_base_url();
			var print_css = frappe.boot.print_css;
			var landscape = print_settings.orientation == 'Landscape';

			var custom_format = this.report_settings.html_format || null;
			var columns = this.get_columns_for_print(print_settings, custom_format);
			var data = this.get_data_for_print();
			var applied_filters = this.get_filter_values();

			var filters_html = this.get_filters_html_for_print();
			var template =
				print_settings.columns || !custom_format ? 'print_grid' : custom_format;
			var content = frappe.render_template(template, {
				title: __(this.report_name),
				subtitle: filters_html,
				filters: applied_filters,
				data: data,
				original_data: this.data,
				columns: columns,
				report: this
			});

			// Render Report in HTML
			var html = frappe.render_template('print_template', {
				title: __(this.report_name),
				content: content,
				base_url: base_url,
				print_css: print_css,
				print_settings: print_settings,
				landscape: landscape,
				columns: columns,
				lang: frappe.boot.lang,
				layout_direction: frappe.utils.is_rtl() ? "rtl" : "ltr"
			});

			frappe.render_pdf(html, print_settings);
		}

		get_filters_html_for_print() {
			var applied_filters = this.get_filter_values();
			return Object.keys(applied_filters)
				.map(function (fieldname) {
					var label = frappe.query_report.get_filter(fieldname).df.label;
					var value = applied_filters[fieldname];
					return ("<h6>" + (__(label)) + ": " + value + "</h6>");
				})
				.join('');
		}

		export_report() {
			var this$1 = this;

			if (this.export_dialog) {
				this.export_dialog.clear();
				this.export_dialog.show();
				return;
			}

			var export_dialog_fields = [
				{
					label: __('Select File Format'),
					fieldname: 'file_format',
					fieldtype: 'Select',
					options: ['Excel', 'CSV'],
					default: 'Excel',
					reqd: 1
				}
			];

			if (this.tree_report) {
				export_dialog_fields.push({
					label: __("Include indentation"),
					fieldname: "include_indentation",
					fieldtype: "Check",
				});
			}

			this.export_dialog = frappe.prompt(export_dialog_fields, function (ref) {
				var file_format = ref.file_format;
				var include_indentation = ref.include_indentation;

				this$1.make_access_log('Export', file_format);
				if (file_format === 'CSV') {
					var column_row = this$1.columns.reduce(function (acc, col) {
						if (!col.hidden) {
							acc.push(col.label);
						}
						return acc;
					}, []);
					var data = this$1.get_data_for_csv(include_indentation);
					var out = [column_row].concat(data);

					frappe.tools.downloadify(out, null, this$1.report_name);
				} else {
					var filters = this$1.get_filter_values(true);
					if (frappe.urllib.get_dict("prepared_report_name")) {
						filters = Object.assign(frappe.urllib.get_dict("prepared_report_name"), filters);
					}

					var visible_idx = this$1.datatable.bodyRenderer.visibleRowIndices;
					if (visible_idx.length + 1 === this$1.data.length) {
						visible_idx.push(visible_idx.length);
					}

					var args = {
						cmd: 'frappe.desk.query_report.export_query',
						report_name: this$1.report_name,
						custom_columns: this$1.custom_columns.length? this$1.custom_columns: [],
						file_format_type: file_format,
						filters: filters,
						visible_idx: visible_idx,
						include_indentation: include_indentation,
					};

					open_url_post(frappe.request.url, args);
				}
			}, __('Export Report: {0}', [this.report_name]), __('Download'));
		}

		get_data_for_csv(include_indentation) {
			var this$1 = this;

			var rows = this.datatable.bodyRenderer.visibleRows;
			if (this.raw_data.add_total_row) {
				rows.push(this.datatable.bodyRenderer.getTotalRow());
			}
			return rows.map(function (row) {
				var standard_column_count = this$1.datatable.datamanager.getStandardColumnCount();
				return row
					.slice(standard_column_count)
					.map(function (cell, i) {
						if (cell.column.fieldtype === "Duration") {
							cell.content = frappe.utils.get_formatted_duration(cell.content);
						}
						if (include_indentation && i===0) {
							cell.content = '   '.repeat(row.meta.indent) + (cell.content || '');
						}
						return cell.content || '';
					});
			});
		}

		get_data_for_print() {
			var this$1 = this;

			if (!this.data.length) {
				return [];
			}

			var rows = this.datatable.datamanager.rowViewOrder.map(function (index) {
				if (this$1.datatable.bodyRenderer.visibleRowIndices.includes(index)) {
					return this$1.data[index];
				}
			}).filter(Boolean);

			if (this.raw_data.add_total_row) {
				var totalRow = this.datatable.bodyRenderer.getTotalRow().reduce(function (row, cell) {
					row[cell.column.id] = cell.content;
					row.is_total_row = true;
					return row;
				}, {});

				rows.push(totalRow);
			}
			return rows;
		}

		get_columns_for_print(print_settings, custom_format) {
			var columns = [];

			if (print_settings && print_settings.columns) {
				columns = this.get_visible_columns().filter(function (column) { return print_settings.columns.includes(column.fieldname); }
				);
			} else {
				columns = custom_format ? this.columns : this.get_visible_columns();
			}

			return columns;
		}

		get_menu_items() {
			var this$1 = this;

			var items = [
				{
					label: __('Refresh'),
					action: function () { return this$1.refresh(); },
					class: 'visible-xs'
				},
				{
					label: __('Edit'),
					action: function () { return frappe.set_route('Form', 'Report', this$1.report_name); },
					condition: function () { return frappe.user.is_report_manager(); },
					standard: true
				},
				{
					label: __('Print'),
					action: function () {
						var dialog = frappe.ui.get_print_settings(
							false,
							function (print_settings) { return this$1.print_report(print_settings); },
							this$1.report_doc.letter_head,
							this$1.get_visible_columns()
						);
						this$1.add_portrait_warning(dialog);
					},
					condition: function () { return frappe.model.can_print(this$1.report_doc.ref_doctype); },
					standard: true
				},
				{
					label: __('PDF'),
					action: function () {
						var dialog = frappe.ui.get_print_settings(
							false,
							function (print_settings) { return this$1.pdf_report(print_settings); },
							this$1.report_doc.letter_head,
							this$1.get_visible_columns()
						);

						this$1.add_portrait_warning(dialog);
					},
					condition: function () { return frappe.model.can_print(this$1.report_doc.ref_doctype); },
					standard: true
				},
				{
					label: __('Export'),
					action: function () { return this$1.export_report(); },
					condition: function () { return frappe.model.can_export(this$1.report_doc.ref_doctype); },
					standard: true
				},
				{
					label: __('Setup Auto Email'),
					action: function () { return frappe.set_route('List', 'Auto Email Report', {'report' : this$1.report_name}); },
					standard: true
				},
				{
					label: __('Add Column'),
					action: function () {
						var d = new frappe.ui.Dialog({
							title: __('Add Column'),
							fields: [
								{
									fieldtype: 'Select',
									fieldname: 'doctype',
									label: __('From Document Type'),
									options: this$1.linked_doctypes.map(function (df) { return ({ label: df.doctype, value: df.doctype }); }),
									change: function () {
										var doctype = d.get_value('doctype');
										frappe.model.with_doctype(doctype, function () {
											var options = frappe.meta.get_docfields(doctype)
												.filter(frappe.model.is_value_type)
												.map(function (df) { return ({ label: df.label, value: df.fieldname }); });

											d.set_df_property('field', 'options', options.sort(function(a, b) {
												if (a.label < b.label) {
													return -1;
												}
												if (a.label > b.label) {
													return 1;
												}
												return 0;
											})
											);
										});
									}
								},
								{
									fieldtype: 'Select',
									label: __('Field'),
									fieldname: 'field',
									options: []
								},
								{
									fieldtype: 'Select',
									label: __('Insert After'),
									fieldname: 'insert_after',
									options: this$1.columns.map(function (df) { return df.label; })
								}
							],
							primary_action: function (values) {
								var custom_columns = [];
								var df = frappe.meta.get_docfield(values.doctype, values.field);
								var insert_after_index = this$1.columns
									.findIndex(function (column) { return column.label === values.insert_after; });

								var fieldname = this$1.get_fieldname_for_column(df.fieldname, values.doctype);

								custom_columns.push({
									fieldname: fieldname,
									field: values.field,
									fieldtype: df.fieldtype,
									label: df.label,
									insert_after_index: insert_after_index,
									link_field: this$1.doctype_field_map[values.doctype],
									doctype: values.doctype,
									options: df.options,
									width: 100
								});

								this$1.custom_columns = this$1.custom_columns.concat(custom_columns);
								frappe.call({
									method: 'frappe.desk.query_report.get_data_for_custom_field',
									args: {
										doctype: values.doctype,
										fieldname: fieldname,
										field: values.field
									},
									callback: function (r) {
										var custom_data = r.message;
										var link_field = this$1.doctype_field_map[values.doctype];
										this$1.add_custom_column(custom_columns, custom_data, link_field, fieldname, insert_after_index);
										d.hide();
									}
								});
								this$1.set_menu_items();
							}
						});

						d.show();
					},
					standard: true
				},
				{
					label: __('User Permissions'),
					action: function () { return frappe.set_route('List', 'User Permission', {
						doctype: 'Report',
						name: this$1.report_name
					}); },
					condition: function () { return frappe.model.can_set_user_permissions('Report'); },
					standard: true
				}
			];

			if (frappe.user.is_report_manager()) {
				items.push({
					label: __('Save'),
					action: function () {
						var d = new frappe.ui.Dialog({
							title: __('Save Report'),
							fields: [
								{
									fieldtype: 'Data',
									fieldname: 'report_name',
									label: __("Report Name"),
									default: this$1.report_doc.is_standard == 'No' ? this$1.report_name : "",
									reqd: true
								}
							],
							primary_action: function (values) {
								frappe.call({
									method: "frappe.desk.query_report.save_report",
									args: {
										reference_report: this$1.report_name,
										report_name: values.report_name,
										columns: this$1.get_visible_columns()
									},
									callback: function(r) {
										this.show_save = false;
										d.hide();
										frappe.set_route('query-report', r.message);
									}
								});
							}
						});
						d.show();
					},
					standard: true
				});
			}

			return items;
		}

		add_portrait_warning(dialog) {
			if (this.columns.length > 10) {
				dialog.set_df_property('orientation', 'change', function () {
					var value = dialog.get_value('orientation');
					var description = value === 'Portrait'
						? __('Report with more than 10 columns looks better in Landscape mode.')
						: '';
					dialog.set_df_property('orientation', 'description', description);
				});
			}
		}

		get_fieldname_for_column(fieldname, doctype) {
			// check if fieldname already used for any other column
			var existing_fieldnames = [];
			this.columns.forEach(function (column) {
				existing_fieldnames.push(column.fieldname);
			});

			// Append doctype after fieldname to avoid conflict
			if (existing_fieldnames.includes(fieldname)) {
				fieldname = frappe.model.scrub(fieldname + " " + doctype);
			}

			return fieldname;
		}

		add_custom_column(custom_column, custom_data, link_field, column_field, insert_after_index) {
			var column = this.prepare_columns(custom_column);

			this.columns.splice(insert_after_index + 1, 0, column[0]);

			this.data.forEach(function (row) {
				row[column_field] = custom_data[row[link_field]];
			});

			this.render_datatable();
		}

		get_linked_doctypes() {
			var this$1 = this;

			var doctypes = [];
			var dynamic_links = [];
			var dynamic_doctypes = new Set();
			this.doctype_field_map = {};

			this.columns.forEach(function (df) {
				if (df.fieldtype == "Link" && df.options && df.options != "Currency") {
					doctypes.push({
						doctype: df.options,
						fieldname: df.fieldname
					});
				}
				else if (df.fieldtype == "Dynamic Link" && df.options) {
					dynamic_links.push({
						link_name: df.options,
						fieldname: df.fieldname
					});
				}
			});

			this.data.forEach(function (row) {
				dynamic_links.forEach(function (field) {
					if (row[field.link_name]){
						dynamic_doctypes.add(row[field.link_name] + ":" + field.fieldname);
					}
				});
			});

			doctypes = doctypes.concat(Array.from(dynamic_doctypes).map(function (d) {
				var doc_field_pair = d.split(":");
				return {
					doctype: doc_field_pair[0],
					fieldname: doc_field_pair[1]
				};
			}));

			doctypes.forEach(function (doc) {
				this$1.doctype_field_map[doc.doctype] = doc.fieldname;
			});

			return doctypes;
		}

		setup_report_wrapper() {
			if (this.$report) { return; }

			// Remove border from
			$(".page-head-content").removeClass('border-bottom');

			var page_form = this.page.main.find('.page-form');
			this.$status = $("<div class=\"form-message text-muted small\"></div>")
				.hide().insertAfter(page_form);

			this.$summary = $("<div class=\"report-summary\"></div>")
				.hide().appendTo(this.page.main);

			this.$chart = $('<div class="chart-wrapper">').hide().appendTo(this.page.main);
			this.$report = $('<div class="report-wrapper">').appendTo(this.page.main);
			this.$message = $(this.message_div('')).hide().appendTo(this.page.main);
		}

		show_status(status_message) {
			this.$status.html(status_message).show();
		}

		hide_status() {
			this.$status.hide();
		}

		show_footer_message() {
			this.$report_footer && this.$report_footer.remove();
			this.$report_footer = $("<div class=\"report-footer text-muted\"></div>").appendTo(this.page.main);
			if (this.tree_report) {
				this.$tree_footer = $(("<div class=\"tree-footer col-md-6\">\n\t\t\t\t<button class=\"btn btn-xs btn-default\" data-action=\"expand_all_rows\">\n\t\t\t\t\t" + (__('Expand All')) + "</button>\n\t\t\t\t<button class=\"btn btn-xs btn-default\" data-action=\"collapse_all_rows\">\n\t\t\t\t\t" + (__('Collapse All')) + "</button>\n\t\t\t</div>"));
				$(this.$report_footer).append(this.$tree_footer);
				this.$tree_footer.find('[data-action=collapse_all_rows]').show();
				this.$tree_footer.find('[data-action=expand_all_rows]').hide();
			}

			var message = __('For comparison, use >5, <10 or =324. For ranges, use 5:10 (for values between 5 & 10).');
			var execution_time_msg = __('Execution Time: {0} sec', [this.execution_time || 0.1]);

			this.$report_footer.append(("<div class=\"col-md-12\">\n\t\t\t<span\">" + message + "</span><span class=\"pull-right\">" + execution_time_msg + "</span>\n\t\t</div>"));
		}

		expand_all_rows() {
			this.$tree_footer.find('[data-action=expand_all_rows]').hide();
			this.datatable.rowmanager.expandAllNodes();
			this.$tree_footer.find('[data-action=collapse_all_rows]').show();
		}

		collapse_all_rows() {
			this.$tree_footer.find('[data-action=collapse_all_rows]').hide();
			this.datatable.rowmanager.collapseAllNodes();
			this.$tree_footer.find('[data-action=expand_all_rows]').show();
		}

		message_div(message) {
			return ("<div class='flex justify-center align-center text-muted' style='height: 50vh;'>\n\t\t\t<div>" + message + "</div>\n\t\t</div>");
		}

		reset_report_view() {
			this.hide_status();
			this.toggle_nothing_to_show(true);
			this.refresh();
		}

		toggle_loading(flag) {
			this.toggle_message(flag, __('Loading') + '...');
		}


		toggle_nothing_to_show(flag) {
			var message = this.prepared_report
				? __('This is a background report. Please set the appropriate filters and then generate a new one.')
				: this.get_no_result_message();

			this.toggle_message(flag, message);

			if (flag && this.prepared_report) {
				this.prepared_report_action = "New";
				if (!this.primary_button.is(':visible')) {
					this.add_prepared_report_buttons();
				}
			}
		}

		toggle_message(flag, message) {
			if (flag) {
				this.$message.find('div').html(message);
				this.$message.show();
			} else {
				this.$message.hide();
			}
		}

		toggle_filter_display(fieldname, flag) {
			this.$page.find(("div[data-fieldname=" + fieldname + "]")).toggleClass('hide-control', flag);
		}

		toggle_report(flag) {
			this.$report.toggle(flag);
			this.$chart.toggle(flag);
			this.$summary.toggle(flag);
		}
		// backward compatibility
		get get_values() {
			return this.get_filter_values;
		}
	};

	Object.defineProperty(frappe, 'query_report_filters_by_name', {
		get: function get() {
			console.warn('[Query Report] frappe.query_report_filters_by_name is deprecated. Please use the new api: frappe.query_report.get_filter_value(fieldname) and frappe.query_report.set_filter_value(fieldname, value)');
			return null;
		}
	});

	frappe.templates['print_grid'] = ' {% if title %} <h2>{{ __(title) }}</h2> <hr> {% endif %} {% if subtitle %} {{ subtitle }} <hr> {% endif %} <table class="table table-bordered">    <thead>   <tr>   <th> # </th>   {% for col in columns %}    {% if col.name && col._id !== "_check" %}    <th     {% if col.minWidth %}      style="min-width: {{ col.minWidth }}px"     {% endif %}     {% if col.docfield && frappe.model.is_numeric_field(col.docfield) %}      class="text-right"     {% endif %}    >     {{ __(col.name) }}</th>    {% endif %}   {% endfor %}   </tr>  </thead>    <tbody>   {% for row in data %}    <tr style="height: 30px">    <td {% if row.bold == 1 %} style="font-weight: bold" {% endif %}>     <span> {{ row._index + 1 }} </span>    </td>    {% for col in columns %}     {% if col.name && col._id !== "_check" %}       {% var value = col.fieldname ? row[col.fieldname] : row[col.id]; %}       <td {% if row.bold == 1 %} style="font-weight: bold" {% endif %}>       <span {% if col._index == 0 %} style="padding-left: {%= cint(row.indent) * 2 %}em" {% endif %}>        {% format_data = row.is_total_row && ["Currency", "Float"].includes(col.fieldtype) ? data[0] : row %}        {% if (row.is_total_row && col._index == 0) { %}         {{ __("Total") }}        {% } else { %}         {{          col.formatter           ? col.formatter(row._index, col._index, value, col, format_data, true)           : col.format            ? col.format(value, row, col, format_data)            : col.docfield             ? frappe.format(value, col.docfield)             : value         }}        {% } %}       </span>      </td>     {% endif %}    {% endfor %}    </tr>   {% endfor %}  </tbody> </table> ';

	frappe.templates['print_tree'] = '<!DOCTYPE html> <html lang="en">   <head>     <meta charset="utf-8">     <meta http-equiv="X-UA-Compatible" content="IE=edge">     <meta name="viewport" content="width=device-width, initial-scale=1">     <meta name="description" content="">     <meta name="author" content="">     <title>{{ title }}</title>     <link href="{{ base_url }}/assets/frappe/css/bootstrap.css" rel="stylesheet">  <link type="text/css" rel="stylesheet"   href="{{ base_url }}/assets/frappe/css/font-awesome.css">  <link rel="stylesheet" type="text/css" href="{{ base_url }}/assets/frappe/css/tree.css">   <style>   {{ print_css }}  </style>  <style>   .tree.opened::before,    .tree-node.opened::before,    .tree:last-child::after,    .tree-node:last-child::after {    z-index: 1;    border-left: 1px solid #d1d8dd;    background: none;   }   .tree a,   .tree-link {    text-decoration: none;    cursor: default;   }   .tree.opened > .tree-children > .tree-node > .tree-link::before,    .tree-node.opened > .tree-children > .tree-node > .tree-link::before {    border-top: 1px solid #d1d8dd;    z-index: 1;    background: none;   }   i.fa.fa-fw.fa-folder {    z-index: 2;    position: relative;   }   .tree:last-child::after, .tree-node:last-child::after {    display: none;   }   .tree-node-toolbar {    display: none;   }   i.octicon.octicon-primitive-dot.text-extra-muted {    width: 7px;    height: 7px;    border-radius: 50%;    background: #d1d8dd;    display: inline-block;    position: relative;    z-index: 2;   }    @media (max-width: 767px) {    ul.tree-children {     padding-left: 20px;    }   }  </style>   </head>   <body>    <div class="print-format-gutter">     {% if print_settings.repeat_header_footer %}    <div id="footer-html" class="visible-pdf">     {% if print_settings.letter_head && print_settings.letter_head.footer %}      <div class="letter-head-footer">       {{ print_settings.letter_head.footer }}      </div>     {% endif %}     <p class="text-center small page-number visible-pdf">      {{ __("Page {0} of {1}", [`<span class="page"></span>`, `<span class="topage"></span>`]) }}     </p>    </div>     {% endif %}      <div class="print-format {% if landscape %} landscape {% endif %}">      {% if print_settings.letter_head %}      <div {% if print_settings.repeat_header_footer %} id="header-html" class="hidden-pdf" {% endif %}>       <div class="letter-head">{{ print_settings.letter_head.header }}</div>      </div>     {% endif %}     <div class="tree opened">      {{ tree }}     </div>     </div>    </div>   </body> </html> ';

	frappe.templates['group_by'] = '<div class="group-by-box">  <div class="visible-xs flex justify-flex-end">   <span class="remove-group-by">    {{ __("Remove") }}   </span>  </div>  <div class="list_groupby row">   <div class="col-sm-8 form-group">    <select class="group-by form-control input-xs">     <option value="" disabled selected>{{ __("Select Group By...") }}</option>     {% for (var parent_doctype in group_by_conditions) { %}      {% for (var val in group_by_conditions[parent_doctype]) { %}       {% if (parent_doctype !== doctype) { %}       <option        data-doctype="{{parent_doctype}}"        value="{{group_by_conditions[parent_doctype][val].fieldname}}"       >        {{ __(group_by_conditions[parent_doctype][val].label) }}        ({{ __(parent_doctype) }})       </option>       {% } else { %}       <option        data-doctype="{{parent_doctype}}"        value="{{group_by_conditions[parent_doctype][val].fieldname}}"       >        {{ __(group_by_conditions[parent_doctype][val].label) }}       </option>       {% } %}      {% } %}     {% } %}    </select>   </div>   <div class="col-sm-3 form-group">    <select class="aggregate-function form-control input-xs">     {% for condition in aggregate_function_conditions %}     <option value="{{condition.name}}">{{ __(condition.label) }}</option>     {% endfor %}    </select>   </div>   <div class="col-sm-4 col-xs-12" style="display: none">    <select class="aggregate-on form-control input-xs">     <option value="" disabled selected>{{ __("Select Field...") }}</option>    </select>   </div>   <div class="groupby-actions pull-left col-sm-1 hidden-xs">    <span class="remove-group-by">     <svg class="icon icon-sm">      <use xlink:href="#icon-close"></use>     </svg>    </span>   </div>  </div> </div> ';

	frappe.provide('frappe.views');

	frappe.ui.GroupBy = class {
		constructor(report_view) {
			this.report_view = report_view;
			this.page = report_view.page;
			this.doctype = report_view.doctype;
			this.make();
		}

		make() {
			this.make_group_by_button();
			this.init_group_by_popover();
			this.set_popover_events();
		}

		init_group_by_popover() {
			var sql_aggregate_functions = [
				{name: 'count', label: __('Count')},
				{name: 'sum', label: __('Sum')},
				{name: 'avg', label: __('Average')}
			];

			var group_by_template = $(
				frappe.render_template('group_by', {
					doctype: this.doctype,
					group_by_conditions: this.get_group_by_fields(),
					aggregate_function_conditions: sql_aggregate_functions,
				})
			);

			this.group_by_button.popover({
				content: group_by_template,
				template: "\n\t\t\t\t<div class=\"group-by-popover popover\">\n\t\t\t\t\t<div class=\"arrow\"></div>\n\t\t\t\t\t<div class=\"popover-body popover-content\">\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t",
				html: true,
				trigger: 'manual',
				container: 'body',
				placement: 'bottom',
				offset: '-100px 0',
			});
		}

		// TODO: make common with filter popover
		set_popover_events() {
			var this$1 = this;

			$(document.body).on('click', function (e) {
				if (this$1.wrapper && this$1.wrapper.is(':visible')) {
					if (
						$(e.target).parents('.group-by-popover').length === 0 &&
						$(e.target).parents('.group-by-box').length === 0 &&
						$(e.target).parents('.group-by-button').length === 0 &&
						!$(e.target).is(this$1.group_by_button)
					) {
						this$1.wrapper && this$1.group_by_button.popover('hide');
					}
				}
			});

			this.group_by_button.on('click', function () {
				this$1.group_by_button.popover('toggle');
			});

			this.group_by_button.on('shown.bs.popover', function () {
				if (!this$1.wrapper) {
					this$1.wrapper = $('.group-by-popover');
					this$1.setup_group_by_area();
				}
			});

			this.group_by_button.on('hidden.bs.popover', function () {
				this$1.update_group_by_button();
			});

			frappe.router.on('change', function () {
				this$1.group_by_button.popover('hide');
			});
		}

		setup_group_by_area() {
			this.aggregate_on_html = "";
			this.group_by_select = this.wrapper.find('select.group-by');
			this.group_by_field && this.group_by_select.val(this.group_by_field);
			this.aggregate_function_select = this.wrapper.find(
				'select.aggregate-function'
			);
			this.aggregate_on_select = this.wrapper.find('select.aggregate-on');
			this.remove_group_by_button = this.wrapper.find('.remove-group-by');

			if (this.aggregate_function) {
				this.aggregate_function_select.val(this.aggregate_function);
			} else {
				// set default to count
				this.aggregate_function_select.val('count');
				this.aggregate_function = 'count';
			}

			this.toggle_aggregate_on_field();
			this.aggregate_on && this.aggregate_on_select.val(this.aggregate_on_field);

			this.set_group_by_events();
		}

		set_group_by_events() {
			var this$1 = this;

			// try running on change
			this.group_by_select.on('change', function () {
				this$1.group_by_field = this$1.group_by_select.val();
				this$1.group_by_doctype = this$1.group_by_select
					.find(':selected')
					.attr('data-doctype');
				this$1.apply_group_by_and_refresh();
			});

			this.aggregate_function_select.on('change', function () {
				//Set aggregate on options as numeric fields if function is sum or average
				this$1.toggle_aggregate_on_field();
				this$1.aggregate_function = this$1.aggregate_function_select.val();
				this$1.apply_group_by_and_refresh();
			});

			this.aggregate_on_select.on('change', function () {
				this$1.aggregate_on_field = this$1.aggregate_on_select.val();
				this$1.aggregate_on_doctype = this$1.aggregate_on_select
					.find(':selected')
					.attr('data-doctype');
				this$1.apply_group_by_and_refresh();
			});

			this.remove_group_by_button.on('click', function () {
				if (this$1.group_by) {
					this$1.remove_group_by();
					this$1.toggle_aggregate_on_field_display(false);
				}
			});
		}

		toggle_aggregate_on_field() {
			var this$1 = this;

			var fn = this.aggregate_function_select.val();
			if (fn === 'sum' || fn === 'avg') {
				if (!this.aggregate_on_html.length) {
					this.aggregate_on_html = "<option value=\"\" disabled selected>\n\t\t\t\t\t\t" + (__('Select Field...')) + "\n\t\t\t\t\t</option>";

					var loop = function ( doctype ) {
						var doctype_fields = this$1.all_fields[doctype];
						doctype_fields.forEach(function (field) {
							// pick numeric fields for sum / avg
							if (frappe.model.is_numeric_field(field.fieldtype)) {
								var option_text =
									doctype == this$1.doctype
										? field.label
										: ((field.label) + " (" + (__(doctype)) + ")");
								this$1.aggregate_on_html += "<option data-doctype=\"" + doctype + "\"\n\t\t\t\t\t\t\t\tvalue=\"" + (field.fieldname) + "\">" + (__(option_text)) + "</option>";
							}
						});
					};

					for (var doctype in this$1.all_fields) loop( doctype );
				}
				this.aggregate_on_select.html(this.aggregate_on_html);
				this.toggle_aggregate_on_field_display(true);
			} else {
				// count, so no aggregate function
				this.toggle_aggregate_on_field_display(false);
			}
		}

		//TODO: Fix this
		toggle_aggregate_on_field_display(show) {
			this.group_by_select.parent().toggleClass('col-sm-5', show);
			this.group_by_select.parent().toggleClass('col-sm-8', !show);
			this.aggregate_function_select.parent().toggleClass('col-sm-2', show);
			this.aggregate_function_select.parent().toggleClass('col-sm-3', !show);
			this.aggregate_on_select.parent().toggle(show);
		}

		get_settings() {
			if (this.group_by) {
				return {
					group_by: this.group_by,
					aggregate_function: this.aggregate_function,
					aggregate_on: this.aggregate_on,
				};
			} else {
				return null;
			}
		}

		apply_settings(settings) {
			var get_fieldname = function (name) { return name.split('.')[1].replace(/`/g, ''); };
			var get_doctype = function (name) { return name
					.split('.')[0]
					.replace(/`/g, '')
					.replace('tab', ''); };

			if (!settings.group_by.startsWith('`tab')) {
				settings.group_by =
					'`tab' + this.doctype + '`.`' + settings.group_by + '`';
			}

			if (settings.aggregate_on && !settings.aggregate_on.startsWith('`tab')) {
				var aggregate_on_doctype = this.get_aggregate_on_doctype(settings);
				settings.aggregate_on =
					'`tab' + aggregate_on_doctype + '`.`' + settings.aggregate_on + '`';
			}

			// Extract fieldname from `tabdoctype`.`fieldname`
			this.group_by_field = get_fieldname(settings.group_by);
			this.group_by_doctype = get_doctype(settings.group_by);

			this.aggregate_function = settings.aggregate_function;

			if (settings.aggregate_on) {
				this.aggregate_on_field = get_fieldname(settings.aggregate_on);
				this.aggregate_on_doctype = get_doctype(settings.aggregate_on);
			}

			this.apply_group_by();
			this.update_group_by_button();
		}

		get_aggregate_on_doctype(settings) {
			for (var i = 0, list = Object.keys(this.all_fields); i < list.length; i += 1) {
				var doctype = list[i];

				var dt_fields = this.all_fields[doctype];
				if (dt_fields.find(function (field) { return field.fieldname == settings.aggregate_on; })) {
					return doctype;
				}
			}
		}

		make_group_by_button() {
			this.page.wrapper.find('.sort-selector').before(
				$(("<div class=\"group-by-selector\">\n\t\t\t\t<button class=\"btn btn-default btn-sm group-by-button ellipsis\">\n\t\t\t\t\t<span class=\"group-by-icon\">\n\t\t\t\t\t\t" + (frappe.utils.icon('group-by')) + "\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"button-label hidden-xs\">\n\t\t\t\t\t\t" + (__('Add Group')) + "\n\t\t\t\t\t</span>\n\t\t\t\t</button>\n\t\t\t</div>"))
			);

			this.group_by_button = this.page.wrapper.find('.group-by-button');
		}

		apply_group_by() {
			this.group_by =
				'`tab' + this.group_by_doctype + '`.`' + this.group_by_field + '`';

			if (this.aggregate_function === 'count') {
				this.aggregate_on_field = null;
				this.aggregate_on_doctype = null;
			} else {
				this.aggregate_on =
					'`tab' +
					this.aggregate_on_doctype +
					'`.`' +
					this.aggregate_on_field +
					'`';
			}

			//All necessary fields must be set before applying group by
			if (
				!this.group_by ||
				!this.aggregate_function ||
				(!this.aggregate_on_field && this.aggregate_function !== 'count')
			) {
				return false;
			}

			return true;
		}

		apply_group_by_and_refresh() {
			if (this.apply_group_by()) {
				this.report_view.refresh();
			}
		}

		set_args(args) {
			if (this.aggregate_function && this.group_by) {
				this.report_view.group_by = this.group_by;
				this.report_view.sort_by = '_aggregate_column';
				this.report_view.sort_order = 'desc';

				// save original fields
				if (
					!this.report_view.fields.map(function (f) { return f[0]; }).includes('_aggregate_column')
				) {
					this.original_fields = this.report_view.fields.map(function (f) { return f; });
				}

				this.report_view.fields = [[this.group_by_field, this.group_by_doctype]];

				// rebuild fields for group by
				args.fields = this.report_view.get_fields();

				// add aggregate column in both query args and report views
				this.report_view.fields.push([
					'_aggregate_column',
					this.aggregate_on_doctype || this.doctype ]);

				// setup columns in datatable
				this.report_view.setup_columns();

				Object.assign(args, {
					with_comment_count: false,
					aggregate_on_field: this.aggregate_on_field || 'name',
					aggregate_on_doctype: this.aggregate_on_doctype || this.doctype,
					aggregate_function: this.aggregate_function || 'count',
					group_by: this.report_view.group_by || null,
					order_by: '_aggregate_column desc',
				});
			}
		}

		get_group_by_docfield() {
			// called from build_column
			var docfield = {};
			if (this.aggregate_function === 'count') {
				docfield = {
					fieldtype: 'Int',
					label: __('Count'),
					parent: this.doctype,
					width: 200,
				};
			} else {
				// get properties of "aggregate_on", for example Net Total
				docfield = Object.assign(
					{},
					frappe.meta.docfield_map[this.aggregate_on_doctype][
						this.aggregate_on_field
					]
				);

				if (this.aggregate_function === 'sum') {
					docfield.label = __('Sum of {0}', [docfield.label]);
				} else {
					docfield.label = __('Average of {0}', [docfield.label]);
				}
			}

			docfield.fieldname = '_aggregate_column';
			return docfield;
		}

		remove_group_by() {
			this.order_by = '';
			this.group_by = null;
			this.group_by_field = null;
			this.report_view.group_by = null;
			this.aggregate_function = 'count';
			this.aggregate_on = null;
			this.aggregate_on_field = null;
			this.group_by_select.val('');
			this.aggregate_function_select.val('count');
			this.aggregate_on_select.empty().val('');
			this.aggregate_on_select.parent().hide();

			// restore original fields
			if (this.original_fields) {
				this.report_view.fields = this.original_fields;
			} else {
				this.report_view.set_default_fields();
			}

			this.report_view.setup_columns();
			this.original_fields = null;
			this.report_view.refresh();
		}

		get_group_by_fields() {
			var this$1 = this;

			this.group_by_fields = {};
			this.all_fields = {};

			var fields = this.report_view.meta.fields.filter(function (f) { return ['Select', 'Link', 'Data', 'Int', 'Check'].includes(f.fieldtype); }
			);
			var tag_field = {fieldname: '_user_tags', fieldtype: 'Data', label: __('Tags')};
			this.group_by_fields[this.doctype] = fields.concat(tag_field);
			this.all_fields[this.doctype] = this.report_view.meta.fields;

			var standard_fields_filter = function (df) { return !in_list(frappe.model.no_value_type, df.fieldtype) && !df.report_hide; };

			var table_fields = frappe.meta
				.get_table_fields(this.doctype)
				.filter(function (df) { return !df.hidden; });

			table_fields.forEach(function (df) {
				var cdt = df.options;
				var child_table_fields = frappe.meta
					.get_docfields(cdt)
					.filter(standard_fields_filter);
				this$1.group_by_fields[cdt] = child_table_fields;
				this$1.all_fields[cdt] = child_table_fields;
			});

			return this.group_by_fields;
		}

		update_group_by_button() {
			var group_by_applied = Boolean(this.group_by_field);
			var button_label = group_by_applied
				? __("Group By {0}", [this.get_group_by_field_label()])
				: __('Add Group');

			this.group_by_button
				.toggleClass('btn-default', !group_by_applied)
				.toggleClass('btn-primary-light', group_by_applied);

			this.group_by_button.find('.group-by-icon')
				.toggleClass('active', group_by_applied);

			this.group_by_button.find('.button-label').html(button_label);
			this.group_by_button.attr('title', button_label);
		}

		get_group_by_field_label() {
			var this$1 = this;

			return this.group_by_fields[this.group_by_doctype].find(
				function (field) { return field.fieldname == this$1.group_by_field; }
			).label;
		}
	};

	frappe.provide('frappe.report_utils');

	frappe.report_utils = {
		make_chart_options: function(columns, raw_data, ref) {
			var y_fields = ref.y_fields;
			var x_field = ref.x_field;
			var chart_type = ref.chart_type;
			var colors = ref.colors;
			var height = ref.height;

			var type = chart_type.toLowerCase();

			var rows =  raw_data.result.filter(function (value) { return Object.keys(value).length; });

			var labels = get_column_values(x_field);
			var datasets = y_fields.map(function (y_field) { return ({
				name: frappe.model.unscrub(y_field),
				values: get_column_values(y_field).map(function (d) { return Number(d); })
			}); });

			if (raw_data.add_total_row) {
				labels = labels.slice(0, -1);
				datasets.forEach(function (dataset) {
					dataset.values = dataset.values.slice(0, -1);
				});
			}

			return {
				data: {
					labels: labels.length? labels: null,
					datasets: datasets
				},
				truncateLegends: 1,
				type: type,
				height: height ? height : 280,
				colors: colors,
				axisOptions: {
					shortenYAxisNumbers: 1,
					xAxisMode: 'tick'
				}
			};

			function get_column_values(column_name) {
				if (Array.isArray(rows[0])) {
					var column_index = columns.findIndex(function (column) { return column.fieldname == column_name; });
					return rows.map(function (row) { return row[column_index]; });
				} else {
					return rows.map(function (row) { return row[column_name]; });
				}
			}
		},

		get_field_options_from_report: function(columns, data) {
			var rows =  data.result.filter(function (value) { return Object.keys(value).length; });
			var first_row = Array.isArray(rows[0]) ? rows[0] : columns.map(function (col) { return rows[0][col.fieldname]; });

			var indices = first_row.reduce(function (accumulator, current_value, current_index) {
				if (Number.isFinite(current_value)) {
					accumulator.push(current_index);
				}
				return accumulator;
			}, []);

			function get_options(fields) {
				return fields.map(function (field) {
					if (field.fieldname) {
						return {label: field.label, value: field.fieldname};
					} else {
						field = frappe.report_utils.prepare_field_from_column(field);
						return {label: field.label, value: field.fieldname};
					}
				});
			}

			var numeric_fields = columns.filter(function (col, i) { return indices.includes(i); });
			var non_numeric_fields = columns.filter(function (col, i) { return !indices.includes(i); });

			var numeric_field_options = get_options(numeric_fields);
			var non_numeric_field_options = get_options(non_numeric_fields);

			return {
				'numeric_fields': numeric_field_options,
				'non_numeric_fields': non_numeric_field_options
			};
		},

		prepare_field_from_column: function(column) {
			var assign;

			if (typeof column === 'string') {
				if (column.includes(':')) {
					var ref = column.split(':');
					var label = ref[0];
					var fieldtype = ref[1];
					var width = ref[2];
					var options;

					if (fieldtype.includes('/')) {
						(assign = fieldtype.split('/'), fieldtype = assign[0], options = assign[1]);
					}

					column = {
						label: label,
						fieldname: label,
						fieldtype: fieldtype,
						width: width,
						options: options
					};
				} else {
					column = {
						label: column,
						fieldname: column,
						fieldtype: 'Data'
					};
				}
			}
			return column;
		},

		get_report_filters: function(report_name) {

			if (frappe.query_reports[report_name]) {
				var filters = frappe.query_reports[report_name].filters;
				return Promise.resolve(filters);
			}

			return frappe.xcall(
				'frappe.desk.query_report.get_script',
				{
					report_name: report_name
				}
			).then(function (r) {
				frappe.dom.eval(r.script || '');
				return frappe.after_ajax(function () {
					return frappe.query_reports[report_name].filters;
				})
			});
		},

		get_filter_values: function get_filter_values(filters) {
			var filter_values = filters
				.map(function (f) {
					var obj;

					var v = f.default;
					return ( obj = {}, obj[f.fieldname] = v, obj );
				})
				.reduce(function (acc, f) {
					Object.assign(acc, f);
					return acc;
				}, {});
			return filter_values;
		},

		get_result_of_fn: function get_result_of_fn(fn, values) {
			var get_result = {
				'Minimum': function (values) { return values.reduce(function (min, val) { return Math.min(min, val); }, values[0]); },
				'Maximum': function (values) { return values.reduce(function (min, val) { return Math.max(min, val); }, values[0]); },
				'Average': function (values) { return values.reduce(function (a, b) { return a + b; }, 0) / values.length; },
				'Sum': function (values) { return values.reduce(function (a, b) { return a + b; }, 0); }
			};
			return get_result[fn](values);
		},

	};

	exports.__moduleExports = clusterize_min;

	return exports;

}({}));
//# sourceMappingURL=report.min.js.map
