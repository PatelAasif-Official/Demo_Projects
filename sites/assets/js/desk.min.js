var Rollup = (function (exports) {
	'use strict';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// for translation
	frappe._messages = {};
	frappe._ = function(txt, replace, context) {
		if ( context === void 0 ) context = null;

		if ($.isEmptyObject(frappe._messages) && frappe.boot) {
			$.extend(frappe._messages, frappe.boot.__messages);
		}
		if (!txt) { return txt; }
		if (typeof txt != "string") { return txt; }

		var translated_text = '';

		var key = txt;    // txt.replace(/\n/g, "");
		if (context) {
			translated_text = frappe._messages[(key + ":" + context)];
		}

		if (!translated_text) {
			translated_text = frappe._messages[key] || txt;
		}

		if (replace && typeof replace === "object") {
			translated_text = $.format(translated_text, replace);
		}
		return translated_text;
	};

	window.__ = frappe._;

	frappe.get_languages = function() {
		if (!frappe.languages) {
			frappe.languages = [];
			$.each(frappe.boot.lang_dict, function(lang, value) {
				frappe.languages.push({ label: lang, value: value });
			});
			frappe.languages = frappe.languages.sort(function(a, b) {
				return a.value < b.value ? -1 : 1;
			});
		}
		return frappe.languages;
	};

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	/*

	Inheritence "Class"
	-------------------
	see: http://ejohn.org/blog/simple-javascript-inheritance/
	To subclass, use:

		var MyClass = Class.extend({
			init: function
		})

	*/
	// https://stackoverflow.com/a/15052240/5353542

	/* Simple JavaScript Inheritance for ES 5.1
	 * based on http://ejohn.org/blog/simple-javascript-inheritance/
	 *  (inspired by base2 and Prototype)
	 * MIT Licensed.
	 */
	(function(global) {
		var fnTest = /xyz/.test(function(){}) ? /\b_super\b/ : /.*/;

		// The base Class implementation (does nothing)
		function Class(){}

		// Create a new Class that inherits from this class
		Class.extend = function(props) {
		  var _super = this.prototype;

		  // Set up the prototype to inherit from the base class
		  // (but without running the init constructor)
		  var proto = Object.create(_super);

		  // Copy the properties over onto the new prototype
		  for (var name in props) {
			// Check if we're overwriting an existing function
			proto[name] = typeof props[name] === "function" &&
			  typeof _super[name] == "function" && fnTest.test(props[name])
			  ? (function(name, fn){
				  return function() {
					var tmp = this._super;

					// Add a new ._super() method that is the same method
					// but on the super-class
					this._super = _super[name];

					// The method only need to be bound temporarily, so we
					// remove it when we're done executing
					var ret = fn.apply(this, arguments);
					this._super = tmp;

					return ret;
				  };
				})(name, props[name])
			  : props[name];
		  }

		  // The new constructor
		  var newClass = typeof proto.init === "function"
			? proto.hasOwnProperty("init")
			  ? proto.init // All construction is actually done in the init method
			  : function SubClass(){ _super.init.apply(this, arguments); }
			: function EmptyClass(){};

		  // Populate our constructed prototype object
		  newClass.prototype = proto;

		  // Enforce the constructor to be what we expect
		  proto.constructor = newClass;

		  // And make this class extendable
		  newClass.extend = Class.extend;

		  return newClass;
		};

		// export
		global.Class = Class;
	  })(commonjsGlobal);

	var _class = {

	};

	// String.prototype.includes polyfill
	// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	if (!String.prototype.includes) {
		String.prototype.includes = function(search, start) {
			if (typeof start !== 'number') {
				start = 0;
			}
			if (start + search.length > this.length) {
				return false;
			} else {
				return this.indexOf(search, start) !== -1;
			}
		};
	}
	// Array.prototype.includes polyfill
	// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/includes
	if (!Array.prototype.includes) {
		Object.defineProperty(Array.prototype, 'includes', {
			value: function(searchElement, fromIndex) {
				if (this == null) {
					throw new TypeError('"this" is null or not defined');
				}
				var o = Object(this);
				var len = o.length >>> 0;
				if (len === 0) {
					return false;
				}
				var n = fromIndex | 0;
				var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
				while (k < len) {
					if (o[k] === searchElement) {
						return true;
					}
					k++;
				}
				return false;
			}
		});
	}


	if (typeof String.prototype.trimLeft !== "function") {
		String.prototype.trimLeft = function() {
			return this.replace(/^\s+/, "");
		};
	}
	if (typeof String.prototype.trimRight !== "function") {
		String.prototype.trimRight = function() {
			return this.replace(/\s+$/, "");
		};
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	if (typeof Object.assign != 'function') {
		// Must be writable: true, enumerable: false, configurable: true
		Object.defineProperty(Object, "assign", {
			value: function assign(target) { // .length of function is 2
				var arguments$1 = arguments;

				if (target == null) { // TypeError if undefined or null
					throw new TypeError('Cannot convert undefined or null to object');
				}

				var to = Object(target);

				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments$1[index];

					if (nextSource != null) { // Skip over if undefined or null
						for (var nextKey in nextSource) {
							// Avoid bugs when hasOwnProperty is shadowed
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
				return to;
			},
			writable: true,
			configurable: true
		});
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// provide a namespace
	if(!window.frappe)
		{ window.frappe = {}; }

	frappe.provide = function(namespace) {
		// docs: create a namespace //
		var nsl = namespace.split('.');
		var parent = window;
		for(var i=0; i<nsl.length; i++) {
			var n = nsl[i];
			if(!parent[n]) {
				parent[n] = {};
			}
			parent = parent[n];
		}
		return parent;
	};

	frappe.provide("locals");
	frappe.provide("frappe.flags");
	frappe.provide("frappe.settings");
	frappe.provide("frappe.utils");
	frappe.provide("frappe.ui.form");
	frappe.provide("frappe.modules");
	frappe.provide("frappe.templates");
	frappe.provide("frappe.test_data");
	frappe.provide('frappe.utils');
	frappe.provide('frappe.model');
	frappe.provide('frappe.user');
	frappe.provide('frappe.session');
	frappe.provide('locals.DocType');

	// for listviews
	frappe.provide("frappe.listview_settings");
	frappe.provide("frappe.tour");
	frappe.provide("frappe.listview_parent_route");

	// constants
	window.NEWLINE = '\n';
	window.TAB = 9;
	window.UP_ARROW = 38;
	window.DOWN_ARROW = 40;

	// proxy for user globals defined in desk.js

	// API globals
	window.cur_frm=null;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// library to mange assets (js, css, models, html) etc in the app.
	// will try and get from localStorage if latest are available
	// depends on frappe.versions to manage versioning

	frappe.require = function(items, callback) {
		if(typeof items === "string") {
			items = [items];
		}
		return new Promise(function (resolve) {
			frappe.assets.execute(items, function () {
				resolve();
				callback && callback();
			});
		});
	};

	frappe.assets = {
		check: function() {
			// if version is different then clear localstorage
			if(window._version_number != localStorage.getItem("_version_number")) {
				frappe.assets.clear_local_storage();
				console.log("Cleared App Cache.");
			}

			if(localStorage._last_load) {
				var not_updated_since = new Date() - new Date(localStorage._last_load);
				if(not_updated_since < 10000 || not_updated_since > 86400000) {
					frappe.assets.clear_local_storage();
				}
			} else {
				frappe.assets.clear_local_storage();
			}

			frappe.assets.init_local_storage();
		},

		init_local_storage: function() {
			localStorage._last_load = new Date();
			localStorage._version_number = window._version_number;
			if(frappe.boot) { localStorage.metadata_version = frappe.boot.metadata_version; }
		},

		clear_local_storage: function() {
			$.each(["_last_load", "_version_number", "metadata_version", "page_info",
				"last_visited"], function(i, key) {
				localStorage.removeItem(key);
			});

			// clear assets
			for(var key in localStorage) {
				if(key.indexOf("desk_assets:")===0 || key.indexOf("_page:")===0
					|| key.indexOf("_doctype:")===0 || key.indexOf("preferred_breadcrumbs:")===0) {
					localStorage.removeItem(key);
				}
			}
			console.log("localStorage cleared");
		},


		// keep track of executed assets
		executed_ : [],

		// pass on to the handler to set
		execute: function(items, callback) {
			var to_fetch = [];
			for(var i=0, l=items.length; i<l; i++) {
				if(!frappe.assets.exists(items[i])) {
					to_fetch.push(items[i]);
				}
			}
			if(to_fetch.length) {
				frappe.assets.fetch(to_fetch, function() {
					frappe.assets.eval_assets(items, callback);
				});
			} else {
				frappe.assets.eval_assets(items, callback);
			}
		},

		eval_assets: function(items, callback) {
			for(var i=0, l=items.length; i<l; i++) {
				// execute js/css if not already.
				var path = items[i];
				if(frappe.assets.executed_.indexOf(path)===-1) {
					// execute
					frappe.assets.handler[frappe.assets.extn(path)](frappe.assets.get(path), path);
					frappe.assets.executed_.push(path);
				}
			}
			callback && callback();
		},

		// check if the asset exists in
		// localstorage
		exists: function(src) {
			if(frappe.assets.executed_.indexOf(src)!== -1) {
				return true;
			}
			if(frappe.boot.developer_mode) {
				return false;
			}
			if(frappe.assets.get(src)) {
				return true;
			} else {
				return false;
			}
		},

		// load an asset via
		fetch: function(items, callback) {
			// this is virtual page load, only get the the source
			// *without* the template

			frappe.call({
				type: "GET",
				method:"frappe.client.get_js",
				args: {
					"items": items
				},
				callback: function(r) {
					$.each(items, function(i, src) {
						frappe.assets.add(src, r.message[i]);
					});
					callback();
				},
				freeze: true,
			});
		},

		add: function(src, txt) {
			if('localStorage' in window) {
				try {
					frappe.assets.set(src, txt);
				} catch(e) {
					// if quota is exceeded, clear local storage and set item
					frappe.assets.clear_local_storage();
					frappe.assets.set(src, txt);
				}
			}
		},

		get: function(src) {
			return localStorage.getItem("desk_assets:" + src);
		},

		set: function(src, txt) {
			localStorage.setItem("desk_assets:" + src, txt);
		},

		extn: function(src) {
			if(src.indexOf('?')!=-1) {
				src = src.split('?').slice(-1)[0];
			}
			return src.split('.').slice(-1)[0];
		},

		handler: {
			js: function(txt, src) {
				frappe.dom.eval(txt);
			},
			css: function(txt, src) {
				frappe.dom.set_style(txt);
			}
		},

		include_style: function include_style(file, base_url, is_rtl) {
			if ( is_rtl === void 0 ) is_rtl=null;

			var path = base_url + "/assets/css/" + file;
			if (is_rtl) {
				path = base_url + "/assets/css-rtl/" + file;
			}
			return ("<link href=\"" + path + "\" rel=\"stylesheet\">");
		}
	};

	function format (str, args) {
		if(str==undefined) { return str; }

		this.unkeyed_index = 0;
		return str.replace(/\{(\w*)\}/g, function(match, key) {

			if (key === '') {
				key = this.unkeyed_index;
				this.unkeyed_index++;
			}
			if (key == +key) {
				return args[key] !== undefined
					? args[key]
					: match;
			}
		}.bind(this));
	}

	if (jQuery) {
		jQuery.format = format;
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// for license information please see license.txt

	frappe.provide("frappe.form.formatters");

	frappe.form.link_formatters = {};

	frappe.form.formatters = {
		_right: function(value, options) {
			if(options && (options.inline || options.only_value)) {
				return value;
			} else {
				return "<div style='text-align: right'>" + value + "</div>";
			}
		},
		Data: function(value, df) {
			if (df && df.options == "URL") {
				return ("<a href=\"" + value + "\" title=\"Open Link\" target=\"_blank\">" + value + "</a>");
			}
			return value==null ? "" : value;
		},
		Select: function(value) {
			return __(frappe.form.formatters["Data"](value));
		},
		Float: function(value, docfield, options, doc) {
			// don't allow 0 precision for Floats, hence or'ing with null
			var precision = docfield.precision
				|| cint(frappe.boot.sysdefaults && frappe.boot.sysdefaults.float_precision)
				|| null;
			if (docfield.options && docfield.options.trim()) {
				// options points to a currency field, but expects precision of float!
				docfield.precision = precision;
				return frappe.form.formatters.Currency(value, docfield, options, doc);

			} else {
				// show 1.000000 as 1
				if (!(options || {}).always_show_decimals && !is_null(value)) {
					var temp = cstr(value).split(".");
					if (temp[1]==undefined || cint(temp[1])===0) {
						precision = 0;
					}
				}

				return frappe.form.formatters._right(
					((value==null || value==="")
						? ""
						: format_number(value, null, precision)), options);
			}
		},
		Int: function(value, docfield, options) {
			return frappe.form.formatters._right(value==null ? "" : cint(value), options)
		},
		Percent: function(value, docfield, options) {
			var precision = (
				docfield.precision
				|| cint(
					frappe.boot.sysdefaults
					&& frappe.boot.sysdefaults.float_precision
				)
				|| 2
			);
			return frappe.form.formatters._right(flt(value, precision) + "%", options);
		},
		Rating: function(value) {
			var rating_html =	"" + ([1, 2, 3, 4, 5].map(function (i) { return ("<svg class=\"icon icon-md " + (i <= (value || 0) ? "star-click": "") + "\" data-idx=\"" + i + "\">\n\t\t\t\t<use href=\"#icon-star\"></use>\n\t\t\t</svg>"); }
			).join(''));
			return ("<div class=\"rating\">\n\t\t\t" + rating_html + "\n\t\t</div>");
		},
		Currency: function (value, docfield, options, doc) {
			var currency  = frappe.meta.get_field_currency(docfield, doc);
			var precision = docfield.precision || cint(frappe.boot.sysdefaults.currency_precision) || 2;

			// If you change anything below, it's going to hurt a company in UAE, a bit.
			if (precision > 2) {
				var parts	 = cstr(value).split("."); // should be minimum 2, comes from the DB
				var decimals = parts.length > 1 ? parts[1] : ""; // parts.length == 2 ???

				if ( decimals.length < 3 || decimals.length < precision ) {
					var fraction = frappe.model.get_value(":Currency", currency, "fraction_units") || 100; // if not set, minimum 2.

					if (decimals.length < cstr(fraction).length) {
						precision = cstr(fraction).length - 1;
					}
				}
			}

			value = (value == null || value === "") ? "" : format_currency(value, currency, precision);

			if ( options && options.only_value ) {
				return value;
			} else {
				return frappe.form.formatters._right(value, options);
			}
		},
		Check: function(value) {
			return ("<input type=\"checkbox\" disabled\n\t\t\tclass=\"disabled-" + (value ? "selected" : "deselected") + "\">");
		},
		Link: function(value, docfield, options, doc) {
			var doctype = docfield._options || docfield.options;
			var original_value = value;
			if(value && value.match && value.match(/^['"].*['"]$/)) {
				value.replace(/^.(.*).$/, "$1");
			}

			if(options && (options.for_print || options.only_value)) {
				return value;
			}

			if(frappe.form.link_formatters[doctype]) {
				// don't apply formatters in case of composite (parent field of same type)
				if (doc && doctype !== doc.doctype) {
					value = frappe.form.link_formatters[doctype](value, doc, docfield);
				}
			}

			if(!value) {
				return "";
			}
			if(value[0] == "'" && value[value.length -1] == "'") {
				return value.substring(1, value.length - 1);
			}
			if(docfield && docfield.link_onclick) {
				return repl('<a onclick="%(onclick)s">%(value)s</a>',
					{onclick: docfield.link_onclick.replace(/"/g, '&quot;'), value:value});
			} else if(docfield && doctype) {
				if (frappe.model.can_read(doctype)) {
					return ("<a\n\t\t\t\t\thref=\"/app/" + (encodeURIComponent(frappe.router.slug(doctype))) + "/" + (encodeURIComponent(original_value)) + "\"\n\t\t\t\t\tdata-doctype=\"" + doctype + "\"\n\t\t\t\t\tdata-name=\"" + original_value + "\">\n\t\t\t\t\t" + (__(options && options.label || value)) + "</a>");
				} else {
					return value;
				}
			} else {
				return value;
			}
		},
		Date: function(value) {
			if (!frappe.datetime.str_to_user) {
				return value;
			}
			if (value) {
				value = frappe.datetime.str_to_user(value);
				// handle invalid date
				if (value==="Invalid date") {
					value = null;
				}
			}

			return value || "";
		},
		DateRange: function(value) {
			if (Array.isArray(value)) {
				return __("{0} to {1}", [frappe.datetime.str_to_user(value[0]), frappe.datetime.str_to_user(value[1])]);
			} else {
				return value || "";
			}
		},
		Datetime: function(value) {
			if(value) {
				var m = moment(frappe.datetime.convert_to_user_tz(value));
				if(frappe.boot.sysdefaults.time_zone) {
					m = m.tz(frappe.boot.sysdefaults.time_zone);
				}
				return m.format(frappe.boot.sysdefaults.date_format.toUpperCase()
					+  ' ' + frappe.boot.sysdefaults.time_format);
			} else {
				return "";
			}
		},
		Text: function(value) {
			if(value) {
				var tags = ["<p", "<div", "<br", "<table"];
				var match = false;

				for(var i=0; i<tags.length; i++) {
					if(value.match(tags[i])) {
						match = true;
						break;
					}
				}

				if(!match) {
					value = frappe.utils.replace_newlines(value);
				}
			}

			return frappe.form.formatters.Data(value);
		},
		Time: function(value) {
			if (value) {
				value = frappe.datetime.str_to_user(value, true);
			}

			return value || "";
		},
		Duration: function(value, docfield) {
			if (value) {
				var duration_options = frappe.utils.get_duration_options(docfield);
				value = frappe.utils.get_formatted_duration(value, duration_options);
			}

			return value || "";
		},
		LikedBy: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= frappe.avatar(v); }
			});
			return html;
		},
		Tag: function(value) {
			var html = "";
			$.each((value || "").split(","), function(i, v) {
				if (v) { html += "\n\t\t\t\t<span\n\t\t\t\t\tclass=\"data-pill btn-xs align-center ellipsis\"\n\t\t\t\t\tstyle=\"background-color: var(--control-bg); box-shadow: none; margin-right: 4px;\"\n\t\t\t\t\tdata-field=\"_user_tags\" data-label=\"" + v + "'\">\n\t\t\t\t\t" + v + "\n\t\t\t\t</span>"; }
			});
			return html;
		},
		Comment: function(value) {
			return value;
		},
		Assign: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= '<span class="label label-warning" \
				style="margin-right: 7px;"\
				data-field="_assign">'+v+'</span>'; }
			});
			return html;
		},
		SmallText: function(value) {
			return frappe.form.formatters.Text(value);
		},
		TextEditor: function(value) {
			var formatted_value = frappe.form.formatters.Text(value);
			// to use ql-editor styles
			try {
				if (!$(formatted_value).find('.ql-editor').length) {
					formatted_value = "<div class=\"ql-editor read-mode\">" + formatted_value + "</div>";
				}
			} catch(e) {
				formatted_value = "<div class=\"ql-editor read-mode\">" + formatted_value + "</div>";
			}

			return formatted_value;
		},
		Code: function(value) {
			return "<pre>" + (value==null ? "" : $("<div>").text(value).html()) + "</pre>"
		},
		WorkflowState: function(value) {
			var workflow_state = frappe.get_doc("Workflow State", value);
			if(workflow_state) {
				return repl("<span class='label label-%(style)s' \
				data-workflow-state='%(value)s'\
				style='padding-bottom: 4px; cursor: pointer;'>\
				<i class='fa fa-small fa-white fa-%(icon)s'></i> %(value)s</span>", {
						value: value,
						style: workflow_state.style.toLowerCase(),
						icon: workflow_state.icon
					});
			} else {
				return "<span class='label'>" + value + "</span>";
			}
		},
		Email: function(value) {
			return $("<div></div>").text(value).html();
		},
		FileSize: function(value) {
			if(value > 1048576) {
				value = flt(flt(value) / 1048576, 1) + "M";
			} else if (value > 1024) {
				value = flt(flt(value) / 1024, 1) + "K";
			}
			return value;
		},
		TableMultiSelect: function(rows, df, options) {
			rows = rows || [];
			var meta = frappe.get_meta(df.options);
			var link_field = meta.fields.find(function (df) { return df.fieldtype === 'Link'; });
			var formatted_values = rows.map(function (row) {
				var value = row[link_field.fieldname];
				return frappe.format(value, link_field, options, row);
			});
			return formatted_values.join(', ');
		},
		Color: function (value) {
			return value ? ("<div>\n\t\t\t<div class=\"selected-color\" style=\"background-color: " + value + "\"></div>\n\t\t\t<span class=\"color-value\">" + value + "</span>\n\t\t</div>") : '';
		}
	};

	frappe.form.get_formatter = function(fieldtype) {
		if(!fieldtype)
			{ fieldtype = "Data"; }
		return frappe.form.formatters[fieldtype.replace(/ /g, "")] || frappe.form.formatters.Data;
	};

	frappe.format = function(value, df, options, doc) {
		if(!df) { df = {"fieldtype":"Data"}; }
		if (df.fieldname == '_user_tags') { df.fieldtype = 'Tag'; }
		var fieldtype = df.fieldtype || "Data";

		// format Dynamic Link as a Link
		if(fieldtype==="Dynamic Link") {
			fieldtype = "Link";
			df._options = doc ? doc[df.options] : null;
		}

		var formatter = df.formatter || frappe.form.get_formatter(fieldtype);

		var formatted = formatter(value, df, options, doc);

		if (typeof formatted == "string")
			{ formatted = frappe.dom.remove_script_and_style(formatted); }

		return formatted;
	};

	frappe.get_format_helper = function(doc) {
		var helper = {
			get_formatted: function(fieldname) {
				var df = frappe.meta.get_docfield(doc.doctype, fieldname);
				if(!df) { console.log("fieldname not found: " + fieldname); }
				return frappe.format(doc[fieldname], df, {inline:1}, doc);
			}
		};
		$.extend(helper, doc);
		return helper;
	};

	frappe.form.link_formatters['User'] = function(value, doc, docfield) {
		var full_name = doc && (doc.full_name || (docfield && doc[((docfield.fieldname) + "_full_name")]));
		return full_name || value;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// add a new dom element
	frappe.provide('frappe.dom');

	frappe.dom = {
		id_count: 0,
		freeze_count: 0,
		by_id: function(id) {
			return document.getElementById(id);
		},
		get_unique_id: function() {
			var id = 'unique-' + frappe.dom.id_count;
			frappe.dom.id_count++;
			return id;
		},
		set_unique_id: function(ele) {
			var $ele = $(ele);
			if($ele.attr('id')) {
				return $ele.attr('id');
			}
			var id = 'unique-' + frappe.dom.id_count;
			$ele.attr('id', id);
			frappe.dom.id_count++;
			return id;
		},
		eval: function(txt) {
			if(!txt) { return; }
			var el = document.createElement('script');
			el.appendChild(document.createTextNode(txt));
			// execute the script globally
			document.getElementsByTagName('head')[0].appendChild(el);
		},
		remove_script_and_style: function(txt) {
			var evil_tags = ["script", "style", "noscript", "title", "meta", "base", "head"];
			var regex = new RegExp(evil_tags.map(function (tag) { return ("<" + tag + ">.*<\\/" + tag + ">"); }).join('|'), 's');
			if (!regex.test(txt)) {
				// no evil tags found, skip the DOM method entirely!
				return txt;
			}

			var div = document.createElement('div');
			div.innerHTML = txt;
			var found = false;
			evil_tags.forEach(function(e) {
				var elements = div.getElementsByTagName(e);
				i = elements.length;
				while (i--) {
					found = true;
					elements[i].parentNode.removeChild(elements[i]);
				}
			});

			// remove links with rel="stylesheet"
			var elements = div.getElementsByTagName('link');
			var i = elements.length;
			while (i--) {
				if (elements[i].getAttribute("rel")=="stylesheet"){
					found = true;
					elements[i].parentNode.removeChild(elements[i]);
				}
			}
			if(found) {
				return div.innerHTML;
			} else {
				// don't disturb
				return txt;
			}
		},
		is_element_in_viewport: function (el, tolerance) {
			if ( tolerance === void 0 ) tolerance=0;


			//special bonus for those using jQuery
			if (typeof jQuery === "function" && el instanceof jQuery) {
				el = el[0];
			}

			var rect = el.getBoundingClientRect();

			return (
				rect.top + tolerance >= 0
				&& rect.left + tolerance >= 0
				&& rect.bottom - tolerance <= $(window).height()
				&& rect.right - tolerance <= $(window).width()
			);
		},

		is_element_in_modal: function is_element_in_modal(element) {
			return Boolean($(element).parents('.modal').length);
		},

		set_style: function(txt, id) {
			if(!txt) { return; }

			var se = document.createElement('style');
			se.type = "text/css";

			if (id) {
				var element = document.getElementById(id);
				if (element) {
					element.parentNode.removeChild(element);
				}
				se.id = id;
			}

			if (se.styleSheet) {
				se.styleSheet.cssText = txt;
			} else {
				se.appendChild(document.createTextNode(txt));
			}
			document.getElementsByTagName('head')[0].appendChild(se);
			return se;
		},
		add: function(parent, newtag, className, cs, innerHTML, onclick) {
			if(parent && parent.substr){ parent = frappe.dom.by_id(parent); }
			var c = document.createElement(newtag);
			if(parent)
				{ parent.appendChild(c); }

			// if image, 3rd parameter is source
			if(className) {
				if(newtag.toLowerCase()=='img')
					{ c.src = className; }
				else
					{ c.className = className; }
			}
			if(cs) { frappe.dom.css(c,cs); }
			if(innerHTML) { c.innerHTML = innerHTML; }
			if(onclick) { c.onclick = onclick; }
			return c;
		},
		css: function(ele, s) {
			if(ele && s) {
				$.extend(ele.style, s);
			}
			return ele;
		},
		activate: function($parent, $child, common_class, active_class) {
			if ( active_class === void 0 ) active_class='active';

			$parent.find(("." + common_class + "." + active_class))
				.removeClass(active_class);
			$child.addClass(active_class);
		},
		freeze: function(msg, css_class) {
			// blur
			if (!$('#freeze').length) {
				var freeze = $('<div id="freeze" class="modal-backdrop fade"></div>')
					.on("click", function() {
						if (cur_frm && cur_frm.cur_grid) {
							cur_frm.cur_grid.toggle_view();
							return false;
						}
					})
					.appendTo("#body");

				freeze.html(repl('<div class="freeze-message-container"><div class="freeze-message"><p class="lead">%(msg)s</p></div></div>',
					{msg: msg || ""}));

				setTimeout(function() { freeze.addClass("in"); }, 1);

			} else {
				$("#freeze").addClass("in");
			}

			if (css_class) {
				$("#freeze").addClass(css_class);
			}

			frappe.dom.freeze_count++;
		},
		unfreeze: function() {
			if(!frappe.dom.freeze_count) { return; } // anything open?
			frappe.dom.freeze_count--;
			if(!frappe.dom.freeze_count) {
				var freeze = $('#freeze').removeClass("in").remove();
			}
		},
		save_selection: function() {
			// via http://stackoverflow.com/questions/5605401/insert-link-in-contenteditable-element
			if (window.getSelection) {
				var sel = window.getSelection();
				if (sel.getRangeAt && sel.rangeCount) {
					var ranges = [];
					for (var i = 0, len = sel.rangeCount; i < len; ++i) {
						ranges.push(sel.getRangeAt(i));
					}
					return ranges;
				}
			} else if (document.selection && document.selection.createRange) {
				return document.selection.createRange();
			}
			return null;
		},
		restore_selection: function(savedSel) {
			if (savedSel) {
				if (window.getSelection) {
					var sel = window.getSelection();
					sel.removeAllRanges();
					for (var i = 0, len = savedSel.length; i < len; ++i) {
						sel.addRange(savedSel[i]);
					}
				} else if (document.selection && savedSel.select) {
					savedSel.select();
				}
			}
		},
		is_touchscreen: function() {
			return ('ontouchstart' in window)
		},
		handle_broken_images: function handle_broken_images(container) {
			$(container).find('img').on('error', function (e) {
				var $img = $(e.currentTarget);
				$img.addClass('no-image');
			});
		},
		scroll_to_bottom: function scroll_to_bottom(container) {
			var $container = $(container);
			$container.scrollTop($container[0].scrollHeight);
		},
		file_to_base64: function file_to_base64(file_obj) {
			return new Promise(function (resolve) {
				var reader = new FileReader();
				reader.onload = function() {
					resolve(reader.result);
				};
				reader.readAsDataURL(file_obj);
			});
		},
		scroll_to_section: function scroll_to_section(section_name) {
			setTimeout(function () {
				var section = $(("a:contains(\"" + section_name + "\")"));
				if (section.length) {
					if(section.parent().hasClass('collapsed')) {
						// opens the section
						section.click();
					}
					frappe.ui.scroll(section.parent().parent());
				}
			}, 200);
		},
		pixel_to_inches: function pixel_to_inches(pixels) {
			var div = $('<div id="dpi" style="height: 1in; width: 1in; left: 100%; position: fixed; top: 100%;"></div>');
			div.appendTo(document.body);

			var dpi_x = document.getElementById('dpi').offsetWidth;
			var inches = pixels / dpi_x;
			div.remove();

			return inches;
		}
	};

	frappe.ellipsis = function(text, max) {
		if(!max) { max = 20; }
		text = cstr(text);
		if(text.length > max) {
			text = text.substr(0, max) + '...';
		}
		return text;
	};

	frappe.run_serially = function(tasks) {
		var result = Promise.resolve();
		tasks.forEach(function (task) {
			if(task) {
				result = result.then ? result.then(task) : Promise.resolve();
			}
		});
		return result;
	};

	frappe.load_image = function (src, onload, onerror, preprocess) {
		if ( preprocess === void 0 ) preprocess = function () {};

		var tester = new Image();
		tester.onload = function() {
			onload(this);
		};
		tester.onerror = onerror;

		preprocess(tester);
		tester.src = src;
	};

	frappe.timeout = function (seconds) {
		return new Promise(function (resolve) {
			setTimeout(function () { return resolve(); }, seconds * 1000);
		});
	};

	frappe.scrub = function(text, spacer) {
		if ( spacer === void 0 ) spacer='_';

		return text.replace(/ /g, spacer).toLowerCase();
	};

	frappe.unscrub = function(txt) {
		return frappe.model.unscrub(txt);
	};

	frappe.get_data_pill = function (label, target_id, remove_action, image) {
		if ( target_id === void 0 ) target_id=null;
		if ( remove_action === void 0 ) remove_action=null;
		if ( image === void 0 ) image=null;

		var data_pill_wrapper = $(("\n\t\t<button class=\"data-pill btn\">\n\t\t\t<div class=\"flex align-center ellipsis\">\n\t\t\t\t" + (image ? image : '') + "\n\t\t\t\t<span class=\"pill-label " + (image ? "ml-2" : "") + "\">" + label + "</span>\n\t\t\t</div>\n\t\t</button>\n\t"));

		if (remove_action) {
			var remove_btn = $(("\n\t\t\t<span class=\"remove-btn cursor-pointer\">\n\t\t\t\t" + (frappe.utils.icon('close', 'sm')) + "\n\t\t\t</span>\n\t\t")).click(function () {
				remove_action(target_id || label, data_pill_wrapper);
			});
			data_pill_wrapper.append(remove_btn);
		}

		return data_pill_wrapper;
	};

	frappe.get_modal = function(title, content) {
		return $(("<div class=\"modal fade\" style=\"overflow: auto;\" tabindex=\"-1\">\n\t\t<div class=\"modal-dialog\">\n\t\t\t<div class=\"modal-content\">\n\t\t\t\t<div class=\"modal-header\">\n\t\t\t\t\t<div class=\"fill-width flex title-section\">\n\t\t\t\t\t\t<span class=\"indicator hidden\"></span>\n\t\t\t\t\t\t<h4 class=\"modal-title\">" + title + "</h4>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"modal-actions\">\n\t\t\t\t\t\t<button class=\"btn btn-modal-minimize btn-link hide\">\n\t\t\t\t\t\t\t" + (frappe.utils.icon('collapse')) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button class=\"btn btn-modal-close btn-link\" data-dismiss=\"modal\">\n\t\t\t\t\t\t\t" + (frappe.utils.icon('close-alt', 'sm', 'close-alt')) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal-body ui-front\">" + content + "</div>\n\t\t\t\t<div class=\"modal-footer hide\">\n\t\t\t\t\t<div class=\"custom-actions\"></div>\n\t\t\t\t\t<div class=\"standard-actions\">\n\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-secondary btn-sm hide btn-modal-secondary\">\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-primary btn-sm hide btn-modal-primary\">\n\t\t\t\t\t\t\t" + (__("Confirm")) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>"));
	};

	frappe.is_online = function() {
		if (frappe.boot.developer_mode == 1) {
			// always online in developer_mode
			return true;
		}
		if ('onLine' in navigator) {
			return navigator.onLine;
		}
		return true;
	};

	// bind online/offline events
	$(window).on('online', function() {
		frappe.show_alert({
			indicator: 'green',
			message: __('You are connected to internet.')
		});
	});

	$(window).on('offline', function() {
		frappe.show_alert({
			indicator: 'orange',
			message: __('Connection lost. Some features might not work.')
		});
	});

	frappe.ui.form.Layout = Class.extend({
		init: function (opts) {
			this.views = {};
			this.pages = [];
			this.sections = [];
			this.fields_list = [];
			this.fields_dict = {};

			$.extend(this, opts);
		},
		make: function() {
			if (!this.parent && this.body) {
				this.parent = this.body;
			}
			this.wrapper = $('<div class="form-layout">').appendTo(this.parent);
			this.message = $('<div class="form-message hidden"></div>').appendTo(this.wrapper);
			if (!this.fields) {
				this.fields = this.get_doctype_fields();
			}
			this.setup_tabbing();
			this.render();
		},
		show_empty_form_message: function() {
			if (!(this.wrapper.find(".frappe-control:visible").length || this.wrapper.find(".section-head.collapsed").length)) {
				this.show_message(__("This form does not have any input"));
			}
		},

		get_doctype_fields: function() {
			var fields = [
				this.get_new_name_field()
			];
			if (this.doctype_layout) {
				fields = fields.concat(this.get_fields_from_layout());
			} else {
				fields = fields.concat(frappe.meta.sort_docfields(frappe.meta.docfield_map[this.doctype]));
			}

			return fields;
		},

		get_new_name_field: function get_new_name_field() {
			return {
				parent: this.frm.doctype,
				fieldtype: 'Data',
				fieldname: '__newname',
				reqd: 1,
				hidden: 1,
				label: __('Name'),
				get_status: function(field) {
					if (field.frm && field.frm.is_new()
						&& field.frm.meta.autoname
						&& ['prompt', 'name'].includes(field.frm.meta.autoname.toLowerCase())) {
						return 'Write';
					}
					return 'None';
				}
			};
		},

		get_fields_from_layout: function get_fields_from_layout() {
			var fields = [];
			for (var i = 0, list = this.doctype_layout.fields; i < list.length; i += 1) {
				var f = list[i];

				var docfield = copy_dict(frappe.meta.docfield_map[this.doctype][f.fieldname]);
				docfield.label = f.label;
				fields.push(docfield);
			}
			return fields;
		},

		show_message: function(html, color) {
			if (this.message_color) {
				// remove previous color
				this.message.removeClass(this.message_color);
			}
			this.message_color = (color && ['yellow', 'blue'].includes(color)) ? color : 'blue';
			if (html) {
				if (html.substr(0, 1)!=='<') {
					// wrap in a block
					html = '<div>' + html + '</div>';
				}
				this.message.removeClass('hidden').addClass(this.message_color);
				$(html).appendTo(this.message);
			} else {
				this.message.empty().addClass('hidden');
			}
		},
		render: function (new_fields) {
			var me = this;
			var fields = new_fields || this.fields;

			this.section = null;
			this.column = null;

			if (this.with_dashboard) {
				this.setup_dashboard_section();
			}

			if (this.no_opening_section()) {
				this.make_section();
			}
			$.each(fields, function (i, df) {
				switch (df.fieldtype) {
					case "Fold":
						me.make_page(df);
						break;
					case "Section Break":
						me.make_section(df);
						break;
					case "Column Break":
						me.make_column(df);
						break;
					default:
						me.make_field(df);
				}
			});

		},

		no_opening_section: function () {
			return (this.fields[0] && this.fields[0].fieldtype != "Section Break") || !this.fields.length;
		},

		setup_dashboard_section: function () {
			if (this.no_opening_section()) {
				this.fields.unshift({fieldtype: 'Section Break'});
			}
		},

		replace_field: function (fieldname, df, render) {
			df.fieldname = fieldname; // change of fieldname is avoided
			if (this.fields_dict[fieldname] && this.fields_dict[fieldname].df) {
				var fieldobj = this.init_field(df, render);
				this.fields_dict[fieldname].$wrapper.remove();
				this.fields_list.splice(this.fields_dict[fieldname], 1, fieldobj);
				this.fields_dict[fieldname] = fieldobj;
				if (this.frm) {
					fieldobj.perm = this.frm.perm;
				}
				this.section.fields_list.splice(this.section.fields_dict[fieldname], 1, fieldobj);
				this.section.fields_dict[fieldname] = fieldobj;
				this.refresh_fields([df]);
			}
		},

		make_field: function (df, colspan, render) {
			!this.section && this.make_section();
			!this.column && this.make_column();

			var fieldobj = this.init_field(df, render);
			this.fields_list.push(fieldobj);
			this.fields_dict[df.fieldname] = fieldobj;
			if (this.frm) {
				fieldobj.perm = this.frm.perm;
			}

			this.section.fields_list.push(fieldobj);
			this.section.fields_dict[df.fieldname] = fieldobj;
			fieldobj.section = this.section;
		},

		init_field: function (df, render) {
			if ( render === void 0 ) render = false;

			var fieldobj = frappe.ui.form.make_control({
				df: df,
				doctype: this.doctype,
				parent: this.column.wrapper.get(0),
				frm: this.frm,
				render_input: render,
				doc: this.doc,
				layout: this
			});

			fieldobj.layout = this;
			return fieldobj;
		},

		make_page: function (df) { // eslint-disable-line no-unused-vars
			var me = this,
				head = $('<div class="form-clickable-section text-center">\
				<a class="btn-fold h6 text-muted">' + __("Show more details") + '</a>\
			</div>').appendTo(this.wrapper);

			this.page = $('<div class="form-page second-page hide"></div>').appendTo(this.wrapper);

			this.fold_btn = head.find(".btn-fold").on("click", function () {
				var page = $(this).parent().next();
				if (page.hasClass("hide")) {
					$(this).removeClass("btn-fold").html(__("Hide details"));
					page.removeClass("hide");
					frappe.utils.scroll_to($(this), true, 30);
					me.folded = false;
				} else {
					$(this).addClass("btn-fold").html(__("Show more details"));
					page.addClass("hide");
					me.folded = true;
				}
			});

			this.section = null;
			this.folded = true;
		},

		unfold: function () {
			this.fold_btn.trigger('click');
		},

		make_section: function (df) {
			this.section = new frappe.ui.form.Section(this, df);

			// append to layout fields
			if (df) {
				this.fields_dict[df.fieldname] = this.section;
				this.fields_list.push(this.section);
			}

			this.column = null;
		},

		make_column: function (df) {
			this.column = new frappe.ui.form.Column(this.section, df);
			if (df && df.fieldname) {
				this.fields_list.push(this.column);
			}
		},

		refresh: function (doc) {
			var me = this;
			if (doc) { this.doc = doc; }

			if (this.frm) {
				this.wrapper.find(".empty-form-alert").remove();
			}

			// NOTE this might seem redundant at first, but it needs to be executed when frm.refresh_fields is called
			me.attach_doc_and_docfields(true);

			if (this.frm && this.frm.wrapper) {
				$(this.frm.wrapper).trigger("refresh-fields");
			}

			// dependent fields
			this.refresh_dependency();

			// refresh sections
			this.refresh_sections();

			if (this.frm) {
				// collapse sections
				this.refresh_section_collapse();
			}

			if (document.activeElement) {
				if (document.activeElement.tagName == 'INPUT' && this.is_numeric_field_active()) {
					document.activeElement.select();
				}
			}
		},
		
		is_numeric_field_active: function is_numeric_field_active() {
			var control = $(document.activeElement).closest(".frappe-control");
			var fieldtype = (control.data() || {}).fieldtype;
			return frappe.model.numeric_fieldtypes.includes(fieldtype);
		},

		refresh_sections: function() {
			// hide invisible sections
			this.wrapper.find(".form-section:not(.hide-control)").each(function() {
				var section = $(this).removeClass("empty-section visible-section");
				if (section.find(".frappe-control:not(.hide-control)").length) {
					section.addClass("visible-section");
				} else {
					// nothing visible, hide the section
					section.addClass("empty-section");
				}
			});
		},

		refresh_fields: function (fields) {
			var fieldnames = fields.map(function (field) {
				if (field.fieldname) { return field.fieldname; }
			});

			this.fields_list.map(function (fieldobj) {
				if (fieldnames.includes(fieldobj.df.fieldname)) {
					fieldobj.refresh();
					if (fieldobj.df["default"]) {
						fieldobj.set_input(fieldobj.df["default"]);
					}
				}
			});
		},

		add_fields: function (fields) {
			this.render(fields);
			this.refresh_fields(fields);
		},

		refresh_section_collapse: function () {
			if (!(this.sections && this.sections.length)) { return; }

			for (var i = 0; i < this.sections.length; i++) {
				var section = this.sections[i];
				var df = section.df;
				if (df && df.collapsible) {
					var collapse = true;

					if (df.collapsible_depends_on) {
						collapse = !this.evaluate_depends_on_value(df.collapsible_depends_on);
					}

					if (collapse && section.has_missing_mandatory()) {
						collapse = false;
					}

					section.collapse(collapse);
				}
			}
		},

		attach_doc_and_docfields: function (refresh) {
			var me = this;
			for (var i = 0, l = this.fields_list.length; i < l; i++) {
				var fieldobj = this.fields_list[i];
				if (me.doc) {
					fieldobj.doc = me.doc;
					fieldobj.doctype = me.doc.doctype;
					fieldobj.docname = me.doc.name;
					fieldobj.df = frappe.meta.get_docfield(me.doc.doctype,
						fieldobj.df.fieldname, me.doc.name) || fieldobj.df;

					// on form change, permissions can change
					if (me.frm) {
						fieldobj.perm = me.frm.perm;
					}
				}
				refresh && fieldobj.df && fieldobj.refresh && fieldobj.refresh();
			}
		},

		refresh_section_count: function () {
			this.wrapper.find(".section-count-label:visible").each(function (i) {
				$(this).html(i + 1);
			});
		},
		setup_tabbing: function () {
			var me = this;
			this.wrapper.on("keydown", function (ev) {
				if (ev.which == 9) {
					var current = $(ev.target),
						doctype = current.attr("data-doctype"),
						fieldname = current.attr("data-fieldname");
					if (doctype)
						{ return me.handle_tab(doctype, fieldname, ev.shiftKey); }
				}
			});
		},
		handle_tab: function (doctype, fieldname, shift) {
			var me = this,
				grid_row = null,
				prev = null,
				fields = me.fields_list,
				focused = false;

			// in grid
			if (doctype != me.doctype) {
				grid_row = me.get_open_grid_row();
				if (!grid_row || !grid_row.layout) {
					return;
				}
				fields = grid_row.layout.fields_list;
			}

			for (var i = 0, len = fields.length; i < len; i++) {
				if (fields[i].df.fieldname == fieldname) {
					if (shift) {
						if (prev) {
							this.set_focus(prev);
						} else {
							$(this.primary_button).focus();
						}
						break;
					}
					if (i < len - 1) {
						focused = me.focus_on_next_field(i, fields);
					}

					if (focused) {
						break;
					}
				}
				if (this.is_visible(fields[i]))
					{ prev = fields[i]; }
			}

			if (!focused) {
				// last field in this group
				if (grid_row) {
					// in grid
					if (grid_row.doc.idx == grid_row.grid.grid_rows.length) {
						// last row, close it and find next field
						grid_row.toggle_view(false, function () {
							grid_row.grid.frm.layout.handle_tab(grid_row.grid.df.parent, grid_row.grid.df.fieldname);
						});
					} else {
						// next row
						grid_row.grid.grid_rows[grid_row.doc.idx].toggle_view(true);
					}
				} else if (!shift) {
					// End of tab navigation
					$(this.primary_button).focus();
				}
			}

			return false;
		},
		focus_on_next_field: function (start_idx, fields) {
			// loop to find next eligible fields
			for (var i = start_idx + 1, len = fields.length; i < len; i++) {
				var field = fields[i];
				if (this.is_visible(field)) {
					if (field.df.fieldtype === "Table") {
						// open table grid
						if (!(field.grid.grid_rows && field.grid.grid_rows.length)) {
							// empty grid, add a new row
							field.grid.add_new_row();
						}
						// show grid row (if exists)
						field.grid.grid_rows[0].show_form();
						return true;

					} else if (!in_list(frappe.model.no_value_type, field.df.fieldtype)) {
						this.set_focus(field);
						return true;
					}
				}
			}
		},
		is_visible: function (field) {
			return field.disp_status === "Write" && (field.$wrapper && field.$wrapper.is(":visible"));
		},
		set_focus: function (field) {
			// next is table, show the table
			if (field.df.fieldtype=="Table") {
				if (!field.grid.grid_rows.length) {
					field.grid.add_new_row(1);
				} else {
					field.grid.grid_rows[0].toggle_view(true);
				}
			} else if (field.editor) {
				field.editor.set_focus();
			} else if (field.$input) {
				field.$input.focus();
			}
		},
		get_open_grid_row: function () {
			return $(".grid-row-open").data("grid_row");
		},
		refresh_dependency: function () {
			// Resolve "depends_on" and show / hide accordingly
			var me = this;

			// build dependants' dictionary
			var has_dep = false;

			for (var fkey in this.fields_list) {
				var f = this.fields_list[fkey];
				f.dependencies_clear = true;
				if (f.df.depends_on || f.df.mandatory_depends_on || f.df.read_only_depends_on) {
					has_dep = true;
				}
			}

			if (!has_dep) { return; }

			// show / hide based on values
			for (var i = me.fields_list.length - 1; i >= 0; i--) {
				var f = me.fields_list[i];
				f.guardian_has_value = true;
				if (f.df.depends_on) {
					// evaluate guardian

					f.guardian_has_value = this.evaluate_depends_on_value(f.df.depends_on);

					// show / hide
					if (f.guardian_has_value) {
						if (f.df.hidden_due_to_dependency) {
							f.df.hidden_due_to_dependency = false;
							f.refresh();
						}
					} else {
						if (!f.df.hidden_due_to_dependency) {
							f.df.hidden_due_to_dependency = true;
							f.refresh();
						}
					}
				}

				if (f.df.mandatory_depends_on) {
					this.set_dependant_property(f.df.mandatory_depends_on, f.df.fieldname, 'reqd');
				}

				if (f.df.read_only_depends_on) {
					this.set_dependant_property(f.df.read_only_depends_on, f.df.fieldname, 'read_only');
				}
			}

			this.refresh_section_count();
		},
		set_dependant_property: function (condition, fieldname, property) {
			var set_property = this.evaluate_depends_on_value(condition);
			var value = set_property ? 1 : 0;
			var form_obj;

			if (this.frm) {
				form_obj = this.frm;
			} else if (this.is_dialog || this.doctype === 'Web Form') {
				form_obj = this;
			}
			if (form_obj) {
				if (this.doc && this.doc.parent && this.doc.parentfield) {
					form_obj.setting_dependency = true;
					form_obj.set_df_property(this.doc.parentfield, property, value, this.doc.parent, fieldname, this.doc.name);
					form_obj.setting_dependency = false;
					// refresh child fields
					this.fields_dict[fieldname] && this.fields_dict[fieldname].refresh();
				} else {
					form_obj.set_df_property(fieldname, property, value);
				}
			}
		},
		evaluate_depends_on_value: function (expression) {
			var out = null;
			var doc = this.doc;

			if (!doc && this.get_values) {
				var doc = this.get_values(true);
			}

			if (!doc) {
				return;
			}

			var parent = this.frm ? this.frm.doc : this.doc || null;

			if (typeof (expression) === 'boolean') {
				out = expression;

			} else if (typeof (expression) === 'function') {
				out = expression(doc);

			} else if (expression.substr(0, 5)=='eval:') {
				try {
					out = frappe.utils.eval(expression.substr(5), { doc: doc, parent: parent });
					if (parent && parent.istable && expression.includes('is_submittable')) {
						out = true;
					}
				} catch (e) {
					frappe.throw(__('Invalid "depends_on" expression'));
				}

			} else if (expression.substr(0, 3)=='fn:' && this.frm) {
				out = this.frm.script_manager.trigger(expression.substr(3), this.doctype, this.docname);
			} else {
				var value = doc[expression];
				if ($.isArray(value)) {
					out = !!value.length;
				} else {
					out = !!value;
				}
			}

			return out;
		}
	});

	frappe.ui.form.Section = Class.extend({
		init: function(layout, df) {
			this.layout = layout;
			this.df = df || {};
			this.fields_list = [];
			this.fields_dict = {};

			this.make();
			// if (this.frm)
			// 	this.section.body.css({"padding":"0px 3%"})
			this.row = {
				wrapper: this.wrapper
			};

			this.refresh();
		},
		make: function() {
			if (!this.layout.page) {
				this.layout.page = $('<div class="form-page"></div>').appendTo(this.layout.wrapper);
			}
			var make_card = this.layout.card_layout;
			this.wrapper = $(("<div class=\"row form-section " + (make_card ? "card-section" : "") + "\">"))
				.appendTo(this.layout.page);
			this.layout.sections.push(this);

			if (this.df) {
				if (this.df.label) {
					this.make_head();
				}
				if (this.df.description) {
					$('<div class="col-sm-12 small text-muted form-section-description">' + __(this.df.description) + '</div>')
						.appendTo(this.wrapper);
				}
				if (this.df.cssClass) {
					this.wrapper.addClass(this.df.cssClass);
				}
				if (this.df.hide_border) {
					this.wrapper.toggleClass("hide-border", true);
				}
			}

			// for bc
			this.body = $('<div class="section-body">').appendTo(this.wrapper);
		},

		make_head: function () {
			var this$1 = this;

			this.head = $(("<div class=\"section-head\">\n\t\t\t" + (__(this.df.label)) + "\n\t\t\t<span class=\"ml-2 collapse-indicator mb-1\">\n\t\t\t</span>\n\t\t</div>"));
			this.head.appendTo(this.wrapper);
			this.indicator = this.head.find('.collapse-indicator');
			this.indicator.hide();
			if (this.df.collapsible) {
				// show / hide based on status
				this.collapse_link = this.head.on("click", function () {
					this$1.collapse();
				});

				this.indicator.show();
			}
		},
		refresh: function() {
			if (!this.df)
				{ return; }

			// hide if explictly hidden
			var hide = this.df.hidden || this.df.hidden_due_to_dependency;

			// hide if no perm
			if (!hide && this.layout && this.layout.frm && !this.layout.frm.get_perm(this.df.permlevel || 0, "read")) {
				hide = true;
			}

			this.wrapper.toggleClass("hide-control", !!hide);
		},
		collapse: function (hide) {
			// unknown edge case
			if (!(this.head && this.body)) {
				return;
			}

			if (hide===undefined) {
				hide = !this.body.hasClass("hide");
			}

			this.body.toggleClass("hide", hide);
			this.head.toggleClass("collapsed", hide);

			var indicator_icon = hide ? 'down' : 'up-line';

			this.indicator & this.indicator.html(frappe.utils.icon(indicator_icon, 'sm', 'mb-1'));

			// refresh signature fields
			this.fields_list.forEach(function (f) {
				if (f.df.fieldtype == 'Signature') {
					f.refresh();
				}
			});
		},

		is_collapsed: function is_collapsed() {
			return this.body.hasClass('hide');
		},

		has_missing_mandatory: function () {
			var missing_mandatory = false;
			for (var j = 0, l = this.fields_list.length; j < l; j++) {
				var section_df = this.fields_list[j].df;
				if (section_df.reqd && this.layout.doc[section_df.fieldname] == null) {
					missing_mandatory = true;
					break;
				}
			}
			return missing_mandatory;
		}
	});

	frappe.ui.form.Column = Class.extend({
		init: function(section, df) {
			if (!df) { df = {}; }

			this.df = df;
			this.section = section;
			this.make();
			this.resize_all_columns();
		},
		make: function () {
			this.wrapper = $('<div class="form-column">\
			<form>\
			</form>\
		</div>').appendTo(this.section.body)
				.find("form")
				.on("submit", function () {
					return false;
				});

			if (this.df.label) {
				$('<label class="control-label">' + __(this.df.label)
					+ '</label>').appendTo(this.wrapper);
			}
		},
		resize_all_columns: function () {
			// distribute all columns equally
			var colspan = cint(12 / this.section.wrapper.find(".form-column").length);

			this.section.wrapper.find(".form-column").removeClass()
				.addClass("form-column")
				.addClass("col-sm-" + colspan);

		},
		refresh: function () {
			this.section.refresh();
		}
	});

	frappe.provide('frappe.ui');

	frappe.ui.FieldGroup = frappe.ui.form.Layout.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.dirty = false;
			this._super();
			$.each(this.fields || [], function(i, f) {
				if(!f.fieldname && f.label) {
					f.fieldname = f.label.replace(/ /g, "_").toLowerCase();
				}
			});
			if(this.values) {
				this.set_values(this.values);
			}
		},
		make: function() {
			var this$1 = this;

			var me = this;
			if(this.fields) {
				this._super();
				this.refresh();
				// set default
				$.each(this.fields_list, function(i, field) {
					if (field.df["default"]) {
						var def_value = field.df["default"];

						if (def_value == 'Today' && field.df["fieldtype"] == 'Date') {
							def_value = frappe.datetime.get_today();
						}

						field.set_input(def_value);
						// if default and has depends_on, render its fields.
						me.refresh_dependency();
					}
				});

				if(!this.no_submit_on_enter) {
					this.catch_enter_as_submit();
				}

				$(this.wrapper).find('input, select').on(
					'change awesomplete-selectcomplete',
					function () {
						this$1.dirty = true;
						frappe.run_serially([
							function () { return frappe.timeout(0.1); },
							function () { return me.refresh_dependency(); }
						]);
					}
				);

			}
		},
		first_button: false,
		focus_on_first_input: function() {
			if(this.no_focus) { return; }
			$.each(this.fields_list, function(i, f) {
				if(!in_list(['Date', 'Datetime', 'Time', 'Check'], f.df.fieldtype) && f.set_focus) {
					f.set_focus();
					return false;
				}
			});
		},
		catch_enter_as_submit: function() {
			var me = this;
			$(this.body).find('input[type="text"], input[type="password"], select').keypress(function(e) {
				if(e.which==13) {
					if(me.has_primary_action) {
						e.preventDefault();
						me.get_primary_btn().trigger("click");
					}
				}
			});
		},
		get_input: function(fieldname) {
			var field = this.fields_dict[fieldname];
			return $(field.txt ? field.txt : field.input);
		},
		get_field: function(fieldname) {
			return this.fields_dict[fieldname];
		},
		get_values: function(ignore_errors) {
			var ret = {};
			var errors = [];
			for (var key in this.fields_dict) {
				var f = this.fields_dict[key];
				if (f.get_value) {
					var v = f.get_value();
					if (
						f.df.reqd &&
						is_null(typeof v === 'string' ? strip_html(v) : v)
					)
						{ errors.push(__(f.df.label)); }

					if (f.df.reqd
						&& f.df.fieldtype === 'Text Editor'
						&& is_null(strip_html(cstr(v))))
						{ errors.push(__(f.df.label)); }

					if (!is_null(v)) { ret[f.df.fieldname] = v; }
				}
			}
			if (errors.length && !ignore_errors) {
				frappe.msgprint({
					title: __('Missing Values Required'),
					message: __('Following fields have missing values:') +
						'<br><br><ul><li>' + errors.join('<li>') + '</ul>',
					indicator: 'orange'
				});
				return null;
			}
			return ret;
		},
		get_value: function(key) {
			var f = this.fields_dict[key];
			return f && (f.get_value ? f.get_value() : null);
		},
		set_value: function(key, val){
			var this$1 = this;

			return new Promise(function (resolve) {
				var f = this$1.fields_dict[key];
				if(f) {
					f.set_value(val).then(function () {
						f.set_input(val);
						this$1.refresh_dependency();
						resolve();
					});
				} else {
					resolve();
				}
			});
		},
		set_input: function(key, val) {
			return this.set_value(key, val);
		},
		set_values: function(dict) {
			var promises = [];
			for(var key in dict) {
				if(this.fields_dict[key]) {
					promises.push(this.set_value(key, dict[key]));
				}
			}

			return Promise.all(promises);
		},
		clear: function() {
			for(var key in this.fields_dict) {
				var f = this.fields_dict[key];
				if(f && f.set_input) {
					f.set_input(f.df['default'] || '');
				}
			}
		},
		set_df_property: function (fieldname, prop, value) {
			var field    = this.get_field(fieldname);
			field.df[prop] = value;
			field.refresh();
		}
	});

	frappe.provide('frappe.ui');

	window.cur_dialog = null;

	frappe.ui.open_dialogs = [];

	frappe.ui.Dialog = class Dialog extends frappe.ui.FieldGroup {
		constructor(opts) {
			super();
			this.display = false;
			this.is_dialog = true;

			$.extend(this, { animate: true, size: null }, opts);
			this.make();
		}

		make() {
			var this$1 = this;

			this.$wrapper = frappe.get_modal("", "");

			if(this.static) {
				this.$wrapper.modal({
					backdrop: 'static',
					keyboard: false
				});
				this.get_close_btn().hide();
			}

			this.wrapper = this.$wrapper.find('.modal-dialog')
				.get(0);
			if (this.size == "small" )
				{ $(this.wrapper).addClass("modal-sm"); }
			else if (this.size == "large" )
				{ $(this.wrapper).addClass("modal-lg"); }
			else if (this.size == "extra-large" )
				{ $(this.wrapper).addClass("modal-xl"); }

			this.make_head();
			this.modal_body = this.$wrapper.find(".modal-body");
			this.$body = $('<div></div>').appendTo(this.modal_body);
			this.body = this.$body.get(0);
			this.$message = $('<div class="hide modal-message"></div>').appendTo(this.modal_body);
			this.header = this.$wrapper.find(".modal-header");
			this.footer = this.$wrapper.find(".modal-footer");
			this.standard_actions = this.footer.find('.standard-actions');
			this.custom_actions = this.footer.find('.custom-actions');
			this.set_indicator();

			// make fields (if any)
			super.make();

			this.refresh_section_collapse();

			// show footer
			this.action = this.action || { primary: { }, secondary: { } };
			if (this.primary_action || (this.action.primary && this.action.primary.onsubmit)) {
				this.set_primary_action(this.primary_action_label || this.action.primary.label || __("Submit"),
					this.primary_action || this.action.primary.onsubmit);
			}

			if (this.secondary_action) {
				this.set_secondary_action(this.secondary_action);
			}

			if (this.secondary_action_label || (this.action.secondary && this.action.secondary.label)) {
				this.set_secondary_action_label(this.secondary_action_label || this.action.secondary.label);
			}

			if (this.minimizable) {
				this.header.find('.title-section').click(function () { return this$1.is_minimized && this$1.toggle_minimize(); });
				this.get_minimize_btn().removeClass('hide').on('click', function () { return this$1.toggle_minimize(); });
			}

			var me = this;
			this.$wrapper
				.on("hide.bs.modal", function() {
					me.display = false;

					if(frappe.ui.open_dialogs[frappe.ui.open_dialogs.length-1]===me) {
						frappe.ui.open_dialogs.pop();
						if(frappe.ui.open_dialogs.length) {
							window.cur_dialog = frappe.ui.open_dialogs[frappe.ui.open_dialogs.length-1];
						} else {
							window.cur_dialog = null;
						}
					}
					me.onhide && me.onhide();
					me.on_hide && me.on_hide();
				})
				.on("shown.bs.modal", function() {
					// focus on first input
					me.display = true;
					window.cur_dialog = me;
					frappe.ui.open_dialogs.push(me);
					me.focus_on_first_input();
					me.on_page_show && me.on_page_show();
					$(document).trigger('frappe.ui.Dialog:shown');
				})
				.on('scroll', function() {
					var $input = $('input:focus');
					if ($input.length && ['Date', 'Datetime', 'Time'].includes($input.attr('data-fieldtype'))) {
						$input.blur();
					}
				});

		}

		get_primary_btn() {
			return this.standard_actions.find(".btn-primary");
		}

		get_minimize_btn() {
			return this.$wrapper.find(".modal-header .btn-modal-minimize");
		}

		set_message(text) {
			this.$message.removeClass('hide');
			this.$body.addClass('hide');
			this.$message.text(text);
		}

		clear_message() {
			this.$message.addClass('hide');
			this.$body.removeClass('hide');
		}

		clear() {
			super.clear();
			this.clear_message();
		}

		set_primary_action(label, click) {
			this.footer.removeClass('hide');
			this.has_primary_action = true;
			var me = this;
			return this.get_primary_btn()
				.removeClass("hide")
				.html(label)
				.click(function() {
					me.primary_action_fulfilled = true;
					// get values and send it
					// as first parameter to click callback
					// if no values then return
					var values = me.get_values();
					if(!values) { return; }
					click && click.apply(me, [values]);
				});
		}

		set_secondary_action(click) {
			this.footer.removeClass('hide');
			this.get_secondary_btn().removeClass('hide').off('click').on('click', click);
		}

		set_secondary_action_label(label) {
			this.get_secondary_btn()
				.removeClass("hide")
				.html(label);
		}

		disable_primary_action() {
			this.get_primary_btn().addClass('disabled');
		}

		enable_primary_action() {
			this.get_primary_btn().removeClass('disabled');
		}

		make_head() {
			this.set_title(this.title);
		}

		set_title(t) {
			this.$wrapper.find(".modal-title").html(t);
		}

		set_indicator() {
			if (this.indicator) {
				this.header.find('.indicator').removeClass().addClass('indicator ' + this.indicator);
			}
		}

		show() {
			// show it
			if (this.animate) {
				this.$wrapper.addClass('fade');
			} else {
				this.$wrapper.removeClass('fade');
			}
			this.$wrapper.modal("show");

			this.$wrapper.removeClass('modal-minimize');

			// clear any message
			this.clear_message();

			this.primary_action_fulfilled = false;
			this.is_visible = true;
			return this;
		}

		hide() {
			this.$wrapper.modal("hide");
			this.is_visible = false;
		}

		get_close_btn() {
			return this.$wrapper.find(".btn-modal-close");
		}

		get_secondary_btn() {
			return this.standard_actions.find(".btn-modal-secondary");
		}

		no_cancel() {
			this.get_close_btn().toggle(false);
		}

		cancel() {
			this.get_close_btn().trigger("click");
		}

		toggle_minimize() {
			$('.modal-backdrop').toggle();
			var modal = this.$wrapper.closest('.modal').toggleClass('modal-minimize');
			modal.attr('tabindex') ? modal.removeAttr('tabindex') : modal.attr('tabindex', -1);
			this.is_minimized = !this.is_minimized;
			var icon = this.is_minimized ? 'expand' : 'collapse';
			this.get_minimize_btn().html(frappe.utils.icon(icon));
			this.on_minimize_toggle && this.on_minimize_toggle(this.is_minimized);
			this.header.find('.modal-title').toggleClass('cursor-pointer');
		}

		add_custom_action(label, action, css_class) {
			if ( css_class === void 0 ) css_class=null;

			this.footer.removeClass('hide');
			var action_button = $(("\n\t\t\t<button class=\"btn btn-secondary btn-sm " + (css_class || '') + "\">\n\t\t\t\t" + label + "\n\t\t\t</button>\n\t\t"));
			this.custom_actions.append(action_button);

			action && action_button.click(action);
		}
	};

	frappe.ui.hide_open_dialog = function () {
		// hide open dialog
		if (window.cur_dialog) {
			if (!cur_dialog.minimizable) {
				cur_dialog.hide();
			} else if (!cur_dialog.is_minimized) {
				cur_dialog.toggle_minimize();
			}
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.messages");

	frappe.messages.waiting = function(parent, msg) {
		return $(frappe.messages.get_waiting_message(msg))
			.appendTo(parent);
	};

	frappe.messages.get_waiting_message = function(msg) {
		return repl('<div class="msg-box" style="width: 63%; margin: 30px auto;">\
		<p class="text-center">%(msg)s</p></div>', { msg: msg });
	};

	frappe.throw = function(msg) {
		if(typeof msg==='string') {
			msg = {message: msg, title: __('Error')};
		}
		if(!msg.indicator) { msg.indicator = 'red'; }
		frappe.msgprint(msg);
		throw new Error(msg.message);
	};

	frappe.confirm = function(message, confirm_action, reject_action) {
		var d = new frappe.ui.Dialog({
			title: __("Confirm"),
			primary_action_label: __("Yes"),
			primary_action: function () {
				confirm_action && confirm_action();
				d.hide();
			},
			secondary_action_label: __("No"),
			secondary_action: function () { return d.hide(); },
		});

		d.$body.append(("<p class=\"frappe-confirm-message\">" + message + "</p>"));
		d.show();

		// flag, used to bind "okay" on enter
		d.confirm_dialog = true;

		// no if closed without primary action
		if (reject_action) {
			d.onhide = function () {
				if (!d.primary_action_fulfilled) {
					reject_action();
				}
			};
		}

		return d;
	};

	frappe.warn = function(title, message_html, proceed_action, primary_label, is_minimizable) {
		var d = new frappe.ui.Dialog({
			title: title,
			indicator: 'red',
			primary_action_label: primary_label,
			primary_action: function () {
				if (proceed_action) { proceed_action(); }
				d.hide();
			},
			secondary_action_label: __("Cancel"),
			secondary_action: function () { return d.hide(); },
			minimizable: is_minimizable
		});

		d.$body.append(("<div class=\"frappe-confirm-message\">" + message_html + "</div>"));
		d.standard_actions.find('.btn-primary').removeClass('btn-primary').addClass('btn-danger');
		d.standard_actions.find('.btn-primary').removeClass('btn-primary').addClass('btn-danger');

		d.show();
		return d;
	};

	frappe.prompt = function(fields, callback, title, primary_label) {
		if (typeof fields === "string") {
			fields = [{
				label: fields,
				fieldname: "value",
				fieldtype: "Data",
				reqd: 1
			}];
		}
		if(!$.isArray(fields)) { fields = [fields]; }
		var d = new frappe.ui.Dialog({
			fields: fields,
			title: title || __("Enter Value"),
		});
		d.set_primary_action(primary_label || __("Submit"), function() {
			var values = d.get_values();
			if(!values) {
				return;
			}
			d.hide();
			callback(values);
		});
		d.show();
		return d;
	};

	frappe.msgprint = function(msg, title, is_minimizable) {
		if(!msg) { return; }

		if($.isPlainObject(msg)) {
			var data = msg;
		} else {
			// passed as JSON
			if(typeof msg==='string' && msg.substr(0,1)==='{') {
				var data = JSON.parse(msg);
			} else {
				var data = {'message': msg, 'title': title};
			}
		}

		if(!data.indicator) {
			data.indicator = 'blue';
		}

		if (data.as_list) {
			var list_rows = data.message.map(function (m) { return ("<li>" + m + "</li>"); }).join('');
			data.message = "<ul style=\"padding-left: 20px\">" + list_rows + "</ul>";
		}

		if (data.as_table) {
			var rows = data.message.map(function (row) {
				var cols = row.map(function (col) { return ("<td>" + col + "</td>"); }).join('');
				return ("<tr>" + cols + "</tr>");
			}).join('');
			data.message = "<table class=\"table table-bordered\" style=\"margin: 0;\">" + rows + "</table>";
		}

		if(data.message instanceof Array) {
			data.message.forEach(function(m) {
				frappe.msgprint(m);
			});
			return;
		}

		if(data.alert) {
			frappe.show_alert(data);
			return;
		}

		if(!frappe.msg_dialog) {
			frappe.msg_dialog = new frappe.ui.Dialog({
				title: __("Message"),
				onhide: function() {
					if(frappe.msg_dialog.custom_onhide) {
						frappe.msg_dialog.custom_onhide();
					}
					frappe.msg_dialog.msg_area.empty();
				},
				minimizable: data.is_minimizable || is_minimizable
			});

			// class "msgprint" is used in tests
			frappe.msg_dialog.msg_area = $('<div class="msgprint">')
				.appendTo(frappe.msg_dialog.body);

			frappe.msg_dialog.clear = function() {
				frappe.msg_dialog.msg_area.empty();
			};

			frappe.msg_dialog.indicator = frappe.msg_dialog.header.find('.indicator');
		}

		// setup and bind an action to the primary button
		if (data.primary_action) {
			if (data.primary_action.server_action && typeof data.primary_action.server_action === 'string') {
				data.primary_action.action = function () {
					frappe.call({
						method: data.primary_action.server_action,
						args: {
							args: data.primary_action.args
						},
						callback: function callback() {
							if (data.primary_action.hide_on_success) {
								frappe.hide_msgprint();
							}
						}
					});
				};
			}

			if (data.primary_action.client_action && typeof data.primary_action.client_action === 'string') {
				var parts = data.primary_action.client_action.split('.');
				var obj = window;
				for (var i = 0, list = parts; i < list.length; i += 1) {
					var part = list[i];

					obj = obj[part];
				}
				data.primary_action.action = function () {
					if (typeof obj === 'function') {
						obj(data.primary_action.args);
					}
				};
			}

			frappe.msg_dialog.set_primary_action(
				__(data.primary_action.label || data.primary_action_label || "Done"),
				data.primary_action.action
			);
		} else {
			if (frappe.msg_dialog.has_primary_action) {
				frappe.msg_dialog.get_primary_btn().addClass('hide');
				frappe.msg_dialog.has_primary_action = false;
			}
		}

		if (data.secondary_action) {
			frappe.msg_dialog.set_secondary_action(data.secondary_action.action);
			frappe.msg_dialog.set_secondary_action_label(__(data.secondary_action.label || "Close"));
		}

		if(data.message==null) {
			data.message = '';
		}

		if(data.message.search(/<br>|<p>|<li>/)==-1) {
			msg = frappe.utils.replace_newlines(data.message);
		}

		var msg_exists = false;
		if(data.clear) {
			frappe.msg_dialog.msg_area.empty();
		} else {
			msg_exists = frappe.msg_dialog.msg_area.html();
		}

		if(data.title || !msg_exists) {
			// set title only if it is explicitly given
			// and no existing title exists
			frappe.msg_dialog.set_title(data.title || __('Message'));
		}

		// show / hide indicator
		if(data.indicator) {
			frappe.msg_dialog.indicator.removeClass().addClass('indicator ' + data.indicator);
		} else {
			frappe.msg_dialog.indicator.removeClass().addClass('hidden');
		}

		// width
		if (data.wide) {
			// msgprint should be narrower than the usual dialog
			if (frappe.msg_dialog.wrapper.classList.contains('msgprint-dialog')) {
				frappe.msg_dialog.wrapper.classList.remove('msgprint-dialog');
			}
		} else {
			// msgprint should be narrower than the usual dialog
			frappe.msg_dialog.wrapper.classList.add('msgprint-dialog');
		}

		if(msg_exists) {
			frappe.msg_dialog.msg_area.append("<hr>");
		// append a <hr> if another msg already exists
		}

		frappe.msg_dialog.msg_area.append(data.message);

		// make msgprint always appear on top
		frappe.msg_dialog.$wrapper.css("z-index", 2000);
		frappe.msg_dialog.show();

		return frappe.msg_dialog;
	};

	window.msgprint = frappe.msgprint;

	frappe.hide_msgprint = function(instant) {
		// clear msgprint
		if(frappe.msg_dialog && frappe.msg_dialog.msg_area) {
			frappe.msg_dialog.msg_area.empty();
		}
		if(frappe.msg_dialog && frappe.msg_dialog.$wrapper.is(":visible")) {
			if(instant) {
				frappe.msg_dialog.$wrapper.removeClass("fade");
			}
			frappe.msg_dialog.hide();
			if(instant) {
				frappe.msg_dialog.$wrapper.addClass("fade");
			}
		}
	};

	// update html in existing msgprint
	frappe.update_msgprint = function(html) {
		if(!frappe.msg_dialog || (frappe.msg_dialog && !frappe.msg_dialog.$wrapper.is(":visible"))) {
			frappe.msgprint(html);
		} else {
			frappe.msg_dialog.msg_area.html(html);
		}
	};

	frappe.verify_password = function(callback) {
		frappe.prompt({
			fieldname: "password",
			label: __("Enter your password"),
			fieldtype: "Password",
			reqd: 1
		}, function(data) {
			frappe.call({
				method: "frappe.core.doctype.user.user.verify_password",
				args: {
					password: data.password
				},
				callback: function(r) {
					if(!r.exc) {
						callback();
					}
				}
			});
		}, __("Verify Password"), __("Verify"));
	};

	frappe.show_progress = function (title, count, total, description, hide_on_completion) {
		if ( total === void 0 ) total = 100;
		if ( hide_on_completion === void 0 ) hide_on_completion = false;

		var dialog;
		if (
			frappe.cur_progress &&
			frappe.cur_progress.title === title &&
			frappe.cur_progress.is_visible
		) {
			dialog = frappe.cur_progress;
		} else {
			dialog = new frappe.ui.Dialog({
				title: title
			});
			dialog.progress = $("<div>\n\t\t\t<div class=\"progress\">\n\t\t\t\t<div class=\"progress-bar\"></div>\n\t\t\t</div>\n\t\t\t<p class=\"description text-muted small\"></p>\n\t\t</div").appendTo(dialog.body);
			dialog.progress_bar = dialog.progress
				.css({ 'margin-top': '10px' })
				.find('.progress-bar');
			dialog.$wrapper.removeClass('fade');
			dialog.show();
			frappe.cur_progress = dialog;
		}
		if (description) {
			dialog.progress.find('.description').text(description);
		}
		dialog.percent = cint((flt(count) * 100) / total);
		dialog.progress_bar.css({ width: dialog.percent + '%' });
		if (hide_on_completion && dialog.percent === 100) {
			// timeout to avoid abrupt hide
			setTimeout(frappe.hide_progress, 500);
		}
		return dialog;
	};

	frappe.hide_progress = function() {
		if(frappe.cur_progress) {
			frappe.cur_progress.hide();
			frappe.cur_progress = null;
		}
	};

	// Floating Message
	frappe.show_alert = function(message, seconds, actions) {
		if ( seconds === void 0 ) seconds=7;
		if ( actions === void 0 ) actions={};

		var indicator_icon_map = {
			'orange': "solid-warning",
			'yellow': "solid-warning",
			'blue': "solid-success",
			'green': "solid-success",
			'red': "solid-error"
		};

		if (typeof message==='string') {
			message = {
				message: message
			};
		}

		if (!$('#dialog-container').length) {
			$('<div id="dialog-container"><div id="alert-container"></div></div>').appendTo('body');
		}

		var icon;
		if (message.indicator) {
			icon = indicator_icon_map[message.indicator.toLowerCase()] || 'solid-' + message.indicator;
		} else {
			icon = 'solid-info';
		}

		var div = $(("\n\t\t<div class=\"alert desk-alert\">\n\t\t\t<div class=\"alert-message-container\">\n\t\t\t\t<div class=\"alert-title-container\">\n\t\t\t\t\t<div>" + (frappe.utils.icon(icon, 'lg')) + "</div>\n\t\t\t\t\t<div class=\"alert-message\">" + (message.message) + "</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"alert-subtitle\">" + (message.subtitle || '') + "</div>\n\t\t\t</div>\n\t\t\t<div class=\"alert-body\" style=\"display: none\"></div>\n\t\t\t<a class=\"close\">" + (frappe.utils.icon('close-alt')) + "</a>\n\t\t</div>"));

		div.hide().appendTo("#alert-container").show();

		if (message.body) {
			div.find('.alert-body').show().html(message.body);
		}

		div.find('.close, button').click(function() {
			div.addClass('out');
			setTimeout(function () { return div.remove(); }, 800);
			return false;
		});

		Object.keys(actions).map(function (key) {
			div.find(("[data-action=" + key + "]")).on('click', actions[key]);
		});

		if (seconds > 2) {
			// Delay for animation
			seconds = seconds - 0.8;
		}

		setTimeout(function () {
			div.addClass('out');
			setTimeout(function () { return div.remove(); }, 800);
			return false;
		}, seconds * 1000);

		return div;
	};

	// Proxy for frappe.show_alert
	Object.defineProperty(window, 'show_alert', {
		get: function() {
			console.warn('Please use `frappe.show_alert` instead of `show_alert`. It will be deprecated soon.');
			return frappe.show_alert;
		}
	});

	frappe.provide('frappe.ui.keys');

	var shortcut_groups = new WeakMap();
	var shortcut_group_list = [];
	frappe.ui.keys.shortcut_groups = shortcut_groups;

	frappe.ui.keys.get_shortcut_group = function (parent) {
		// parent must be an object
		if (!shortcut_groups.has(parent)) {
			shortcut_groups.set(parent, new frappe.ui.keys.AltShortcutGroup());
		}
		return shortcut_groups.get(parent);
	};

	var listener_added = false;
	var $current_dropdown = null;
	var $body = $(document.body);

	frappe.ui.keys.bind_shortcut_group_event = function () {
		if (listener_added) { return; }
		listener_added = true;

		function highlight_alt_shortcuts() {
			if ($current_dropdown) {
				$current_dropdown.addClass('alt-pressed');
				$body.removeClass('alt-pressed');
			} else {
				$body.addClass('alt-pressed');
				$current_dropdown && $current_dropdown.removeClass('alt-pressed');
			}
		}

		function unhighlight_alt_shortcuts() {
			$current_dropdown && $current_dropdown.removeClass('alt-pressed');
			$body.removeClass('alt-pressed');
		}

		$(document).on('keydown', function (e) {
			var key = (frappe.ui.keys.key_map[e.which] || '').toLowerCase();

			if (key === 'alt') {
				highlight_alt_shortcuts();
			}

			if (e.shiftKey || e.ctrlKey || e.metaKey) {
				return;
			}

			if (key && e.altKey) {
				var shortcut = get_shortcut_for_key(key);
				if (shortcut) {
					e.preventDefault();
					shortcut.$target[0].click();
				}
				highlight_alt_shortcuts();
			}
		});
		$(document).on('keyup', function (e) {
			if (e.key === 'Alt') {
				unhighlight_alt_shortcuts();
			}
		});
		$(document).on('mousemove', function () {
			unhighlight_alt_shortcuts();
		});
	};

	function get_shortcut_for_key(key) {
		// Get the shortcut for combination of alt+key
		// Priority 1: Open dropdown
		// Priority 2: Current Page

		var shortcuts = shortcut_group_list
			.filter(function (shortcut_group) { return key in shortcut_group.shortcuts_dict; })
			.map(function (shortcut_group) { return shortcut_group.shortcuts_dict[key]; })
			.filter(function (shortcut) { return shortcut.$target.is(':visible'); });

		var shortcut = null;

		if ($current_dropdown && $current_dropdown.is('.open')) {
			shortcut = shortcuts.find(
				function (shortcut) { return $.contains($current_dropdown[0], shortcut.$target[0]); }
			);
		}

		if (shortcut) { return shortcut; }

		shortcut = shortcuts.find(
			function (shortcut) { return $.contains(window.cur_page.page.page.wrapper[0], shortcut.$target[0]); }
		);

		return shortcut;
	}

	frappe.ui.keys.AltShortcutGroup = class AltShortcutGroup {
		constructor() {
			this.shortcuts_dict = {};
			$current_dropdown = null;
			this.bind_events();
			frappe.ui.keys.bind_shortcut_group_event();
			shortcut_group_list.push(this);
		}

		bind_events() {
			$(document).on('show.bs.dropdown', function (e) {
				$current_dropdown && $current_dropdown.removeClass('alt-pressed');
				var $target = $(e.target);
				if ($target.is('.dropdown, .btn-group')) {
					$current_dropdown = $target;
				}
			});
			$(document).on('hide.bs.dropdown', function () {
				$current_dropdown && $current_dropdown.removeClass('alt-pressed');
				$current_dropdown = null;
			});
		}

		add($target, $text_el) {
			var this$1 = this;

			if (!$text_el) {
				$text_el = $target;
			}
			var text_content = $text_el.text().trim();
			var letters = text_content.split('');
			// first unused letter
			var shortcut_letter = letters.find(function (letter) {
				letter = letter.toLowerCase();
				var is_valid_char = letter >= 'a' && letter <= 'z';
				return !this$1.is_taken(letter) && is_valid_char;
			});
			if (!shortcut_letter) {
				$text_el.attr('data-label', text_content);
				return;
			}
			for (var key in this.shortcuts_dict) {
				var shortcut$1 = this.shortcuts_dict[key];
				if (shortcut$1.text === text_content) {
					shortcut$1.$target = $target;
					shortcut$1.$text_el = $text_el;
					this.underline_text(shortcut$1);
					return;
				}
			}

			var shortcut = {
				$target: $target,
				$text_el: $text_el,
				letter: shortcut_letter,
				text: text_content
			};
			this.shortcuts_dict[shortcut_letter.toLowerCase()] = shortcut;
			this.underline_text(shortcut);
		}

		underline_text(shortcut) {
			shortcut.$text_el.attr('data-label', shortcut.text);
			var underline_el_found = false;
			var text_html = shortcut.text.split('').map(function (letter) {
				if (letter === shortcut.letter && !underline_el_found) {
					letter = "<span class=\"alt-underline\">" + letter + "</span>";
					underline_el_found = true;
				}
				return letter;
			}).join('');
			var original_text_html = shortcut.$text_el.html();
			text_html = original_text_html.replace(shortcut.text.trim(), text_html.trim());
			shortcut.$text_el.html(text_html);
		}

		is_taken(letter) {
			var is_in_global_shortcut = frappe.ui.keys.standard_shortcuts
				.filter(function (s) { return !s.page; })
				.some(function (s) { return s.shortcut === ("alt+" + letter); });
			return letter in this.shortcuts_dict || is_in_global_shortcut;
		}
	};

	frappe.provide('frappe.ui.keys.handlers');

	frappe.ui.keys.setup = function() {
		$(window).on('keydown', function(e) {
			var key = frappe.ui.keys.get_key(e);
			if(frappe.ui.keys.handlers[key]) {
				var out = null;
				for(var i=0, l = frappe.ui.keys.handlers[key].length; i<l; i++) {
					var handler = frappe.ui.keys.handlers[key][i];
					var _out = handler.apply(this, [e]);
					if(_out===false) {
						out = _out;
					}
				}
				return out;
			}
		});
	};

	var standard_shortcuts = [];
	frappe.ui.keys.standard_shortcuts = standard_shortcuts;
	frappe.ui.keys.add_shortcut = function (ref) {
		if ( ref === void 0 ) ref = {};
		var shortcut = ref.shortcut;
		var action = ref.action;
		var description = ref.description;
		var page = ref.page;
		var target = ref.target;
		var condition = ref.condition;
		var ignore_inputs = ref.ignore_inputs; if ( ignore_inputs === void 0 ) ignore_inputs = false;

		if (target instanceof jQuery) {
			var $target = target;
			action = function () {
				$target[0].click();
			};
		}
		if (!condition) {
			condition = function () { return true; };
		}
		var handler = function (e) {
			var $focused_element = $(document.activeElement);
			var is_input_focused = $focused_element.is('input, select, textarea, [contenteditable=true]');
			if (is_input_focused && !ignore_inputs) { return; }
			if (!condition()) { return; }

			if (!page || page.wrapper.is(':visible')) {
				var prevent_default = action(e);
				// prevent default if true is explicitly returned
				// or nothing returned (undefined)
				if (prevent_default || prevent_default === undefined) {
					e.preventDefault();
				}
			}
		};
		// monkey patch page to handler
		handler.page = page;
		// remove handler with the same page attached to it
		frappe.ui.keys.off(shortcut, page);
		// attach new handler
		frappe.ui.keys.on(shortcut, handler);

		// update standard shortcut list
		var existing_shortcut_index = standard_shortcuts.findIndex(
			function (s) { return s.shortcut === shortcut; }
		);
		var new_shortcut = { shortcut: shortcut, action: action, description: description, page: page, condition: condition };
		if (existing_shortcut_index === -1) {
			standard_shortcuts.push(new_shortcut);
		} else {
			standard_shortcuts[existing_shortcut_index] = new_shortcut;
		}
	};

	frappe.ui.keys.show_keyboard_shortcut_dialog = function () {
		if (frappe.ui.keys.is_dialog_shown) { return; }

		var global_shortcuts = standard_shortcuts.filter(function (shortcut) { return !shortcut.page; });
		var current_page_shortcuts = standard_shortcuts.filter(
			function (shortcut) { return shortcut.page && shortcut.page === window.cur_page.page.page; });

		function generate_shortcuts_html(shortcuts, heading) {
			if (!shortcuts.length) {
				return '';
			}
			var html = shortcuts
				.filter(function (s) { return s.condition ? s.condition() : true; })
				.map(function (shortcut) {
					var shortcut_label = shortcut.shortcut
						.split('+')
						.map(frappe.utils.to_title_case)
						.join('+');
					if (frappe.utils.is_mac()) {
						shortcut_label = shortcut_label.replace('Ctrl', '⌘');
					}
					return ("<tr>\n\t\t\t\t\t<td width=\"40%\"><kbd>" + shortcut_label + "</kbd></td>\n\t\t\t\t\t<td width=\"60%\">" + (shortcut.description || '') + "</td>\n\t\t\t\t</tr>");
				}).join('');
			html = "<h5 style=\"margin: 0;\">" + heading + "</h5>\n\t\t\t<table style=\"margin-top: 10px;\" class=\"table table-bordered\">\n\t\t\t\t" + html + "\n\t\t\t</table>";
			return html;
		}

		var global_shortcuts_html = generate_shortcuts_html(global_shortcuts, __('Global Shortcuts'));
		var current_page_shortcuts_html = generate_shortcuts_html(current_page_shortcuts, __('Page Shortcuts'));

		var dialog = new frappe.ui.Dialog({
			title: __('Keyboard Shortcuts'),
			on_hide: function on_hide() {
				frappe.ui.keys.is_dialog_shown = false;
			}
		});

		dialog.$body.append(global_shortcuts_html);
		dialog.$body.append(current_page_shortcuts_html);
		dialog.$body.append(("\n\t\t<div class=\"text-muted\">\n\t\t\t" + (__('Press Alt Key to trigger additional shortcuts in Menu and Sidebar')) + "\n\t\t</div>\n\t"));

		dialog.show();
		frappe.ui.keys.is_dialog_shown = true;
	};

	frappe.ui.keys.get_key = function(e) {
		var keycode = e.keyCode || e.which;
		var key = frappe.ui.keys.key_map[keycode] || String.fromCharCode(keycode);

		if(e.ctrlKey || e.metaKey) {
			// add ctrl+ the key
			key = 'ctrl+' + key;
		}
		if(e.shiftKey) {
			// add ctrl+ the key
			key = 'shift+' + key;
		}
		if (e.altKey) {
			// add alt+ the key
			key = 'alt+' + key;
		}
		if (e.altKey && e.ctrlKey) {
			// add alt+ctrl+ the key or single key e.g f1,f2,etc..
			return key.toLowerCase();
		}
		return key.toLowerCase();
	};

	frappe.ui.keys.on = function(key, handler) {
		if(!frappe.ui.keys.handlers[key]) {
			frappe.ui.keys.handlers[key] = [];
		}
		frappe.ui.keys.handlers[key].push(handler);
	};

	frappe.ui.keys.off = function(key, page) {
		var handlers = frappe.ui.keys.handlers[key];
		if (!handlers || handlers.length === 0) { return; }
		frappe.ui.keys.handlers[key] = handlers.filter(function (h) {
			if (!page) { return false; }
			return h.page !== page;
		});
	};

	frappe.ui.keys.add_shortcut({
		shortcut: 'ctrl+s',
		action: function(e) {
			frappe.app.trigger_primary_action();
			e.preventDefault();
			return false;
		},
		description: __('Trigger Primary Action'),
		ignore_inputs: true
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'ctrl+g',
		action: function(e) {
			$("#navbar-search").focus();
			e.preventDefault();
			return false;
		},
		description: __('Open Awesomebar')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'ctrl+h',
		action: function(e) {
			e.preventDefault();
			$('.navbar-home img').click();
		},
		description: __('Navigate Home')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'alt+s',
		action: function(e) {
			e.preventDefault();
			$('.dropdown-navbar-user a').eq(0).click();
		},
		description: __('Open Settings')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'shift+/',
		action: function() {
			frappe.ui.keys.show_keyboard_shortcut_dialog();
		},
		description: __('Show Keyboard Shortcuts')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'alt+h',
		action: function(e) {
			e.preventDefault();
			$('.dropdown-help a').eq(0).click();
		},
		description: __('Open Help')
	});

	frappe.ui.keys.on('escape', function(e) {
		close_grid_and_dialog();
	});

	frappe.ui.keys.on('esc', function(e) {
		close_grid_and_dialog();
	});

	frappe.ui.keys.on('enter', function(e) {
		if(window.cur_dialog && cur_dialog.confirm_dialog) {
			cur_dialog.get_primary_btn().trigger('click');
		}
	});

	frappe.ui.keys.on('ctrl+down', function(e) {
		var grid_row = frappe.ui.form.get_open_grid_form();
		grid_row && grid_row.toggle_view(false, function() { grid_row.open_next(); });
	});

	frappe.ui.keys.on('ctrl+up', function(e) {
		var grid_row = frappe.ui.form.get_open_grid_form();
		grid_row && grid_row.toggle_view(false, function() { grid_row.open_prev(); });
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'shift+ctrl+r',
		action: function() {
			frappe.ui.toolbar.clear_cache();
		},
		description: __('Clear Cache and Reload')
	});

	frappe.ui.keys.key_map = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'ctrl',
		91: 'meta',
		18: 'alt',
		27: 'escape',
		37: 'left',
		39: 'right',
		38: 'up',
		40: 'down',
		32: 'space',
		112: 'f1',
		113: 'f2',
		114: 'f3',
		115: 'f4',
		116: 'f5',
		191: '/',
		188: '<',
		190: '>'
	};

	'abcdefghijklmnopqrstuvwxyz'.split('').forEach(function (letter, i) {
		frappe.ui.keys.key_map[65 + i] = letter;
	});

	// keyCode map
	frappe.ui.keyCode = {
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		ENTER: 13,
		TAB: 9,
		SPACE: 32,
		BACKSPACE: 8
	};

	function close_grid_and_dialog() {
		// close open grid row
		var open_row = $(".grid-row-open");
		if (open_row.length) {
			var grid_row = open_row.data("grid_row");
			grid_row.toggle_view(false);
			return false;
		}

		// close open dialog
		if (cur_dialog && !cur_dialog.no_cancel_flag) {
			cur_dialog.cancel();
			return false;
		}
	}

	// blur when escape is pressed on dropdowns
	$(document).on('keydown', '.dropdown-toggle', function (e) {
		if (e.which === frappe.ui.keyCode.ESCAPE) {
			$(e.currentTarget).blur();
		}
	});

	// Copyright (c) 2017, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.ui");

	frappe.ui.color = {
		get: function(color_name, shade) {
			if(color_name && shade) { return this.get_color_shade(color_name, shade); }
			if(color_name) { return this.get_color_shade(color_name, 'default'); }
			return frappe.ui.color_map;
		},
		get_color: function(color_name) {
			var color_names = Object.keys(frappe.ui.color_map);
			if(color_names.includes(color_name)) {
				return frappe.ui.color_map[color_name];
			} else {
				// eslint-disable-next-line
				console.warn(("'color_name' can be one of " + color_names + " and not " + color_name));
			}
		},
		get_color_map: function get_color_map() {
			var colors = ['red', 'green', 'blue', 'dark-green', 'yellow', 'gray', 'purple', 'pink', 'orange'];
			var shades = ['100', '300', '500', '700'];
			var style = getComputedStyle(document.body);
			var color_map = {};
			colors.forEach(function (color) {
				color_map[color] = shades.map(function (shade) { return style.getPropertyValue(("--" + color + "-" + shade)).trim(); }
				);
			});
			return color_map;
		},
		get_color_shade: function(color_name, shade) {
			var shades = {
				'default': 2,
				'light': 1,
				'extra-light': 0,
				'dark': 3
			};

			if(Object.keys(shades).includes(shade)) {
				var color = this.get_color(color_name);
				return color ? color[shades[shade]] : color_name;
			} else {
				// eslint-disable-next-line
				console.warn(("'shade' can be one of " + (Object.keys(shades)) + " and not " + shade));
			}
		},
		all: function() {
			return Object.values(frappe.ui.color_map)
				.reduce(function (acc, curr) { return acc.concat(curr); } , []);
		},
		names: function() {
			return Object.keys(frappe.ui.color_map);
		},
		is_standard: function(color_name) {
			if(!color_name) { return false; }
			if(color_name.startsWith('#')) {
				return this.all().includes(color_name);
			}
			return this.names().includes(color_name);
		},
		get_color_name: function(hex) {
			for (var key in frappe.ui.color_map) {
				var colors = frappe.ui.color_map[key];
				if (colors.includes(hex)) { return key; }
			}
		},
		get_contrast_color: function(hex) {
			if(!this.validate_hex(hex)) {
				return;
			}
			if(!this.is_standard(hex)) {
				var brightness = this.brightness(hex);
				if(brightness < 128) {
					return this.lighten(hex, 0.5);
				}
				return this.lighten(hex, -0.5);
			}

			var color_name = this.get_color_name(hex);
			var colors = this.get_color(color_name);
			var shade_value = colors.indexOf(hex);
			if(shade_value <= 1) {
				return this.get(color_name, 'dark');
			}
			return this.get(color_name, 'extra-light');
		},

		validate_hex: function(hex) {
			// https://stackoverflow.com/a/8027444/5353542
			return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
		},

		lighten: function lighten(color, percent) {
			// https://stackoverflow.com/a/13542669/5353542
			var f = parseInt(color.slice(1), 16),
				t = percent < 0 ? 0 : 255,
				p = percent < 0 ? percent * -1 : percent,
				R = f >> 16,
				G = f >> 8 & 0x00FF,
				B = f & 0x0000FF;
			return "#" +
				(0x1000000 +
					(Math.round((t - R) * p) + R) *
					0x10000 +
					(Math.round((t - G) * p) + G) *
					0x100 + (Math.round((t - B) * p) + B)
				).toString(16).slice(1);
		},

		hex_to_rgb: function hex_to_rgb(hex) {
			if(hex.startsWith('#')) {
				hex = hex.substring(1);
			}
			var r = parseInt(hex.substring(0, 2), 16);
			var g = parseInt(hex.substring(2, 4), 16);
			var b = parseInt(hex.substring(4, 6), 16);
			return {r: r, g: g, b: b};
		},

		brightness: function brightness(hex) {
			var rgb = this.hex_to_rgb(hex);
			// https://www.w3.org/TR/AERT#color-contrast
			// 255 - brightest (#fff)
			// 0 - darkest (#000)
			return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
		}
	};

	frappe.ui.color_map = frappe.ui.color.get_color_map();

	frappe.provide('frappe.ui');

	frappe.ui.Sidebar = class Sidebar {
		constructor(ref) {
		var wrapper = ref.wrapper;
		var css_class = ref.css_class;

			this.wrapper = wrapper;
			this.css_class = css_class;
			this.items = {};
			this.make_dom();
		}

		make_dom() {
			this.wrapper.html(("\n\t\t\t<div class=\"" + (this.css_class) + " overlay-sidebar hidden-xs hidden-sm\">\n\t\t\t</div>\n\t\t"));

			this.$sidebar = this.wrapper.find('.' + this.css_class);
		}

		add_item(item, section, h6) {
			if ( h6 === void 0 ) h6=false;

			var $section, $li_item;
			if(!section && this.wrapper.find('.sidebar-menu').length === 0) {
				// if no section, add section with no heading
				$section = this.get_section();
			} else {
				$section = this.get_section(section);
			}

			if(item instanceof jQuery) {
				$li_item = $("<li>");
				item.appendTo($li_item);
			} else {
				var className = h6 ? 'h6' : '';
				var html = "<li class=" + className + ">\n\t\t\t\t<a " + (item.href ? ("href=\"" + (item.href) + "\"") : '') + ">" + (item.label) + "</a>\n\t\t\t</li>";
				$li_item = $(html).click(
					function () { return item.on_click && item.on_click(); }
				);
			}

			$section.append($li_item);

			if(item.name) {
				this.items[item.name] = $li_item;
			}
		}

		remove_item(name) {
			if(this.items[name]) {
				this.items[name].remove();
			}
		}

		get_section(section_heading) {
			if ( section_heading === void 0 ) section_heading="";

			var $section = $(this.wrapper.find(
				("[data-section-heading=\"" + section_heading + "\"]")));
			if($section.length) {
				return $section;
			}

			var $section_heading = section_heading ?
				("<li class=\"h6\">" + section_heading + "</li>") : '';

			$section = $(("\n\t\t\t<ul class=\"list-unstyled sidebar-menu\" data-section-heading=\"" + (section_heading || 'default') + "\">\n\t\t\t\t" + $section_heading + "\n\t\t\t</ul>\n\t\t"));

			this.$sidebar.append($section);
			return $section;
		}
	};

	frappe.ui.LinkPreview = class {

		constructor() {
			this.popovers_list = [];
			this.LINK_CLASSES = 'a[data-doctype], input[data-fieldtype="Link"], .popover';
			this.popover_timeout = null;
			this.setup_events();
		}

		setup_events() {
			var this$1 = this;

			$(document.body).on('mouseover', this.LINK_CLASSES, function (e) {
				this$1.link_hovered = true;
				this$1.element = $(e.currentTarget);
				this$1.is_link = this$1.element.get(0).tagName.toLowerCase() === 'a';

				if (!this$1.element.parents().find('.popover').length) {
					this$1.identify_doc();
					this$1.popover = this$1.element.data("bs.popover");
					if (this$1.name && this$1.doctype) {
						this$1.setup_popover_control(e);
					}
				}
			});
			this.handle_popover_hide();
		}

		identify_doc() {
			if (this.is_link) {
				this.doctype = this.element.attr('data-doctype');
				this.name = this.element.attr('data-name');
				this.href = this.element.attr('href');
			} else {
				this.href = this.element.parents('.control-input-wrapper').find('.control-value a').attr('href');
				// input
				this.doctype = this.element.attr('data-target');
				this.name = this.element.val();
			}
		}

		setup_popover_control(e) {
			var this$1 = this;

			if (!(frappe.boot.link_preview_doctypes || []).includes(this.doctype)) {
				return;
			}
			//If control field value is changed, new popover has to be created
			this.element.on('change', function () {
				this$1.new_popover = true;
			});
			if (!this.popover || this.new_popover) {
				this.data_timeout = setTimeout(function () {
					this$1.create_popover(e);
				}, 100);

			} else {
				this.popover_timeout = setTimeout(function () {
					if (this$1.element.is(':focus')) {
						return;
					}
					this$1.show_popover(e);
				}, 1000);
			}
		}

		create_popover(e) {
			var this$1 = this;

			this.new_popover = false;
			if (this.element.is(':focus')) {
				return;
			}

			this.get_preview_data().then(function (preview_data) {
				if (preview_data) {
					if (this$1.popover_timeout) {
						clearTimeout(this$1.popover_timeout);
					}

					this$1.popover_timeout = setTimeout(function () {
						if (this$1.popover) {
							var new_content = this$1.get_popover_html(preview_data);
							this$1.popover.options.content = new_content;
						} else {
							this$1.init_preview_popover(preview_data);
						}
						this$1.show_popover(e);

					}, 1000);
				}
			});
		}

		show_popover(e) {
			var this$1 = this;

			this.default_timeout = setTimeout(function () {
				this$1.clear_all_popovers();
			}, 10000);

			if (!this.is_link) {
				var left = e.pageX;
				this.element.popover('show');
				var width = $('.popover').width();
				$('.control-field-popover').css('left', (left - (width / 2)) + 'px');
			} else {
				this.element.popover('show');
			}
		}

		handle_popover_hide() {
			var this$1 = this;

			$(document).on('mouseout', this.LINK_CLASSES, function () {
				// To allow popover to be hovered on
				if (!$('.popover:hover').length) {
					this$1.link_hovered = false;
				}
				if (!this$1.link_hovered) {
					if (this$1.data_timeout) {
						clearTimeout(this$1.data_timeout);
					}
					if (this$1.popover_timeout) {
						clearTimeout(this$1.popover_timeout);
					}
					if (this$1.default_timeout) {
						clearTimeout(this$1.default_timeout);
					}
					this$1.clear_all_popovers();
				}
			});

			frappe.router.on('change', function () {
				this$1.clear_all_popovers();
			});
		}

		clear_all_popovers() {
			this.popovers_list.forEach(function ($el) { return $el.hide(); });
		}

		get_preview_data() {
			return frappe.xcall('frappe.desk.link_preview.get_preview_data', {
				'doctype': this.doctype,
				'docname': this.name,
			});
		}

		init_preview_popover(preview_data) {
			var popover_content = this.get_popover_html(preview_data);
			this.element.popover({
				container: 'body',
				template: "\n\t\t\t\t<div class=\"link-preview-popover popover\">\n\t\t\t\t\t<div class=\"arrow\"></div>\n\t\t\t\t\t<div class=\"popover-body popover-content\">\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t",
				html: true,
				sanitizeFn: function (content) { return content; },
				content: popover_content,
				trigger: 'manual',
				placement: 'top',
			});

			var $popover = $(this.element.data('bs.popover').tip);
			$popover.toggleClass('control-field-popover', this.is_link);
			this.popovers_list.push(this.element.data('bs.popover'));

		}

		get_popover_html(preview_data) {
			if (!this.href) {
				this.href = window.location.href;
			}

			if (this.href && this.href.includes(' ')) {
				this.href = this.href.replace(new RegExp(' ', 'g'), '%20');
			}

			var popover_content ="\n\t\t\t<div class=\"preview-popover-header\">\n\t\t\t\t<div class=\"preview-header\">\n\t\t\t\t\t" + (this.get_image_html(preview_data)) + "\n\t\t\t\t\t<div class=\"preview-name\">\n\t\t\t\t\t\t<a href=" + (this.href) + ">" + (__(preview_data.preview_title)) + "</a>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"text-muted preview-title\">" + (this.get_id_html(preview_data)) + "</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<hr>\n\t\t\t<div class=\"popover-body\">\n\t\t\t\t" + (this.get_content_html(preview_data)) + "\n\t\t\t</div>\n\t\t";

			return popover_content;
		}

		get_id_html(preview_data) {
			var id_html = '';
			if (preview_data.preview_title !== preview_data.name) {
				id_html = "<a class=\"text-muted\" href=" + (this.href) + ">" + (preview_data.name) + "</a>";
			}

			return id_html;
		}

		get_image_html(preview_data) {
			var avatar_html = frappe.get_avatar(
				"avatar-medium",
				preview_data.preview_title,
				preview_data.preview_image
			);

			return ("<div class=\"preview-image\">\n\t\t\t" + avatar_html + "\n\t\t</div>");
		}

		get_content_html(preview_data) {
			var content_html = '';

			Object.keys(preview_data).forEach(function (key) {
				if (!['preview_image', 'preview_title', 'name'].includes(key)) {
					var value = frappe.ellipsis(preview_data[key], 280);
					var label = key;
					content_html += "\n\t\t\t\t\t<div class=\"preview-field\">\n\t\t\t\t\t\t<div class=\"preview-label text-muted\">" + (__(label)) + "</div>\n\t\t\t\t\t\t<div class=\"preview-value\">" + value + "</div>\n\t\t\t\t\t</div>\n\t\t\t\t";
				}
			});

			return ("<div class=\"preview-table\">" + content_html + "</div>");
		}

	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// My HTTP Request

	frappe.provide('frappe.request');
	frappe.provide('frappe.request.error_handlers');
	frappe.request.url = '/';
	frappe.request.ajax_count = 0;
	frappe.request.waiting_for_ajax = [];
	frappe.request.logs = {};

	frappe.xcall = function(method, params) {
		return new Promise(function (resolve, reject) {
			frappe.call({
				method: method,
				args: params,
				callback: function (r) {
					resolve(r.message);
				},
				error: function (r) {
					reject(r.message);
				}
			});
		});
	};

	// generic server call (call page, object)
	frappe.call = function(opts) {
		if (!frappe.is_online()) {
			frappe.show_alert({
				indicator: 'orange',
				message: __('Connection Lost'),
				subtitle: __('You are not connected to Internet. Retry after sometime.')
			}, 3);
			opts.always && opts.always();
			return $.ajax();
		}
		if (typeof arguments[0]==='string') {
			opts = {
				method: arguments[0],
				args: arguments[1],
				callback: arguments[2],
				headers: arguments[3]
			};
		}

		if(opts.quiet) {
			opts.no_spinner = true;
		}
		var args = $.extend({}, opts.args);

		// cmd
		if(opts.module && opts.page) {
			args.cmd = opts.module+'.page.'+opts.page+'.'+opts.page+'.'+opts.method;
		} else if(opts.doc) {
			$.extend(args, {
				cmd: "run_doc_method",
				docs: frappe.get_doc(opts.doc.doctype, opts.doc.name),
				method: opts.method,
				args: opts.args,
			});
		} else if(opts.method) {
			args.cmd = opts.method;
		}

		var callback = function(data, response_text) {
			if(data.task_id) {
				// async call, subscribe
				frappe.socketio.subscribe(data.task_id, opts);

				if(opts.queued) {
					opts.queued(data);
				}
			}
			else if (opts.callback) {
				// ajax
				return opts.callback(data, response_text);
			}
		};

		var url = opts.url;
		if (!url) {
			url = '/api/method/' + args.cmd;
			if (window.cordova) {
				var host = frappe.request.url;
				host = host.slice(0, host.length - 1);
				url = host + url;
			}
			delete args.cmd;
		}

		// debouce if required
		if (opts.debounce && frappe.request.is_fresh(args, opts.debounce)) {
			return Promise.resolve();
		}

		return frappe.request.call({
			type: opts.type || "POST",
			args: args,
			success: callback,
			error: opts.error,
			always: opts.always,
			btn: opts.btn,
			freeze: opts.freeze,
			freeze_message: opts.freeze_message,
			headers: opts.headers || {},
			error_handlers: opts.error_handlers || {},
			// show_spinner: !opts.no_spinner,
			async: opts.async,
			silent: opts.silent,
			url: url,
		});
	};


	frappe.request.call = function(opts) {
		frappe.request.prepare(opts);

		var statusCode = {
			200: function(data, xhr) {
				opts.success_callback && opts.success_callback(data, xhr.responseText);
			},
			401: function(xhr) {
				if(frappe.app.session_expired_dialog && frappe.app.session_expired_dialog.display) {
					frappe.app.redirect_to_login();
				} else {
					frappe.app.handle_session_expired();
				}
			},
			404: function(xhr) {
				if (frappe.flags.setting_original_route) {
					// original route is wrong, redirect to login
					frappe.app.redirect_to_login();
				} else {
					frappe.msgprint({title: __("Not found"), indicator: 'red',
						message: __('The resource you are looking for is not available')});
				}
			},
			403: function(xhr) {
				if (frappe.session.user === "Guest" && frappe.session.logged_in_user !== "Guest") {
					// session expired
					frappe.app.handle_session_expired();
				} else if (xhr.responseJSON && xhr.responseJSON._error_message) {
					frappe.msgprint({
						title: __("Not permitted"), indicator: 'red',
						message: xhr.responseJSON._error_message
					});

					xhr.responseJSON._server_messages = null;
				} else if (xhr.responseJSON && xhr.responseJSON._server_messages) {
					var _server_messages = JSON.parse(xhr.responseJSON._server_messages);

					// avoid double messages
					if (_server_messages.indexOf(__("Not permitted")) !== -1) {
						return;
					}
				} else {
					frappe.msgprint({
						title: __("Not permitted"), indicator: 'red',
						message: __('You do not have enough permissions to access this resource. Please contact your manager to get access.')});
				}


			},
			508: function(xhr) {
				frappe.utils.play_sound("error");
				frappe.msgprint({title:__('Please try again'), indicator:'red',
					message:__("Another transaction is blocking this one. Please try again in a few seconds.")});
			},
			413: function(data, xhr) {
				frappe.msgprint({indicator:'red', title:__('File too big'), message:__("File size exceeded the maximum allowed size of {0} MB",
					[(frappe.boot.max_file_size || 5242880) / 1048576])});
			},
			417: function(xhr) {
				var r = xhr.responseJSON;
				if (!r) {
					try {
						r = JSON.parse(xhr.responseText);
					} catch (e) {
						r = xhr.responseText;
					}
				}

				opts.error_callback && opts.error_callback(r);
			},
			501: function(data, xhr) {
				if(typeof data === "string") { data = JSON.parse(data); }
				opts.error_callback && opts.error_callback(data, xhr.responseText);
			},
			500: function(xhr) {
				frappe.utils.play_sound("error");
				try {
					opts.error_callback && opts.error_callback();
					frappe.request.report_error(xhr, opts);
				} catch (e) {
					frappe.request.report_error(xhr, opts);
				}
			},
			504: function(xhr) {
				frappe.msgprint(__("Request Timed Out"));
				opts.error_callback && opts.error_callback();
			},
			502: function(xhr) {
				frappe.msgprint(__("Internal Server Error"));
			}
		};

		var ajax_args = {
			url: opts.url || frappe.request.url,
			data: opts.args,
			type: opts.type,
			dataType: opts.dataType || 'json',
			async: opts.async,
			headers: Object.assign({
				"X-Frappe-CSRF-Token": frappe.csrf_token,
				"Accept": "application/json",
	 			"X-Frappe-CMD": (opts.args && opts.args.cmd  || '') || ''
			}, opts.headers),
			cache: false
		};

		if (opts.args && opts.args.doctype) {
			ajax_args.headers["X-Frappe-Doctype"] = encodeURIComponent(opts.args.doctype);
		}

		frappe.last_request = ajax_args.data;

		return $.ajax(ajax_args)
			.done(function(data, textStatus, xhr) {
				try {
					if(typeof data === "string") { data = JSON.parse(data); }

					// sync attached docs
					if(data.docs || data.docinfo) {
						frappe.model.sync(data);
					}

					// sync translated messages
					if(data.__messages) {
						$.extend(frappe._messages, data.__messages);
					}

					// callbacks
					var status_code_handler = statusCode[xhr.statusCode().status];
					if (status_code_handler) {
						status_code_handler(data, xhr);
					}
				} catch(e) {
					console.log("Unable to handle success response", data); // eslint-disable-line
					console.trace(e); // eslint-disable-line
				}

			})
			.always(function(data, textStatus, xhr) {
				try {
					if(typeof data==="string") {
						data = JSON.parse(data);
					}
					if(data.responseText) {
						var xhr = data;
						data = JSON.parse(data.responseText);
					}
				} catch(e) {
					data = null;
					// pass
				}
				frappe.request.cleanup(opts, data);
				if(opts.always) {
					opts.always(data);
				}
			})
			.fail(function(xhr, textStatus) {
				try {
					var status_code_handler = statusCode[xhr.statusCode().status];
					if (status_code_handler) {
						status_code_handler(xhr);
					} else {
						// if not handled by error handler!
						opts.error_callback && opts.error_callback(xhr);
					}
				} catch(e) {
					console.log("Unable to handle failed response"); // eslint-disable-line
					console.trace(e); // eslint-disable-line
				}
			});
	};

	frappe.request.is_fresh = function(args, threshold) {
		// return true if a request with similar args has been sent recently
		if (!frappe.request.logs[args.cmd]) {
			frappe.request.logs[args.cmd] = [];
		}

		for (var i = 0, list = frappe.request.logs[args.cmd]; i < list.length; i += 1) {
			// check if request has same args and was made recently
			var past_request = list[i];

			if ((new Date() - past_request.timestamp) < threshold
				&& frappe.utils.deep_equal(args, past_request.args)) {
				// eslint-disable-next-line no-console
				console.log('throttled');
				return true;
			}
		}

		// log the request
		frappe.request.logs[args.cmd].push({args: args, timestamp: new Date()});
		return false;
	};

	// call execute serverside request
	frappe.request.prepare = function(opts) {
		$("body").attr("data-ajax-state", "triggered");

		// btn indicator
		if(opts.btn) { $(opts.btn).prop("disabled", true); }

		// freeze page
		if(opts.freeze) { frappe.dom.freeze(opts.freeze_message); }

		// stringify args if required
		for(var key in opts.args) {
			if(opts.args[key] && ($.isPlainObject(opts.args[key]) || $.isArray(opts.args[key]))) {
				opts.args[key] = JSON.stringify(opts.args[key]);
			}
		}

		// no cmd?
		if(!opts.args.cmd && !opts.url) {
			console.log(opts);
			throw "Incomplete Request";
		}

		opts.success_callback = opts.success;
		opts.error_callback = opts.error;
		delete opts.success;
		delete opts.error;

	};

	frappe.request.cleanup = function(opts, r) {
		// stop button indicator
		if(opts.btn) {
			$(opts.btn).prop("disabled", false);
		}

		$("body").attr("data-ajax-state", "complete");

		// un-freeze page
		if(opts.freeze) { frappe.dom.unfreeze(); }

		if(r) {

			// session expired? - Guest has no business here!
			if (r.session_expired ||
				(frappe.session.user === 'Guest' && frappe.session.logged_in_user !== "Guest")) {
				frappe.app.handle_session_expired();
				return;
			}

			// error handlers
			var global_handlers = frappe.request.error_handlers[r.exc_type] || [];
			var request_handler = opts.error_handlers ? opts.error_handlers[r.exc_type] : null;
			var handlers = [].concat(global_handlers, request_handler).filter(Boolean);

			if (r.exc_type) {
				handlers.forEach(function (handler) {
					handler(r);
				});
			}

			// show messages
			if(r._server_messages && !opts.silent) {
				// show server messages if no handlers exist
				if (handlers.length === 0) {
					r._server_messages = JSON.parse(r._server_messages);
					frappe.hide_msgprint();
					frappe.msgprint(r._server_messages);
				}
			}

			// show errors
			if(r.exc) {
				r.exc = JSON.parse(r.exc);
				if(r.exc instanceof Array) {
					$.each(r.exc, function(i, v) {
						if(v) {
							console.log(v);
						}
					});
				} else {
					console.log(r.exc);
				}
			}

			// debug messages
			if(r._debug_messages) {
				if(opts.args) {
					console.log("======== arguments ========");
					console.log(opts.args);
					console.log("========");
				}
				$.each(JSON.parse(r._debug_messages), function(i, v) { console.log(v); });
				console.log("======== response ========");
				delete r._debug_messages;
				console.log(r);
				console.log("========");
			}
		}

		frappe.last_response = r;
	};

	frappe.after_server_call = function () {
		if(frappe.request.ajax_count) {
			return new Promise(function (resolve) {
				frappe.request.waiting_for_ajax.push(function () {
					resolve();
				});
			});
		} else {
			return null;
		}
	};

	frappe.after_ajax = function(fn) {
		return new Promise(function (resolve) {
			if(frappe.request.ajax_count) {
				frappe.request.waiting_for_ajax.push(function () {
					if(fn) { return resolve(fn()); }
					resolve();
				});
			} else {
				if(fn) { return resolve(fn()); }
				resolve();
			}
		});
	};

	frappe.request.report_error = function(xhr, request_opts) {
		var data = JSON.parse(xhr.responseText);
		var exc;
		if (data.exc) {
			try {
				exc = (JSON.parse(data.exc) || []).join("\n");
			} catch (e) {
				exc = data.exc;
			}
			delete data.exc;
		} else {
			exc = "";
		}

		var show_communication = function() {
			var error_report_message = [
				'<h5>Please type some additional information that could help us reproduce this issue:</h5>',
				'<div style="min-height: 100px; border: 1px solid #bbb; \
				border-radius: 5px; padding: 15px; margin-bottom: 15px;"></div>',
				'<hr>',
				'<h5>App Versions</h5>',
				'<pre>' + JSON.stringify(frappe.boot.versions, null, "\t") + '</pre>',
				'<h5>Route</h5>',
				'<pre>' + frappe.get_route_str() + '</pre>',
				'<hr>',
				'<h5>Error Report</h5>',
				'<pre>' + exc + '</pre>',
				'<hr>',
				'<h5>Request Data</h5>',
				'<pre>' + JSON.stringify(request_opts, null, "\t") + '</pre>',
				'<hr>',
				'<h5>Response JSON</h5>',
				'<pre>' + JSON.stringify(data, null, '\t')+ '</pre>'
			].join("\n");

			var communication_composer = new frappe.views.CommunicationComposer({
				subject: 'Error Report [' + frappe.datetime.nowdate() + ']',
				recipients: error_report_email,
				message: error_report_message,
				doc: {
					doctype: "User",
					name: frappe.session.user
				}
			});
			communication_composer.dialog.$wrapper.css("z-index", cint(frappe.msg_dialog.$wrapper.css("z-index")) + 1);
		};

		if (exc) {
			var error_report_email = frappe.boot.error_report_email;

			request_opts = frappe.request.cleanup_request_opts(request_opts);

			// window.msg_dialog = frappe.msgprint({message:error_message, indicator:'red', big: true});

			if (!frappe.error_dialog) {
				frappe.error_dialog = new frappe.ui.Dialog({
					title: __('Server Error'),
					primary_action_label: __('Report'),
					primary_action: function () {
						if (error_report_email) {
							show_communication();
						} else {
							frappe.msgprint(__('Support Email Address Not Specified'));
						}
						frappe.error_dialog.hide();
					}
				});
				frappe.error_dialog.wrapper.classList.add('msgprint-dialog');

			}

			var parts = strip(exc).split('\n');

			frappe.error_dialog.$body.html(parts[parts.length - 1]);
			frappe.error_dialog.show();

		}
	};

	frappe.request.cleanup_request_opts = function(request_opts) {
		var doc = (request_opts.args || {}).doc;
		if (doc) {
			doc = JSON.parse(doc);
			$.each(Object.keys(doc), function(i, key) {
				if (key.indexOf("password")!==-1 && doc[key]) {
					// mask the password
					doc[key] = "*****";
				}
			});
			request_opts.args.doc = JSON.stringify(doc);
		}
		return request_opts;
	};

	frappe.request.on_error = function(error_type, handler) {
		frappe.request.error_handlers[error_type] = frappe.request.error_handlers[error_type] || [];
		frappe.request.error_handlers[error_type].push(handler);
	};

	$(document).ajaxSend(function() {
		frappe.request.ajax_count++;
	});

	$(document).ajaxComplete(function() {
		frappe.request.ajax_count--;
		if(!frappe.request.ajax_count) {
			$.each(frappe.request.waiting_for_ajax || [], function(i, fn) {
				fn();
			});
			frappe.request.waiting_for_ajax = [];
		}
	});

	frappe.socketio = {
		open_tasks: {},
		open_docs: [],
		emit_queue: [],
		init: function(port) {
			if ( port === void 0 ) port = 3000;

			if (!window.io) {
				return;
			}

			if (frappe.boot.disable_async) {
				return;
			}

			if (frappe.socketio.socket) {
				return;
			}

			//Enable secure option when using HTTPS
			if (window.location.protocol == "https:") {
				frappe.socketio.socket = io.connect(frappe.socketio.get_host(port), {secure: true});
			}
			else if (window.location.protocol == "http:") {
				frappe.socketio.socket = io.connect(frappe.socketio.get_host(port));
			}
			else if (window.location.protocol == "file:") {
				frappe.socketio.socket = io.connect(window.localStorage.server);
			}

			if (!frappe.socketio.socket) {
				console.log("Unable to connect to " + frappe.socketio.get_host(port));
				return;
			}

			frappe.socketio.socket.on('msgprint', function(message) {
				frappe.msgprint(message);
			});

			frappe.socketio.socket.on('eval_js', function(message) {
				eval(message);
			});

			frappe.socketio.socket.on('progress', function(data) {
				if(data.progress) {
					data.percent = flt(data.progress[0]) / data.progress[1] * 100;
				}
				if(data.percent) {
					if(data.percent==100) {
						frappe.hide_progress();
					} else {
						frappe.show_progress(data.title || __("Progress"), data.percent, 100, data.description);
					}
				}
			});

			frappe.socketio.setup_listeners();
			frappe.socketio.setup_reconnect();

			$(document).on('form-load form-rename', function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				for (var i=0, l=frappe.socketio.open_docs.length; i<l; i++) {
					var d = frappe.socketio.open_docs[i];
					if (frm.doctype==d.doctype && frm.docname==d.name) {
						// already subscribed
						return false;
					}
				}

				frappe.socketio.doc_subscribe(frm.doctype, frm.docname);
			});

			$(document).on("form-refresh", function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				frappe.socketio.doc_open(frm.doctype, frm.docname);
			});

			$(document).on('form-unload', function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				// frappe.socketio.doc_unsubscribe(frm.doctype, frm.docname);
				frappe.socketio.doc_close(frm.doctype, frm.docname);
			});

			$(document).on('form-typing', function(e, frm) {
				frappe.socketio.form_typing(frm.doctype, frm.docname);
			});

			$(document).on('form-stopped-typing', function(e, frm) {
				frappe.socketio.form_stopped_typing(frm.doctype, frm.docname);
			});

			window.addEventListener('beforeunload', function () {
				if (!cur_frm || cur_frm.is_new()) {
					return;
				}

				// if tab/window is closed, notify other users
				if (cur_frm.doc) {
					frappe.socketio.doc_close(cur_frm.doctype, cur_frm.docname);
				}
			});
		},
		get_host: function(port) {
			if ( port === void 0 ) port = 3000;

			var host = window.location.origin;
			if(window.dev_server) {
				var parts = host.split(":");
				port = frappe.boot.socketio_port || port.toString() || '3000';
				if(parts.length > 2) {
					host = parts[0] + ":" + parts[1];
				}
				host = host + ":" + port;
			}
			return host;
		},
		subscribe: function(task_id, opts) {
			// TODO DEPRECATE

			frappe.socketio.socket.emit('task_subscribe', task_id);
			frappe.socketio.socket.emit('progress_subscribe', task_id);

			frappe.socketio.open_tasks[task_id] = opts;
		},
		task_subscribe: function(task_id) {
			frappe.socketio.socket.emit('task_subscribe', task_id);
		},
		task_unsubscribe: function(task_id) {
			frappe.socketio.socket.emit('task_unsubscribe', task_id);
		},
		doc_subscribe: function(doctype, docname) {
			if (frappe.flags.doc_subscribe) {
				console.log('throttled');
				return;
			}

			frappe.flags.doc_subscribe = true;

			// throttle to 1 per sec
			setTimeout(function() { frappe.flags.doc_subscribe = false; }, 1000);

			frappe.socketio.socket.emit('doc_subscribe', doctype, docname);
			frappe.socketio.open_docs.push({doctype: doctype, docname: docname});
		},
		doc_unsubscribe: function(doctype, docname) {
			frappe.socketio.socket.emit('doc_unsubscribe', doctype, docname);
			frappe.socketio.open_docs = $.filter(frappe.socketio.open_docs, function(d) {
				if(d.doctype===doctype && d.name===docname) {
					return null;
				} else {
					return d;
				}
			});
		},
		doc_open: function(doctype, docname) {
			// notify that the user has opened this doc, if not already notified
			if (!frappe.socketio.last_doc
				|| (frappe.socketio.last_doc[0] != doctype || frappe.socketio.last_doc[1] != docname)) {
				frappe.socketio.socket.emit('doc_open', doctype, docname);

				frappe.socketio.last_doc &&
					frappe.socketio.doc_close(frappe.socketio.last_doc[0], frappe.socketio.last_doc[1]);
			}
			frappe.socketio.last_doc = [doctype, docname];
		},
		doc_close: function(doctype, docname) {
			// notify that the user has closed this doc
			frappe.socketio.socket.emit('doc_close', doctype, docname);

			// if the doc is closed the user has also stopped typing
			frappe.socketio.socket.emit('doc_typing_stopped', doctype, docname);
		},
		form_typing: function(doctype, docname) {
			// notifiy that the user is typing on the doc
			frappe.socketio.socket.emit('doc_typing', doctype, docname);
		},
		form_stopped_typing: function(doctype, docname) {
			// notifiy that the user has stopped typing
			frappe.socketio.socket.emit('doc_typing_stopped', doctype, docname);
		},
		setup_listeners: function() {
			frappe.socketio.socket.on('task_status_change', function(data) {
				frappe.socketio.process_response(data, data.status.toLowerCase());
			});
			frappe.socketio.socket.on('task_progress', function(data) {
				frappe.socketio.process_response(data, "progress");
			});
		},
		setup_reconnect: function() {
			// subscribe again to open_tasks
			frappe.socketio.socket.on("connect", function() {
				// wait for 5 seconds before subscribing again
				// because it takes more time to start python server than nodejs server
				// and we use validation requests to python server for subscribing
				setTimeout(function() {
					$.each(frappe.socketio.open_tasks, function(task_id, opts) {
						frappe.socketio.subscribe(task_id, opts);
					});

					// re-connect open docs
					$.each(frappe.socketio.open_docs, function(d) {
						if(locals[d.doctype] && locals[d.doctype][d.name]) {
							frappe.socketio.doc_subscribe(d.doctype, d.name);
						}
					});

					if (cur_frm && cur_frm.doc) {
						frappe.socketio.doc_open(cur_frm.doc.doctype, cur_frm.doc.name);
					}
				}, 5000);
			});
		},
		process_response: function(data, method) {
			if(!data) {
				return;
			}

			// success
			var opts = frappe.socketio.open_tasks[data.task_id];
			if(opts[method]) {
				opts[method](data);
			}

			// "callback" is std frappe term
			if(method==="success") {
				if(opts.callback) { opts.callback(data); }
			}

			// always
			frappe.request.cleanup(opts, data);
			if(opts.always) {
				opts.always(data);
			}

			// error
			if(data.status_code && data.status_code > 400 && opts.error) {
				opts.error(data);
			}
		}
	};

	frappe.provide("frappe.realtime");
	frappe.realtime.on = function(event, callback) {
		frappe.socketio.socket && frappe.socketio.socket.on(event, callback);
	};

	frappe.realtime.off = function(event, callback) {
		frappe.socketio.socket && frappe.socketio.socket.off(event, callback);
	};

	frappe.realtime.publish = function(event, message) {
		if(frappe.socketio.socket) {
			frappe.socketio.socket.emit(event, message);
		}
	};

	var isArray = Array.isArray;
	var keyList = Object.keys;
	var hasProp = Object.prototype.hasOwnProperty;

	var fastDeepEqual = function equal(a, b) {
	  if (a === b) { return true; }

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    var arrA = isArray(a)
	      , arrB = isArray(b)
	      , i
	      , length
	      , key;

	    if (arrA && arrB) {
	      length = a.length;
	      if (length != b.length) { return false; }
	      for (i = length; i-- !== 0;)
	        { if (!equal(a[i], b[i])) { return false; } }
	      return true;
	    }

	    if (arrA != arrB) { return false; }

	    var dateA = a instanceof Date
	      , dateB = b instanceof Date;
	    if (dateA != dateB) { return false; }
	    if (dateA && dateB) { return a.getTime() == b.getTime(); }

	    var regexpA = a instanceof RegExp
	      , regexpB = b instanceof RegExp;
	    if (regexpA != regexpB) { return false; }
	    if (regexpA && regexpB) { return a.toString() == b.toString(); }

	    var keys = keyList(a);
	    length = keys.length;

	    if (length !== keyList(b).length)
	      { return false; }

	    for (i = length; i-- !== 0;)
	      { if (!hasProp.call(b, keys[i])) { return false; } }

	    for (i = length; i-- !== 0;) {
	      key = keys[i];
	      if (!equal(a[key], b[key])) { return false; }
	    }

	    return true;
	  }

	  return a!==a && b!==b;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide("frappe.utils");

	// Array de duplicate
	if (!Array.prototype.uniqBy) {
		Object.defineProperty(Array.prototype, 'uniqBy', {
			value: function (key) {
				var seen = {};
				return this.filter(function (item) {
					var k = key(item);
					return k in seen ? false : (seen[k] = true);
				});
			}
		});
		Object.defineProperty(Array.prototype, 'move', {
			value: function(from, to) {
				this.splice(to, 0, this.splice(from, 1)[0]);
			}
		});
	}

	// Pluralize
	String.prototype.plural = function(revert) {
		var plural = {
			"(quiz)$": "$1zes",
			"^(ox)$": "$1en",
			"([m|l])ouse$": "$1ice",
			"(matr|vert|ind)ix|ex$": "$1ices",
			"(x|ch|ss|sh)$": "$1es",
			"([^aeiouy]|qu)y$": "$1ies",
			"(hive)$": "$1s",
			"(?:([^f])fe|([lr])f)$": "$1$2ves",
			"(shea|lea|loa|thie)f$": "$1ves",
			sis$: "ses",
			"([ti])um$": "$1a",
			"(tomat|potat|ech|her|vet)o$": "$1oes",
			"(bu)s$": "$1ses",
			"(alias)$": "$1es",
			"(octop)us$": "$1i",
			"(ax|test)is$": "$1es",
			"(us)$": "$1es",
			"([^s]+)$": "$1s",
		};

		var singular = {
			"(quiz)zes$": "$1",
			"(matr)ices$": "$1ix",
			"(vert|ind)ices$": "$1ex",
			"^(ox)en$": "$1",
			"(alias)es$": "$1",
			"(octop|vir)i$": "$1us",
			"(cris|ax|test)es$": "$1is",
			"(shoe)s$": "$1",
			"(o)es$": "$1",
			"(bus)es$": "$1",
			"([m|l])ice$": "$1ouse",
			"(x|ch|ss|sh)es$": "$1",
			"(m)ovies$": "$1ovie",
			"(s)eries$": "$1eries",
			"([^aeiouy]|qu)ies$": "$1y",
			"([lr])ves$": "$1f",
			"(tive)s$": "$1",
			"(hive)s$": "$1",
			"(li|wi|kni)ves$": "$1fe",
			"(shea|loa|lea|thie)ves$": "$1f",
			"(^analy)ses$": "$1sis",
			"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$":
				"$1$2sis",
			"([ti])a$": "$1um",
			"(n)ews$": "$1ews",
			"(h|bl)ouses$": "$1ouse",
			"(corpse)s$": "$1",
			"(us)es$": "$1",
			s$: "",
		};

		var irregular = {
			move: "moves",
			foot: "feet",
			goose: "geese",
			sex: "sexes",
			child: "children",
			man: "men",
			tooth: "teeth",
			person: "people",
		};

		var uncountable = [
			"sheep",
			"fish",
			"deer",
			"moose",
			"series",
			"species",
			"money",
			"rice",
			"information",
			"equipment" ];

		// save some time in the case that singular and plural are the same
		if (uncountable.indexOf(this.toLowerCase()) >= 0) { return this; }

		// check for irregular forms
		var word;
		var pattern;
		var replace;
		for (word in irregular) {
			if (revert) {
				pattern = new RegExp(irregular[word] + "$", "i");
				replace = word;
			} else {
				pattern = new RegExp(word + "$", "i");
				replace = irregular[word];
			}
			if (pattern.test(this)) { return this.replace(pattern, replace); }
		}

		var array;
		if (revert) { array = singular; }
		else { array = plural; }

		// check for matches using regular expressions
		var reg;
		for (reg in array) {
			pattern = new RegExp(reg, "i");

			if (pattern.test(this)) { return this.replace(pattern, array[reg]); }
		}

		return this;
	};

	Object.assign(frappe.utils, {
		get_random: function(len) {
			var text = "";
			var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

			for ( var i=0; i < len; i++ )
				{ text += possible.charAt(Math.floor(Math.random() * possible.length)); }

			return text;
		},
		get_file_link: function(filename) {
			filename = cstr(filename);
			if (frappe.utils.is_url(filename)) {
				return filename;
			} else if (filename.indexOf("/")===-1) {
				return "files/" + filename;
			} else {
				return filename;
			}
		},
		replace_newlines: function replace_newlines(t) {
			return t?t.replace(/\n/g, '<br>'):'';
		},
		is_html: function(txt) {
			if (!txt) { return false; }

			if (txt.indexOf("<br>")==-1 && txt.indexOf("<p")==-1
				&& txt.indexOf("<img")==-1 && txt.indexOf("<div")==-1 && !txt.includes('<span')) {
				return false;
			}
			return true;
		},
		is_mac: function() {
			return window.navigator.platform === 'MacIntel';
		},
		is_xs: function() {
			return $(document).width() < 768;
		},
		is_sm: function() {
			return $(document).width() < 991 && $(document).width() >= 768;
		},
		is_md: function() {
			return $(document).width() < 1199 && $(document).width() >= 991;
		},
		is_json: function(str) {
			try {
				JSON.parse(str);
			} catch (e) {
				return false;
			}
			return true;
		},
		strip_whitespace: function(html) {
			return (html || "").replace(/<p>\s*<\/p>/g, "").replace(/<br>(\s*<br>\s*)+/g, "<br><br>");
		},
		encode_tags: function(html) {
			var tagsToReplace = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;'
			};

			function replaceTag(tag) {
				return tagsToReplace[tag] || tag;
			}

			return html.replace(/[&<>]/g, replaceTag);
		},
		strip_original_content: function(txt) {
			var out = [],
				part = [],
				newline = txt.indexOf("<br>")===-1 ? "\n" : "<br>";

			$.each(txt.split(newline), function(i, t) {
				var tt = strip(t);
				if (tt && (tt.substr(0, 1)===">" || tt.substr(0, 4)==="&gt;")) {
					part.push(t);
				} else {
					out.push(t);
					part = [];
				}
			});
			return out.join(newline);
		},


		escape_html: function(txt) {
			var escape_html_mapping = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#39;',
				'/': '&#x2F;',
				'`': '&#x60;',
				'=': '&#x3D;'
			};

			return String(txt).replace(/[&<>"'`=/]/g, function(char) {
				return escape_html_mapping[char];
			});
		},

		html2text: function(html) {
			var d = document.createElement('div');
			d.innerHTML = html;
			return d.textContent;
		},

		is_url: function(txt) {
			return txt.toLowerCase().substr(0, 7)=='http://'
				|| txt.toLowerCase().substr(0, 8)=='https://';
		},
		to_title_case: function(string, with_space) {
			if ( with_space === void 0 ) with_space=false;

			var titlecased_string = string.toLowerCase().replace(/(?:^|[\s-/])\w/g, function(match) {
				return match.toUpperCase();
			});

			var replace_with = with_space ? ' ' : '';

			return titlecased_string.replace(/-|_/g, replace_with);
		},
		toggle_blockquote: function(txt) {
			if (!txt) { return txt; }

			var content = $("<div></div>").html(txt);
			content.find("blockquote").parent("blockquote").addClass("hidden")
				.before('<p><a class="text-muted btn btn-default toggle-blockquote" style="padding: 2px 7px 0px; line-height: 1;"> \
					• • • \
				</a></p>');
			return content.html();
		},
		scroll_to: function(element, animate, additional_offset, element_to_be_scrolled) {
			if ( animate === void 0 ) animate=true;

			element_to_be_scrolled = element_to_be_scrolled || $("html, body");
			var scroll_top = 0;
			if (element) {
				// If a number is passed, just subtract the offset,
				// otherwise calculate scroll position from element
				scroll_top = typeof element == "number"
					? element - cint(additional_offset)
					: this.get_scroll_position(element, additional_offset);
			}

			if (scroll_top < 0) {
				scroll_top = 0;
			}

			// already there
			if (scroll_top == element_to_be_scrolled.scrollTop()) {
				return;
			}

			if (animate) {
				element_to_be_scrolled.animate({ scrollTop: scroll_top });
			} else {
				element_to_be_scrolled.scrollTop(scroll_top);
			}

		},
		get_scroll_position: function(element, additional_offset) {
			var header_offset = $(".navbar").height() + $(".page-head:visible").height();
			var scroll_top = $(element).offset().top - header_offset - cint(additional_offset);
			return scroll_top;
		},
		filter_dict: function(dict, filters) {
			var ret = [];
			if (typeof filters=='string') {
				return [dict[filters]];
			}
			$.each(dict, function(i, d) {
				for (var key in filters) {
					if ($.isArray(filters[key])) {
						if (filters[key][0]=="in") {
							if (filters[key][1].indexOf(d[key])==-1)
								{ return; }
						} else if (filters[key][0]=="not in") {
							if (filters[key][1].indexOf(d[key])!=-1)
								{ return; }
						} else if (filters[key][0]=="<") {
							if (!(d[key] < filters[key])) { return; }
						} else if (filters[key][0]=="<=") {
							if (!(d[key] <= filters[key])) { return; }
						} else if (filters[key][0]==">") {
							if (!(d[key] > filters[key])) { return; }
						} else if (filters[key][0]==">=") {
							if (!(d[key] >= filters[key])) { return; }
						}
					} else {
						if (d[key]!=filters[key]) { return; }
					}
				}
				ret.push(d);
			});
			return ret;
		},
		comma_or: function(list) {
			return frappe.utils.comma_sep(list, " " + __("or") + " ");
		},
		comma_and: function(list) {
			return frappe.utils.comma_sep(list, " " + __("and") + " ");
		},
		comma_sep: function(list, sep) {
			if (list instanceof Array) {
				if (list.length==0) {
					return "";
				} else if (list.length==1) {
					return list[0];
				} else {
					return list.slice(0, list.length-1).join(", ") + sep + list.slice(-1)[0];
				}
			} else {
				return list;
			}
		},
		set_footnote: function(footnote_area, wrapper, txt) {
			if (!footnote_area) {
				footnote_area = $('<div class="text-muted footnote-area level">')
					.appendTo(wrapper);
			}

			if (txt) {
				footnote_area.html(txt);
			} else {
				footnote_area.remove();
				footnote_area = null;
			}
			return footnote_area;
		},
		get_args_dict_from_url: function(txt) {
			var args = {};
			$.each(decodeURIComponent(txt).split("&"), function(i, arg) {
				arg = arg.split("=");
				args[arg[0]] = arg[1];
			});
			return args;
		},
		get_url_from_dict: function(args) {
			return $.map(args, function(val, key) {
				if (val!==null)
					{ return encodeURIComponent(key)+"="+encodeURIComponent(val); }
				else
					{ return null; }
			}).join("&") || "";
		},
		validate_type: function ( val, type ) {
			// from https://github.com/guillaumepotier/Parsley.js/blob/master/parsley.js#L81
			var regExp;

			switch ( type ) {
				case "phone":
					regExp = /^([0-9 +_\-,.*#()]){1,20}$/;
					break;
				case "name":
					regExp = /^[\w][\w'-]*([ \w][\w'-]+)*$/;
					break;
				case "number":
					regExp = /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/;
					break;
				case "digits":
					regExp = /^\d+$/;
					break;
				case "alphanum":
					regExp = /^\w+$/;
					break;
				case "email":
					// from https://emailregex.com/
					regExp = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
					break;
				case "url":
					regExp = /^((([A-Za-z0-9.+-]+:(?:\/\/)?)(?:[-;:&=\+\,\w]@)?[A-Za-z0-9.-]+(:[0-9]+)?|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)$/i;
					break;
				case "dateIso":
					regExp = /^(\d{4})\D?(0[1-9]|1[0-2])\D?([12]\d|0[1-9]|3[01])$/;
					break;
				default:
					return false;
			}

			// test regExp if not null
			return '' !== val ? regExp.test( val ) : false;
		},
		guess_style: function(text, default_style, _colour) {
			var style = default_style || "default";
			var colour = "gray";
			if (text) {
				if (has_words(["Pending", "Review", "Medium", "Not Approved"], text)) {
					style = "warning";
					colour = "orange";
				} else if (has_words(["Open", "Urgent", "High", "Failed", "Rejected", "Error"], text)) {
					style = "danger";
					colour = "red";
				} else if (has_words(["Closed", "Finished", "Converted", "Completed", "Complete", "Confirmed",
					"Approved", "Yes", "Active", "Available", "Paid", "Success"], text)) {
					style = "success";
					colour = "green";
				} else if (has_words(["Submitted"], text)) {
					style = "info";
					colour = "blue";
				}
			}
			return _colour ? colour : style;
		},

		guess_colour: function(text) {
			return frappe.utils.guess_style(text, null, true);
		},

		get_indicator_color: function(state) {
			return frappe.db.get_list('Workflow State', {filters: {name: state}, fields: ['name', 'style']}).then(function (res) {
				var state = res[0];
				if (!state.style) {
					return frappe.utils.guess_colour(state.name);
				}
				var style = state.style;
				var colour_map = {
					"Success": "green",
					"Warning": "orange",
					"Danger": "red",
					"Primary": "blue",
				};

				return colour_map[style];
			});

		},

		sort: function(list, key, compare_type, reverse) {
			if (!list || list.length < 2)
				{ return list || []; }

			var sort_fn = {
				"string": function(a, b) {
					return cstr(a[key]).localeCompare(cstr(b[key]));
				},
				"number": function(a, b) {
					return flt(a[key]) - flt(b[key]);
				}
			};

			if (!compare_type)
				{ compare_type = typeof list[0][key]==="string" ? "string" : "number"; }

			list.sort(sort_fn[compare_type]);

			if (reverse) {
				list.reverse();
			}

			return list;
		},

		unique: function(list) {
			var dict = {},
				arr = [];
			for (var i=0, l=list.length; i < l; i++) {
				if (!(list[i] in dict)) {
					dict[list[i]] = null;
					arr.push(list[i]);
				}
			}
			return arr;
		},

		remove_nulls: function(list) {
			var new_list = [];
			for (var i=0, l=list.length; i < l; i++) {
				if (!is_null(list[i])) {
					new_list.push(list[i]);
				}
			}
			return new_list;
		},

		all: function(lst) {
			for (var i=0, l=lst.length; i<l; i++) {
				if (!lst[i]) {
					return false;
				}
			}
			return true;
		},

		dict: function(keys, values) {
			// make dictionaries from keys and values
			var out = [];
			$.each(values, function(row_idx, row) {
				var new_row = {};
				$.each(keys, function(key_idx, key) {
					new_row[key] = row[key_idx];
				});
				out.push(new_row);
			});
			return out;
		},

		sum: function(list) {
			return list.reduce(function(previous_value, current_value) {
				return flt(previous_value) + flt(current_value);
			}, 0.0);
		},

		arrays_equal: function(arr1, arr2) {
			if (!arr1 || !arr2) {
				return false;
			}
			if (arr1.length != arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if ($.isArray(arr1[i])) {
					if (!frappe.utils.arrays_equal(arr1[i], arr2[i])) {
						return false;
					}
				} else if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		},

		intersection: function(a, b) {
			// from stackoverflow: http://stackoverflow.com/questions/1885557/simplest-code-for-array-intersection-in-javascript
			/* finds the intersection of
			 * two arrays in a simple fashion.
			 *
			 * PARAMS
			 *  a - first array, must already be sorted
			 *  b - second array, must already be sorted
			 *
			 * NOTES
			 *
			 *  Should have O(n) operations, where n is
			 *    n = MIN(a.length(), b.length())
			 */
			var ai=0, bi=0;
			var result = new Array();

			// sorted copies
			a = ([].concat(a)).sort();
			b = ([].concat(b)).sort();

			while ( ai < a.length && bi < b.length ) {
				if (a[ai] < b[bi] ) {
					ai++;
				} else if (a[ai] > b[bi] ) {
					bi++;
				} else {
					/* they're equal */
					result.push(a[ai]);
					ai++;
					bi++;
				}
			}

			return result;
		},

		resize_image: function(reader, callback, max_width, max_height) {
			var tempImg = new Image();
			if (!max_width) { max_width = 600; }
			if (!max_height) { max_height = 400; }
			tempImg.src = reader.result;

			tempImg.onload = function() {
				var tempW = tempImg.width;
				var tempH = tempImg.height;
				if (tempW > tempH) {
					if (tempW > max_width) {
						tempH *= max_width / tempW;
						tempW = max_width;
					}
				} else {
					if (tempH > max_height) {
						tempW *= max_height / tempH;
						tempH = max_height;
					}
				}

				var canvas = document.createElement('canvas');
				canvas.width = tempW;
				canvas.height = tempH;
				var ctx = canvas.getContext("2d");
				ctx.drawImage(this, 0, 0, tempW, tempH);
				var dataURL = canvas.toDataURL("image/jpeg");
				setTimeout(function() {
					callback(dataURL);
				}, 10 );
			};
		},

		csv_to_array: function (strData, strDelimiter) {
			// Check to see if the delimiter is defined. If not,
			// then default to comma.
			strDelimiter = (strDelimiter || ",");

			// Create a regular expression to parse the CSV values.
			var objPattern = new RegExp(
				(
					// Delimiters.
					"(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

					// Quoted fields.
					"(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

					// Standard fields.
					"([^\"\\" + strDelimiter + "\\r\\n]*))"
				),
				"gi"
			);


			// Create an array to hold our data. Give the array
			// a default empty first row.
			var arrData = [[]];

			// Create an array to hold our individual pattern
			// matching groups.
			var arrMatches = null;


			// Keep looping over the regular expression matches
			// until we can no longer find a match.
			while ((arrMatches = objPattern.exec( strData ))) {

				// Get the delimiter that was found.
				var strMatchedDelimiter = arrMatches[ 1 ];

				// Check to see if the given delimiter has a length
				// (is not the start of string) and if it matches
				// field delimiter. If id does not, then we know
				// that this delimiter is a row delimiter.
				if (
					strMatchedDelimiter.length &&
					strMatchedDelimiter !== strDelimiter
				) {

					// Since we have reached a new row of data,
					// add an empty row to our data array.
					arrData.push( [] );

				}

				var strMatchedValue;

				// Now that we have our delimiter out of the way,
				// let's check to see which kind of value we
				// captured (quoted or unquoted).
				if (arrMatches[ 2 ]) {

					// We found a quoted value. When we capture
					// this value, unescape any double quotes.
					strMatchedValue = arrMatches[ 2 ].replace(
						new RegExp( "\"\"", "g" ),
						"\""
					);

				} else {

					// We found a non-quoted value.
					strMatchedValue = arrMatches[ 3 ];

				}


				// Now that we have our value string, let's add
				// it to the data array.
				arrData[ arrData.length - 1 ].push( strMatchedValue );
			}

			// Return the parsed data.
			return ( arrData );
		},

		warn_page_name_change: function() {
			frappe.msgprint(__("Note: Changing the Page Name will break previous URL to this page."));
		},

		notify: function(subject, body, route, onclick) {
			console.log('push notifications are evil and deprecated');
		},

		set_title: function(title) {
			frappe._original_title = title;
			if (frappe._title_prefix) {
				title = frappe._title_prefix + " " + title.replace(/<[^>]*>/g, "");
			}
			document.title = title;

			// save for re-routing
			var sub_path = frappe.router.get_sub_path();
			frappe.route_titles[sub_path] = title;
		},

		set_title_prefix: function(prefix) {
			frappe._title_prefix = prefix;

			// reset the original title
			frappe.utils.set_title(frappe._original_title);
		},

		is_image_file: function(filename) {
			if (!filename) { return false; }
			// url can have query params
			filename = filename.split('?')[0];
			return (/\.(gif|jpg|jpeg|tiff|png|svg)$/i).test(filename);
		},

		play_sound: function(name) {
			try {
				if (frappe.boot.user.mute_sounds) {
					return;
				}

				var audio = $("#sound-" + name)[0];
				audio.volume = audio.getAttribute("volume");
				audio.play();

			} catch (e) {
				console.log("Cannot play sound", name, e);
				// pass
			}

		},
		split_emails: function(txt) {
			var email_list = [];

			if (!txt) {
				return email_list;
			}

			// emails can be separated by comma or newline
			txt.split(/[,\n](?=(?:[^"]|"[^"]*")*$)/g).forEach(function(email) {
				email = email.trim();
				if (email) {
					email_list.push(email);
				}
			});

			return email_list;
		},
		supportsES6: function() {
			try {
				new Function("(a = 0) => a");
				return true;
			} catch (err) {
				return false;
			}
		}(),
		throttle: function (func, wait, options) {
			var context, args, result;
			var timeout = null;
			var previous = 0;
			if (!options) { options = {}; }

			var later = function () {
				previous = options.leading === false ? 0 : Date.now();
				timeout = null;
				result = func.apply(context, args);
				if (!timeout) { context = args = null; }
			};

			return function () {
				var now = Date.now();
				if (!previous && options.leading === false) { previous = now; }
				var remaining = wait - (now - previous);
				context = this;
				args = arguments;
				if (remaining <= 0 || remaining > wait) {
					if (timeout) {
						clearTimeout(timeout);
						timeout = null;
					}
					previous = now;
					result = func.apply(context, args);
					if (!timeout) { context = args = null; }
				} else if (!timeout && options.trailing !== false) {
					timeout = setTimeout(later, remaining);
				}
				return result;
			};
		},
		debounce: function(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) { func.apply(context, args); }
				};
				var callNow = immediate && !timeout;
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (callNow) { func.apply(context, args); }
			};
		},
		get_form_link: function(doctype, name, html, display_text, query_params_obj) {
			if ( html === void 0 ) html=false;
			if ( display_text === void 0 ) display_text=null;
			if ( query_params_obj === void 0 ) query_params_obj=null;

			display_text = display_text || name;
			name = encodeURIComponent(name);
			var route = "/app/" + (encodeURIComponent(doctype.toLowerCase().replace(/ /g, '-'))) + "/" + name;
			if (query_params_obj) {
				route += frappe.utils.make_query_string(query_params_obj);
			}
			if (html) {
				return ("<a href=\"" + route + "\">" + display_text + "</a>");
			}
			return route;
		},
		get_route_label: function get_route_label(route_str) {
			var route = route_str.split('/');

			if (route[2] === 'Report' || route[0] === 'query-report') {
				return __('{0} Report', [route[3] || route[1]]);
			}
			if (route[0] === 'List') {
				return __('{0} List', [route[1]]);
			}
			if (route[0] === 'modules') {
				return __('{0} Modules', [route[1]]);
			}
			if (route[0] === 'dashboard') {
				return __('{0} Dashboard', [route[1]]);
			}
			return __(frappe.utils.to_title_case(route[0], true));
		},
		report_column_total: function(values, column, type) {
			if (column.column.disable_total) {
				return '';
			} else if (values.length > 0) {
				if (column.column.fieldtype == "Percent" || type === "mean") {
					return values.reduce(function (a, b) { return a + flt(b); }) / values.length;
				} else if (column.column.fieldtype == "Int") {
					return values.reduce(function (a, b) { return a + cint(b); });
				} else if (frappe.model.is_numeric_field(column.column.fieldtype)) {
					return values.reduce(function (a, b) { return a + flt(b); });
				} else {
					return null;
				}
			} else {
				return null;
			}
		},
		setup_search: function setup_search($wrapper, el_class, text_class, data_attr) {
			var $search_input = $wrapper.find('[data-element="search"]').show();
			$search_input.focus().val('');
			var $elements = $wrapper.find(el_class).show();

			$search_input.off('keyup').on('keyup', function () {
				var text_filter = $search_input.val().toLowerCase();
				// Replace trailing and leading spaces
				text_filter = text_filter.replace(/^\s+|\s+$/g, '');
				for (var i = 0; i < $elements.length; i++) {
					var text_element = $elements.eq(i).find(text_class);
					var text = text_element.text().toLowerCase();

					var name = '';
					if (data_attr && text_element.attr(data_attr)) {
						name = text_element.attr(data_attr).toLowerCase();
					}

					if (text.includes(text_filter) || name.includes(text_filter)) {
						$elements.eq(i).css('display', '');
					} else {
						$elements.eq(i).css('display', 'none');
					}
				}
			});
		},
		deep_equal: function deep_equal$1(a, b) {
			return fastDeepEqual(a, b);
		},

		file_name_ellipsis: function file_name_ellipsis(filename, length) {
			var first_part_length = length * 2 / 3;
			var last_part_length = length - first_part_length;
			var parts = filename.split('.');
			var extn = parts.pop();
			var name = parts.join('');
			var first_part = name.slice(0, first_part_length);
			var last_part = name.slice(-last_part_length);
			if (name.length > length) {
				return (first_part + "..." + last_part + "." + extn);
			} else {
				return filename;
			}
		},
		get_decoded_string: function get_decoded_string(dataURI) {
			// decodes base64 to string
			var parts = dataURI.split(',');
			var encoded_data = parts[1];
			var decoded = atob(encoded_data);
			try {
				var escaped = escape(decoded);
				decoded = decodeURIComponent(escaped);

			} catch (e) {
				// pass decodeURIComponent failure
				// just return atob response
			}
			return decoded;
		},
		copy_to_clipboard: function copy_to_clipboard(string) {
			var input = $("<input>");
			$("body").append(input);
			input.val(string).select();

			document.execCommand("copy");
			input.remove();

			frappe.show_alert({
				indicator: 'green',
				message: __('Copied to clipboard.')
			});
		},
		is_rtl: function is_rtl(lang) {
			if ( lang === void 0 ) lang=null;

			return ["ar", "he", "fa", "ps"].includes(lang || frappe.boot.lang);
		},
		bind_actions_with_object: function bind_actions_with_object($el, object) {
			// remove previously bound event
			$($el).off('click.class_actions');
			// attach new event
			$($el).on('click.class_actions', '[data-action]', function (e) {
				var $target = $(e.currentTarget);
				var action = $target.data('action');
				var method = object[action];
				method ? object[action](e, $target) : null;
			});

			return $el;
		},
		
		eval: function eval$1(code, context) {
			if ( context === void 0 ) context={};

			var variable_names = Object.keys(context);
			var variables = Object.values(context);
			code = "let out = " + code + "; return out";
			try {
				var expression_function = new (Function.prototype.bind.apply( Function, [ null ].concat( variable_names, [code]) ));
				return expression_function.apply(void 0, variables);
			} catch (error) {
				console.log('Error evaluating the following expression:'); // eslint-disable-line no-console
				console.error(code); // eslint-disable-line no-console
				throw error;
			}
		},

		get_browser: function get_browser() {
			var ua = navigator.userAgent;
			var tem;
			var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

			if (/trident/i.test(M[1])) {
				tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
				return { name: "IE", version: tem[1] || "" };
			}
			if (M[1] === "Chrome") {
				tem = ua.match(/\bOPR|Edge\/(\d+)/);
				if (tem != null) {
					return { name: "Opera", version: tem[1] };
				}
			}
			M = M[2]
				? [M[1], M[2]]
				: [navigator.appName, navigator.appVersion, "-?"];
			if ((tem = ua.match(/version\/(\d+)/i)) != null) {
				M.splice(1, 1, tem[1]);
			}
			return {
				name: M[0],
				version: M[1],
			};
		},

		get_formatted_duration: function get_formatted_duration(value, duration_options) {
			if ( duration_options === void 0 ) duration_options=null;

			var duration = '';
			if (!duration_options) {
				duration_options = {
					hide_days: 0,
					hide_seconds: 0
				};
			}
			if (value) {
				var total_duration = frappe.utils.seconds_to_duration(value, duration_options);

				if (total_duration.days) {
					duration += total_duration.days + __('d', null, 'Days (Field: Duration)');
				}
				if (total_duration.hours) {
					duration += (duration.length ? " " : "");
					duration += total_duration.hours + __('h', null, 'Hours (Field: Duration)');
				}
				if (total_duration.minutes) {
					duration += (duration.length ? " " : "");
					duration += total_duration.minutes + __('m', null, 'Minutes (Field: Duration)');
				}
				if (total_duration.seconds) {
					duration += (duration.length ? " " : "");
					duration += total_duration.seconds + __('s', null, 'Seconds (Field: Duration)');
				}
			}
			return duration;
		},

		seconds_to_duration: function seconds_to_duration(value, duration_options) {
			var secs = value;
			var total_duration = {
				days: Math.floor(secs / (3600 * 24)),
				hours: Math.floor(secs % (3600 * 24) / 3600),
				minutes: Math.floor(secs % 3600 / 60),
				seconds: Math.floor(secs % 60)
			};
			if (duration_options.hide_days) {
				total_duration.hours = Math.floor(secs / 3600);
				total_duration.days = 0;
			}
			return total_duration;
		},

		duration_to_seconds: function duration_to_seconds(days, hours, minutes, seconds) {
			if ( days === void 0 ) days=0;
			if ( hours === void 0 ) hours=0;
			if ( minutes === void 0 ) minutes=0;
			if ( seconds === void 0 ) seconds=0;

			var value = 0;
			if (days) {
				value += days * 24 * 60 * 60;
			}
			if (hours) {
				value += hours * 60 * 60;
			}
			if (minutes) {
				value += minutes * 60;
			}
			if (seconds) {
				value += seconds;
			}
			return value;
		},

		get_duration_options: function(docfield) {
			var duration_options = {
				hide_days: docfield.hide_days,
				hide_seconds: docfield.hide_seconds
			};
			return duration_options;
		},

		get_number_system: function (country) {
			var number_system_map = {
				'India':
					[{
						divisor: 1.0e+7,
						symbol: 'Cr'
					},
					{
						divisor: 1.0e+5,
						symbol: 'Lakh'
					}],
				'':
					[{
						divisor: 1.0e+12,
						symbol: 'T'
					},
					{
						divisor: 1.0e+9,
						symbol: 'B'
					},
					{
						divisor: 1.0e+6,
						symbol: 'M'
					},
					{
						divisor: 1.0e+3,
						symbol: 'K',
					}]
			};

			if (!Object.keys(number_system_map).includes(country)) { country = ''; }

			return number_system_map[country];
		},

		map_defaults: {
			center: [19.0800, 72.8961],
			zoom: 13,
			tiles: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
			options: {
				attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
			}
		},

		icon: function icon(icon_name, size, icon_class) {
			if ( size === void 0 ) size="sm";
			if ( icon_class === void 0 ) icon_class="";

			var size_class = "";
			var icon_style = "";
			if (typeof size == "object") {
				icon_style = "width: " + (size.width) + "; height: " + (size.height);
			} else {
				size_class = "icon-" + size;
			}
			return ("<svg class=\"icon " + size_class + "\" style=\"" + icon_style + "\">\n\t\t\t<use class=\"" + icon_class + "\" href=\"#icon-" + icon_name + "\"></use>\n\t\t</svg>");
		},

		make_chart: function make_chart(wrapper, custom_options) {
			if ( custom_options === void 0 ) custom_options={};

			var chart_args = {
				type: 'bar',
				colors: ['light-blue'],
				axisOptions: {
					xIsSeries: 1,
					shortenYAxisNumbers: 1,
					xAxisMode: 'tick'
				}
			};

			for (var key in custom_options) {
				if (typeof chart_args[key] === 'object' && typeof custom_options[key] === 'object') {
					chart_args[key] = Object.assign(chart_args[key], custom_options[key]);
				} else {
					chart_args[key] = custom_options[key];
				}
			}

			return new frappe.Chart(wrapper, chart_args);
		},

		generate_route: function generate_route(item) {
			var type = item.type.toLowerCase();
			if (type === "doctype") {
				item.doctype = item.name;
			}
			var route = "";
			if (!item.route) {
				if (item.link) {
					route = strip(item.link, "#");
				} else if (type === "doctype") {
					var doctype_slug = frappe.router.slug(item.doctype);

					if (frappe.model.is_single(item.doctype)) {
						route = doctype_slug;
					} else {
						if (!item.doc_view) {
							if (frappe.model.is_tree(item.doctype)) {
								item.doc_view = "Tree";
							} else {
								item.doc_view = "List";
							}
						}

						switch (item.doc_view) {
							case "List":
								if (item.filters) {
									frappe.route_options = item.filters;
								}
								route = doctype_slug;
								break;
							case "Tree":
								route = doctype_slug + "/view/tree";
								break;
							case "Report Builder":
								route = doctype_slug + "/view/report";
								break;
							case "Dashboard":
								route = doctype_slug + "/view/dashboard";
								break;
							case "New":
								route = doctype_slug + "/new";
								break;
							case "Calendar":
								route = doctype_slug + "/view/calendar/default";
								break;
							default:
								frappe.throw({ message: __("Not a valid view:") + item.doc_view, title: __("Unknown View") });
								route = "";
						}
					}
				} else if (type === "report") {
					if (item.is_query_report) {
						route = "query-report/" + item.name;
					} else if (!item.doctype) {
						route = "/report/" + item.name;
					} else {
						route = frappe.router.slug(item.doctype) + "/view/report/" + item.name;
					}
				} else if (type === "page") {
					route = item.name;
				} else if (type === "dashboard") {
					route = "dashboard-view/" + (item.name);
				}

			} else {
				route = item.route;
			}

			if (item.route_options) {
				route +=
					"?" +
					$.map(item.route_options, function (value, key) {
						return (
							encodeURIComponent(key) + "=" + encodeURIComponent(value)
						);
					}).join("&");
			}

			// if(type==="page" || type==="help" || type==="report" ||
			// (item.doctype && frappe.model.can_read(item.doctype))) {
			//     item.shown = true;
			// }
			return ("/app/" + route);
		},

		shorten_number: function (number, country, min_length, max_no_of_decimals) {
			if ( min_length === void 0 ) min_length=4;
			if ( max_no_of_decimals === void 0 ) max_no_of_decimals=2;

			/* returns the number as an abbreviated string
			 * PARAMS
			 *  number - number to be shortened
			 *  country - country that determines the numnber system to be used
			 *  min_length - length below which the number will not be shortened
			 *	max_no_of_decimals - max number of decimals of the shortened number
			*/

			// return number if total digits is lesser than min_length
			var len = String(number).match(/\d/g).length;
			if (len < min_length) { return number.toString(); }

			var number_system = this.get_number_system(country);
			var x = Math.abs(Math.round(number));
			for (var i = 0, list = number_system; i < list.length; i += 1) {
				var map = list[i];

				if (x >= map.divisor) {
					var result = number/map.divisor;
					var no_of_decimals = this.get_number_of_decimals(result);
					/*
						If no_of_decimals is greater than max_no_of_decimals,
						round the number to max_no_of_decimals
					*/
					result = no_of_decimals > max_no_of_decimals
						? result.toFixed(max_no_of_decimals)
						: result;
					return result + ' ' + map.symbol;
				}
			}

			return number.toFixed(max_no_of_decimals);
		},

		get_number_of_decimals: function (number) {
			if (Math.floor(number) === number) { return 0; }
			return number.toString().split(".")[1].length || 0;
		},

		build_summary_item: function build_summary_item(summary) {
			if (summary.type == "separator") {
				return $(("<div class=\"summary-separator\">\n\t\t\t\t<div class=\"summary-value " + (summary.color ? summary.color.toLowerCase() : 'text-muted') + "\">" + (summary.value) + "</div>\n\t\t\t</div>"));
			}
			var df = { fieldtype: summary.datatype };
			var doc = null;
			if (summary.datatype == "Currency") {
				df.options = "currency";
				doc = { currency: summary.currency };
			}

			var value = frappe.format(summary.value, df, { only_value: true }, doc);
			var color = summary.indicator ? summary.indicator.toLowerCase()
				: summary.color ? summary.color.toLowerCase() : '';

			return $(("<div class=\"summary-item\">\n\t\t\t<span class=\"summary-label\">" + (summary.label) + "</span>\n\t\t\t<div class=\"summary-value " + color + "\">" + value + "</div>\n\t\t</div>"));
		},

		print: function print(doctype, docname, print_format, letterhead, lang_code) {
			var w = window.open(
				frappe.urllib.get_full_url(
					'/printview?doctype=' +
					encodeURIComponent(doctype) +
					'&name=' +
					encodeURIComponent(docname) +
					'&trigger_print=1' +
					'&format=' +
					encodeURIComponent(print_format) +
					'&no_letterhead=' +
					(letterhead ? '0' : '1') +
					'&letterhead=' +
					encodeURIComponent(letterhead) +
					(lang_code ? '&_lang=' + lang_code : '')
				)
			);

			if (!w) {
				frappe.msgprint(__('Please enable pop-ups'));
				return;
			}
		},

		get_clipboard_data: function get_clipboard_data(clipboard_paste_event) {
			var e = clipboard_paste_event;
			var clipboard_data = e.clipboardData || window.clipboardData || e.originalEvent.clipboardData;
			return clipboard_data.getData('Text');
		}
	});

	frappe.provide('frappe.utils');
	/**
	 * Simple EventEmitterMixin which uses jQuery's event system
	 */
	var EventEmitterMixin = {
		init: function init() {
			this.jq = jQuery({});
		},

		trigger: function trigger(evt, data) {
			!this.jq && this.init();
			this.jq.trigger(evt, data);
		},

		once: function once(evt, handler) {
			!this.jq && this.init();
			this.jq.one(evt, function (e, data) { return handler(data); });
		},

		on: function on(evt, handler) {
			!this.jq && this.init();
			this.jq.bind(evt, function (e, data) { return handler(data); });
		},

		off: function off(evt, handler) {
			!this.jq && this.init();
			this.jq.unbind(evt, function (e, data) { return handler(data); });
		}
	};

	frappe.utils.make_event_emitter = function(object) {
		Object.assign(object, EventEmitterMixin);
		return object;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// route urls to their virtual pages

	// re-route map (for rename)
	frappe.provide('frappe.views');
	frappe.re_route = {"#login": ""};
	frappe.route_titles = {};
	frappe.route_flags = {};
	frappe.route_history = [];
	frappe.view_factory = {};
	frappe.view_factories = [];
	frappe.route_options = null;
	frappe.route_hooks = {};

	$(window).on('hashchange', function(e) {
		// v1 style routing, route is in hash
		if (window.location.hash && !frappe.router.is_app_route(e.currentTarget.pathname)) {
			var sub_path = frappe.router.get_sub_path(window.location.hash);
			frappe.router.push_state(sub_path);
			return false;
		}
	});

	window.addEventListener('popstate', function (e) {
		// forward-back button, just re-render based on current route
		frappe.router.route();
		e.preventDefault();
		return false;
	});

	// routing v2, capture all clicks so that the target is managed with push-state
	$('body').on('click', 'a', function(e) {
		var override = function (route) {
			e.preventDefault();
			frappe.set_route(route);
			return false;
		};

		var href = e.currentTarget.getAttribute('href');

		// click handled, but not by href
		if (e.currentTarget.getAttribute('onclick') // has a handler
			|| (e.ctrlKey || e.metaKey) // open in a new tab
			|| href==='#') { // hash is home
			return;
		}

		if (href === '') {
			return override('/app');
		}

		if (href && href.startsWith('#')) {
			// target startswith "#", this is a v1 style route, so remake it.
			return override(e.currentTarget.hash);
		}

		if (frappe.router.is_app_route(e.currentTarget.pathname)) {
			// target has "/app, this is a v2 style route.
			return override(e.currentTarget.pathname + e.currentTarget.hash);
		}
	});

	frappe.router = {
		current_route: null,
		routes: {},
		factory_views: ['form', 'list', 'report', 'tree', 'print', 'dashboard'],
		list_views: ['list', 'kanban', 'report', 'calendar', 'tree', 'gantt', 'dashboard', 'image', 'inbox'],
		layout_mapped: {},

		is_app_route: function is_app_route(path) {
			// desk paths must begin with /app or doctype route
			if (path.substr(0, 1) === '/') { path = path.substr(1); }
			path = path.split('/');
			if (path[0]) {
				return path[0]==='app';
			}
		},

		setup: function setup() {
			// setup the route names by forming slugs of the given doctypes
			for (var i = 0, list = frappe.boot.user.can_read; i < list.length; i += 1) {
				var doctype = list[i];

				this.routes[this.slug(doctype)] = {doctype: doctype};
			}
			if (frappe.boot.doctype_layouts) {
				for (var i$1 = 0, list$1 = frappe.boot.doctype_layouts; i$1 < list$1.length; i$1 += 1) {
					var doctype_layout = list$1[i$1];

					this.routes[this.slug(doctype_layout.name)] = {doctype: doctype_layout.document_type, doctype_layout: doctype_layout.name };
				}
			}
		},

		route: function route() {
			// resolve the route from the URL or hash
			// translate it so the objects are well defined
			// and render the page as required

			if (!frappe.app) { return; }

			var sub_path = this.get_sub_path();
			if (this.re_route(sub_path)) { return; }

			this.current_sub_path = sub_path;
			this.current_route = this.parse();
			this.set_history(sub_path);
			this.render();
			this.set_title(sub_path);
			this.trigger('change');
		},

		parse: function parse(route) {
			route = this.get_sub_path_string(route).split('/');
			if (!route) { return []; }
			route = $.map(route, this.decode_component);
			this.set_route_options_from_url(route);
			return this.convert_to_standard_route(route);
		},

		convert_to_standard_route: function convert_to_standard_route(route) {
			// /app/settings = ["Workspaces", "Settings"]
			// /app/user = ["List", "User"]
			// /app/user/view/report = ["List", "User", "Report"]
			// /app/user/view/tree = ["Tree", "User"]
			// /app/user/user-001 = ["Form", "User", "user-001"]
			// /app/user/user-001 = ["Form", "User", "user-001"]
			// /app/event/view/calendar/default = ["List", "Event", "Calendar", "Default"]

			if (frappe.workspaces[route[0]]) {
				// workspace
				route = ['Workspaces', frappe.workspaces[route[0]].name];
			} else if (this.routes[route[0]]) {
				// route
				route = this.set_doctype_route(route);
			}

			return route;
		},

		set_doctype_route: function set_doctype_route(route) {
			var doctype_route = this.routes[route[0]];
			// doctype route
			if (route[1]) {
				if (route[2] && route[1]==='view') {
					route = this.get_standard_route_for_list(route, doctype_route);
				} else {
					var docname = route[1];
					if (route.length > 2) {
						docname = route.slice(1).join('/');
					}
					route = ['Form', doctype_route.doctype, docname];
				}
			} else if (frappe.model.is_single(doctype_route.doctype)) {
				route = ['Form', doctype_route.doctype, doctype_route.doctype];
			} else {
				route = ['List', doctype_route.doctype, 'List'];
			}

			if (doctype_route.doctype_layout) {
				// set the layout
				this.doctype_layout = doctype_route.doctype_layout;
			}

			return route;
		},

		get_standard_route_for_list: function get_standard_route_for_list(route, doctype_route) {
			var standard_route;
			if (route[2].toLowerCase()==='tree') {
				standard_route = ['Tree', doctype_route.doctype];
			} else {
				standard_route = ['List', doctype_route.doctype, frappe.utils.to_title_case(route[2])];
				// calendar / kanban / dashboard / folder
				if (route[3]) { standard_route.push.apply(standard_route, route.slice(3, route.length)); }
			}
			return standard_route;
		},

		set_history: function set_history() {
			frappe.route_history.push(this.current_route);
			frappe.ui.hide_open_dialog();
		},

		render: function render() {
			if (this.current_route[0]) {
				this.render_page();
			} else {
				// Show home
				frappe.views.pageview.show('');
			}
		},

		render_page: function render_page() {
			// create the page generator (factory) object and call `show`
			// if there is no generator, render the `Page` object

			var route = this.current_route;
			var factory = frappe.utils.to_title_case(route[0]);

			if (route[1] && frappe.views[factory + "Factory"]) {
				route[0] = factory;
				// has a view generator, generate!
				if (!frappe.view_factory[factory]) {
					frappe.view_factory[factory] = new frappe.views[factory + "Factory"]();
				}

				frappe.view_factory[factory].show();
			} else {
				// show page
				var route_name = frappe.utils.xss_sanitise(route[0]);
				if (frappe.views.pageview) {
					frappe.views.pageview.show(route_name);
				}
			}
		},

		re_route: function re_route(sub_path) {
			if (frappe.re_route[sub_path] !== undefined) {
				// after saving a doc, for example,
				// "new-doctype-1" and the renamed "TestDocType", both exist in history
				// now if we try to go back,
				// it doesn't allow us to go back to the one prior to "new-doctype-1"
				// Hence if this check is true, instead of changing location hash,
				// we just do a back to go to the doc previous to the "new-doctype-1"
				var re_route_val = this.get_sub_path(frappe.re_route[sub_path]);
				if (re_route_val === this.current_sub_path) {
					window.history.back();
				} else {
					frappe.set_route(re_route_val);
				}

				return true;
			}
		},

		clear_re_route: function clear_re_route(doctype, docname) {
			delete frappe.re_route[
				((encodeURIComponent(frappe.router.slug(doctype))) + "/" + (encodeURIComponent(docname)))
			];
		},

		set_title: function set_title(sub_path) {
			if (frappe.route_titles[sub_path]) {
				frappe.utils.set_title(frappe.route_titles[sub_path]);
			}
		},

		set_route: function set_route() {
			var this$1 = this;

			// set the route (push state) with given arguments
			// example 1: frappe.set_route('a', 'b', 'c');
			// example 2: frappe.set_route(['a', 'b', 'c']);
			// example 3: frappe.set_route('a/b/c');
			var route = Array.from(arguments);

			return new Promise(function (resolve) {
				route = this$1.get_route_from_arguments(route);
				route = this$1.convert_from_standard_route(route);
				var sub_path = this$1.make_url(route);
				this$1.push_state(sub_path);

				setTimeout(function () {
					frappe.after_ajax && frappe.after_ajax(function () {
						resolve();
					});
				}, 100);
			});
		},

		get_route_from_arguments: function get_route_from_arguments(route) {
			if (route.length===1 && $.isArray(route[0])) {
				// called as frappe.set_route(['a', 'b', 'c']);
				route = route[0];
			}

			if (route.length===1 && route[0] && route[0].includes('/')) {
				// called as frappe.set_route('a/b/c')
				route = $.map(route[0].split('/'), this.decode_component);
			}

			if (route && route[0] == '') {
				route.shift();
			}

			if (route && ['desk', 'app'].includes(route[0])) {
				// we only need subpath, remove "app" (or "desk")
				route.shift();
			}

			return route;

		},

		convert_from_standard_route: function convert_from_standard_route(route) {
			// ["List", "Sales Order"] => /sales-order
			// ["Form", "Sales Order", "SO-0001"] => /sales-order/SO-0001
			// ["Tree", "Account"] = /account/view/tree

			var view = route[0] ? route[0].toLowerCase() : '';
			var new_route = route;
			if (view === 'list') {
				if (route[2] && route[2] !== 'list' && !$.isPlainObject(route[2])) {
					new_route = [this.slug(route[1]), 'view', route[2].toLowerCase()];

					// calendar / inbox / file folder
					if (route[3]) { new_route.push.apply(new_route, route.slice(3, route.length)); }
				} else {
					if ($.isPlainObject(route[2])) {
						frappe.route_options = route[2];
					}
					new_route = [this.slug(route[1])];
				}
			} else if (view === 'form') {
				new_route = [this.slug(route[1])];
				if (route[2]) {
					// if not single
					new_route.push(route[2]);
				}
			} else if (view === 'tree') {
				new_route = [this.slug(route[1]), 'view', 'tree'];
			}
			return new_route;
		},

		slug_parts: function slug_parts(route) {
			// slug doctype

			// if app is part of the route, then first 2 elements are "" and "app"
			if (route[0] && this.factory_views.includes(route[0].toLowerCase())) {
				route[0] = route[0].toLowerCase();
				route[1] = this.slug(route[1]);
			}
			return route;
		},

		make_url: function make_url(params) {
			var path_string = $.map(params, function(a) {
				if ($.isPlainObject(a)) {
					frappe.route_options = a;
					return null;
				} else {
					a = String(a);
					if (a && a.match(/[%'"\s\t]/)) {
						// if special chars, then encode
						a = encodeURIComponent(a);
					}
					return a;
				}
			}).join('/');

			return '/app/' + (path_string || 'home');
		},

		push_state: function push_state(url) {
			// change the URL and call the router
			if (window.location.pathname !== url) {

				// push state so the browser looks fine
				history.pushState(null, null, url);

				// now process the route
				this.route();
			}
		},

		get_sub_path_string: function get_sub_path_string(route) {
			// return clean sub_path from hash or url
			// supports both v1 and v2 routing
			if (!route) {
				route = window.location.pathname + window.location.hash + window.location.search;
				if (route.includes('app#')) {
					// to support v1
					route = window.location.hash;
				}
			}

			return this.strip_prefix(route);
		},

		strip_prefix: function strip_prefix(route) {
			if (route.substr(0, 1)=='/') { route = route.substr(1); } // for /app/sub
			if (route.startsWith('app/')) { route = route.substr(4); } // for desk/sub
			if (route == 'app') { route = route.substr(4); } // for /app
			if (route.substr(0, 1)=='/') { route = route.substr(1); }
			if (route.substr(0, 1)=='#') { route = route.substr(1); }
			if (route.substr(0, 1)=='!') { route = route.substr(1); }
			return route;
		},

		get_sub_path: function get_sub_path(route) {
			var sub_path = this.get_sub_path_string(route);
			route = $.map(sub_path.split('/'), this.decode_component).join('/');

			return route;
		},

		set_route_options_from_url: function set_route_options_from_url(route) {
			// set query parameters as frappe.route_options
			var last_part = route[route.length - 1];
			if (last_part.indexOf("?") < last_part.indexOf("=")) {
				// has ? followed by =
				var parts = last_part.split("?");

				// route should not contain string after ?
				route[route.length - 1] = parts[0];

				var query_params = frappe.utils.get_query_params(parts[1]);
				frappe.route_options = $.extend(frappe.route_options || {}, query_params);
			}
		},

		decode_component: function decode_component(r) {
			try {
				return decodeURIComponent(r);
			} catch (e) {
				if (e instanceof URIError) {
					// legacy: not sure why URIError is ignored.
					return r;
				} else {
					throw e;
				}
			}
		},

		slug: function slug(name) {
			return name.toLowerCase().replace(/ /g, '-');
		}
	};

	// global functions for backward compatibility
	frappe.get_route = function () { return frappe.router.current_route; };
	frappe.get_route_str = function () { return frappe.router.current_route.join('/'); };
	frappe.set_route = function() {
		return frappe.router.set_route.apply(frappe.router, arguments);
	};

	frappe.get_prev_route = function() {
		if (frappe.route_history && frappe.route_history.length > 1) {
			return frappe.route_history[frappe.route_history.length - 2];
		} else {
			return [];
		}
	};

	frappe.set_re_route = function() {
		var tmp = frappe.router.get_sub_path();
		frappe.set_route.apply(null, arguments);
		frappe.re_route[tmp] = frappe.router.get_sub_path();
	};

	frappe.has_route_options = function() {
		return Boolean(Object.keys(frappe.route_options || {}).length);
	};

	frappe.utils.make_event_emitter(frappe.router);

	frappe.route_history_queue = [];
	var routes_to_skip = ['Form', 'social', 'setup-wizard', 'recorder'];

	var save_routes = frappe.utils.debounce(function () {
		if (frappe.session.user === 'Guest') { return; }
		var routes = frappe.route_history_queue;
		frappe.route_history_queue = [];
		
		frappe.xcall('frappe.deferred_insert.deferred_insert', {
			'doctype': 'Route History',
			'records': routes
		}).catch(function () {
			frappe.route_history_queue.concat(routes);
		});	

	}, 10000);

	frappe.router.on('change', function () {
		var route = frappe.get_route();
		if (is_route_useful(route)) {
			frappe.route_history_queue.push({
				'user': frappe.session.user,
				'creation': frappe.datetime.now_datetime(),
				'route': frappe.get_route_str()
			});

			save_routes();
		}
	});

	function is_route_useful(route) {
		if (!route[1]) {
			return false;
		} else if ((route[0] === 'List' && !route[2]) || routes_to_skip.includes(route[0])) {
			return false;
		} else {
			return true;
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.defaults = {
		get_user_default: function(key) {
			var defaults = frappe.boot.user.defaults;
			var d = defaults[key];
			if(!d && frappe.defaults.is_a_user_permission_key(key))
				{ d = defaults[frappe.model.scrub(key)]; }
			if($.isArray(d)) { d = d[0]; }

			if(!frappe.defaults.in_user_permission(key, d)) {
				return;
			}

			return d;
		},
		get_user_defaults: function(key) {
			var defaults = frappe.boot.user.defaults;
			var d = defaults[key];

			if (frappe.defaults.is_a_user_permission_key(key)) {
				if (d && $.isArray(d) && d.length===1) {
					// Use User Permission value when only when it has a single value
					d = d[0];
				} else {
					d = defaults[key] || defaults[frappe.model.scrub(key)];
				}
			}
			if(!$.isArray(d)) { d = [d]; }

			// filter out values which are not permitted to the user
			d.filter(function (item) {
				if(frappe.defaults.in_user_permission(key, item)) {
					return item;
				}
			});
			return d;
		},
		get_global_default: function(key) {
			var d = frappe.sys_defaults[key];
			if($.isArray(d)) { d = d[0]; }
			return d;
		},
		get_global_defaults: function(key) {
			var d = frappe.sys_defaults[key];
			if(!$.isArray(d)) { d = [d]; }
			return d;
		},
		set_default: function(key, value, callback) {
			if(typeof value!=="string")
				{ value = JSON.stringify(value); }

			frappe.boot.user.defaults[key] = value;
			return frappe.call({
				method: "frappe.client.set_default",
				args: {
					key: key,
					value: value
				},
				callback: callback || function(r) {}
			});
		},
		set_user_default_local: function(key, value) {
			frappe.boot.user.defaults[key] = value;
		},
		get_default: function(key) {
			var defaults = frappe.boot.user.defaults;
			var value = defaults[key];
			if (frappe.defaults.is_a_user_permission_key(key)) {
				if (value && $.isArray(value) && value.length===1) {
					value = value[0];
				} else {
					value = defaults[frappe.model.scrub(key)];
				}
			}

			if(!frappe.defaults.in_user_permission(key, value)) {
				return;
			}

			if(value) {
				try {
					return JSON.parse(value)
				} catch(e) {
					return value;
				}
			}
		},

		is_a_user_permission_key: function(key) {
			return key.indexOf(":")===-1 && key !== frappe.model.scrub(key);
		},

		in_user_permission: function(key, value) {
			var user_permission = this.get_user_permissions()[frappe.model.unscrub(key)];

			if (user_permission && user_permission.length) {

				var doc_found = user_permission.some(function (perm) {
					return perm.doc === value;
				});
				return doc_found;

			} else {
				// there is no user permission for this doctype
				// so we can allow this doc i.e., value
				return true;
			}

		},

		get_user_permissions: function() {
			return this._user_permissions || {};
		},

		update_user_permissions: function() {
			var this$1 = this;

			var method = 'frappe.core.doctype.user_permission.user_permission.get_user_permissions';
			frappe.call(method).then(function (r) {
				if (r.message) {
					this$1._user_permissions = Object.assign({}, r.message);
				}
			});
		}
	};

	frappe.RoleEditor = class {
		constructor(wrapper, frm, disable) {
		var this$1 = this;

			this.frm = frm;
			this.wrapper = wrapper;
			this.disable = disable;
			var user_roles = this.frm.doc.roles.map(function (a) { return a.role; });
			this.multicheck = frappe.ui.form.make_control({
				parent: wrapper,
				df: {
					fieldname: "roles",
					fieldtype: "MultiCheck",
					select_all: true,
					columns: 3,
					get_data: function () {
						return frappe.xcall('frappe.core.doctype.user.user.get_all_roles').then(function (roles) {
							return roles.map(function (role) {
								return {
									label: __(role),
									value: role,
									checked: user_roles.includes(role)
								};
							});
						});
					},
					on_change: function () {
						this$1.set_roles_in_table();
						this$1.frm.dirty();
					}
				},
				render_input: true
			});

			var original_func = this.multicheck.make_checkboxes;
			this.multicheck.make_checkboxes = function () {
				original_func.call(this$1.multicheck);
				this$1.multicheck.$wrapper.find('.label-area').click(function (e) {
					var role = $(e.target).data('unit');
					role && this$1.show_permissions(role);
					e.preventDefault();
				});
			};
		}
		set_enable_disable() {
			$(this.wrapper).find('input[type="checkbox"]').attr('disabled', this.disable ? true : false);
		}
		show_permissions(role) {
			var this$1 = this;

			// show permissions for a role
			if (!this.perm_dialog) {
				this.make_perm_dialog();
			}
			$(this.perm_dialog.body).empty();
			return frappe.xcall('frappe.core.doctype.user.user.get_perm_info', { role: role })
				.then(function (permissions) {
					var $body = $(this$1.perm_dialog.body);
					if (!permissions.length) {
						$body.append(("<div class=\"text-muted text-center padding\">\n\t\t\t\t\t\t" + (__('{0} role does not have permission on any doctype', [role])) + "\n\t\t\t\t\t</div>"));
					} else {
						$body.append(("\n\t\t\t\t\t\t<table class=\"user-perm\">\n\t\t\t\t\t\t\t<thead>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<th> " + (__('Document Type')) + " </th>\n\t\t\t\t\t\t\t\t\t<th> " + (__('Level')) + " </th>\n\t\t\t\t\t\t\t\t\t" + (frappe.perm.rights.map(function (p) { return ("<th> " + (frappe.unscrub(p)) + "</th>"); }).join("")) + "\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t</thead>\n\t\t\t\t\t\t\t<tbody></tbody>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t"));
						permissions.forEach(function (perm) {
							$body.find('tbody').append(("\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>" + (perm.parent) + "</td>\n\t\t\t\t\t\t\t\t<td>" + (perm.permlevel) + "</td>\n\t\t\t\t\t\t\t\t" + (frappe.perm.rights.map(function (p) { return ("<td class=\"text-muted bold\">" + (perm[p] ? frappe.utils.icon('check', 'xs') : '-') + "</td>"); }).join("")) + "\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t"));
						});
					}
					this$1.perm_dialog.set_title(role);
					this$1.perm_dialog.show();
				});
		}
		make_perm_dialog() {
			this.perm_dialog = new frappe.ui.Dialog({
				title: __('Role Permissions')
			});

			this.perm_dialog.$wrapper
				.find('.modal-dialog')
				.css("width", "1200px")
				.css("max-width", "80vw");
		}
		show() {
			var user_roles = this.frm.doc.roles.map(function (a) { return a.role; });
			this.multicheck.selected_options = user_roles;
			this.multicheck.refresh_input();
			this.set_enable_disable();
		}
		set_roles_in_table() {
			var this$1 = this;

			var roles = this.frm.doc.roles || [];
			var checked_options = this.multicheck.get_checked_options();
			roles.map(function (role_doc) {
				if (!checked_options.includes(role_doc.role)) {
					frappe.model.clear_doc(role_doc.doctype, role_doc.name);
				}
			});
			checked_options.map(function (role) {
				if (!roles.find(function (d) { return d.role === role; })) {
					var role_doc = frappe.model.add_child(this$1.frm.doc, "Has Role", "roles");
					role_doc.role = role;
				}
			});
		}
		get_roles() {
			return {
				checked_roles: this.multicheck.get_checked_options(),
				unchecked_roles: this.multicheck.get_unchecked_options()
			};
		}
	};

	frappe.ModuleEditor = Class.extend({
		init: function(frm, wrapper) {
			this.wrapper = $('<div class="row module-block-list"></div>').appendTo(wrapper);
			this.frm = frm;
			this.make();
		},
		make: function() {
			var me = this;
			this.frm.doc.__onload.all_modules.forEach(function(m) {
				$(repl('<div class="col-sm-6"><div class="checkbox">\
				<label><input type="checkbox" class="block-module-check" data-module="%(module)s">\
				%(module)s</label></div></div>', {module: m})).appendTo(me.wrapper);
			});
			this.bind();
		},
		refresh: function() {
			var me = this;
			this.wrapper.find(".block-module-check").prop("checked", true);
			$.each(this.frm.doc.block_modules, function(i, d) {
				me.wrapper.find(".block-module-check[data-module='"+ d.module +"']").prop("checked", false);
			});
		},
		bind: function() {
			var me = this;
			this.wrapper.on("change", ".block-module-check", function() {
				var module = $(this).attr('data-module');
				if ($(this).prop("checked")) {
					// remove from block_modules
					me.frm.doc.block_modules = $.map(me.frm.doc.block_modules || [], function(d) {
						if (d.module != module) {
							return d;
						}
					});
				} else {
					me.frm.add_child("block_modules", {"module": module});
				}
			});
		}
	});

	// Simple JavaScript Templating
	// Adapted from John Resig - http://ejohn.org/ - MIT Licensed

	frappe.template = {compiled: {}, debug:{}};
	frappe.template.compile = function(str, name) {
		var key = name || str;

		if(!frappe.template.compiled[key]) {
			if(str.indexOf("'")!==-1) {
				str.replace(/'/g, "\\'");
				//console.warn("Warning: Single quotes (') may not work in templates");
			}

			// replace jinja style tags
			str = str.replace(/{{/g, "{%=").replace(/}}/g, "%}");

			// {% if not test %} --> {% if (!test) { %}
			str = str.replace(/{%\s?if\s?\s?not\s?([^\(][^%{]+)\s?%}/g, "{% if (! $1) { %}");

			// {% if test %} --> {% if (test) { %}
			str = str.replace(/{%\s?if\s?([^\(][^%{]+)\s?%}/g, "{% if ($1) { %}");

			// {% for item in list %}
			//       --> {% for (var i=0, len=list.length; i<len; i++) {  var item = list[i]; %}
			function replacer(match, p1, p2, offset, string) {
				var i = frappe.utils.get_random(3);
				var len = frappe.utils.get_random(3);
				return "{% for (var "+i+"=0, "+len+"="+p2+".length; "+i+"<"+len+"; "+i+"++) { var "
					+p1+" = "+p2+"["+i+"]; "+p1+"._index = "+i+"; %}";
			}
			str = str.replace(/{%\s?for\s([a-z._]+)\sin\s([a-z._]+)\s?%}/g, replacer);

			// {% endfor %} --> {% } %}
			str = str.replace(/{%\s?endif\s?%}/g, "{% }; %}");

			// {% else %} --> {% } else { %}
			str = str.replace(/{%\s?else\s?%}/g, "{% } else { %}");

			// {% endif %} --> {% } %}
			str = str.replace(/{%\s?endfor\s?%}/g, "{% }; %}");

			var fn_str = "var _p=[],print=function(){_p.push.apply(_p,arguments)};" +

		        // Introduce the data as local variables using with(){}
		        "with(obj){\n_p.push('" +

		        // Convert the template into pure JavaScript
		        str
		          .replace(/[\r\t\n]/g, " ")
		          .split("{%").join("\t")
		          .replace(/((^|%})[^\t]*)'/g, "$1\r")
		          .replace(/\t=(.*?)%}/g, "',$1,'")
		          .split("\t").join("');\n")
		          .split("%}").join("\n_p.push('")
		          .split("\r").join("\\'")
		      + "');}return _p.join('');";

			  frappe.template.debug[name] = fn_str;
			try {
				frappe.template.compiled[key] = new Function("obj", fn_str);
			} catch (e) {
				console.log("Error in Template:");
				console.log(fn_str);
				if(e.lineNumber) {
					console.log("Error in Line "+e.lineNumber+", Col "+e.columnNumber+":");
					console.log(fn_str.split("\n")[e.lineNumber - 1]);
				}
			}
	    }

		return frappe.template.compiled[key];
	};
	frappe.render = function(str, data, name) {
		return frappe.template.compile(str, name)(data);
	};
	frappe.render_template = function(name, data) {
		if(name.indexOf(' ')!==-1) {
			var template = name;
		} else {
			var template = frappe.templates[name];
		}
		if(data===undefined) {
			data = {};
		}
		if (!template) {
			frappe.throw(("Template <b>" + name + "</b> not found."));
		}
		return frappe.render(template, data, name);
	};
	frappe.render_grid = function(opts) {
		// build context
		if (opts.grid) {
			opts.columns = opts.grid.getColumns();
			opts.data = opts.grid.getData().getItems();
		}

		if (
			opts.print_settings &&
			opts.print_settings.orientation &&
			opts.print_settings.orientation.toLowerCase() === "landscape"
		) {
			opts.landscape = true;
		}

		// show landscape view if columns more than 10
		if (opts.landscape == null) {
			if(opts.columns && opts.columns.length > 10) {
				opts.landscape = true;
			} else {
				opts.landscape = false;
			}
		}

		// render content
		if(!opts.content) {
			opts.content = frappe.render_template(opts.template || "print_grid", opts);
		}

		// render HTML wrapper page
		opts.base_url = frappe.urllib.get_base_url();
		opts.print_css = frappe.boot.print_css;

		opts.lang = opts.lang || frappe.boot.lang,
		opts.layout_direction = opts.layout_direction || frappe.utils.is_rtl() ? "rtl" : "ltr";

		var html = frappe.render_template("print_template", opts);

		var w = window.open();

		if(!w) {
			frappe.msgprint(__("Please enable pop-ups in your browser"));
		}

		w.document.write(html);
		w.document.close();
	},
	frappe.render_tree = function(opts) {
		opts.base_url = frappe.urllib.get_base_url();
		opts.landscape = false;
		opts.print_css = frappe.boot.print_css;
		var tree = frappe.render_template("print_tree", opts);
		var w = window.open();

		if(!w) {
			frappe.msgprint(__("Please enable pop-ups in your browser"));
		}

		w.document.write(tree);
		w.document.close();
	};
	frappe.render_pdf = function(html, opts) {
		if ( opts === void 0 ) opts = {};

		//Create a form to place the HTML content
		var formData = new FormData();

		//Push the HTML content into an element
		formData.append("html", html);
		if (opts.orientation) {
			formData.append("orientation", opts.orientation);
		}
		var blob = new Blob([], { type: "text/xml"});
		formData.append("blob", blob);

		var xhr = new XMLHttpRequest();
		xhr.open("POST", '/api/method/frappe.utils.print_format.report_to_pdf');
		xhr.setRequestHeader("X-Frappe-CSRF-Token", frappe.csrf_token);
		xhr.responseType = "arraybuffer";

		xhr.onload = function(success) {
			if (this.status === 200) {
				var blob = new Blob([success.currentTarget.response], {type: "application/pdf"});
				var objectUrl = URL.createObjectURL(blob);

				//Open report in a new window
				window.open(objectUrl);
			}
		};
		xhr.send(formData);
	};

	frappe.templates['page'] = '<div class="page-head flex">  <div class="container">   <div class="row flex align-center page-head-content justify-between">    <div class="col-md-4 col-sm-6 col-xs-8 page-title">               <span class="sidebar-toggle-btn">      <svg class="icon icon-md sidebar-toggle-placeholder">       <use xlink:href="#icon-menu"></use>      </svg>      <span class="sidebar-toggle-icon">       <svg class="icon icon-md">        <use xlink:href="#icon-sidebar-collapse">        </use>       </svg>      </span>     </span>     <div class="flex fill-width title-area">      <div>       <div class="flex">        <h3 class="ellipsis title-text"></h3>        <span class="indicator-pill whitespace-nowrap"></span>       </div>       <div class="ellipsis sub-heading hide text-muted"></div>      </div>      <button class="btn btn-default more-button hide">       <svg class="icon icon-sm">        <use xlink:href="#icon-dot-horizontal">        </use>       </svg>      </button>     </div>    </div>    <div class="flex col page-actions justify-content-end">          <div class="custom-actions hide hidden-xs hidden-md"></div>     <div class="standard-actions flex">      <span class="page-icon-group hide hidden-xs hidden-sm"></span>      <div class="menu-btn-group hide">       <button type="button" class="btn btn-default icon-btn" data-toggle="dropdown" aria-expanded="false">        <span>         <span class="menu-btn-group-label">          <svg class="icon icon-sm">           <use xlink:href="#icon-dot-horizontal">           </use>          </svg>         </span>        </span>       </button>       <ul class="dropdown-menu dropdown-menu-right" role="menu"></ul>      </div>      <button class="btn btn-secondary btn-default btn-sm hide"></button>      <div class="actions-btn-group hide">       <button type="button" class="btn btn-primary btn-sm" data-toggle="dropdown" aria-expanded="false">        <span class="hidden-xs">         <span class="actions-btn-group-label">{%= __("Actions") %}</span>         <svg class="icon icon-xs">          <use xlink:href="#icon-select">          </use>         </svg>        </span>       </button>       <ul class="dropdown-menu dropdown-menu-right" role="menu">       </ul>      </div>      <button class="btn btn-primary btn-sm hide primary-action"></button>     </div>    </div>   </div>  </div> </div> <div class="container page-body">  <div class="page-toolbar hide">   <div class="container">   </div>  </div>  <div class="page-wrapper">   <div class="page-content">    <div class="workflow-button-area btn-group pull-right hide"></div>    <div class="clearfix"></div>   </div>  </div> </div>';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	/**
	 * Make a standard page layout with a toolbar and title
	 *
	 * @param {Object} opts
	 *
	 * @param {string} opts.parent [HTMLElement] Parent element
	 * @param {boolean} opts.single_column Whether to include sidebar
	 * @param {string} [opts.title] Page title
	 * @param {Object} [opts.make_page]
	 *
	 * @returns {frappe.ui.Page}
	 */

	/**
	 * @typedef {Object} frappe.ui.Page
	 */


	frappe.ui.make_app_page = function(opts) {
		opts.parent.page = new frappe.ui.Page(opts);
		return opts.parent.page;
	};

	frappe.ui.pages = {};

	frappe.ui.Page = Class.extend({
		init: function(opts) {
			$.extend(this, opts);

			this.set_document_title = true;
			this.buttons = {};
			this.fields_dict = {};
			this.views = {};

			this.make();
			frappe.ui.pages[frappe.get_route_str()] = this;
		},

		make: function() {
			this.wrapper = $(this.parent);
			this.add_main_section();
			this.setup_scroll_handler();
			this.setup_sidebar_toggle();
		},

		setup_scroll_handler: function setup_scroll_handler() {
			window.addEventListener('scroll', function () {
				if (document.documentElement.scrollTop) {
					$('.page-head').toggleClass('drop-shadow', true);
				} else {
					$('.page-head').removeClass('drop-shadow');
				}
			});
		},

		get_empty_state: function(title, message, primary_action) {
			var $empty_state = $(("<div class=\"page-card-container\">\n\t\t\t<div class=\"page-card\">\n\t\t\t\t<div class=\"page-card-head\">\n\t\t\t\t\t<span class=\"indicator blue\">\n\t\t\t\t\t\t" + title + "</span>\n\t\t\t\t</div>\n\t\t\t\t<p>" + message + "</p>\n\t\t\t\t<div>\n\t\t\t\t\t<button class=\"btn btn-primary btn-sm\">" + primary_action + "</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>"));

			return $empty_state;
		},

		load_lib: function(callback) {
			frappe.require(this.required_libs, callback);
		},

		add_main_section: function() {
			$(frappe.render_template("page", {})).appendTo(this.wrapper);
			if (this.single_column) {
				// nesting under col-sm-12 for consistency
				this.add_view("main", '<div class="row layout-main">\
					<div class="col-md-12 layout-main-section-wrapper">\
						<div class="layout-main-section"></div>\
						<div class="layout-footer hide"></div>\
					</div>\
				</div>');
			} else {
				this.add_view("main", "\n\t\t\t\t<div class=\"row layout-main\">\n\t\t\t\t\t<div class=\"col-lg-2 layout-side-section\"></div>\n\t\t\t\t\t<div class=\"col layout-main-section-wrapper\">\n\t\t\t\t\t\t<div class=\"layout-main-section\"></div>\n\t\t\t\t\t\t<div class=\"layout-footer hide\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t");
			}

			this.setup_page();
		},

		setup_page: function() {
			this.$title_area = this.wrapper.find(".title-area");

			this.$sub_title_area = this.wrapper.find("h6");

			if(this.title)
				{ this.set_title(this.title); }

			if(this.icon)
				{ this.get_main_icon(this.icon); }

			this.body = this.main = this.wrapper.find(".layout-main-section");
			this.container = this.wrapper.find(".page-body");
			this.sidebar = this.wrapper.find(".layout-side-section");
			this.footer = this.wrapper.find(".layout-footer");
			this.indicator = this.wrapper.find(".indicator-pill");

			this.page_actions = this.wrapper.find(".page-actions");

			this.btn_primary = this.page_actions.find(".primary-action");
			this.btn_secondary = this.page_actions.find(".btn-secondary");

			this.menu = this.page_actions.find(".menu-btn-group .dropdown-menu");
			this.menu_btn_group = this.page_actions.find(".menu-btn-group");

			this.actions = this.page_actions.find(".actions-btn-group .dropdown-menu");
			this.actions_btn_group = this.page_actions.find(".actions-btn-group");

			this.standard_actions = this.page_actions.find(".standard-actions");
			this.custom_actions = this.page_actions.find(".custom-actions");

			this.page_form = $('<div class="page-form row hide"></div>').prependTo(this.main);
			this.inner_toolbar = this.custom_actions;
			this.icon_group = this.page_actions.find(".page-icon-group");

			if(this.make_page) {
				this.make_page();
			}

			this.card_layout && this.main.addClass('frappe-card');

			// keyboard shortcuts
			var menu_btn = this.menu_btn_group.find('button');
			menu_btn.attr("title", __("Menu")).tooltip({ delay: { "show": 600, "hide": 100 } });
			frappe.ui.keys
				.get_shortcut_group(this.page_actions[0])
				.add(menu_btn, menu_btn.find('.menu-btn-group-label'));

			var action_btn = this.actions_btn_group.find('button');
			frappe.ui.keys
				.get_shortcut_group(this.page_actions[0])
				.add(action_btn, action_btn.find('.actions-btn-group-label'));
		},

		setup_sidebar_toggle: function setup_sidebar_toggle() {
			var this$1 = this;

			var sidebar_toggle = $('.page-head').find('.sidebar-toggle-btn');
			var sidebar_wrapper = this.wrapper.find('.layout-side-section');
			if (this.disable_sidebar_toggle || !sidebar_wrapper.length) {
				sidebar_toggle.remove();
			} else {
				sidebar_toggle.attr("title", __("Toggle Sidebar")).tooltip({
					delay: { "show": 600, "hide": 100 },
					trigger: "hover",
				});
				sidebar_toggle.click(function () {
					if (frappe.utils.is_xs() || frappe.utils.is_sm()) {
						this$1.setup_overlay_sidebar();
					} else {
						sidebar_wrapper.toggle();
					}
					$(document.body).trigger('toggleSidebar');
					this$1.update_sidebar_icon();
				});
			}
		},

		setup_overlay_sidebar: function setup_overlay_sidebar() {
			var this$1 = this;

			var overlay_sidebar = this.sidebar.find('.overlay-sidebar')
				.addClass('opened');
			$('<div class="close-sidebar">').hide().appendTo(this.sidebar).fadeIn();
			var scroll_container = $('html')
				.css("overflow-y", "hidden");

			this.sidebar.find(".close-sidebar").on('click', function (e) { return close_sidebar(e); });
			this.sidebar.on("click", "button:not(.dropdown-toggle)", function (e) { return close_sidebar(e); });

			var close_sidebar = function () {
				scroll_container.css("overflow-y", "");
				this$1.sidebar.find("div.close-sidebar").fadeOut(function () {
					overlay_sidebar.removeClass('opened')
						.find('.dropdown-toggle')
						.removeClass('text-muted');
				});
			};
		},

		update_sidebar_icon: function update_sidebar_icon() {
			var sidebar_toggle = $('.page-head').find('.sidebar-toggle-btn');
			var sidebar_toggle_icon = sidebar_toggle.find('.sidebar-toggle-icon');
			var sidebar_wrapper = this.wrapper.find('.layout-side-section');
			var is_sidebar_visible = $(sidebar_wrapper).is(":visible");
			sidebar_toggle_icon.html(frappe.utils.icon(is_sidebar_visible ? 'sidebar-collapse' : 'sidebar-expand', 'md'));
		},

		set_indicator: function(label, color) {
			this.clear_indicator().removeClass("hide").html(("<span>" + label + "</span>")).addClass(color);
		},

		add_action_icon: function(icon, click, css_class, tooltip_label) {
			if ( css_class === void 0 ) css_class='';

			var button = $(("\n\t\t\t<button class=\"text-muted btn btn-default " + css_class + " icon-btn\">\n\t\t\t\t" + (frappe.utils.icon(icon)) + "\n\t\t\t</button>\n\t\t"));

			button.appendTo(this.icon_group.removeClass("hide"));
			button.click(click);
			button.attr("title", __(tooltip_label || frappe.unscrub(icon)))
				.tooltip({ delay: { "show": 600, "hide": 100 }, trigger: "hover" });

			return button;
		},

		clear_indicator: function() {
			return this.indicator.removeClass().addClass("indicator-pill whitespace-nowrap hide");
		},

		get_icon_label: function(icon, label) {
			var icon_name = icon;
			var size = 'xs';
			if (typeof icon === 'object') {
				icon_name = icon.icon;
				size = icon.size || 'xs';
			}
			return ((icon ? frappe.utils.icon(icon_name, size) : '') + " <span class=\"hidden-xs\"> " + (__(label)) + " </span>");
		},

		set_action: function(btn, opts) {
			var me = this;
			if (opts.icon) {
				opts.label = this.get_icon_label(opts.icon, opts.label);
			}

			this.clear_action_of(btn);

			btn.removeClass("hide")
				.prop("disabled", false)
				.html(opts.label)
				.on("click", function() {
					var response = opts.click.apply(this);
					me.btn_disable_enable(btn, response);
				});

			if (opts.working_label) {
				btn.attr("data-working-label", opts.working_label);
			}

			// alt shortcuts
			var text_span = btn.find('span');
			frappe.ui.keys
				.get_shortcut_group(this)
				.add(btn, text_span.length ? text_span : btn);
		},

		set_primary_action: function(label, click, icon, working_label) {
			this.set_action(this.btn_primary, {
				label: label,
				click: click,
				icon: icon,
				working_label: working_label
			});
			return this.btn_primary;

		},

		set_secondary_action: function(label, click, icon, working_label) {
			this.set_action(this.btn_secondary, {
				label: label,
				click: click,
				icon: icon,
				working_label: working_label
			});

			return this.btn_secondary;
		},


		clear_action_of: function(btn) {
			btn.addClass("hide").unbind("click").removeAttr("data-working-label");
		},

		clear_primary_action: function() {
			this.clear_action_of(this.btn_primary);
		},

		clear_secondary_action: function() {
			this.clear_action_of(this.btn_secondary);
		},

		clear_actions: function() {
			this.clear_primary_action();
			this.clear_secondary_action();
		},

		clear_custom_actions: function clear_custom_actions() {
			this.custom_actions.addClass("hide").empty();
		},

		clear_icons: function() {
			this.icon_group.addClass("hide").empty();
		},

		//--- Menu --//

		add_menu_item: function(label, click, standard, shortcut) {
			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: this.menu,
				shortcut: shortcut
			});
		},

		add_custom_menu_item: function(parent, label, click, standard, shortcut, icon) {
			if ( icon === void 0 ) icon=null;

			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: parent,
				shortcut: shortcut,
				icon: icon
			});
		},

		clear_menu: function() {
			this.clear_btn_group(this.menu);
		},

		show_menu: function() {
			this.menu_btn_group.removeClass("hide");
		},

		hide_menu: function() {
			this.menu_btn_group.addClass("hide");
		},

		show_icon_group: function() {
			this.icon_group.removeClass("hide");
		},

		hide_icon_group: function() {
			this.icon_group.addClass("hide");
		},

		//--- Actions Menu--//

		show_actions_menu: function() {
			this.actions_btn_group.removeClass("hide");
		},

		hide_actions_menu: function() {
			this.actions_btn_group.addClass("hide");
		},


		add_action_item: function(label, click, standard) {
			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: this.actions
			});
		},

		add_actions_menu_item: function(label, click, standard) {
			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: this.actions,
				show_parent: false
			});
		},

		clear_actions_menu: function() {
			this.clear_btn_group(this.actions);
		},


		//-- Generic --//

		/*
		* Add label to given drop down menu. If label, is already contained in the drop
		* down menu, it will be ignored.
		* @param {string} label - Text for the drop down menu
		* @param {function} click - function to be called when `label` is clicked
		* @param {Boolean} standard
		* @param {object} parent - DOM object representing the parent of the drop down item lists
		* @param {string} shortcut - Keyboard shortcut associated with the element
		* @param {Boolean} show_parent - Whether to show the dropdown button if dropdown item is added
		*/
		add_dropdown_item: function(ref) {
			var label = ref.label;
			var click = ref.click;
			var standard = ref.standard;
			var parent = ref.parent;
			var shortcut = ref.shortcut;
			var show_parent = ref.show_parent; if ( show_parent === void 0 ) show_parent = true;
			var icon = ref.icon; if ( icon === void 0 ) icon = null;

			if (show_parent) {
				parent.parent().removeClass("hide");
			}

			var $link = this.is_in_group_button_dropdown(parent, 'li > a.grey-link', label);
			if ($link) { return $link; }

			var $li;
			var $icon = "";

			if (icon) {
				$icon = "<span class=\"menu-item-icon\">" + (frappe.utils.icon(icon)) + "</span>";
			}

			if (shortcut) {
				var shortcut_obj = this.prepare_shortcut_obj(shortcut, click, label);
				$li = $(("\n\t\t\t\t<li>\n\t\t\t\t\t<a class=\"grey-link dropdown-item\" href=\"#\" onClick=\"return false;\">\n\t\t\t\t\t\t" + $icon + "\n\t\t\t\t\t\t<span class=\"menu-item-label\">" + label + "</span>\n\t\t\t\t\t\t<kbd class=\"pull-right\">\n\t\t\t\t\t\t\t<span>" + (shortcut_obj.shortcut_label) + "</span>\n\t\t\t\t\t\t</kbd>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t"));
				frappe.ui.keys.add_shortcut(shortcut_obj);
			} else {
				$li = $(("\n\t\t\t\t<li>\n\t\t\t\t\t<a class=\"grey-link dropdown-item\" href=\"#\" onClick=\"return false;\">\n\t\t\t\t\t\t" + $icon + "\n\t\t\t\t\t\t<span class=\"menu-item-label\">" + label + "</span>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t"));
			}

			$link = $li.find("a").on("click", click);

			if (standard) {
				$li.appendTo(parent);
			} else {
				this.divider = parent.find(".dropdown-divider");
				if(!this.divider.length) {
					this.divider = $('<li class="dropdown-divider user-action"></li>').prependTo(parent);
				}
				$li.addClass("user-action").insertBefore(this.divider);
			}

			// alt shortcut
			frappe.ui.keys
				.get_shortcut_group(parent.get(0))
				.add($link, $link.find('.menu-item-label'));

			return $link;
		},

		prepare_shortcut_obj: function prepare_shortcut_obj(shortcut, click, label) {
			var shortcut_obj;
			// convert to object, if shortcut string passed
			if (typeof shortcut === 'string') {
				shortcut_obj = { shortcut: shortcut };
			} else {
				shortcut_obj = shortcut;
			}
			// label
			if (frappe.utils.is_mac()) {
				shortcut_obj.shortcut_label = shortcut_obj.shortcut.replace('Ctrl', '⌘');
			} else {
				shortcut_obj.shortcut_label = shortcut_obj.shortcut;
			}
			// actual shortcut string
			shortcut_obj.shortcut = shortcut_obj.shortcut.toLowerCase();
			// action is button click
			if (!shortcut_obj.action) {
				shortcut_obj.action = click;
			}
			// shortcut description can be button label
			if (!shortcut_obj.description) {
				shortcut_obj.description = label;
			}
			// page
			shortcut_obj.page = this;
			return shortcut_obj;
		},

		/*
		* Check if there already exists a button with a specified label in a specified button group
		* @param {object} parent - This should be the `ul` of the button group.
		* @param {string} selector - CSS Selector of the button to be searched for. By default, it is `li`.
		* @param {string} label - Label of the button
		*/
		is_in_group_button_dropdown: function(parent, selector, label) {

			if (!selector) { selector = 'li'; }

			if (!label || !parent) { return false; }

			var result = $(parent).find((selector + ":contains('" + label + "')"))
				.filter(function() {
					var item = $(this).html();
					return $(item).attr('data-label') === label;
				});
			return result.length > 0 && result;
		},

		clear_btn_group: function(parent) {
			parent.empty();
			parent.parent().addClass("hide");
		},

		add_divider: function() {
			return $('<li class="dropdown-divider"></li>').appendTo(this.menu);
		},

		get_or_add_inner_group_button: function(label) {
			var $group = this.inner_toolbar.find((".inner-group-button[data-label=\"" + (encodeURIComponent(label)) + "\"]"));
			if (!$group.length) {
				$group = $(
					("<div class=\"inner-group-button\" data-label=\"" + (encodeURIComponent(label)) + "\">\n\t\t\t\t\t<button type=\"button\" class=\"btn btn-default ellipsis\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t\t\t" + label + "\n\t\t\t\t\t\t" + (frappe.utils.icon('select', 'xs')) + "\n\t\t\t\t\t</button>\n\t\t\t\t\t<div role=\"menu\" class=\"dropdown-menu\"></div>\n\t\t\t\t</div>")
				).appendTo(this.inner_toolbar);
			}
			return $group;
		},

		get_inner_group_button: function(label) {
			return this.inner_toolbar.find((".inner-group-button[data-label=\"" + (encodeURIComponent(label)) + "\"]"));
		},

		set_inner_btn_group_as_primary: function(label) {
			this.get_or_add_inner_group_button(label).find("button").removeClass("btn-default").addClass("btn-primary");
		},

		btn_disable_enable: function(btn, response) {
			if (response && response.then) {
				btn.prop('disabled', true);
				response.then(function () {
					btn.prop('disabled', false);
				});
			} else if (response && response.always) {
				btn.prop('disabled', true);
				response.always(function () {
					btn.prop('disabled', false);
				});
			}
		},

		/*
		* Add button to button group. If there exists another button with the same label,
		* `add_inner_button` will not add the new button to the button group even if the callback
		* function is different.
		*
		* @param {string} label - Label of the button to be added to the group
		* @param {object} action - function to be called when button is clicked
		* @param {string} group - Label of the group button
		*/
		add_inner_button: function(label, action, group, type) {
			if ( type === void 0 ) type="default";

			var me = this;
			var _action = function() {
				var btn = $(this);
				var response = action();
				me.btn_disable_enable(btn, response);
			};
			if(group) {
				var $group = this.get_or_add_inner_group_button(group);
				$(this.inner_toolbar).removeClass("hide");

				if (!this.is_in_group_button_dropdown($group.find(".dropdown-menu"), 'a', label)) {
					return $(("<a class=\"dropdown-item\" href=\"#\" onclick=\"return false;\" data-label=\"" + (encodeURIComponent(label)) + "\">" + label + "</a>"))
						.on('click', _action)
						.appendTo($group.find(".dropdown-menu"));
				}

			} else {
				var button = this.inner_toolbar.find(("button[data-label=\"" + (encodeURIComponent(label)) + "\"]"));
				if (button.length == 0) {
					button = $(("<button data-label=\"" + (encodeURIComponent(label)) + "\" class=\"btn btn-" + type + " ellipsis\">\n\t\t\t\t\t" + (__(label)) + "\n\t\t\t\t</button>"));
					button.on("click", _action);
					button.appendTo(this.inner_toolbar.removeClass("hide"));
				}
				return button;
			}
		},

		remove_inner_button: function(label, group) {
			if (typeof label === 'string') {
				label = [label];
			}
			// translate
			label = label.map(function (l) { return __(l); });

			if (group) {
				var $group = this.get_inner_group_button(__(group));
				if ($group.length) {
					$group.find((".dropdown-item[data-label=\"" + (encodeURIComponent(label)) + "\"]")).remove();
				}
				if ($group.find('.dropdown-item').length === 0) { $group.remove(); }
			} else {
				this.inner_toolbar.find(("button[data-label=\"" + (encodeURIComponent(label)) + "\"]")).remove();
			}
		},

		add_inner_message: function(message) {
			var $message = $(("<span class='inner-page-message text-muted small'>" + message + "</div>"));
			this.inner_toolbar.find('.inner-page-message').remove();
			this.inner_toolbar.removeClass("hide").prepend($message);

			return $message;
		},

		clear_inner_toolbar: function() {
			this.inner_toolbar.empty().addClass("hide");
		},

		//-- Sidebar --//

		add_sidebar_item: function(label, action, insert_after, prepend) {
			var parent = this.sidebar.find(".sidebar-menu.standard-actions");
			var li = $('<li>');
			var link = $('<a>').html(label).on("click", action).appendTo(li);

			if (insert_after) {
				li.insertAfter(parent.find(insert_after));
			} else {
				if(prepend) {
					li.prependTo(parent);
				} else {
					li.appendTo(parent);
				}
			}
			return link;
		},

		//---//

		clear_user_actions: function() {
			this.menu.find(".user-action").remove();
		},

		// page::title
		get_title_area: function() {
			return this.$title_area;
		},

		set_title: function(title, icon, strip, tab_title) {
			if ( icon === void 0 ) icon=null;
			if ( strip === void 0 ) strip=true;
			if ( tab_title === void 0 ) tab_title="";

			if (!title) { title = ""; }
			if (strip) {
				title = strip_html(title);
			}
			this.title = title;
			frappe.utils.set_title(tab_title || title);
			if (icon) {
				title = (frappe.utils.icon(icon)) + " " + title;
			}
			var title_wrapper = this.$title_area.find(".title-text");
			title_wrapper.html(title);
			title_wrapper.attr('title', this.title);
		},

		set_title_sub: function(txt) {
			// strip icon
			this.$sub_title_area.html(txt).toggleClass("hide", !!!txt);
		},

		get_main_icon: function(icon) {
			return this.$title_area.find(".title-icon")
				.html('<i class="'+icon+' fa-fw"></i> ')
				.toggle(true);
		},

		add_help_button: function(txt) {
			//
		},

		add_button: function(label, click, opts) {
			if (!opts) { opts = {}; }
			var button = $(("<button\n\t\t\tclass=\"btn " + (opts.btn_class || 'btn-default') + " " + (opts.btn_size || 'btn-sm') + " ellipsis\">\n\t\t\t\t" + (opts.icon ? frappe.utils.icon(opts.icon): '') + "\n\t\t\t\t" + label + "\n\t\t</button>"));
			button.appendTo(this.custom_actions);
			button.on('click', click);
			this.custom_actions.removeClass('hide');

			return button;
		},

		add_custom_button_group: function(label, icon, parent) {
			var dropdown_label = "<span class=\"hidden-xs\">\n\t\t\t<span class=\"custom-btn-group-label\">" + (__(label)) + "</span>\n\t\t\t" + (frappe.utils.icon('select', 'xs')) + "\n\t\t</span>";

			if (icon) {
				dropdown_label = "<span class=\"hidden-xs\">\n\t\t\t\t" + (frappe.utils.icon(icon)) + "\n\t\t\t\t<span class=\"custom-btn-group-label\">" + (__(label)) + "</span>\n\t\t\t\t" + (frappe.utils.icon('select', 'xs')) + "\n\t\t\t</span>\n\t\t\t<span class=\"visible-xs\">\n\t\t\t\t" + (frappe.utils.icon(icon)) + "\n\t\t\t</span>";
			}

			var custom_btn_group = $(("\n\t\t\t<div class=\"custom-btn-group\">\n\t\t\t\t<button type=\"button\" class=\"btn btn-default btn-sm ellipsis\" data-toggle=\"dropdown\" aria-expanded=\"false\">\n\t\t\t\t\t" + dropdown_label + "\n\t\t\t\t</button>\n\t\t\t\t<ul class=\"dropdown-menu\" role=\"menu\"></ul>\n\t\t\t</div>\n\t\t"));

			if (!parent) { parent = this.custom_actions; }
			parent.removeClass('hide').append(custom_btn_group);

			return custom_btn_group.find('.dropdown-menu');
		},

		add_dropdown_button: function(parent, label, click, icon) {
			frappe.ui.toolbar.add_dropdown_button(parent, label, click, icon);
		},

		// page::form
		add_label: function(label) {
			this.show_form();
			return $("<label class='col-md-1 page-only-label'>"+label+" </label>")
				.appendTo(this.page_form);
		},
		add_select: function(label, options) {
			var field = this.add_field({label:label, fieldtype:"Select"});
			return field.$wrapper.find("select").empty().add_options(options);
		},
		add_data: function(label) {
			var field = this.add_field({label: label, fieldtype: "Data"});
			return field.$wrapper.find("input").attr("placeholder", label);
		},
		add_date: function(label, date) {
			var field = this.add_field({label: label, fieldtype: "Date", "default": date});
			return field.$wrapper.find("input").attr("placeholder", label);
		},
		add_check: function(label) {
			return $("<div class='checkbox'><label><input type='checkbox'>" + label + "</label></div>")
				.appendTo(this.page_form)
				.find("input");
		},
		add_break: function() {
			// add further fields in the next line
			this.page_form.append('<div class="clearfix invisible-xs"></div>');
		},
		add_field: function(df, parent) {
			this.show_form();

			if (!df.placeholder) {
				df.placeholder = df.label;
			}

			df.input_class = 'input-xs';

			var f = frappe.ui.form.make_control({
				df: df,
				parent: parent || this.page_form,
				only_input: df.fieldtype == "Check" ? false : true,
			});
			f.refresh();
			$(f.wrapper)
				.addClass('col-md-2')
				.attr("title", __(df.label)).tooltip({
					delay: { "show": 600, "hide": 100},
					trigger: "hover"
				});

			// html fields in toolbar are only for display
			if (df.fieldtype=='HTML') {
				return;
			}

			// hidden fields dont have $input
			if (!f.$input) { f.make_input(); }

			f.$input.attr("placeholder", __(df.label));

			if(df.fieldtype==="Check") {
				$(f.wrapper).find(":first-child")
					.removeClass("col-md-offset-4 col-md-8");
			}

			if(df.fieldtype=="Button") {
				$(f.wrapper).find(".page-control-label").html("&nbsp;");
				f.$input.addClass("btn-xs").css({"width": "100%", "margin-top": "-1px"});
			}

			if(df["default"])
				{ f.set_input(df["default"]); }
			this.fields_dict[df.fieldname || df.label] = f;
			return f;
		},
		clear_fields: function() {
			this.page_form.empty();
		},
		show_form: function() {
			this.page_form.removeClass("hide");
		},
		hide_form: function() {
			this.page_form.addClass("hide");
		},
		get_form_values: function() {
			var values = {};
			this.page_form.fields_dict.forEach(function(field, key) {
				values[key] = field.get_value();
			});
			return values;
		},
		add_view: function(name, html) {
			var element = html;
			if(typeof (html) === "string") {
				element = $(html);
			}
			this.views[name] = element.appendTo($(this.wrapper).find(".page-content"));
			if(!this.current_view) {
				this.current_view = this.views[name];
			} else {
				this.views[name].toggle(false);
			}
			return this.views[name];
		},
		set_view: function(name) {
			if(this.current_view_name===name)
				{ return; }
			this.current_view && this.current_view.toggle(false);
			this.current_view = this.views[name];

			this.previous_view_name = this.current_view_name;
			this.current_view_name = name;

			this.views[name].toggle(true);

			this.wrapper.trigger('view-change');
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// License: GNU General Public License v3. See license.txt

	frappe.provide("frappe.ui");

	frappe.ui.Slide = class Slide {
		constructor(slide) {
		if ( slide === void 0 ) slide = null;

			$.extend(this, slide);
			this.setup();
		}

		setup() {
			this.$wrapper = $('<div class="slide-wrapper hidden"></div>')
				.attr({ "data-slide-id": this.id, "data-slide-name": this.name })
				.appendTo(this.parent);
		}

		// Make has to be called manually, to account for on-demand use cases
		make() {
			if (this.before_load) { this.before_load(this); }

			this.$body = $(("<div class=\"slide-body\">\n\t\t\t<div class=\"content text-center\">\n\t\t\t\t<h1 class=\"title slide-title\">" + (this.title) + "</h1>\n\t\t\t</div>\n\t\t\t<div class=\"form-wrapper\">\n\t\t\t\t<div class=\"form\"></div>\n\t\t\t\t<div class=\"add-more text-center\" style=\"margin-top: 5px;\">\n\t\t\t\t\t<button class=\"form-more-btn hide btn btn-default btn-xs\">\n\t\t\t\t\t\t<span>Add More</span>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>")).appendTo(this.$wrapper);

			this.$content = this.$body.find(".content");
			this.$form = this.$body.find(".form");
			this.$primary_btn = this.slides_footer.find('.primary');
			this.$form_wrapper = this.$body.find(".form-wrapper");

			if (this.image_src) { this.$content.append(
				$(("<img src=\"" + (this.image_src) + "\" style=\"margin: 20px;\">"))); }
			if (this.help) { this.$content.append($(("<p class=\"slide-help\">" + (this.help) + "</p>"))); }

			this.reqd_fields = [];

			this.refresh();
			this.made = true;
		}

		refresh() {
			this.render_parent_dots();
			if (!this.done) {
				this.setup_form();
			} else {
				this.setup_done_state();
			}
		}

		setup_form() {
			this.form = new frappe.ui.FieldGroup({
				fields: this.get_atomic_fields(),
				body: this.$form[0],
				no_submit_on_enter: true
			});
			this.form.make();
			if (this.add_more) { this.bind_more_button(); }

			this.set_reqd_fields();

			if (this.onload) { this.onload(this); }
			this.set_reqd_fields();
		}

		setup_done_state() { }

		// Form methods
		get_atomic_fields() {
			var this$1 = this;

			var fields = JSON.parse(JSON.stringify(this.fields));
			if (this.add_more) {
				this.count = 1;
				fields = fields.map(function (field, i) {
					if (field.fieldname) {
						field.fieldname += '_1';
					}
					if (i === 1 && this$1.mandatory_entry) {
						field.reqd = 1;
					}
					if (!field.static) {
						if (field.label) { field.label; }
					}
					return field;
				});
			}
			return fields;
		}

		set_reqd_fields() {
			var this$1 = this;

			var dict = this.form.fields_dict;
			this.reqd_fields = [];
			Object.keys(dict).map(function (key) {
				if (dict[key].df.reqd) {
					this$1.reqd_fields.push(dict[key]);
				}
			});
		}

		set_values() {
			this.values = this.form.get_values();
			if (this.values === null) {
				return false;
			}
			if (this.validate && !this.validate()) {
				return false;
			}
			return true;
		}

		bind_more_button() {
			var this$1 = this;

			this.$more = this.$body.find('.form-more-btn');
			this.$more.removeClass('hide')
				.on('click', function () {
					this$1.count++;
					var fields = JSON.parse(JSON.stringify(this$1.fields));

					this$1.form.add_fields(fields.map(function (field) {
						if (field.fieldname) { field.fieldname += '_' + this$1.count; }
						if (!field.static) {
							if (field.label) { field.label; }
						}
						field.reqd = 0;
						return field;
					}));

					if (this$1.count === this$1.max_count) {
						this$1.$more.addClass('hide');
					}
				});
		}

		// Primary button (outside of slide)
		resetup_primary_button() {
			this.unbind_primary_action();
			this.bind_fields_to_action_btn();
			this.reset_action_button_state();
			this.bind_primary_action();
		}

		bind_fields_to_action_btn() {
			var me = this;
			this.reqd_fields.map(function (field) {
				field.$wrapper.on('change input click', function () {
					me.reset_action_button_state();
				});
				field.$wrapper.on('keydown', 'input', function (e) {
					if (e.key == 'Enter') {
						me.reset_action_button_state();
					}
				});
			});
		}

		reset_action_button_state() {
			var empty_fields = this.reqd_fields.filter(function (field) {
				return !field.get_value();
			});
			if (empty_fields.length) {
				this.slides_footer.find('.action').addClass('disabled');
			} else {
				this.slides_footer.find('.action').removeClass('disabled');
			}
		}

		unbind_primary_action() {
			this.slides_footer.find(".primary").off();
		}

		bind_primary_action() {
			var this$1 = this;

			this.slides_footer.find(".primary").on('click.primary_action', function () {
				this$1.primary_action();
			});
		}

		is_last_slide() {
			if (this.id === this.parent[0].children.length - 1) {
				return true;
			}
			return false;
		}

		before_show() { }

		show_slide() {
			this.$wrapper.removeClass("hidden");
			this.before_show();
			this.resetup_primary_button();
			if (!this.done) {
				this.$body.find('.form-control').first().focus();
				this.$primary_btn.show();
			} else {
				this.$primary_btn.hide();
			}
		}

		hide_slide() {
			this.$wrapper.addClass("hidden");
		}

		get_input(fieldname) {
			return this.form.get_input(fieldname);
		}

		get_field(fieldname) {
			return this.form.get_field(fieldname);
		}

		get_value(fieldname) {
			return this.form.get_value(fieldname);
		}

		destroy() {
			this.$body.remove();
		}

		primary_action() { }
	};

	frappe.ui.Slides = class Slides {
		constructor(ref) {
		var parent = ref.parent; if ( parent === void 0 ) parent = null;
		var slides = ref.slides; if ( slides === void 0 ) slides = [];
		var slide_class = ref.slide_class; if ( slide_class === void 0 ) slide_class = null;
		var unidirectional = ref.unidirectional; if ( unidirectional === void 0 ) unidirectional = 0;
		var done_state = ref.done_state; if ( done_state === void 0 ) done_state = 0;
		var before_load = ref.before_load; if ( before_load === void 0 ) before_load = null;
		var on_update = ref.on_update; if ( on_update === void 0 ) on_update = null;

			this.parent = parent;
			this.slides = slides;
			this.slide_class = slide_class;
			this.unidirectional = unidirectional;
			this.done_state = done_state;
			this.before_load = before_load;
			this.on_update = on_update;
			this.page_name = "setup-wizard";

			this.slide_dict = {};

			//In case of refreshing
			this.made_slide_ids = [];
			this.values = {};
			this.make();
		}

		make() {
			this.$slide_progress = $("<div>").addClass("slides-progress text-center text-extra-muted")
				.appendTo(this.parent);
			this.container = $('<div>').addClass("slides-wrapper").attr({ "tabindex": -1 })
				.appendTo(this.parent);
			this.$body = $("<div>").addClass("slide-container")
				.appendTo(this.container);
			this.$footer = $("<div>").addClass("slide-footer")
				.appendTo(this.container);

			this.render_progress_dots();
			this.make_prev_next_buttons();
			if (this.before_load) { this.before_load(this.$footer); }

			// can be on demand
			this.setup();

			// can be on demand
			this.show_slide(0);
		}

		setup() {
			var this$1 = this;

			this.slides.map(function (slide, id) {
				if (!this$1.slide_dict[id]) {
					this$1.slide_dict[id] = new (this$1.slide_class)(
						$.extend(this$1.slides[id], {
							parent: this$1.$body,
							slides_footer: this$1.$footer,
							render_parent_dots: this$1.render_progress_dots.bind(this$1),
							id: id,
						})
					);
					if (!this$1.unidirectional) {
						this$1.slide_dict[id].make();
					}
				} else {
					if (this$1.made_slide_ids.includes(id + "")) {
						this$1.slide_dict[id].destroy();
						this$1.slide_dict[id].make();
					}
				}
			});
		}

		refresh(id) {
			this.render_progress_dots();
			this.show_hide_prev_next(id);
			this.$body.find('.form-control').first().focus();
		}

		render_progress_dots() {
			var this$1 = this;

			// Depends on this.unidirectional and this.done_state
			// Can be called by a slide to update states
			this.$slide_progress.empty();

			this.slides.map(function (slide, id) {
				var $dot = $(("<div class=\"slide-step\">\n\t\t\t\t<div class=\"slide-step-indicator\"></div>\n\t\t\t\t<div class=\"slide-step-complete\">" + (frappe.utils.icon('tick', 'xs')) + "</div>\n\t\t\t</div>"))
					.attr({ 'data-step-id': id });

				if (this$1.done_state && (this$1.slide_dict[id] &&
					this$1.slide_dict[id].done || slide.done)) {
					$dot.addClass('step-success');
				}
				if (this$1.unidirectional && id === this$1.current_id) {
					$dot.addClass('active');
				}
				// Add pointer event for non-unidirectional
				this$1.$slide_progress.append($dot);
			});

			this.completed = 0;
			this.slides.map(function (slide, i) {
				if (this$1.slide_dict[i]) {
					if (this$1.slide_dict[i].done) { this$1.completed++; }
				} else {
					if (slide.done) { this$1.completed++; }
				}
			});
			if (this.on_update) { this.on_update(this.completed, this.slides.length); }

			if (!this.unidirectional) { this.bind_progress_dots(); }
		}

		make_prev_next_buttons() {
			var this$1 = this;

			$(("<div class=\"row\">\n\t\t\t<div class=\"col-sm-4 text-left prev-div\">\n\t\t\t\t<button class=\"prev-btn btn btn-secondary btn-sm\" tabindex=\"0\">" + (__("Previous")) + "</button>\n\t\t\t</div>\n\t\t\t<div class=\"col-sm-8 text-right next-div\">\n\t\t\t\t<button class=\"next-btn btn btn-default btn-sm\" tabindex=\"0\">" + (__("Next")) + "</button>\n\t\t\t</div>\n\t\t</div>")).appendTo(this.$footer);

			this.$prev_btn = this.$footer.find('.prev-btn').attr('tabIndex', 0)
				.on('click', function () { return this$1.show_slide(this$1.current_id - 1); });

			this.$next_btn = this.$footer.find('.next-btn').attr('tabIndex', 0)
				.on('click', function () {
					if (this$1.done_state) {
						if (this$1.slide) { this$1.slide.done = true; }
						if (this$1.current_slide) { this$1.current_slide.done = true; }
					}
					if (!this$1.unidirectional || (this$1.unidirectional && this$1.current_slide.set_values())) {
						this$1.show_slide(this$1.current_id + 1);
					}
				});
		}

		bind_progress_dots() {
			var me = this;
			this.$slide_progress.find('.fa-circle').addClass('link').on('click', function () {
				var id = $(this).attr('data-step-id');
				me.show_slide(id);
			});
		}

		before_show_slide() {
			return true;
		}

		show_slide(id) {
			id = cint(id);
			if (!this.before_show_slide() ||
				(this.current_slide && this.current_id === id)) {
				return;
			}

			this.update_values();

			if (this.current_slide) { this.current_slide.hide_slide(); }
			if (this.unidirectional && !this.slide_dict[id].made) {
				this.slide_dict[id].make();
			}
			this.current_id = id;
			this.current_slide = this.slide_dict[id];
			this.current_slide.show_slide();
			this.refresh(id);
		}

		destroy_slide(id) {
			if (this.slide_dict[id]) { this.slide_dict[id].destroy(); }
			this.slide_dict[id] = null;
		}

		// eslint-disable-next-line no-unused-vars
		on_update(completed, total) { }

		show_hide_prev_next(id) {
			(id === 0) ?
				this.$prev_btn.hide() : this.$prev_btn.show();
			(id + 1 === this.slides.length) ?
				this.$next_btn.hide() : this.$next_btn.show();
		}

		get_values() {
			var values = {};
			$.each(this.slide_dict, function (id, slide) {
				if (slide.values) {
					$.extend(values, slide.values);
				}
			});
			return values;
		}

		update_values() {
			this.values = $.extend(this.values, this.get_values());
		}
	};

	frappe.find = {
		page_primary_action: function () {
			return $('.page-actions:visible .btn-primary');
		},
		field: function (fieldname, value) {
			return new Promise(function (resolve) {
				var input = $(("[data-fieldname=\"" + fieldname + "\"] :input"));
				if(value) {
					input.val(value).trigger('change');
					frappe.after_ajax(function () { resolve(input); });
				} else {
					resolve(input);
				}
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.IconBar = Class.extend({
		init: function(parent, n_groups) {
			this.parent = parent;
			this.buttons = {};
			this.make(n_groups);
		},
		make: function(n_groups) {
			this.$wrapper = $('<div class="iconbar-wrapper hide"></div>').appendTo(this.parent);
			for(var i=0; i<n_groups; i++) {
				this.get_group(i+1);
			}
		},
		get_group: function(group) {
			var $ul = this.$wrapper.find(".iconbar-"+group+" ul");

			if(!$ul.length)
				{ $ul = $('<div class="iconbar iconbar-'+group+' hide"><ul></ul></div>')
					.appendTo(this.$wrapper).find("ul"); }

			return $ul;
		},
		add_btn: function(group, icon, label, click) {
			var $ul = this.get_group(group);
			var $li = $('<li><i class="'+icon+'"></i></li>')
				.appendTo($ul)
				.on("click", function() {
					click.apply(this);
					return false;
				});

			$li.find("i").attr("title", label).tooltip({ delay: { "show": 600, "hide": 100 }, trigger: "hover" });


			this.$wrapper.find(".iconbar-" + group).removeClass("hide");
			this.show();
			return $li;
		},
		hide: function(group) {
			if(group) {
				this.$wrapper.find(".iconbar-" + group).addClass("hide");
				this.check_if_all_hidden();
			} else {
				this.$wrapper.addClass("hide").trigger("hidden");
			}
		},
		show: function(group) {
			if(group) {
				this.$wrapper.find(".iconbar-" + group).removeClass("hide");
				this.show();
			} else {
				if(this.$wrapper.hasClass("hide"))
					{ this.$wrapper.removeClass("hide").trigger("shown"); }
			}
		},
		clear: function(group) {
			this.$wrapper.find(".iconbar-" + group).addClass("hide").find("ul").empty();
			this.check_if_all_hidden();
		},
		check_if_all_hidden: function() {
			if(!this.$wrapper.find(".iconbar:visible").length) {
				this.hide();
			}
		}
	});

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.form.LinkSelector = Class.extend({
		init: function (opts) {
			/* help: Options: doctype, get_query, target */
			$.extend(this, opts);

			var me = this;
			if (this.doctype != "[Select]") {
				frappe.model.with_doctype(this.doctype, function (r) {
					me.make();
				});
			} else {
				this.make();
			}
		},
		make: function () {
			var me = this;

			this.start = 0;
			this.dialog = new frappe.ui.Dialog({
				title: __("Select {0}", [(this.doctype == '[Select]') ? __("value") : __(this.doctype)]),
				fields: [
					{
						fieldtype: "Data", fieldname: "txt", label: __("Beginning with"),
						description: __("You can use wildcard %"),
					},
					{
						fieldtype: "HTML", fieldname: "results"
					},
					{
						fieldtype: "Button", fieldname: "more", label: __("More"), click: function () {
							me.start += 20;
							me.search();
						}
					}
				],
				primary_action_label: __("Search"),
				primary_action: function () {
					me.start = 0;
					me.search();
				}
			});

			if (this.txt)
				{ this.dialog.fields_dict.txt.set_input(this.txt); }

			this.dialog.get_input("txt").on("keypress", function (e) {
				if (e.which === 13) {
					me.start = 0;
					me.search();
				}
			});
			this.dialog.show();
			this.search();
		},
		search: function () {
			var args = {
				txt: this.dialog.fields_dict.txt.get_value(),
				searchfield: "name",
				start: this.start
			};
			var me = this;

			if (this.target.set_custom_query) {
				this.target.set_custom_query(args);
			}

			// load custom query from grid
			if (this.target.is_grid && this.target.fieldinfo[this.fieldname]
				&& this.target.fieldinfo[this.fieldname].get_query) {
				$.extend(args,
					this.target.fieldinfo[this.fieldname].get_query(cur_frm.doc));
			}

			frappe.link_search(this.doctype, args, function (r) {
				var parent = me.dialog.fields_dict.results.$wrapper;
				if (args.start === 0) {
					parent.empty();
				}

				if (r.values.length) {
					$.each(r.values, function (i, v) {
						var row = $(repl('<div class="row link-select-row">\
						<div class="col-xs-4">\
							<b><a href="#">%(name)s</a></b></div>\
						<div class="col-xs-8">\
							<span class="text-muted">%(values)s</span></div>\
						</div>', {
								name: v[0],
								values: v.splice(1).join(", ")
							})).appendTo(parent);

						row.find("a")
							.attr('data-value', v[0])
							.click(function () {
								var value = $(this).attr("data-value");
								if (me.target.is_grid) {
									// set in grid
									me.set_in_grid(value);
								} else {
									if (me.target.doctype)
										{ me.target.parse_validate_and_set_in_model(value); }
									else {
										me.target.set_input(value);
										me.target.$input.trigger("change");
									}
									me.dialog.hide();
								}
								return false;
							});
					});
				} else {
					$('<p><br><span class="text-muted">' + __("No Results") + '</span>'
						+ (frappe.model.can_create(me.doctype) ?
							('<br><br><a class="new-doc btn btn-default btn-sm">'
								+ __('Create a new {0}', [__(me.doctype)]) + "</a>") : '')
						+ '</p>').appendTo(parent).find(".new-doc").click(function () {
							frappe.new_doc(me.doctype);
						});
				}

				if (r.values.length < 20) {
					var more_btn = me.dialog.fields_dict.more.$wrapper;
					more_btn.hide();
				}

			}, this.dialog.get_primary_btn());

		},
		set_in_grid: function (value) {
			var me = this, updated = false;
			var d = null;
			if (this.qty_fieldname) {
				frappe.prompt({
					fieldname: "qty", fieldtype: "Float", label: "Qty",
					"default": 1, reqd: 1
				}, function (data) {
					$.each(me.target.frm.doc[me.target.df.fieldname] || [], function (i, d) {
						if (d[me.fieldname] === value) {
							frappe.model.set_value(d.doctype, d.name, me.qty_fieldname, data.qty);
							frappe.show_alert(__("Added {0} ({1})", [value, d[me.qty_fieldname]]));
							updated = true;
							return false;
						}
					});
					if (!updated) {
						frappe.run_serially([
							function () {
								d = me.target.add_new_row();
							},
							function () { return frappe.timeout(0.1); },
							function () {
								var args = {};
								args[me.fieldname] = value;
								args[me.qty_fieldname] = data.qty;

								return frappe.model.set_value(d.doctype, d.name, args);
							},
							function () { return frappe.show_alert(__("Added {0} ({1})", [value, data.qty])); }
						]);
					}
				}, __("Set Quantity"), __("Set"));
			} else if (me.dynamic_link_field) {
				var d = me.target.add_new_row();
				frappe.model.set_value(d.doctype, d.name, me.dynamic_link_field, me.dynamic_link_reference);
				frappe.model.set_value(d.doctype, d.name, me.fieldname, value);
				frappe.show_alert(__("{0} {1} added", [me.dynamic_link_reference, value]));
			} else {
				var d = me.target.add_new_row();
				frappe.model.set_value(d.doctype, d.name, me.fieldname, value);
				frappe.show_alert(__("{0} added", [value]));
			}
		}
	});

	frappe.link_search = function (doctype, args, callback, btn) {
		if (!args) {
			args = {
				txt: ''
			};
		}
		args.doctype = doctype;
		if (!args.searchfield) {
			args.searchfield = 'name';
		}

		frappe.call({
			method: "frappe.desk.search.search_widget",
			type: "GET",
			args: args,
			callback: function (r) {
				callback && callback(r);
			},
			btn: btn
		});
	};

	frappe.ui.form.MultiSelectDialog = class MultiSelectDialog {
		constructor(opts) {
		var this$1 = this;

			/* Options: doctype, target, setters, get_query, action, add_filters_group, data_fields, primary_action_label */
			Object.assign(this, opts);
			this.for_select = this.doctype == "[Select]";
			if (!this.for_select) {
				frappe.model.with_doctype(this.doctype, function () { return this$1.init(); });
			} else {
				this.init();
			}
		}

		init() {
			this.page_length = 20;
			this.start = 0;
			this.fields = this.get_fields();

			this.make();
		}

		get_fields() {
			var primary_fields = this.get_primary_filters();
			var result_fields = this.get_result_fields();
			var data_fields = this.get_data_fields();
			var child_selection_fields = this.get_child_selection_fields();

			return primary_fields.concat( result_fields, data_fields, child_selection_fields);
		}

		get_result_fields() {
			var this$1 = this;

			var show_next_page = function () {
				this$1.start += 20;
				this$1.get_results();
			};
			return [
				{
					fieldtype: "HTML", fieldname: "results_area"
				},
				{
					fieldtype: "Button", fieldname: "more_btn",
					label: __("More"), click: show_next_page.bind(this)
				}
			];
		}

		get_data_fields() {
			if (this.data_fields && this.data_fields.length) {
				// Custom Data Fields
				return [
					{ fieldtype: "Section Break" } ].concat( this.data_fields
				);
			} else {
				return [];
			}
		}

		get_child_selection_fields() {
			var fields = [];
			if (this.allow_child_item_selection && this.child_fieldname) {
				fields.push({ fieldtype: "HTML", fieldname: "child_selection_area" });
			}
			return fields;
		}

		make() {
			var this$1 = this;

			var doctype_plural = this.doctype.plural();
			var title = __("Select {0}", [this.for_select ? __("value") : __(doctype_plural)]);

			this.dialog = new frappe.ui.Dialog({
				title: title,
				fields: this.fields,
				primary_action_label: this.primary_action_label || __("Get Items"),
				secondary_action_label: __("Make {0}", [__(this.doctype)]),
				primary_action: function () {
					var filters_data = this$1.get_custom_filters();
					var data_values = cur_dialog.get_values(); // to pass values of data fields
					var filtered_children = this$1.get_selected_child_names();
					var selected_documents = this$1.get_checked_values().concat( this$1.get_parent_name_of_selected_children());
					this$1.action(selected_documents, Object.assign({}, this$1.args,
						data_values,
						filters_data,
						{filtered_children: filtered_children}));
				},
				secondary_action: this.make_new_document.bind(this)
			});

			if (this.add_filters_group) {
				this.make_filter_area();
			}

			this.args = {};

			this.setup_results();
			this.bind_events();
			this.get_results();
			this.dialog.show();
		}

		make_new_document(e) {
			// If user wants to close the modal
			if (e) {
				this.set_route_options();
				frappe.new_doc(this.doctype, true);
			}
		}

		set_route_options() {
			var this$1 = this;

			// set route options to get pre-filled form fields
			frappe.route_options = {};
			if (Array.isArray(this.setters)) {
				for (var i = 0, list = this.setters; i < list.length; i += 1) {
					var df = list[i];

					frappe.route_options[df.fieldname] = this.dialog.fields_dict[df.fieldname].get_value() || undefined;
				}
			} else {
				Object.keys(this.setters).forEach(function (setter) {
					frappe.route_options[setter] = this$1.dialog.fields_dict[setter].get_value() || undefined;
				});
			}
		}

		setup_results() {
			this.$parent = $(this.dialog.body);
			this.$wrapper = this.dialog.fields_dict.results_area.$wrapper.append("<div class=\"results mt-3\"\n\t\t\tstyle=\"border: 1px solid #d1d8dd; border-radius: 3px; height: 300px; overflow: auto;\"></div>");

			this.$results = this.$wrapper.find('.results');
			this.$results.append(this.make_list_row());
		}

		toggle_child_selection() {
			var this$1 = this;

			if (this.dialog.fields_dict['allow_child_item_selection'].get_value()) {
				this.get_child_result().then(function (r) {
					this$1.child_results = r.message || [];
					this$1.render_child_datatable();
		
					this$1.$wrapper.addClass('hidden');
					this$1.$child_wrapper.removeClass('hidden');
					this$1.dialog.fields_dict.more_btn.$wrapper.hide();
				});
			} else {
				this.child_results = [];
				this.get_results();
				this.$wrapper.removeClass('hidden');
				this.$child_wrapper.addClass('hidden');
			}
		}

		render_child_datatable() {
			var this$1 = this;

			if (!this.child_datatable) {
				this.setup_child_datatable();
			} else {
				setTimeout(function () {
					this$1.child_datatable.rowmanager.checkMap = [];
					this$1.child_datatable.refresh(this$1.get_child_datatable_rows());
					this$1.$child_wrapper.find('.dt-scrollable').css('height', '300px');
				}, 500);
			}
		}

		get_child_datatable_columns() {
			var parent = this.doctype;
			return [parent ].concat( this.child_columns).map(function (d) { return ({ name: frappe.unscrub(d), editable: false }); });
		}

		get_child_datatable_rows() {
			return this.child_results.map(function (d) { return Object.values(d).slice(1); }); // slice name field
		}

		setup_child_datatable() {
			var header_columns = this.get_child_datatable_columns();
			var rows = this.get_child_datatable_rows();
			this.$child_wrapper = this.dialog.fields_dict.child_selection_area.$wrapper;
			this.$child_wrapper.addClass('mt-3');

			this.child_datatable = new frappe.DataTable(this.$child_wrapper.get(0), {
				columns: header_columns,
				data: rows,
				layout: 'fluid',
				inlineFilters: true,
				serialNoColumn: false,
				checkboxColumn: true,
				cellHeight: 35,
				noDataMessage: __('No Data'),
				disableReorderColumn: true
			});
			this.$child_wrapper.find('.dt-scrollable').css('height', '300px');
		}

		get_primary_filters() {
			var this$1 = this;

			var fields = [];

			var columns = new Array(3);

			// Hack for three column layout
			// To add column break
			columns[0] = [
				{
					fieldtype: "Data",
					label: __("Name"),
					fieldname: "search_term"
				}
			];
			columns[1] = [];
			columns[2] = [];

			if ($.isArray(this.setters)) {
				this.setters.forEach(function (setter, index) {
					columns[(index + 1) % 3].push(setter);
				});
			} else {
				Object.keys(this.setters).forEach(function (setter, index) {
					var df_prop = frappe.meta.docfield_map[this$1.doctype][setter];

					// Index + 1 to start filling from index 1
					// Since Search is a standrd field already pushed
					columns[(index + 1) % 3].push({
						fieldtype: df_prop.fieldtype,
						label: df_prop.label,
						fieldname: setter,
						options: df_prop.options,
						default: this$1.setters[setter]
					});
				});
			}

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal
			if (Object.seal) {
				Object.seal(columns);
				// now a is a fixed-size array with mutable entries
			}

			if (this.allow_child_item_selection) {
				this.child_doctype = frappe.meta.get_docfield(this.doctype, this.child_fieldname).options;
				columns[0].push({
					fieldtype: "Check",
					label: __("Select {0}", [this.child_doctype]),
					fieldname: "allow_child_item_selection",
					onchange: this.toggle_child_selection.bind(this)
				});
			}

			fields = columns[0].concat( [{ fieldtype: "Column Break" }],
				columns[1],
				[{ fieldtype: "Column Break" }],
				columns[2],
				[{ fieldtype: "Section Break", fieldname: "primary_filters_sb" }]
			);

			if (this.add_filters_group) {
				fields.push(
					{
						fieldtype: 'HTML',
						fieldname: 'filter_area',
					}
				);
			}

			return fields;
		}

		make_filter_area() {
			var this$1 = this;

			this.filter_group = new frappe.ui.FilterGroup({
				parent: this.dialog.get_field('filter_area').$wrapper,
				doctype: this.doctype,
				on_change: function () {
					this$1.get_results();
				}
			});
			// 'Apply Filter' breaks since the filers are not in a popover
			// Hence keeping it hidden
			this.filter_group.wrapper.find('.apply-filters').hide();
		}

		get_custom_filters() {
			if (this.add_filters_group && this.filter_group) {
				return this.filter_group.get_filters().reduce(function (acc, filter) {
					var obj;

					return Object.assign(acc, ( obj = {}, obj[filter[1]] = [filter[2], filter[3]], obj ));
				}, {});
			} else {
				return {};
			}
		}

		bind_events() {
			var this$1 = this;

			var me = this;

			this.$results.on('click', '.list-item-container', function (e) {
				if (!$(e.target).is(':checkbox') && !$(e.target).is('a')) {
					$(this).find(':checkbox').trigger('click');
				}
			});

			this.$results.on('click', '.list-item--head :checkbox', function (e) {
				this$1.$results.find('.list-item-container .list-row-check')
					.prop("checked", ($(e.target).is(':checked')));
			});

			this.$parent.find('.input-with-feedback').on('change', function () {
				frappe.flags.auto_scroll = false;
				this$1.get_results();
			});

			this.$parent.find('[data-fieldtype="Data"]').on('input', function () {
				var $this = $(this$1);
				clearTimeout($this.data('timeout'));
				$this.data('timeout', setTimeout(function () {
					frappe.flags.auto_scroll = false;
					me.empty_list();
					me.get_results();
				}, 300));
			});
		}

		get_parent_name_of_selected_children() {
			var this$1 = this;

			if (!this.child_datatable || !this.child_datatable.datamanager.rows.length) { return []; }

			var parent_names = this.child_datatable.rowmanager.checkMap.reduce(function (parent_names, checked, index) {
				if (checked == 1) {
					var parent_name = this$1.child_results[index].parent;
					parent_names.push(parent_name);
				}
				return parent_names;
			}, []);

			return parent_names;
		}

		get_selected_child_names() {
			var this$1 = this;

			if (!this.child_datatable || !this.child_datatable.datamanager.rows.length) { return []; }

			var checked_names = this.child_datatable.rowmanager.checkMap.reduce(function (checked_names, checked, index) {
				if (checked == 1) {
					var child_row_name = this$1.child_results[index].name;
					checked_names.push(child_row_name);
				}
				return checked_names;
			}, []);

			return checked_names;
		}

		get_checked_values() {
			// Return name of checked value.
			return this.$results.find('.list-item-container').map(function () {
				if ($(this).find('.list-row-check:checkbox:checked').length > 0) {
					return $(this).attr('data-item-name');
				}
			}).get();
		}

		get_checked_items() {
			// Return checked items with all the column values.
			var checked_values = this.get_checked_values();
			return this.results.filter(function (res) { return checked_values.includes(res.name); });
		}

		make_list_row(result) {
			if ( result === void 0 ) result = {};

			var me = this;
			// Make a head row by default (if result not passed)
			var head = Object.keys(result).length === 0;

			var contents = "";
			var columns = ["name"];

			if ($.isArray(this.setters)) {
				for (var i = 0, list = this.setters; i < list.length; i += 1) {
					var df = list[i];

					columns.push(df.fieldname);
				}
			} else {
				columns = columns.concat(Object.keys(this.setters));
			}

			columns.forEach(function (column) {
				contents += "<div class=\"list-item__content ellipsis\">\n\t\t\t\t" + (head ? ("<span class=\"ellipsis text-muted\" title=\"" + (__(frappe.model.unscrub(column))) + "\">" + (__(frappe.model.unscrub(column))) + "</span>")
			: (column !== "name" ? ("<span class=\"ellipsis result-row\" title=\"" + (__(result[column] || '')) + "\">" + (__(result[column] || '')) + "</span>")
				: ("<a href=\"" + ("/app/" + frappe.router.slug(me.doctype) + "/" + result[column] || '') + "\" class=\"list-id ellipsis\" title=\"" + (__(result[column] || '')) + "\">\n\t\t\t\t\t\t\t" + (__(result[column] || '')) + "</a>"))) + "\n\t\t\t</div>";
			});

			var $row = $(("<div class=\"list-item\">\n\t\t\t<div class=\"list-item__content\" style=\"flex: 0 0 10px;\">\n\t\t\t\t<input type=\"checkbox\" class=\"list-row-check\" data-item-name=\"" + (result.name) + "\" " + (result.checked ? 'checked' : '') + ">\n\t\t\t</div>\n\t\t\t" + contents + "\n\t\t</div>"));

			head ? $row.addClass('list-item--head')
				: $row = $(("<div class=\"list-item-container\" data-item-name=\"" + (result.name) + "\"></div>")).append($row);

			return $row;
		}

		render_result_list(results, more, empty) {
			if ( more === void 0 ) more = 0;
			if ( empty === void 0 ) empty = true;

			var me = this;
			var more_btn = me.dialog.fields_dict.more_btn.$wrapper;

			// Make empty result set if filter is set
			if (!frappe.flags.auto_scroll && empty) {
				this.empty_list();
			}
			more_btn.hide();
			$(".modal-dialog .list-item--head").css("z-index", 0);

			if (results.length === 0) { return; }
			if (more) { more_btn.show(); }

			var checked = this.get_checked_values();

			results
				.filter(function (result) { return !checked.includes(result.name); })
				.forEach(function (result) {
					me.$results.append(me.make_list_row(result));
				});

			this.$results.find(".list-item--head").css("z-index", 0);

			if (frappe.flags.auto_scroll) {
				this.$results.animate({ scrollTop: me.$results.prop('scrollHeight') }, 500);
			}
		}

		empty_list() {
			// Store all checked items
			var checked = this.get_checked_items().map(function (item) {
				return Object.assign({}, item,
					{checked: true});
			});

			// Remove **all** items
			this.$results.find('.list-item-container').remove();

			// Rerender checked items
			this.render_result_list(checked, 0, false);
		}

		get_filters_from_setters() {
			var me = this;
			var filters = this.get_query ? this.get_query().filters : {} || {};
			var filter_fields = [];

			if ($.isArray(this.setters)) {
				for (var i = 0, list = this.setters; i < list.length; i += 1) {
					var df = list[i];

					filters[df.fieldname] = me.dialog.fields_dict[df.fieldname].get_value() || undefined;
					me.args[df.fieldname] = filters[df.fieldname];
					filter_fields.push(df.fieldname);
				}
			} else {
				Object.keys(this.setters).forEach(function (setter) {
					var value = me.dialog.fields_dict[setter].get_value();
					if (me.dialog.fields_dict[setter].df.fieldtype == "Data" && value) {
						filters[setter] = ["like", "%" + value + "%"];
					} else {
						filters[setter] = value || undefined;
						me.args[setter] = filters[setter];
						filter_fields.push(setter);
					}
				});
			}

			return [filters, filter_fields];
		}

		get_args_for_search() {
			var ref = this.get_filters_from_setters();
			var filters = ref[0];
			var filter_fields = ref[1];

			var custom_filters = this.get_custom_filters();
			Object.assign(filters, custom_filters);

			return {
				doctype: this.doctype,
				txt: this.dialog.fields_dict["search_term"].get_value(),
				filters: filters,
				filter_fields: filter_fields,
				start: this.start,
				page_length: this.page_length + 1,
				query: this.get_query ? this.get_query().query : '',
				as_dict: 1
			};
		}

		async perform_search(args) {
			var res = await frappe.call({
				type: "GET",
				method: 'frappe.desk.search.search_widget',
				no_spinner: true,
				args: args,
			});
			var more = res.values.length && res.values.length > this.page_length ? 1 : 0;
			if (more) {
				res.values.pop();
			}

			return [res, more];
		}

		async get_results() {
			var this$1 = this;

			var args = this.get_args_for_search();
			var ref = await this.perform_search(args);
			var res = ref[0];
			var more = ref[1];

			this.results = [];
			if (res.values.length) {
				res.values.forEach(function (result) {
					result.checked = 0;
					this$1.results.push(result);
				});
			}
			this.render_result_list(this.results, more);
		}

		async get_filtered_parents_for_child_search() {
			var parent_search_args = this.get_args_for_search();
			parent_search_args.filter_fields = ['name'];
			// eslint-disable-next-line no-unused-vars
			var ref = await this.perform_search(parent_search_args);
			var response = ref[0];
			var _ = ref[1];

			var parent_names = [];
			if (response.values.length) {
				parent_names = response.values.map(function (v) { return v.name; });
			}
			return parent_names;
		}

		async add_parent_filters(filters) {
			var parent_names = await this.get_filtered_parents_for_child_search();
			if (parent_names.length) {
				filters.push([ "parent", "in", parent_names ]);
			}
		}

		add_custom_child_filters(filters) {
			var this$1 = this;

			if (this.add_filters_group && this.filter_group) {
				this.filter_group.get_filters().forEach(function (filter) {
					if (filter[0] == this$1.child_doctype) {
						filters.push([filter[1], filter[2], filter[3]]);
					}
				});
			}
		}

		async get_child_result() {
			var filters = [["parentfield", "=", this.child_fieldname]];

			await this.add_parent_filters(filters);
			this.add_custom_child_filters(filters);

			return frappe.call({
				method: "frappe.client.get_list",
				args: {
					doctype: this.child_doctype,
					filters: filters,
					fields: ['name', 'parent' ].concat( this.child_columns),
					parent: this.doctype,
					order_by: 'parent'
				}
			});
		}
	};

	// frappe.ui.Capture
	// Author - Achilles Rasquinha <achilles@frappe.io>

	/**
	 * @description Converts a canvas, image or a video to a data URL string.
	 *
	 * @param 	{HTMLElement} element - canvas, img or video.
	 * @returns {string} 			  - The data URL string.
	 *
	 * @example
	 * frappe._.get_data_uri(video)
	 * // returns "data:image/pngbase64,..."
	 */
	frappe._.get_data_uri = function (element) {

		var width = element.videoWidth;
		var height = element.videoHeight;

		var $canvas = $('<canvas/>');
		$canvas[0].width = width;
		$canvas[0].height = height;

		var context = $canvas[0].getContext('2d');
		context.drawImage(element, 0, 0, width, height);

		var data_uri = $canvas[0].toDataURL('image/png');

		return data_uri;
	};

	/**
	 * @description Frappe's Capture object.
	 *
	 * @example
	 * const capture = frappe.ui.Capture()
	 * capture.show()
	 *
	 * capture.click((data_uri) => {
	 * 	// do stuff
	 * })
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Taking_still_photos
	 */
	frappe.ui.Capture = class {
		constructor(options) {
		if ( options === void 0 ) options = {};

			this.options = frappe.ui.Capture.OPTIONS;
			this.set_options(options);
		}

		set_options(options) {
			this.options = Object.assign({}, frappe.ui.Capture.OPTIONS, options);

			return this;
		}

		render() {
			var this$1 = this;

			return navigator.mediaDevices.getUserMedia({ video: true }).then(function (stream) {
				this$1.stream = stream;

				this$1.dialog = new frappe.ui.Dialog({
					title: this$1.options.title,
					animate: this$1.options.animate,
					on_hide: function () { return this$1.stop_media_stream(); }
				});

				this$1.dialog.get_close_btn().on('click', function () {
					this$1.hide();
				});

				var set_take_photo_action = function () {
					this$1.dialog.set_primary_action(__('Take Photo'), function () {
						var data_url = frappe._.get_data_uri(video);
						$e.find('.fc-p').attr('src', data_url);

						$e.find('.fc-s').hide();
						$e.find('.fc-p').show();

						this$1.dialog.set_secondary_action_label(__('Retake'));
						this$1.dialog.get_secondary_btn().show();

						this$1.dialog.set_primary_action(__('Submit'), function () {
							this$1.hide();
							if (this$1.callback) { this$1.callback(data_url); }
						});
					});
				};

				set_take_photo_action();

				this$1.dialog.set_secondary_action(function () {
					$e.find('.fc-p').hide();
					$e.find('.fc-s').show();

					this$1.dialog.get_secondary_btn().hide();
					this$1.dialog.get_primary_btn().off('click');
					set_take_photo_action();
				});

				this$1.dialog.get_secondary_btn().hide();

				var $e = $(frappe.ui.Capture.TEMPLATE);

				var video = $e.find('video')[0];
				video.srcObject = this$1.stream;
				video.play();
				var $container = $(this$1.dialog.body);

				$container.html($e);
			});
		}

		show() {
			var this$1 = this;

			this.render()
				.then(function () {
					this$1.dialog.show();
				})
				.catch(function (err) {
					if (this$1.options.error) {
						frappe.show_alert(frappe.ui.Capture.ERR_MESSAGE, 3);
					}

					throw err;
				});
		}

		hide() {
			if (this.dialog) { this.dialog.hide(); }
			this.stop_media_stream();
		}

		stop_media_stream() {
			if (this.stream) {
				this.stream.getTracks().forEach(function (track) {
					track.stop();
				});
			}
		}

		submit(fn) {
			this.callback = fn;
		}
	};
	frappe.ui.Capture.OPTIONS = {
		title: __("Camera"),
		animate: false,
		error: false
	};
	frappe.ui.Capture.ERR_MESSAGE = __('Unable to load camera.');
	frappe.ui.Capture.TEMPLATE = "\n<div class=\"frappe-capture\">\n\t<div class=\"panel panel-default\">\n\t\t<div class=\"embed-responsive embed-responsive-16by9\">\n\t\t\t<img class=\"fc-p embed-responsive-item\" style=\"object-fit: contain; display: none;\"/>\n\t\t\t<video class=\"fc-s embed-responsive-item\">" + (frappe.ui.Capture.ERR_MESSAGE) + "</video>\n\t\t</div>\n\t</div>\n</div>\n";

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt


	frappe.provide("frappe.ui");
	frappe.ui.app_icon = {
		get_html: function(module, small) {
			var icon = module.icon;
			var color = module.color;
			if (icon
				&& icon.match(/([\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF])/g)) {
				module.emoji = module.icon;
			}
			var icon_style = "";
			if(module.reverse) {
				icon_style = "color: #36414C;";
			}

			if(!color) {
				color = '#4aa3df';
			}

			// first letter
			if(!icon || module.emoji) {
				icon = '<span class="inner" ' +
					(module.reverse ? ('style="' + icon_style + '"') : '')
					+ '>' + (module.emoji || module._label[0].toUpperCase()) + '</span>';
			} else if(icon.split(".").slice(-1)[0]==="svg") {
				$.ajax({
					url: frappe.urllib.get_full_url(icon),
					dataType: "text",
					async: false,
					success: function(data) {
						icon = data;
					}
				});
				icon = '<object class="app-icon-svg">'+ icon+'</object>';
			} else {
				icon = '<i class="'+ icon+'" title="' + module._label + '" style="'+ icon_style + '"></i>';
			}

			return '<div class="app-icon'+ (small ? " app-icon-small" : "")
				+'" style="background-color: '+ color +'" title="'+ module._label +'">'+icon+'</div>';
		}
	};

	frappe.provide('frappe.ui');

	frappe.ui.ThemeSwitcher = class ThemeSwitcher {
		constructor() {
			this.setup_dialog();
			this.refresh();
		}

		setup_dialog() {
			this.dialog = new frappe.ui.Dialog({
				title: __("Switch Theme")
			});
			this.body = $("<div class=\"theme-grid\"></div>").appendTo(this.dialog.$body);
			this.bind_events();
		}

		bind_events() {
			var this$1 = this;

			this.dialog.$wrapper.on('keydown', function (e) {
				if (!this$1.themes) { return; }

				var key = frappe.ui.keys.get_key(e);
				var increment_by;

				if (key === "right") {
					increment_by = 1;
				} else if (key === "left") {
					increment_by = -1;
				} else {
					return;
				}

				var current_index = this$1.themes.findIndex(function (theme) {
					return theme.name === this$1.current_theme;
				});

				var new_theme = this$1.themes[current_index + increment_by];
				if (!new_theme) { return; }

				new_theme.$html.click();
				return false;
			});
		}

		refresh() {
			var this$1 = this;

			this.current_theme = document.documentElement.getAttribute("data-theme") || "light";
			this.fetch_themes().then(function () {
				this$1.render();
			});
		}

		fetch_themes() {
			var this$1 = this;

			return new Promise(function (resolve) {
				this$1.themes = [
					{
						name: "light",
						label: __("Frappe Light"),
					},
					{
						name: "dark",
						label: __("Timeless Night"),
					}
				];

				resolve(this$1.themes);
			});
		}

		render() {
			var this$1 = this;

			this.themes.forEach(function (theme) {
				var html = this$1.get_preview_html(theme);
				html.appendTo(this$1.body);
				theme.$html = html;
			});
		}

		get_preview_html(theme) {
			var this$1 = this;

			var preview = $(("<div class=\"" + (this.current_theme == theme.name ? "selected" : "") + "\">\n\t\t\t<div data-theme=" + (theme.name) + ">\n\t\t\t\t<div class=\"background\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<div class=\"preview-check\">" + (frappe.utils.icon('tick', 'xs')) + "</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"navbar\"></div>\n\t\t\t\t\t<div class=\"p-2\">\n\t\t\t\t\t\t<div class=\"toolbar\">\n\t\t\t\t\t\t\t<span class=\"text\"></span>\n\t\t\t\t\t\t\t<span class=\"primary\"></span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"foreground\"></div>\n\t\t\t\t\t\t<div class=\"foreground\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"mt-3 text-center\">\n\t\t\t\t<h5 class=\"theme-title\">" + (theme.label) + "</h5>\n\t\t\t</div>\n\t\t</div>"));

			preview.on('click', function () {
				if (this$1.current_theme === theme.name) { return; }

				this$1.themes.forEach(function (th) {
					th.$html.removeClass("selected");
				});

				preview.addClass("selected");
				this$1.toggle_theme(theme.name);
			});

			return preview;
		}

		toggle_theme(theme) {
			this.current_theme = theme.toLowerCase();
			document.documentElement.setAttribute("data-theme", this.current_theme);
			frappe.show_alert("Theme Changed", 3);

			frappe.xcall("frappe.core.doctype.user.user.switch_theme", {
				theme: toTitle(theme)
			});
		}
		show() {
			this.dialog.show();
		}

		hide() {
			this.dialog.hide();
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.model');

	$.extend(frappe.model, {
		no_value_type: ['Section Break', 'Column Break', 'HTML', 'Table', 'Table MultiSelect',
			'Button', 'Image', 'Fold', 'Heading'],

		layout_fields: ['Section Break', 'Column Break', 'Fold'],

		std_fields_list: ['name', 'owner', 'creation', 'modified', 'modified_by',
			'_user_tags', '_comments', '_assign', '_liked_by', 'docstatus',
			'parent', 'parenttype', 'parentfield', 'idx'],

		core_doctypes_list: ['DocType', 'DocField', 'DocPerm', 'User', 'Role', 'Has Role',
			'Page', 'Module Def', 'Print Format', 'Report', 'Customize Form',
			'Customize Form Field', 'Property Setter', 'Custom Field', 'Client Script'],

		std_fields: [
			{fieldname:'name', fieldtype:'Link', label:__('ID')},
			{fieldname:'owner', fieldtype:'Link', label:__('Created By'), options: 'User'},
			{fieldname:'idx', fieldtype:'Int', label:__('Index')},
			{fieldname:'creation', fieldtype:'Date', label:__('Created On')},
			{fieldname:'modified', fieldtype:'Date', label:__('Last Updated On')},
			{fieldname:'modified_by', fieldtype:'Data', label:__('Last Updated By')},
			{fieldname:'_user_tags', fieldtype:'Data', label:__('Tags')},
			{fieldname:'_liked_by', fieldtype:'Data', label:__('Liked By')},
			{fieldname:'_comments', fieldtype:'Text', label:__('Comments')},
			{fieldname:'_assign', fieldtype:'Text', label:__('Assigned To')},
			{fieldname:'docstatus', fieldtype:'Int', label:__('Document Status')} ],

		numeric_fieldtypes: ["Int", "Float", "Currency", "Percent", "Duration"],

		std_fields_table: [
			{fieldname:'parent', fieldtype:'Data', label:__('Parent')} ],

		table_fields: ['Table', 'Table MultiSelect'],

		new_names: {},
		events: {},
		user_settings: {},

		init: function() {
			// setup refresh if the document is updated somewhere else
			frappe.realtime.on("doc_update", function(data) {
				// set list dirty
				frappe.views.ListView.trigger_list_update(data);
				var doc = locals[data.doctype] && locals[data.doctype][data.name];

				if(doc) {
					// current document is dirty, show message if its not me
					if(frappe.get_route()[0]==="Form" && cur_frm.doc.doctype===doc.doctype && cur_frm.doc.name===doc.name) {
						if(!frappe.ui.form.is_saving && data.modified!=cur_frm.doc.modified) {
							doc.__needs_refresh = true;
							cur_frm.check_doctype_conflict();
						}
					} else {
						if(!doc.__unsaved) {
							// no local changes, remove from locals
							frappe.model.remove_from_locals(doc.doctype, doc.name);
						} else {
							// show message when user navigates back
							doc.__needs_refresh = true;
						}
					}
				}
			});

			frappe.realtime.on("list_update", function(data) {
				frappe.views.ListView.trigger_list_update(data);
			});

		},

		is_value_type: function(fieldtype) {
			if (typeof fieldtype == 'object') {
				fieldtype = fieldtype.fieldtype;
			}
			// not in no-value type
			return frappe.model.no_value_type.indexOf(fieldtype)===-1;
		},

		is_non_std_field: function(fieldname) {
			return !frappe.model.std_fields_list.includes(fieldname);
		},

		get_std_field: function(fieldname, ignore) {
			if ( ignore === void 0 ) ignore=false;

			var docfield = $.map([].concat(frappe.model.std_fields).concat(frappe.model.std_fields_table),
				function(d) {
					if(d.fieldname==fieldname) { return d; }
				});
			if (!docfield.length) {
				//Standard fields are ignored in case of adding columns as a result of groupby
				if (ignore) {
					return {fieldname: fieldname};
				} else {
					frappe.msgprint(__("Unknown Column: {0}", [fieldname]));
				}
			}
			return docfield[0];
		},

		get_from_localstorage: function(doctype) {
			if (localStorage["_doctype:" + doctype]) {
				return JSON.parse(localStorage["_doctype:" + doctype]);
			}
		},

		set_in_localstorage: function(doctype, docs) {
			try {
				localStorage["_doctype:" + doctype] = JSON.stringify(docs);
			} catch(e) {
				// if quota is exceeded, clear local storage and set item
				console.warn("localStorage quota exceeded, clearing doctype cache");
				frappe.model.clear_local_storage();
				localStorage["_doctype:" + doctype] = JSON.stringify(docs);
			}
		},

		clear_local_storage: function() {
			for(var key in localStorage) {
				if (key.startsWith("_doctype:")) {
					localStorage.removeItem(key);
				}
			}
		},

		with_doctype: function(doctype, callback, async) {
			if(locals.DocType[doctype]) {
				callback && callback();
			} else {
				var cached_timestamp = null;
				var cached_doc = null;

				var cached_docs = frappe.model.get_from_localstorage(doctype);

				if (cached_docs) {
					cached_doc = cached_docs.filter(function (doc) { return doc.name === doctype; })[0];
					if(cached_doc) {
						cached_timestamp = cached_doc.modified;
					}
				}

				return frappe.call({
					method:'frappe.desk.form.load.getdoctype',
					type: "GET",
					args: {
						doctype: doctype,
						with_parent: 1,
						cached_timestamp: cached_timestamp
					},
					async: async,
					callback: function(r) {
						if(r.exc) {
							frappe.msgprint(__("Unable to load: {0}", [__(doctype)]));
							throw "No doctype";
						}
						if(r.message=="use_cache") {
							frappe.model.sync(cached_doc);
						} else {
							frappe.model.set_in_localstorage(doctype, r.docs);
						}
						frappe.model.init_doctype(doctype);

						if(r.user_settings) {
							// remember filters and other settings from last view
							frappe.model.user_settings[doctype] = JSON.parse(r.user_settings);
							frappe.model.user_settings[doctype].updated_on = moment().toString();
						}
						callback && callback(r);
					}
				});
			}
		},

		init_doctype: function(doctype) {
			var meta = locals.DocType[doctype];
			if(meta.__list_js) {
				eval(meta.__list_js);
			}
			if(meta.__custom_list_js) {
				eval(meta.__custom_list_js);
			}
			if(meta.__calendar_js) {
				eval(meta.__calendar_js);
			}
			if(meta.__map_js) {
				eval(meta.__map_js);
			}
			if(meta.__tree_js) {
				eval(meta.__tree_js);
			}
			if(meta.__templates) {
				$.extend(frappe.templates, meta.__templates);
			}
		},

		with_doc: function(doctype, name, callback) {
			return new Promise(function (resolve) {
				if(!name) { name = doctype; } // single type
				if(locals[doctype] && locals[doctype][name] && frappe.model.get_docinfo(doctype, name)) {
					callback && callback(name);
					resolve(frappe.get_doc(doctype, name));
				} else {
					return frappe.call({
						method: 'frappe.desk.form.load.getdoc',
						type: "GET",
						args: {
							doctype: doctype,
							name: name
						},
						callback: function(r) {
							callback && callback(name, r);
							resolve(frappe.get_doc(doctype, name));
						}
					});
				}
			});
		},

		get_docinfo: function(doctype, name) {
			return frappe.model.docinfo[doctype] && frappe.model.docinfo[doctype][name] || null;
		},

		set_docinfo: function(doctype, name, key, value) {
			if (frappe.model.docinfo[doctype] && frappe.model.docinfo[doctype][name]) {
				frappe.model.docinfo[doctype][name][key] = value;
			}
		},

		get_shared: function(doctype, name) {
			return frappe.model.get_docinfo(doctype, name).shared;
		},

		get_server_module_name: function(doctype) {
			var dt = frappe.model.scrub(doctype);
			var module = frappe.model.scrub(locals.DocType[doctype].module);
			var app = frappe.boot.module_app[module];
			return app + "." + module + '.doctype.' + dt + '.' + dt;
		},

		scrub: function(txt) {
			return txt.replace(/ /g, "_").toLowerCase();  // use to slugify or create a slug, a "code-friendly" string
		},

		unscrub: function(txt) {
			return __(txt || '').replace(/-|_/g, " ").replace(/\w*/g,
	            function(keywords){return keywords.charAt(0).toUpperCase() + keywords.substr(1).toLowerCase();});
		},

		can_create: function(doctype) {
			return frappe.boot.user.can_create.indexOf(doctype)!==-1;
		},

		can_select: function(doctype) {
			if (frappe.boot.user) {
				return frappe.boot.user.can_select.indexOf(doctype)!==-1;
			}
		},

		can_read: function(doctype) {
			if (frappe.boot.user) {
				return frappe.boot.user.can_read.indexOf(doctype)!==-1;
			}
		},

		can_write: function(doctype) {
			return frappe.boot.user.can_write.indexOf(doctype)!==-1;
		},

		can_get_report: function(doctype) {
			return frappe.boot.user.can_get_report.indexOf(doctype)!==-1;
		},

		can_delete: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.user.can_delete.indexOf(doctype)!==-1;
		},

		can_cancel: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.user.can_cancel.indexOf(doctype)!==-1;
		},

		has_workflow: function(doctype) {
			return frappe.get_list('Workflow', {'document_type': doctype,
				'is_active': 1}).length;
		},

		is_submittable: function(doctype) {
			if(!doctype) { return false; }
			return locals.DocType[doctype]
				&& locals.DocType[doctype].is_submittable;
		},

		is_table: function(doctype) {
			if(!doctype) { return false; }
			return locals.DocType[doctype] && locals.DocType[doctype].istable;
		},

		is_single: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.single_types.indexOf(doctype) != -1;
		},

		is_tree: function(doctype) {
			if (!doctype) { return false; }
			return frappe.boot.treeviews.indexOf(doctype) != -1;
		},

		is_fresh: function is_fresh(doc) {
			// returns true if document has been recently loaded (5 seconds ago)
			return doc && doc.__last_sync_on && ((new Date() - doc.__last_sync_on)) < 5000;
		},

		can_import: function(doctype, frm) {
			// system manager can always import
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].import===1; }
			return frappe.boot.user.can_import.indexOf(doctype)!==-1;
		},

		can_export: function(doctype, frm) {
			// system manager can always export
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].export===1; }
			return frappe.boot.user.can_export.indexOf(doctype)!==-1;
		},

		can_print: function(doctype, frm) {
			if(frm) { return frm.perm[0].print===1; }
			return frappe.boot.user.can_print.indexOf(doctype)!==-1;
		},

		can_email: function(doctype, frm) {
			if(frm) { return frm.perm[0].email===1; }
			return frappe.boot.user.can_email.indexOf(doctype)!==-1;
		},

		can_share: function(doctype, frm) {
			if(frm) {
				return frm.perm[0].share===1;
			}
			return frappe.boot.user.can_share.indexOf(doctype)!==-1;
		},

		can_set_user_permissions: function(doctype, frm) {
			// system manager can always set user permissions
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].set_user_permissions===1; }
			return frappe.boot.user.can_set_user_permissions.indexOf(doctype)!==-1;
		},

		has_value: function(dt, dn, fn) {
			// return true if property has value
			var val = locals[dt] && locals[dt][dn] && locals[dt][dn][fn];
			var df = frappe.meta.get_docfield(dt, fn, dn);

			if(frappe.model.table_fields.includes(df.fieldtype)) {
				var ret = false;
				$.each(locals[df.options] || {}, function(k,d) {
					if(d.parent==dn && d.parenttype==dt && d.parentfield==df.fieldname) {
						ret = true;
						return false;
					}
				});
			} else {
				var ret = !is_null(val);
			}
			return ret ? true : false;
		},

		get_list: function(doctype, filters) {
			var docsdict = locals[doctype] || locals[":" + doctype] || {};
			if($.isEmptyObject(docsdict))
				{ return []; }
			return frappe.utils.filter_dict(docsdict, filters);
		},

		get_value: function(doctype, filters, fieldname, callback) {
			if(callback) {
				frappe.call({
					method:"frappe.client.get_value",
					args: {
						doctype: doctype,
						fieldname: fieldname,
						filters: filters
					},
					callback: function(r) {
						if(!r.exc) {
							callback(r.message);
						}
					}
				});
			} else {
				if(typeof filters==="string" && locals[doctype] && locals[doctype][filters]) {
					return locals[doctype][filters][fieldname];
				} else {
					var l = frappe.get_list(doctype, filters);
					return (l.length && l[0]) ? l[0][fieldname] : null;
				}
			}
		},

		set_value: function(doctype, docname, fieldname, value, fieldtype) {
			/* help: Set a value locally (if changed) and execute triggers */

			var doc;
			if ($.isPlainObject(doctype)) {
				// first parameter is the doc, shift parameters to the left
				doc = doctype; fieldname = docname; value = fieldname;
			} else {
				doc = locals[doctype] && locals[doctype][docname];
			}

			var to_update = fieldname;
			var tasks = [];
			if(!$.isPlainObject(to_update)) {
				to_update = {};
				to_update[fieldname] = value;
			}

			$.each(to_update, function (key, value) {
				if (doc && doc[key] !== value) {
					if(doc.__unedited && !(!doc[key] && !value)) {
						// unset unedited flag for virgin rows
						doc.__unedited = false;
					}

					doc[key] = value;
					tasks.push(function () { return frappe.model.trigger(key, value, doc); });
				} else {
					// execute link triggers (want to reselect to execute triggers)
					if(in_list(["Link", "Dynamic Link"], fieldtype) && doc) {
						tasks.push(function () { return frappe.model.trigger(key, value, doc); });
					}
				}
			});

			return frappe.run_serially(tasks);
		},

		on: function(doctype, fieldname, fn) {
			/* help: Attach a trigger on change of a particular field.
			To trigger on any change in a particular doctype, use fieldname as "*"
			*/
			/* example: frappe.model.on("Customer", "age", function(fieldname, value, doc) {
			  if(doc.age < 16) {
			   	frappe.msgprint("Warning, Customer must atleast be 16 years old.");
			    raise "CustomerAgeError";
			  }
			}) */
			frappe.provide("frappe.model.events." + doctype);
			if(!frappe.model.events[doctype][fieldname]) {
				frappe.model.events[doctype][fieldname] = [];
			}
			frappe.model.events[doctype][fieldname].push(fn);
		},

		trigger: function(fieldname, value, doc) {
			var tasks = [];

			function enqueue_events(events) {
				if (!events) { return; }

				var loop = function () {
					var fn = list[i];

					if (!fn) { return; }

					tasks.push(function () {
						var return_value = fn(fieldname, value, doc);

						// if the trigger returns a promise, return it,
						// or use the default promise frappe.after_ajax
						if (return_value && return_value.then) {
							return return_value;
						} else {
							return frappe.after_server_call();
						}
					});
				};

				for (var i = 0, list = events; i < list.length; i += 1) loop();
			}
			if(frappe.model.events[doc.doctype]) {
				enqueue_events(frappe.model.events[doc.doctype][fieldname]);
				enqueue_events(frappe.model.events[doc.doctype]['*']);
			}

			return frappe.run_serially(tasks);
		},

		get_doc: function(doctype, name) {
			if(!name) { name = doctype; }
			if($.isPlainObject(name)) {
				var doc = frappe.get_list(doctype, name);
				return doc && doc.length ? doc[0] : null;
			}
			return locals[doctype] ? locals[doctype][name] : null;
		},

		get_children: function(doctype, parent, parentfield, filters) {
			if($.isPlainObject(doctype)) {
				var doc = doctype;
				var filters = parentfield;
				var parentfield = parent;
			} else {
				var doc = frappe.get_doc(doctype, parent);
			}

			var children = doc[parentfield] || [];
			if(filters) {
				return frappe.utils.filter_dict(children, filters);
			} else {
				return children;
			}
		},

		clear_table: function(doc, parentfield) {
			for (var i=0, l=(doc[parentfield] || []).length; i<l; i++) {
				var d = doc[parentfield][i];
				delete locals[d.doctype][d.name];
			}
			doc[parentfield] = [];
		},

		remove_from_locals: function(doctype, name) {
			this.clear_doc(doctype, name);
			if(frappe.views.formview[doctype]) {
				delete frappe.views.formview[doctype].frm.opendocs[name];
			}
		},

		clear_doc: function(doctype, name) {
			var doc = locals[doctype] && locals[doctype][name];
			if(!doc) { return; }

			var parent = null;
			if(doc.parenttype) {
				var parent = doc.parent,
					parenttype = doc.parenttype,
					parentfield = doc.parentfield;
			}
			delete locals[doctype][name];
			if(parent) {
				var parent_doc = locals[parenttype][parent];
				var newlist = [], idx = 1;
				$.each(parent_doc[parentfield], function(i, d) {
					if(d.name!=name) {
						newlist.push(d);
						d.idx = idx;
						idx++;
					}
					parent_doc[parentfield] = newlist;
				});
			}
		},

		get_no_copy_list: function(doctype) {
			var no_copy_list = ['name','amended_from','amendment_date','cancel_reason'];

			var docfields = frappe.get_doc("DocType", doctype).fields || [];
			for(var i=0, j=docfields.length; i<j; i++) {
				var df = docfields[i];
				if(cint(df.no_copy)) { no_copy_list.push(df.fieldname); }
			}

			return no_copy_list;
		},

		delete_doc: function(doctype, docname, callback) {
			var title = docname;
			var title_field = frappe.get_meta(doctype).title_field;
			if (frappe.get_meta(doctype).autoname == "hash" && title_field) {
				var title = frappe.model.get_value(doctype, docname, title_field);
				title += " (" + docname + ")";
			}
			frappe.confirm(__("Permanently delete {0}?", [title]), function() {
				return frappe.call({
					method: 'frappe.client.delete',
					args: {
						doctype: doctype,
						name: docname
					},
					callback: function(r, rt) {
						if(!r.exc) {
							frappe.utils.play_sound("delete");
							frappe.model.clear_doc(doctype, docname);
							if(callback) { callback(r,rt); }
						}
					}
				})
			});
		},

		rename_doc: function(doctype, docname, callback) {
				var message = __("Merge with existing");
				var warning = __("This cannot be undone");
				var merge_label = message + " <b>(" + warning + ")</b>";

			var d = new frappe.ui.Dialog({
				title: __("Rename {0}", [__(docname)]),
				fields: [
					{label: __("New Name"), fieldname: "new_name", fieldtype: "Data", reqd: 1, "default": docname},
					{label: merge_label, fieldtype: "Check", fieldname: "merge"} ]
			});

			d.set_primary_action(__("Rename"), function() {
				var args = d.get_values();
				if(!args) { return; }
				return frappe.call({
					method:"frappe.rename_doc",
					args: {
						doctype: doctype,
						old: docname,
						new: args.new_name,
						merge: args.merge
					},
					btn: d.get_primary_btn(),
					callback: function(r,rt) {
						if(!r.exc) {
							$(document).trigger('rename', [doctype, docname,
								r.message || args.new_name]);
							if(locals[doctype] && locals[doctype][docname])
								{ delete locals[doctype][docname]; }
							d.hide();
							if(callback)
								{ callback(r.message); }
						}
					}
				});
			});
			d.show();
		},

		round_floats_in: function(doc, fieldnames) {
			if(!fieldnames) {
				fieldnames = frappe.meta.get_fieldnames(doc.doctype, doc.parent,
					{"fieldtype": ["in", ["Currency", "Float"]]});
			}
			for(var i=0, j=fieldnames.length; i < j; i++) {
				var fieldname = fieldnames[i];
				doc[fieldname] = flt(doc[fieldname], precision(fieldname, doc));
			}
		},

		validate_missing: function(doc, fieldname) {
			if(!doc[fieldname]) {
				frappe.throw(__("Please specify") + ": " +
					__(frappe.meta.get_label(doc.doctype, fieldname, doc.parent || doc.name)));
			}
		},

		get_all_docs: function(doc) {
			var all = [doc];
			for(var key in doc) {
				if($.isArray(doc[key])) {
					var children = doc[key];
					for (var i=0, l=children.length; i < l; i++) {
						all.push(children[i]);
					}
				}
			}
			return all;
		},

		get_full_column_name: function(fieldname, doctype) {
			if (fieldname.includes('`tab')) { return fieldname; }
			return '`tab' + doctype + '`.`' + fieldname + '`';
		},

		is_numeric_field: function(fieldtype) {
			if (!fieldtype) { return; }
			if (typeof fieldtype === 'object') {
				fieldtype = fieldtype.fieldtype;
			}
			return frappe.model.numeric_fieldtypes.includes(fieldtype);
		}
	});

	// legacy
	frappe.get_doc = frappe.model.get_doc;
	frappe.get_children = frappe.model.get_children;
	frappe.get_list = frappe.model.get_list;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.db = {
		get_list: function(doctype, args) {
			if (!args) {
				args = {};
			}
			args.doctype = doctype;
			if (!args.fields) {
				args.fields = ['name'];
			}
			if (!('limit' in args)) {
				args.limit = 20;
			}
			return new Promise (function (resolve) {
				frappe.call({
					method: 'frappe.desk.reportview.get_list',
					args: args,
					type: 'GET',
					callback: function(r) {
						resolve(r.message);
					}
				});
			});
		},
		exists: function(doctype, name) {
			return new Promise (function (resolve) {
				frappe.db.get_value(doctype, {name: name}, 'name').then(function (r) {
					(r.message && r.message.name) ? resolve(true) : resolve(false);
				});
			});
		},
		get_value: function(doctype, filters, fieldname, callback, parent_doc) {
			return frappe.call({
				method: "frappe.client.get_value",
				type: 'GET',
				args: {
					doctype: doctype,
					fieldname: fieldname,
					filters: filters,
					parent: parent_doc
				},
				callback: function(r) {
					callback && callback(r.message);
				}
			});
		},
		get_single_value: function (doctype, field) {
			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.client.get_single_value',
					args: { doctype: doctype, field: field },
					type: 'GET',
				}).then(function (r) { return resolve(r ? r.message : null); });
			});
		},
		set_value: function(doctype, docname, fieldname, value, callback) {
			return frappe.call({
				method: "frappe.client.set_value",
				args: {
					doctype: doctype,
					name: docname,
					fieldname: fieldname,
					value: value
				},
				callback: function(r) {
					callback && callback(r.message);
				}
			});
		},
		get_doc: function(doctype, name, filters) {
			if ( filters === void 0 ) filters = null;

			return new Promise(function (resolve, reject) {
				frappe.call({
					method: "frappe.client.get",
					type: 'GET',
					args: { doctype: doctype, name: name, filters: filters },
					callback: function (r) {
						frappe.model.sync(r.message);
						resolve(r.message);
					}
				}).fail(reject);
			});
		},
		insert: function(doc) {
			return frappe.xcall('frappe.client.insert', { doc: doc });
		},
		delete_doc: function(doctype, name) {
			return new Promise(function (resolve) {
				frappe.call('frappe.client.delete', { doctype: doctype, name: name }, function (r) { return resolve(r.message); });
			});
		},
		count: function(doctype, args) {
			if ( args === void 0 ) args={};

			var filters = args.filters || {};

			// has a filter with childtable?
			var distinct = Array.isArray(filters) && filters.some(function (filter) {
				return filter[0] !== doctype;
			});

			var fields = [];

			return frappe.xcall('frappe.desk.reportview.get_count', {
				doctype: doctype,
				filters: filters,
				fields: fields,
				distinct: distinct,
			});
		},
		get_link_options: function get_link_options(doctype, txt, filters) {
			if ( txt === void 0 ) txt = '';
			if ( filters === void 0 ) filters={};

			return new Promise(function (resolve) {
				frappe.call({
					type: 'GET',
					method: 'frappe.desk.search.search_link',
					args: {
						doctype: doctype,
						txt: txt,
						filters: filters
					},
					callback: function callback(r) {
						resolve(r.results);
					}
				});
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.meta.docfield_map');
	frappe.provide('frappe.meta.docfield_copy');
	frappe.provide('frappe.meta.docfield_list');
	frappe.provide('frappe.meta.doctypes');
	frappe.provide("frappe.meta.precision_map");

	frappe.get_meta = function(doctype) {
		return locals['DocType'] ? locals['DocType'][doctype] : null;
	};

	$.extend(frappe.meta, {
		sync: function(doc) {
			$.each(doc.fields, function(i, df) {
				frappe.meta.add_field(df);
			});
			frappe.meta.sync_messages(doc);
			if(doc.__print_formats) { frappe.model.sync(doc.__print_formats); }
			if(doc.__workflow_docs) { frappe.model.sync(doc.__workflow_docs); }
		},

		// build docfield_map and docfield_list
		add_field: function(df) {
			frappe.provide('frappe.meta.docfield_map.' + df.parent);
			frappe.meta.docfield_map[df.parent][df.fieldname || df.label] = df;

			if(!frappe.meta.docfield_list[df.parent])
				{ frappe.meta.docfield_list[df.parent] = []; }

			// check for repeat
			for(var i in frappe.meta.docfield_list[df.parent]) {
				var d = frappe.meta.docfield_list[df.parent][i];
				if(df.fieldname==d.fieldname)
					{ return; } // no repeat
			}
			frappe.meta.docfield_list[df.parent].push(df);
		},

		make_docfield_copy_for: function(doctype, docname, docfield_list) {
			if ( docfield_list === void 0 ) docfield_list=null;

			var c = frappe.meta.docfield_copy;
			if(!c[doctype])
				{ c[doctype] = {}; }
			if(!c[doctype][docname])
				{ c[doctype][docname] = {}; }

			docfield_list = docfield_list || frappe.meta.docfield_list[doctype] || [];
			for(var i=0, j=docfield_list.length; i<j; i++) {
				var df = docfield_list[i];
				c[doctype][docname][df.fieldname || df.label] = copy_dict(df);
			}
		},

		get_field: function(doctype, fieldname, name) {
			var out = frappe.meta.get_docfield(doctype, fieldname, name);

			// search in standard fields
			if (!out) {
				frappe.model.std_fields.every(function(d) {
					if(d.fieldname===fieldname) {
						out = d;
						return false;
					} else {
						return true;
					}
				});
			}
			return out;
		},

		get_docfield: function(doctype, fieldname, name) {
			var fields_dict = frappe.meta.get_docfield_copy(doctype, name);
			return fields_dict ? fields_dict[fieldname] : null;
		},

		set_formatter: function(doctype, fieldname, name, formatter) {
			frappe.meta.get_docfield(doctype, fieldname, name).formatter = formatter;
		},

		set_indicator_formatter: function(doctype, fieldname, name, get_text, get_color) {
			frappe.meta.get_docfield(doctype, fieldname, name).formatter =
				function(value, df, options, doc) {
					return repl('<span class="indicator %(color)s">%(name)s</span>', {
						color: get_color(),
						name: get_text()
					});
				};
		},

		get_docfields: function(doctype, name, filters) {
			var docfield_map = frappe.meta.get_docfield_copy(doctype, name);

			var docfields = frappe.meta.sort_docfields(docfield_map);

			if(filters) {
				docfields = frappe.utils.filter_dict(docfields, filters);
			}

			return docfields;
		},

		get_linked_fields: function(doctype) {
			return $.map(frappe.get_meta(doctype).fields,
				function(d) { return d.fieldtype=="Link" ? d.options : null; });
		},

		get_fields_to_check_permissions: function(doctype) {
			var fields = $.map(frappe.meta.get_docfields(doctype, name), function(df) {
				return (df.fieldtype==="Link" && df.ignore_user_permissions!==1) ? df : null;
			});
			fields = fields.concat({label: "Name", fieldname: name, options: doctype});
			return fields;
		},

		sort_docfields: function(docs) {
			return $.map(docs, function(d) { return d; }).sort(function(a, b) { return a.idx - b.idx });
		},

		get_docfield_copy: function(doctype, name) {
			if(!name) { return frappe.meta.docfield_map[doctype]; }

			if(!(frappe.meta.docfield_copy[doctype] && frappe.meta.docfield_copy[doctype][name])) {
				frappe.meta.make_docfield_copy_for(doctype, name);
			}

			return frappe.meta.docfield_copy[doctype][name];
		},

		get_fieldnames: function(doctype, name, filters) {
			return $.map(frappe.utils.filter_dict(frappe.meta.docfield_map[doctype], filters),
				function(df) { return df.fieldname; });
		},

		has_field: function(dt, fn) {
			var docfield_map = frappe.meta.docfield_map[dt];
			return docfield_map && docfield_map[fn];
		},

		get_table_fields: function(dt) {
			return $.map(frappe.meta.docfield_list[dt], function(d) {
				return frappe.model.table_fields.includes(d.fieldtype) ? d : null});
		},

		get_doctype_for_field: function(doctype, key) {
			var out = null;
			if(in_list(frappe.model.std_fields_list, key)) {
				// standard
				out = doctype;
			} else if(frappe.meta.has_field(doctype, key)) {
				// found in parent
				out = doctype;
			} else {
				frappe.meta.get_table_fields(doctype).every(function(d) {
					if(frappe.meta.has_field(d.options, key)) {
						out = d.options;
						return false;
					}
					return true;
				});

				if(!out) {
					// eslint-disable-next-line
					console.log(__('Warning: Unable to find {0} in any table related to {1}', [key, __(doctype)]));
				}
			}
			return out;
		},

		get_parentfield: function(parent_dt, child_dt) {
			var df = (frappe.get_doc("DocType", parent_dt).fields || [])
				.filter(function (df) { return frappe.model.table_fields.includes(df.fieldtype) && df.options===child_dt; });
			if(!df.length)
				{ throw "parentfield not found for " + parent_dt + ", " + child_dt; }
			return df[0].fieldname;
		},

		get_label: function(dt, fn, dn) {
			var standard = {
				'owner': __('Owner'),
				'creation': __('Created On'),
				'modified': __('Last Modified On'),
				'idx': __('Idx'),
				'name': __('Name'),
				'modified_by': __('Last Modified By')
			};
			if(standard[fn]) {
				return standard[fn];
			} else {
				var df = this.get_docfield(dt, fn, dn);
				return (df ? df.label : "") || fn;
			}
		},

		get_print_formats: function(doctype) {
			var print_format_list = ["Standard"];
			var default_print_format = locals.DocType[doctype].default_print_format;
			var enable_raw_printing = frappe.model.get_doc(":Print Settings", "Print Settings").enable_raw_printing;
			var print_formats = frappe.get_list("Print Format", {doc_type: doctype})
				.sort(function(a, b) { return (a > b) ? 1 : -1; });
			$.each(print_formats, function(i, d) {
				if (
					!in_list(print_format_list, d.name)
					&& d.print_format_type !== 'JS'
					&& (cint(enable_raw_printing) || !d.raw_printing)
				) {
					print_format_list.push(d.name);
				}
			});

			if(default_print_format && default_print_format != "Standard") {
				var index = print_format_list.indexOf(default_print_format);
				print_format_list.splice(index, 1).sort();
				print_format_list.unshift(default_print_format);
			}

			return print_format_list;
		},

		sync_messages: function(doc) {
			if(doc.__messages) {
				$.extend(frappe._messages, doc.__messages);
			}
		},

		get_field_currency: function(df, doc) {
			var currency = frappe.boot.sysdefaults.currency;
			if(!doc && cur_frm)
				{ doc = cur_frm.doc; }

			if(df && df.options) {
				if(doc && df.options.indexOf(":")!=-1) {
					var options = df.options.split(":");
					if(options.length==3) {
						// get reference record e.g. Company
						var docname = doc[options[1]];
						if(!docname && cur_frm) {
							docname = cur_frm.doc[options[1]];
						}
						currency = frappe.model.get_value(options[0], docname, options[2]) ||
							frappe.model.get_value(":" + options[0], docname, options[2]) ||
							currency;
					}
				} else if(doc && doc[df.options]) {
					currency = doc[df.options];
				} else if(cur_frm && cur_frm.doc[df.options]) {
					currency = cur_frm.doc[df.options];
				}
			}
			return currency;
		},

		get_field_precision: function(df, doc) {
			var precision = null;
			if (df && df.precision) {
				precision = cint(df.precision);
			} else if(df && df.fieldtype === "Currency") {
				precision = cint(frappe.defaults.get_default("currency_precision"));
				if(!precision) {
					var number_format = get_number_format();
					var number_format_info = get_number_format_info(number_format);
					precision = number_format_info.precision;
				}
			} else {
				precision = cint(frappe.defaults.get_default("float_precision")) || 3;
			}
			return precision;
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	$.extend(frappe.model, {
		docinfo: {},
		sync: function(r) {
			/* docs:
				extract docs, docinfo (attachments, comments, assignments)
				from incoming request and set in `locals` and `frappe.model.docinfo`
			*/
			var isPlain;
			if(!r.docs && !r.docinfo) { r = {docs:r}; }

			isPlain = $.isPlainObject(r.docs);
			if(isPlain) { r.docs = [r.docs]; }

			if(r.docs) {

				for(var i=0, l=r.docs.length; i<l; i++) {
					var d = r.docs[i];

					if (locals[d.doctype] && locals[d.doctype][d.name]) {
						// update values
						frappe.model.update_in_locals(d);
					} else {
						frappe.model.add_to_locals(d);
					}

					d.__last_sync_on = new Date();

					if(d.doctype==="DocType") {
						frappe.meta.sync(d);
					}

					if(d.localname) {
						frappe.model.new_names[d.localname] = d.name;
						$(document).trigger('rename', [d.doctype, d.localname, d.name]);
						delete locals[d.doctype][d.localname];

						// update docinfo to new dict keys
						if(i===0) {
							frappe.model.docinfo[d.doctype][d.name] = frappe.model.docinfo[d.doctype][d.localname];
							frappe.model.docinfo[d.doctype][d.localname] = undefined;
						}
					}
				}



			}

			// set docinfo (comments, assign, attachments)
			if(r.docinfo) {
				var doc;
				if(r.docs) {
					doc = r.docs[0];
				} else {
					if(cur_frm) { doc = cur_frm.doc; }
				}
				if(doc) {
					if(!frappe.model.docinfo[doc.doctype])
						{ frappe.model.docinfo[doc.doctype] = {}; }
					frappe.model.docinfo[doc.doctype][doc.name] = r.docinfo;
				}
			}

			return r.docs;
		},
		add_to_locals: function(doc) {
			if(!locals[doc.doctype])
				{ locals[doc.doctype] = {}; }

			if(!doc.name && doc.__islocal) { // get name (local if required)
				if(!doc.parentfield) { frappe.model.clear_doc(doc); }

				doc.name = frappe.model.get_new_name(doc.doctype);

				if(!doc.parentfield) { frappe.provide("frappe.model.docinfo." + doc.doctype + "." + doc.name); }
			}

			locals[doc.doctype][doc.name] = doc;

			var meta = frappe.get_meta(doc.doctype);
			var is_table = meta ? meta.istable : doc.parentfield;
			// add child docs to locals
			if (!is_table) {
				for(var i in doc) {
					var value = doc[i];

					if($.isArray(value)) {
						for (var x=0, y=value.length; x < y; x++) {
							var d = value[x];

							if(typeof d=='object' && !d.parent)
								{ d.parent = doc.name; }

							frappe.model.add_to_locals(d);
						}
					}
				}
			}
		},
		update_in_locals: function(doc) {
			// update values in the existing local doc instead of replacing
			var local_doc = locals[doc.doctype][doc.name];
			var clear_keys = function(source, target) {
				Object.keys(target).map(function (key) {
					if (source[key] == undefined) { delete target[key]; }
				});
			};

			for (var fieldname in doc) {
				var df = frappe.meta.get_field(doc.doctype, fieldname);
				if (df && frappe.model.table_fields.includes(df.fieldtype)) {
					// table
					if (!(doc[fieldname] instanceof Array)) {
						doc[fieldname] = [];
					}

					if (!(local_doc[fieldname] instanceof Array)) {
						local_doc[fieldname] = [];
					}

					// child table, override each row and append new rows if required
					for (var i=0; i < doc[fieldname].length; i++ ) {
						var d = doc[fieldname][i];
						var local_d = local_doc[fieldname][i];
						if (local_d) {
							// deleted and added again
							if (!locals[d.doctype]) { locals[d.doctype] = {}; }

							if (!d.name) {
								// incoming row is new, find a new name
								d.name = frappe.model.get_new_name(doc.doctype);
							}

							// if incoming row is not registered, register it
							if (!locals[d.doctype][d.name]) {
								// detach old key
								delete locals[d.doctype][local_d.name];

								// re-attach with new name
								locals[d.doctype][d.name] = local_d;
							}

							// row exists, just copy the values
							Object.assign(local_d, d);
							clear_keys(d, local_d);

						} else {
							local_doc[fieldname].push(d);
							if (!d.parent) { d.parent = doc.name; }
							frappe.model.add_to_locals(d);
						}
					}

					// remove extra rows
					if (local_doc[fieldname].length > doc[fieldname].length) {
						for (var i$1 = doc[fieldname].length; i$1 < local_doc[fieldname].length; i$1++) {

							// clear from local
							var d$1 = local_doc[fieldname][i$1];
							if (locals[d$1.doctype] && locals[d$1.doctype][d$1.name]) {
								delete locals[d$1.doctype][d$1.name];
							}
						}
						local_doc[fieldname].length = doc[fieldname].length;

					}
				} else {
					// literal
					local_doc[fieldname] = doc[fieldname];
				}
			}

			// clear keys on parent
			clear_keys(doc, local_doc);
		}

	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.model");

	$.extend(frappe.model, {
		new_names: {},
		new_name_count: {},

		get_new_doc: function(
			doctype,
			parent_doc,
			parentfield,
			with_mandatory_children
		) {
			frappe.provide("locals." + doctype);
			var doc = {
				docstatus: 0,
				doctype: doctype,
				name: frappe.model.get_new_name(doctype),
				__islocal: 1,
				__unsaved: 1,
				owner: frappe.session.user
			};
			frappe.model.set_default_values(doc, parent_doc);

			if (parent_doc) {
				$.extend(doc, {
					parent: parent_doc.name,
					parentfield: parentfield,
					parenttype: parent_doc.doctype
				});
				if (!parent_doc[parentfield]) { parent_doc[parentfield] = []; }
				doc.idx = parent_doc[parentfield].length + 1;
				parent_doc[parentfield].push(doc);
			} else {
				frappe.provide("frappe.model.docinfo." + doctype + "." + doc.name);
			}

			frappe.model.add_to_locals(doc);

			if (with_mandatory_children) {
				frappe.model.create_mandatory_children(doc);
			}

			if (!parent_doc) {
				doc.__run_link_triggers = 1;
			}

			// set the name if called from a link field
			if (frappe.route_options && frappe.route_options.name_field) {
				var meta = frappe.get_meta(doctype);
				// set title field / name as name
				if (meta.autoname && meta.autoname.indexOf("field:") !== -1) {
					doc[meta.autoname.substr(6)] = frappe.route_options.name_field;
				} else if (meta.title_field) {
					doc[meta.title_field] = frappe.route_options.name_field;
				}

				delete frappe.route_options.name_field;
			}

			// set route options
			if (frappe.route_options && !doc.parent) {
				$.each(frappe.route_options, function(fieldname, value) {
					var df = frappe.meta.has_field(doctype, fieldname);
					if (
						df &&
						in_list(
							["Link", "Data", "Select", "Dynamic Link"],
							df.fieldtype
						) &&
						!df.no_copy
					) {
						doc[fieldname] = value;
					}
				});
				frappe.route_options = null;
			}

			return doc;
		},

		make_new_doc_and_get_name: function(doctype, with_mandatory_children) {
			return frappe.model.get_new_doc(
				doctype,
				null,
				null,
				with_mandatory_children
			).name;
		},

		get_new_name: function(doctype) {
			var cnt = frappe.model.new_name_count;
			if (!cnt[doctype]) { cnt[doctype] = 0; }
			cnt[doctype]++;
			return frappe.router.slug(("new-" + doctype + "-" + (cnt[doctype])));
		},

		set_default_values: function(doc, parent_doc) {
			var doctype = doc.doctype;
			var docfields = frappe.meta.get_docfields(doctype);
			var updated = [];
			for (var fid = 0; fid < docfields.length; fid++) {
				var f = docfields[fid];
				if (
					!in_list(frappe.model.no_value_type, f.fieldtype) &&
					doc[f.fieldname] == null
				) {
					if (f.no_default) { continue; }
					var v = frappe.model.get_default_value(f, doc, parent_doc);
					if (v) {
						if (in_list(["Int", "Check"], f.fieldtype)) { v = cint(v); }
						else if (in_list(["Currency", "Float"], f.fieldtype))
							{ v = flt(v); }

						doc[f.fieldname] = v;
						updated.push(f.fieldname);
					} else if (
						f.fieldtype == "Select" &&
						f.options &&
						typeof f.options === "string" &&
						!in_list(["[Select]", "Loading..."], f.options)
					) {
						doc[f.fieldname] = f.options.split("\n")[0];
					}
				}
			}
			return updated;
		},

		create_mandatory_children: function(doc) {
			var meta = frappe.get_meta(doc.doctype);
			if (meta && meta.istable) { return; }

			// create empty rows for mandatory table fields
			frappe.meta.get_docfields(doc.doctype).forEach(function(df) {
				if (df.fieldtype === "Table" && df.reqd) {
					frappe.model.add_child(doc, df.fieldname);
				}
			});
		},

		get_default_value: function(df, doc, parent_doc) {
			var assign;

			var user_default = "";
			var user_permissions = frappe.defaults.get_user_permissions();
			var allowed_records = [];
			var default_doc = null;
			var value = null;
			if (user_permissions) {
				((assign = frappe.perm.filter_allowed_docs_for_doctype(
					user_permissions[df.options],
					doc.doctype
				), allowed_records = assign.allowed_records, default_doc = assign.default_doc));
			}
			var meta = frappe.get_meta(doc.doctype);
			var has_user_permissions =
				df.fieldtype === "Link" &&
				!$.isEmptyObject(user_permissions) &&
				df.ignore_user_permissions != 1 &&
				allowed_records.length;

			// don't set defaults for "User" link field using User Permissions!
			if (df.fieldtype === "Link" && df.options !== "User") {
				// If user permission has Is Default enabled or single-user permission has found against respective doctype.
				if (has_user_permissions && default_doc) {
					value = default_doc;
				} else {
					// 2 - look in user defaults

					if (!df.ignore_user_permissions) {
						var user_defaults = frappe.defaults.get_user_defaults(df.options);
						if (user_defaults && user_defaults.length===1) {
							// Use User Permission value when only when it has a single value
							user_default = user_defaults[0];
						}
					}
					
					if (!user_default) {
						user_default = frappe.defaults.get_user_default(df.fieldname);
					} else if (
						!user_default &&
						df.remember_last_selected_value &&
						frappe.boot.user.last_selected_values
					) {
						user_default = frappe.boot.user.last_selected_values[df.options];
					}

					var is_allowed_user_default =
						user_default &&
						(!has_user_permissions ||
							allowed_records.includes(user_default));

					// is this user default also allowed as per user permissions?
					if (is_allowed_user_default) {
						value = user_default;
					}
				}
			}

			// 3 - look in default of docfield
			if (!value || df["default"]) {
				var default_val = String(df["default"]);
				if (
					default_val == "__user" ||
					default_val.toLowerCase() == "user"
				) {
					value = frappe.session.user;
				} else if (default_val == "user_fullname") {
					value = frappe.session.user_fullname;
				} else if (default_val == "Today") {
					value = frappe.datetime.get_today();
				} else if ((default_val || "").toLowerCase() === "now") {
					value = frappe.datetime.now_datetime();
				} else if (default_val[0] === ":") {
					var boot_doc = frappe.model.get_default_from_boot_docs(
						df,
						doc,
						parent_doc
					);
					var is_allowed_boot_doc =
						!has_user_permissions || allowed_records.includes(boot_doc);

					if (is_allowed_boot_doc) {
						value = boot_doc;
					}
				} else if (df.fieldname === meta.title_field) {
					// ignore defaults for title field
					value = "";
				} else {
					// is this default value is also allowed as per user permissions?
					var is_allowed_default =
						!has_user_permissions ||
						allowed_records.includes(df.default);
					if (
						df.fieldtype !== "Link" ||
						df.options === "User" ||
						is_allowed_default
					) {
						value = df["default"];
					}
				}
			} else if (df.fieldtype == "Time") {
				value = frappe.datetime.now_time();
			}

			// set it here so we know it was set as a default
			df.__default_value = value;

			return value;
		},

		get_default_from_boot_docs: function(df, doc, parent_doc) {
			// set default from partial docs passed during boot like ":User"
			if (frappe.get_list(df["default"]).length > 0) {
				var ref_fieldname = df["default"]
					.slice(1)
					.toLowerCase()
					.replace(" ", "_");
				var ref_value = parent_doc
					? parent_doc[ref_fieldname]
					: frappe.defaults.get_user_default(ref_fieldname);
				var ref_doc = ref_value
					? frappe.get_doc(df["default"], ref_value)
					: null;

				if (ref_doc && ref_doc[df.fieldname]) {
					return ref_doc[df.fieldname];
				}
			}
		},

		add_child: function(parent_doc, doctype, parentfield, idx) {
			// if given doc, fieldname only
			if (arguments.length === 2) {
				parentfield = doctype;
				doctype = frappe.meta.get_field(parent_doc.doctype, parentfield)
					.options;
			}

			// create row doc
			idx = idx ? idx - 0.1 : (parent_doc[parentfield] || []).length + 1;

			var child = frappe.model.get_new_doc(doctype, parent_doc, parentfield);
			child.idx = idx;

			// renum for fraction
			if (idx !== cint(idx)) {
				var sorted = parent_doc[parentfield].sort(function(a, b) {
					return a.idx - b.idx;
				});
				for (var i = 0, j = sorted.length; i < j; i++) {
					var d = sorted[i];
					d.idx = i + 1;
				}
			}

			if (cur_frm && cur_frm.doc == parent_doc) { cur_frm.dirty(); }

			return child;
		},

		copy_doc: function(doc, from_amend, parent_doc, parentfield) {
			var no_copy_list = [
				"name",
				"amended_from",
				"amendment_date",
				"cancel_reason"
			];
			var newdoc = frappe.model.get_new_doc(
				doc.doctype,
				parent_doc,
				parentfield
			);

			for (var key in doc) {
				// dont copy name and blank fields
				var df = frappe.meta.get_docfield(doc.doctype, key);

				if (
					df &&
					key.substr(0, 2) != "__" &&
					!in_list(no_copy_list, key) &&
					!(df && (!from_amend && cint(df.no_copy) == 1))
				) {
					var value = doc[key] || [];
					if (frappe.model.table_fields.includes(df.fieldtype)) {
						for (var i = 0, j = value.length; i < j; i++) {
							var d = value[i];
							frappe.model.copy_doc(
								d,
								from_amend,
								newdoc,
								df.fieldname
							);
						}
					} else {
						newdoc[key] = doc[key];
					}
				}
			}

			var user = frappe.session.user;

			newdoc.__islocal = 1;
			newdoc.docstatus = 0;
			newdoc.owner = user;
			newdoc.creation = "";
			newdoc.modified_by = user;
			newdoc.modified = "";

			return newdoc;
		},

		open_mapped_doc: function(opts) {
			if (opts.frm && opts.frm.doc.__unsaved) {
				frappe.throw(
					__(
						"You have unsaved changes in this form. Please save before you continue."
					)
				);
			} else if (!opts.source_name && opts.frm) {
				opts.source_name = opts.frm.doc.name;
			} else if (!opts.frm && !opts.source_name) {
				opts.source_name = null;
			}

			return frappe.call({
				type: "POST",
				method: "frappe.model.mapper.make_mapped_doc",
				args: {
					method: opts.method,
					source_name: opts.source_name,
					args: opts.args || null,
					selected_children: opts.frm ? opts.frm.get_selected() : null
				},
				freeze: true,
				freeze_message: opts.freeze_message || "",
				callback: function(r) {
					if (!r.exc) {
						frappe.model.sync(r.message);
						if (opts.run_link_triggers) {
							frappe.get_doc(
								r.message.doctype,
								r.message.name
							).__run_link_triggers = true;
						}
						frappe.set_route("Form", r.message.doctype, r.message.name);
					}
				}
			});
		}
	});

	frappe.create_routes = {};
	frappe.new_doc = function(doctype, opts, init_callback) {
		if (doctype === "File") {
			new frappe.ui.FileUploader({
				folder: opts ? opts.folder : "Home"
			});
			return;
		}
		return new Promise(function (resolve) {
			if (opts && $.isPlainObject(opts)) {
				frappe.route_options = opts;
			}
			frappe.model.with_doctype(doctype, function() {
				if (frappe.create_routes[doctype]) {
					frappe
						.set_route(frappe.create_routes[doctype])
						.then(function () { return resolve(); });
				} else {
					frappe.ui.form
						.make_quick_entry(doctype, null, init_callback)
						.then(function () { return resolve(); });
				}
			});
		});
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.perm");

	// backward compatibilty
	Object.assign(window, {
		READ: "read",
		WRITE: "write",
		CREATE: "create",
		DELETE: "delete",
		SUBMIT: "submit",
		CANCEL: "cancel",
		AMEND: "amend",
	});

	$.extend(frappe.perm, {
		rights: ["read", "write", "create", "delete", "submit", "cancel", "amend",
			"report", "import", "export", "print", "email", "share", "set_user_permissions"],

		doctype_perm: {},

		has_perm: function (doctype, permlevel, ptype, doc) {
			if (!permlevel) { permlevel = 0; }
			if (!frappe.perm.doctype_perm[doctype]) {
				frappe.perm.doctype_perm[doctype] = frappe.perm.get_perm(doctype);
			}

			var perms = frappe.perm.doctype_perm[doctype];

			if (!perms || !perms[permlevel]) { return false; }

			var perm = !!perms[permlevel][ptype];

			if (permlevel === 0 && perm && doc) {
				var docinfo = frappe.model.get_docinfo(doctype, doc.name);
				if (docinfo && !docinfo.permissions[ptype])
					{ perm = false; }
			}

			return perm;
		},

		get_perm: function (doctype, doc) {
			var perm = [{ read: 0, permlevel: 0 }];

			var meta = frappe.get_doc("DocType", doctype);
			var user  = frappe.session.user;

			if (user === "Administrator" || frappe.user_roles.includes("Administrator")) {
				perm[0].read = 1;
			}

			if (!meta) { return perm; }

			perm = frappe.perm.get_role_permissions(meta);

			if (doc) {
				// apply user permissions via docinfo (which is processed server-side)
				var docinfo = frappe.model.get_docinfo(doctype, doc.name);
				if (docinfo && docinfo.permissions) {
					Object.keys(docinfo.permissions).forEach(function (ptype) {
						perm[0][ptype] = docinfo.permissions[ptype];
					});
				}

				// if owner
				if (!$.isEmptyObject(perm[0].if_owner)) {
					if (doc.owner === user) {
						$.extend(perm[0], perm[0].if_owner);
					} else {
						// not owner, remove permissions
						$.each(perm[0].if_owner, function (ptype) {
							if (perm[0].if_owner[ptype]) {
								perm[0][ptype] = 0;
							}
						});
					}
				}

				// apply permissions from shared
				if (docinfo && docinfo.shared) {
					for (var i = 0; i < docinfo.shared.length; i++) {
						var s = docinfo.shared[i];
						if (s.user === user) {
							perm[0]["read"] = perm[0]["read"] || s.read;
							perm[0]["write"] = perm[0]["write"] || s.write;
							perm[0]["submit"] = perm[0]["submit"] || s.submit;
							perm[0]["share"] = perm[0]["share"] || s.share;

							if (s.read) {
								// also give print, email permissions if read
								// and these permissions exist at level [0]
								perm[0].email = frappe.boot.user.can_email.indexOf(doctype) !== -1 ? 1 : 0;
								perm[0].print = frappe.boot.user.can_print.indexOf(doctype) !== -1 ? 1 : 0;
							}
						}
					}
				}

			}

			if (frappe.model.can_read(doctype) && !perm[0].read) {
				// read via sharing
				perm[0].read = 1;
			}

			return perm;
		},

		get_role_permissions: function (meta) {
			var perm = [{ read: 0, permlevel: 0 }];
			// Returns a `dict` of evaluated Role Permissions
			(meta.permissions || []).forEach(function (p) {
				// if user has this role
				var permlevel = cint(p.permlevel);
				if (!perm[permlevel]) {
					perm[permlevel] = {};
					perm[permlevel]["permlevel"] = permlevel;
				}

				if (frappe.user_roles.includes(p.role)) {
					frappe.perm.rights.forEach(function (right) {
						var value = perm[permlevel][right] || (p[right] || 0);
						if (value) {
							perm[permlevel][right] = value;
						}
					});
				}
			});

			// fill gaps with empty object
			perm = perm.map(function (p) { return p || {}; });
			return perm;
		},

		get_match_rules: function (doctype, ptype) {
			var match_rules = [];

			if (!ptype) { ptype = "read"; }

			var perm = frappe.perm.get_perm(doctype);

			var user_permissions = frappe.defaults.get_user_permissions();

			if (user_permissions && !$.isEmptyObject(user_permissions)) {
				var rules = {};
				var fields_to_check = frappe.meta.get_fields_to_check_permissions(doctype);
				$.each(fields_to_check, function (i, df) {
					var user_permissions_for_doctype = user_permissions[df.options] || [];
					var allowed_records = frappe.perm.get_allowed_docs_for_doctype(user_permissions_for_doctype, doctype);
					if (allowed_records.length) {
						rules[df.label] = allowed_records;
					}
				});
				if (!$.isEmptyObject(rules)) {
					match_rules.push(rules);
				}
			}

			if (perm[0].if_owner && perm[0].read) {
				match_rules.push({ "Owner": frappe.session.user });
			}
			return match_rules;
		},

		get_field_display_status: function (df, doc, perm, explain) {
			// returns the display status of a particular field
			// returns one of "Read", "Write" or "None"
			if (!perm && doc) {
				perm = frappe.perm.get_perm(doc.doctype, doc);
			}

			if (!perm) {
				return (df && (cint(df.hidden) || cint(df.hidden_due_to_dependency))) ? "None" : "Write";
			}

			if (!df.permlevel) { df.permlevel = 0; }
			var p = perm[df.permlevel];
			var status = "None";

			// permission
			if (p) {
				if (p.write && !df.disabled) {
					status = "Write";
				} else if (p.read) {
					status = "Read";
				}
			}
			if (explain) { console.log("By Permission:" + status); }

			// hidden
			if (cint(df.hidden)) { status = "None"; }
			if (explain) { console.log("By Hidden:" + status); }

			// hidden due to dependency
			if (cint(df.hidden_due_to_dependency)) { status = "None"; }
			if (explain) { console.log("By Hidden Due To Dependency:" + status); }

			if (!doc) {
				return status;
			}

			// submit
			if (status === "Write" && cint(doc.docstatus) > 0) { status = "Read"; }
			if (explain) { console.log("By Submit:" + status); }

			// allow on submit
			// let allow_on_submit = df.fieldtype==="Table" ? 0 : cint(df.allow_on_submit);
			var allow_on_submit = cint(df.allow_on_submit);
			if (status === "Read" && allow_on_submit && cint(doc.docstatus) === 1 && p.write) {
				status = "Write";
			}
			if (explain) { console.log("By Allow on Submit:" + status); }

			// workflow state
			if (status === "Read" && cur_frm && cur_frm.state_fieldname) {
				// fields updated by workflow must be read-only
				if (cint(cur_frm.read_only) ||
					in_list(cur_frm.states.update_fields, df.fieldname) ||
					df.fieldname == cur_frm.state_fieldname) {
					status = "Read";
				}
			}
			if (explain) { console.log("By Workflow:" + status); }

			// read only field is checked
			if (status === "Write" && cint(df.read_only)) {
				status = "Read";
			}
			if (explain) { console.log("By Read Only:" + status); }

			if (status === "Write" && df.set_only_once && !doc.__islocal) {
				status = "Read";
			}
			if (explain) { console.log("By Set Only Once:" + status); }

			return status;
		},

		is_visible: function (df, doc, perm) {
			if (typeof df === 'string') {
				// df is fieldname
				df = frappe.meta.get_docfield(doc.doctype, df, doc.parent || doc.name);
			}

			var status = frappe.perm.get_field_display_status(df, doc, perm);

			return status === "None" ? false : true;
		},

		get_allowed_docs_for_doctype: function (user_permissions, doctype) {
			// returns docs from the list of user permissions that are allowed under provided doctype
			return frappe.perm.filter_allowed_docs_for_doctype(user_permissions, doctype, false);
		},

		filter_allowed_docs_for_doctype: function (user_permissions, doctype, with_default_doc) {
			if ( with_default_doc === void 0 ) with_default_doc=true;

			// returns docs from the list of user permissions that are allowed under provided doctype
			// also returns default doc when with_default_doc is set
			var filtered_perms = (user_permissions || []).filter(function (perm) {
				return (perm.applicable_for === doctype || !perm.applicable_for);
			});

			var allowed_docs = (filtered_perms).map(function (perm) { return perm.doc; });

			if (with_default_doc) {
				var default_doc = allowed_docs.length === 1 ? allowed_docs : filtered_perms
					.filter(function (perm) { return perm.is_default; })
					.map(function (record) { return record.doc; });

				return {
					allowed_records: allowed_docs,
					default_doc: default_doc[0]
				};
			} else {
				return allowed_docs;
			}
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.workflow");

	frappe.workflow = {
		state_fields: {},
		workflows: {},
		setup: function(doctype) {
			var wf = frappe.get_list("Workflow", {document_type: doctype});
			if(wf.length) {
				frappe.workflow.workflows[doctype] = wf[0];
				frappe.workflow.state_fields[doctype] = wf[0].workflow_state_field;
			} else {
				frappe.workflow.state_fields[doctype] = null;
			}
		},
		get_state_fieldname: function(doctype) {
			if(frappe.workflow.state_fields[doctype]===undefined) {
				frappe.workflow.setup(doctype);
			}
			return frappe.workflow.state_fields[doctype];
		},
		get_default_state: function(doctype, docstatus) {
			frappe.workflow.setup(doctype);
			var value = null;
			$.each(frappe.workflow.workflows[doctype].states, function(i, workflow_state) {
				if(cint(workflow_state.doc_status)===cint(docstatus)) {
					value = workflow_state.state;
					return false;
				}
			});
			return value;
		},
		get_transitions: function(doc) {
			frappe.workflow.setup(doc.doctype);
			return frappe.xcall('frappe.model.workflow.get_transitions', {doc: doc});
		},
		get_document_state: function(doctype, state) {
			frappe.workflow.setup(doctype);
			return frappe.get_children(frappe.workflow.workflows[doctype], "states", {state:state})[0];
		},
		is_self_approval_enabled: function(doctype) {
			return frappe.workflow.workflows[doctype].allow_self_approval;
		},
		is_read_only: function(doctype, name) {
			var state_fieldname = frappe.workflow.get_state_fieldname(doctype);
			if(state_fieldname) {
				var doc = locals[doctype][name];
				if(!doc)
					{ return false; }
				if(doc.__islocal)
					{ return false; }

				var state = doc[state_fieldname] ||
					frappe.workflow.get_default_state(doctype, doc.docstatus);

				var allow_edit = state ? frappe.workflow.get_document_state(doctype, state) && frappe.workflow.get_document_state(doctype, state).allow_edit : null;

				if(!frappe.user_roles.includes(allow_edit)) {
					return true;
				}
			}
			return false;
		},
		get_update_fields: function(doctype) {
			var update_fields = $.unique($.map(frappe.workflow.workflows[doctype].states || [],
				function(d) {
					return d.update_field;
				}));
			return update_fields;
		},
		get_state: function get_state(doc) {
			var state_field = this.get_state_fieldname(doc.doctype);
			var state = doc[state_field];
			if (!state) {
				state = this.get_default_state(doc.doctype, doc.docstatus);
			}
			return state;
		},
		get_all_transitions: function get_all_transitions(doctype) {
			return frappe.workflow.workflows[doctype].transitions || [];
		},
		get_all_transition_actions: function get_all_transition_actions(doctype) {
			var transitions = this.get_all_transitions(doctype);
			return transitions.map(function (transition) {
				return transition.action;
			});
		},
	};

	frappe.provide('frappe.model.user_settings');

	$.extend(frappe.model.user_settings, {
		get: function(doctype) {
			return frappe.call('frappe.model.utils.user_settings.get', { doctype: doctype })
				.then(function (r) { return JSON.parse(r.message || '{}'); });
		},
		save: function(doctype, key, value) {
			if (frappe.session.user === 'Guest') { return Promise.resolve(); }
			
			var old_user_settings = frappe.model.user_settings[doctype] || {};
			var new_user_settings = $.extend(true, {}, old_user_settings); // deep copy

			if ($.isPlainObject(value)) {
				new_user_settings[key] = new_user_settings[key] || {};
				$.extend(new_user_settings[key], value);
			} else {
				new_user_settings[key] = value;
			}

			var a = JSON.stringify(old_user_settings);
			var b = JSON.stringify(new_user_settings);
			if (a !== b) {
				// update if changed
				return this.update(doctype, new_user_settings);
			}
			return Promise.resolve();
		},
		remove: function(doctype, key) {
			var user_settings = frappe.model.user_settings[doctype] || {};
			delete user_settings[key];

			return this.update(doctype, user_settings);
		},
		update: function(doctype, user_settings) {
			if (frappe.session.user === 'Guest') { return Promise.resolve(); }
			return frappe.call({
				method: 'frappe.model.utils.user_settings.save',
				args: {
					doctype: doctype,
					user_settings: user_settings
				},
				callback: function(r) {
					frappe.model.user_settings[doctype] = r.message;
				}
			});
		}
	});

	frappe.get_user_settings = function(doctype, key) {
		var settings = frappe.model.user_settings[doctype] || {};
		if(key) {
			settings = settings[key] || {};
		}
		return settings;
	};

	!function(a){function b(a,b){var c=(65535&a)+(65535&b),d=(a>>16)+(b>>16)+(c>>16);return d<<16|65535&c}function c(a,b){return a<<b|a>>>32-b}function d(a,d,e,f,g,h){return b(c(b(b(d,a),b(f,h)),g),e)}function e(a,b,c,e,f,g,h){return d(b&c|~b&e,a,b,f,g,h)}function f(a,b,c,e,f,g,h){return d(b&e|c&~e,a,b,f,g,h)}function g(a,b,c,e,f,g,h){return d(b^c^e,a,b,f,g,h)}function h(a,b,c,e,f,g,h){return d(c^(b|~e),a,b,f,g,h)}function i(a,c){a[c>>5]|=128<<c%32,a[(c+64>>>9<<4)+14]=c;var d,i,j,k,l,m=1732584193,n=-271733879,o=-1732584194,p=271733878;for(d=0;d<a.length;d+=16){ i=m,j=n,k=o,l=p,m=e(m,n,o,p,a[d],7,-680876936),p=e(p,m,n,o,a[d+1],12,-389564586),o=e(o,p,m,n,a[d+2],17,606105819),n=e(n,o,p,m,a[d+3],22,-1044525330),m=e(m,n,o,p,a[d+4],7,-176418897),p=e(p,m,n,o,a[d+5],12,1200080426),o=e(o,p,m,n,a[d+6],17,-1473231341),n=e(n,o,p,m,a[d+7],22,-45705983),m=e(m,n,o,p,a[d+8],7,1770035416),p=e(p,m,n,o,a[d+9],12,-1958414417),o=e(o,p,m,n,a[d+10],17,-42063),n=e(n,o,p,m,a[d+11],22,-1990404162),m=e(m,n,o,p,a[d+12],7,1804603682),p=e(p,m,n,o,a[d+13],12,-40341101),o=e(o,p,m,n,a[d+14],17,-1502002290),n=e(n,o,p,m,a[d+15],22,1236535329),m=f(m,n,o,p,a[d+1],5,-165796510),p=f(p,m,n,o,a[d+6],9,-1069501632),o=f(o,p,m,n,a[d+11],14,643717713),n=f(n,o,p,m,a[d],20,-373897302),m=f(m,n,o,p,a[d+5],5,-701558691),p=f(p,m,n,o,a[d+10],9,38016083),o=f(o,p,m,n,a[d+15],14,-660478335),n=f(n,o,p,m,a[d+4],20,-405537848),m=f(m,n,o,p,a[d+9],5,568446438),p=f(p,m,n,o,a[d+14],9,-1019803690),o=f(o,p,m,n,a[d+3],14,-187363961),n=f(n,o,p,m,a[d+8],20,1163531501),m=f(m,n,o,p,a[d+13],5,-1444681467),p=f(p,m,n,o,a[d+2],9,-51403784),o=f(o,p,m,n,a[d+7],14,1735328473),n=f(n,o,p,m,a[d+12],20,-1926607734),m=g(m,n,o,p,a[d+5],4,-378558),p=g(p,m,n,o,a[d+8],11,-2022574463),o=g(o,p,m,n,a[d+11],16,1839030562),n=g(n,o,p,m,a[d+14],23,-35309556),m=g(m,n,o,p,a[d+1],4,-1530992060),p=g(p,m,n,o,a[d+4],11,1272893353),o=g(o,p,m,n,a[d+7],16,-155497632),n=g(n,o,p,m,a[d+10],23,-1094730640),m=g(m,n,o,p,a[d+13],4,681279174),p=g(p,m,n,o,a[d],11,-358537222),o=g(o,p,m,n,a[d+3],16,-722521979),n=g(n,o,p,m,a[d+6],23,76029189),m=g(m,n,o,p,a[d+9],4,-640364487),p=g(p,m,n,o,a[d+12],11,-421815835),o=g(o,p,m,n,a[d+15],16,530742520),n=g(n,o,p,m,a[d+2],23,-995338651),m=h(m,n,o,p,a[d],6,-198630844),p=h(p,m,n,o,a[d+7],10,1126891415),o=h(o,p,m,n,a[d+14],15,-1416354905),n=h(n,o,p,m,a[d+5],21,-57434055),m=h(m,n,o,p,a[d+12],6,1700485571),p=h(p,m,n,o,a[d+3],10,-1894986606),o=h(o,p,m,n,a[d+10],15,-1051523),n=h(n,o,p,m,a[d+1],21,-2054922799),m=h(m,n,o,p,a[d+8],6,1873313359),p=h(p,m,n,o,a[d+15],10,-30611744),o=h(o,p,m,n,a[d+6],15,-1560198380),n=h(n,o,p,m,a[d+13],21,1309151649),m=h(m,n,o,p,a[d+4],6,-145523070),p=h(p,m,n,o,a[d+11],10,-1120210379),o=h(o,p,m,n,a[d+2],15,718787259),n=h(n,o,p,m,a[d+9],21,-343485551),m=b(m,i),n=b(n,j),o=b(o,k),p=b(p,l); }return [m,n,o,p]}function j(a){var b,c="";for(b=0;b<32*a.length;b+=8){ c+=String.fromCharCode(a[b>>5]>>>b%32&255); }return c}function k(a){var b,c=[];for(c[(a.length>>2)-1]=void 0,b=0;b<c.length;b+=1){ c[b]=0; }for(b=0;b<8*a.length;b+=8){ c[b>>5]|=(255&a.charCodeAt(b/8))<<b%32; }return c}function l(a){return j(i(k(a),8*a.length))}function m(a,b){var c,d,e=k(a),f=[],g=[];for(f[15]=g[15]=void 0,e.length>16&&(e=i(e,8*a.length)),c=0;16>c;c+=1){ f[c]=909522486^e[c],g[c]=1549556828^e[c]; }return d=i(f.concat(k(b)),512+8*b.length),j(i(g.concat(d),640))}function n(a){var b,c,d="0123456789abcdef",e="";for(c=0;c<a.length;c+=1){ b=a.charCodeAt(c),e+=d.charAt(b>>>4&15)+d.charAt(15&b); }return e}function o(a){return unescape(encodeURIComponent(a))}function p(a){return l(o(a))}function q(a){return n(p(a))}function r(a,b){return m(o(a),o(b))}function s(a,b){return n(r(a,b))}function t(a,b,c){return b?c?r(b,a):s(b,a):c?p(a):q(a)}"function"==typeof define&&define.amd?define(function(){return t}):a.md5=t;}(window);

	frappe.user_info = function(uid) {
		if(!uid)
			{ uid = frappe.session.user; }

		if(uid.toLowerCase()==="bot") {
			return {
				fullname: __("Bot"),
				image: "/assets/frappe/images/ui/bot.png",
				abbr: "B"
			};
		}

		if(!(frappe.boot.user_info && frappe.boot.user_info[uid])) {
			var user_info = {
				fullname: frappe.utils.capitalize(uid.split("@")[0]) || "Unknown"
			};
		} else {
			var user_info = frappe.boot.user_info[uid];
		}

		user_info.abbr = frappe.get_abbr(user_info.fullname);
		user_info.color = frappe.get_palette(user_info.fullname);

		return user_info;
	};

	frappe.ui.set_user_background = function(src, selector, style) {
		if(!selector) { selector = "#page-desktop"; }
		if(!style) { style = "Fill Screen"; }
		if(src) {
			if (window.cordova && src.indexOf("http") === -1) {
				src = frappe.base_url + src;
			}
			var background = repl('background: url("%(src)s") center center;', {src: src});
		} else {
			var background = "background-color: #4B4C9D;";
		}

		frappe.dom.set_style(repl('%(selector)s { \
		%(background)s \
		background-attachment: fixed; \
		%(style)s \
	}', {
			selector:selector,
			background:background,
			style: style==="Fill Screen" ? "background-size: cover;" : ""
		}));
	};

	frappe.provide('frappe.user');

	$.extend(frappe.user, {
		name: 'Guest',
		full_name: function(uid) {
			return uid === frappe.session.user ?
				__("You", null, "Name of the current user. For example: You edited this 5 hours ago.") :
				frappe.user_info(uid).fullname;
		},
		image: function(uid) {
			return frappe.user_info(uid).image;
		},
		abbr: function(uid) {
			return frappe.user_info(uid).abbr;
		},
		has_role: function(rl) {
			if(typeof rl=='string')
				{ rl = [rl]; }
			for(var i in rl) {
				if((frappe.boot ? frappe.boot.user.roles : ['Guest']).indexOf(rl[i])!=-1)
					{ return true; }
			}
		},
		get_desktop_items: function() {
			// hide based on permission
			var modules_list = $.map(frappe.boot.allowed_modules, function(icon) {
				var m = icon.module_name;
				var type = frappe.modules[m] && frappe.modules[m].type;

				if(frappe.boot.user.allow_modules.indexOf(m) === -1) { return null; }

				var ret = null;
				if (type === "module") {
					if(frappe.boot.user.allow_modules.indexOf(m)!=-1 || frappe.modules[m].is_help)
						{ ret = m; }
				} else if (type === "page") {
					if(frappe.boot.allowed_pages.indexOf(frappe.modules[m].link)!=-1)
						{ ret = m; }
				} else if (type === "list") {
					if(frappe.model.can_read(frappe.modules[m]._doctype))
						{ ret = m; }
				} else if (type === "view") {
					ret = m;
				} else if (type === "setup") {
					if(frappe.user.has_role("System Manager") || frappe.user.has_role("Administrator"))
						{ ret = m; }
				} else {
					ret = m;
				}

				return ret;
			});

			return modules_list;
		},

		is_report_manager: function() {
			return frappe.user.has_role(['Administrator', 'System Manager', 'Report Manager']);
		},

		get_formatted_email: function(email) {
			var fullname = frappe.user.full_name(email);

			if (!fullname) {
				return email;
			} else {
				// to quote or to not
				var quote = '';

				// only if these special characters are found
				// why? To make the output same as that in python!
				if (fullname.search(/[\[\]\\()<>@,:;".]/) !== -1) {
					quote = '"';
				}

				return repl('%(quote)s%(fullname)s%(quote)s <%(email)s>', {
					fullname: fullname,
					email: email,
					quote: quote
				});
			}
		},

		get_emails: function ( ) {
			return Object.keys(frappe.boot.user_info).map(function (key) { return frappe.boot.user_info[key].email; });
		},

		/* Normally frappe.user is an object
		 * having properties and methods.
		 * But in the following case
		 *
		 * if (frappe.user === 'Administrator')
		 *
		 * frappe.user will cast to a string
		 * returning frappe.user.name
		 */
		toString: function() {
			return this.name;
		}
	});

	frappe.session_alive = true;
	$(document).bind('mousemove', function() {
		if(frappe.session_alive===false) {
			$(document).trigger("session_alive");
		}
		frappe.session_alive = true;
		if(frappe.session_alive_timeout)
			{ clearTimeout(frappe.session_alive_timeout); }
		frappe.session_alive_timeout = setTimeout('frappe.session_alive=false;', 30000);
	});

	// common file between desk and website

	frappe.avatar = function (user, css_class, title, image_url, remove_color, filterable) {
		if ( image_url === void 0 ) image_url=null;
		if ( remove_color === void 0 ) remove_color=false;
		if ( filterable === void 0 ) filterable=false;

		var user_info;
		if (user) {
			// desk
			user_info = frappe.user_info(user);
		} else {
			// website
			var full_name = title || frappe.get_cookie("full_name");
			user_info = {
				image: image_url === null ? frappe.get_cookie("user_image") : image_url,
				fullname: full_name,
				abbr: frappe.get_abbr(full_name),
				color: frappe.get_palette(full_name)
			};
		}

		if (!title) {
			title = user_info.fullname;
		}

		var data_attr = '';
		if (filterable) {
			css_class += " filterable";
			data_attr = "data-filter=\"_assign,like,%" + user + "%\"";
		}

		return frappe.get_avatar(
			css_class, title, image_url || user_info.image, remove_color, data_attr
		);
	};

	frappe.get_avatar = function(css_class, title, image_url, remove_color, data_attributes) {
		if ( image_url === void 0 ) image_url=null;

		if (!css_class) {
			css_class = "avatar-small";
		}

		if (image_url) {
			var image = (window.cordova && image_url.indexOf('http') === -1) ? frappe.base_url + image_url : image_url;
			return ("<span class=\"avatar " + css_class + "\" title=\"" + title + "\" " + data_attributes + ">\n\t\t\t\t<span class=\"avatar-frame\" style='background-image: url(\"" + image + "\")'\n\t\t\t\t\ttitle=\"" + title + "\"></span>\n\t\t\t</span>");
		} else {
			var abbr =  frappe.get_abbr(title);
			var style = '';
			if (!remove_color) {
				var color = frappe.get_palette(title);
				style = "background-color: var(" + (color[0]) + "); color: var(" + (color[1]) + ")";
			}

			if (css_class === 'avatar-small' || css_class == 'avatar-xs') {
				abbr = abbr.substr(0, 1);
			}

			return ("<span class=\"avatar " + css_class + "\" title=\"" + title + "\" " + data_attributes + ">\n\t\t\t<div class=\"avatar-frame standard-image\"\n\t\t\t\tstyle=\"" + style + "\">\n\t\t\t\t\t" + abbr + "\n\t\t\t</div>\n\t\t</span>");
		}
	};

	frappe.avatar_group = function (users, limit, options) {
		if ( limit === void 0 ) limit=4;
		if ( options === void 0 ) options = {};

		var avatar_action_html = '';
		var display_users = users.slice(0, limit);
		var extra_users = users.slice(limit);
		var css_class = options.css_class || '';

		var html = display_users.map(function (user) { return frappe.avatar(user, 'avatar-small ' + css_class, null, null, false, options.filterable); }
		).join('');
		if (extra_users.length === 1) {
			html += frappe.avatar(extra_users[0], 'avatar-small ' + css_class, null, null, false, options.filterable);
		} else if (extra_users.length > 1) {
			html = "\n\t\t\t" + html + "\n\t\t\t<span class=\"avatar avatar-small " + css_class + "\">\n\t\t\t\t<div class=\"avatar-frame standard-image avatar-extra-count\"\n\t\t\t\t\ttitle=\"" + (extra_users.map(function (u) { return frappe.user_info(u).fullname; }).join(', ')) + "\">\n\t\t\t\t\t+" + (extra_users.length) + "\n\t\t\t\t</div>\n\t\t\t</span>\n\t\t";
		}

		if (options.action_icon) {
			avatar_action_html = "\n\t\t\t<span class=\"avatar avatar-small\">\n\t\t\t\t<div class=\"avatar-frame avatar-action\">\n\t\t\t\t\t" + (frappe.utils.icon(options.action_icon, 'sm')) + "\n\t\t\t\t</div>\n\t\t\t</span>\n\t\t";
		}

		var $avatar_group =
			$(("<div class=\"avatar-group " + (options.align || 'right') + " " + (options.overlap != false ? 'overlap' : '') + "\">\n\t\t\t" + html + "\n\t\t\t" + avatar_action_html + "\n\t\t</div>"));

		$avatar_group.find('.avatar-action').on('click', options.action);
		return $avatar_group;
	};

	frappe.ui.scroll = function (element, animate, additional_offset) {
		var header_offset = $(".navbar").height() + $(".page-head").height();
		var top = $(element).offset().top - header_offset - cint(additional_offset);
		if (animate) {
			$("html, body").animate({ scrollTop: top });
		} else {
			$(window).scrollTop(top);
		}
	};

	frappe.palette = [
		['--orange-avatar-bg', '--orange-avatar-color'],
		['--pink-avatar-bg', '--pink-avatar-color'],
		['--blue-avatar-bg', '--blue-avatar-color'],
		['--green-avatar-bg', '--green-avatar-color'],
		['--dark-green-avatar-bg', '--dark-green-avatar-color'],
		['--red-avatar-bg', '--red-avatar-color'],
		['--yellow-avatar-bg', '--yellow-avatar-color'],
		['--purple-avatar-bg', '--purple-avatar-color'],
		['--gray-avatar-bg', '--gray-avatar-color0']
	];

	frappe.get_palette = function (txt) {
		var idx = cint((parseInt(md5(txt).substr(4, 2), 16) + 1) / 5.33);
		return frappe.palette[idx % 8];
	};

	frappe.get_abbr = function (txt, max_length) {
		if (!txt) { return ""; }
		var abbr = "";
		$.each(txt.split(" "), function (i, w) {
			if (abbr.length >= (max_length || 2)) {
				// break
				return false;

			} else if (!w.trim().length) {
				// continue
				return true;
			}
			abbr += w.trim()[0];
		});

		return abbr || "?";
	};

	frappe.gravatars = {};
	frappe.get_gravatar = function (email_id, size) {
		if ( size === void 0 ) size = 0;

		var param = size ? ('s=' + size) : 'd=retro';
		if (!frappe.gravatars[email_id]) {
			// TODO: check if gravatar exists
			frappe.gravatars[email_id] = "https://secure.gravatar.com/avatar/" + md5(email_id) + "?" + param;
		}
		return frappe.gravatars[email_id];
	};

	// string commons

	window.repl = function repl(s, dict) {
		if (s == null) { return ''; }
		for (var key in dict) {
			s = s.split("%(" + key + ")s").join(dict[key]);
		}
		return s;
	};

	window.replace_all = function (s, t1, t2) {
		return s.split(t1).join(t2);
	};

	window.strip_html = function(txt) {
		return cstr(txt).replace(/<[^>]*>/g, "");
	};

	window.strip = function (s, chars) {
		if (s) {
			s = lstrip(s, chars);
			s = rstrip(s, chars);
			return s;
		}
	};

	window.lstrip = function lstrip(s, chars) {
		if (!chars) { chars = ['\n', '\t', ' ']; }
		// strip left
		var first_char = s.substr(0, 1);
		while (in_list(chars, first_char)) {
			s = s.substr(1);
			first_char = s.substr(0, 1);
		}
		return s;
	};

	window.rstrip = function (s, chars) {
		if (!chars) { chars = ['\n', '\t', ' ']; }
		var last_char = s.substr(s.length - 1);
		while (in_list(chars, last_char)) {
			s = s.substr(0, s.length - 1);
			last_char = s.substr(s.length - 1);
		}
		return s;
	};

	frappe.get_cookie = function getCookie(name) {
		return frappe.get_cookies()[name];
	};

	frappe.get_cookies = function getCookies() {
		var c = document.cookie, v = 0, cookies = {};
		if (document.cookie.match(/^\s*\$Version=(?:"1"|1);\s*(.*)/)) {
			c = RegExp.$1;
			v = 1;
		}
		if (v === 0) {
			c.split(/[,;]/).map(function (cookie) {
				var parts = cookie.split(/=/, 2),
					name = decodeURIComponent(parts[0].trimLeft()),
					value = parts.length > 1 ? decodeURIComponent(parts[1].trimRight()) : null;
				if (value && value.charAt(0) === '"') {
					value = value.substr(1, value.length - 2);
				}
				cookies[name] = value;
			});
		} else {
			c.match(/(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g).map(function ($0, $1) {
				var name = $0,
					value = $1.charAt(0) === '"'
						? $1.substr(1, -1).replace(/\\(.)/g, "$1")
						: $1;
				cookies[name] = value;
			});
		}
		return cookies;
	};

	frappe.is_mobile = function () {
		return $(document).width() < 768;
	};

	frappe.utils.xss_sanitise = function (string, options) {
		// Reference - https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
		var sanitised = string; // un-sanitised string.
		var DEFAULT_OPTIONS = {
			strategies: ['html', 'js'] // use all strategies.
		};
		var HTML_ESCAPE_MAP = {
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;',
			'/': '&#x2F;'
		};
		var REGEX_SCRIPT = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi; // used in jQuery 1.7.2 src/ajax.js Line 14
		options = Object.assign({}, DEFAULT_OPTIONS, options); // don't deep copy, immutable beauty.

		// Rule 1
		if (options.strategies.includes('html')) {
			for (var char in HTML_ESCAPE_MAP) {
				var escape = HTML_ESCAPE_MAP[char];
				var regex = new RegExp(char, "g");
				sanitised = sanitised.replace(regex, escape);
			}
		}

		// Rule 3 - TODO: Check event handlers?
		if (options.strategies.includes('js')) {
			sanitised = sanitised.replace(REGEX_SCRIPT, "");
		}

		return sanitised;
	};

	frappe.utils.sanitise_redirect = function (url) {
		var is_external = (function () {
			return function (url) {
				function domain(url) {
					var base_domain = /^(?:https?:\/\/)?(?:[^@\n]+@)?(?:www\.)?([^:/\n?]+)/img.exec(url);
					return base_domain == null ? "" : base_domain[1];
				}

				function is_absolute(url) {
					// returns true for url that have a defined scheme
					// anything else, eg. internal urls return false
					return /^(?:[a-z]+:)?\/\//i.test(url);
				}

				// check for base domain only if the url is absolute
				// return true for relative url (except protocol-relative urls)
				return is_absolute(url) ? domain(location.href) !== domain(url) : false;
			}
		})();

		var sanitise_javascript = (function (url) {
			// please do not ask how or why
			var REGEX_SCRIPT = /j[\s]*(&#x.{1,7})?a[\s]*(&#x.{1,7})?v[\s]*(&#x.{1,7})?a[\s]*(&#x.{1,7})?s[\s]*(&#x.{1,7})?c[\s]*(&#x.{1,7})?r[\s]*(&#x.{1,7})?i[\s]*(&#x.{1,7})?p[\s]*(&#x.{1,7})?t/gi;

			return url.replace(REGEX_SCRIPT, "");
		});

		url = frappe.utils.strip_url(url);

		return is_external(url) ? "" : sanitise_javascript(frappe.utils.xss_sanitise(url, { strategies: ["js"] }));
	};

	frappe.utils.strip_url = function (url) {
		// strips invalid characters from the beginning of the URL
		// in our case, the url can start with either a protocol, //, or even #
		// so anything except those characters can be considered invalid
		return url.replace(/^[^A-Za-z0-9(//)#]+/g, '');
	};

	frappe.utils.new_auto_repeat_prompt = function (frm) {
		var fields = [
			{
				'fieldname': 'frequency',
				'fieldtype': 'Select',
				'label': __('Frequency'),
				'reqd': 1,
				'options': [
					{ 'label': __('Daily'), 'value': 'Daily' },
					{ 'label': __('Weekly'), 'value': 'Weekly' },
					{ 'label': __('Monthly'), 'value': 'Monthly' },
					{ 'label': __('Quarterly'), 'value': 'Quarterly' },
					{ 'label': __('Half-yearly'), 'value': 'Half-yearly' },
					{ 'label': __('Yearly'), 'value': 'Yearly' }
				]
			},
			{
				'fieldname': 'start_date',
				'fieldtype': 'Date',
				'label': __('Start Date'),
				'reqd': 1,
				'default': frappe.datetime.nowdate()
			},
			{
				'fieldname': 'end_date',
				'fieldtype': 'Date',
				'label': __('End Date')
			}
		];
		frappe.prompt(fields, function (values) {
			frappe.call({
				method: "frappe.automation.doctype.auto_repeat.auto_repeat.make_auto_repeat",
				args: {
					'doctype': frm.doc.doctype,
					'docname': frm.doc.name,
					'frequency': values['frequency'],
					'start_date': values['start_date'],
					'end_date': values['end_date']
				},
				callback: function (r) {
					if (r.message) {
						frappe.show_alert({
							'message': __("Auto Repeat created for this document"),
							'indicator': 'green'
						});
						frm.reload_doc();
					}
				}
			});
		},
		__('Auto Repeat'),
		__('Save')
		);
	};

	frappe.utils.get_page_view_count = function (route) {
		return frappe.call("frappe.website.doctype.web_page_view.web_page_view.get_page_view_count", {
			path: route
		});
	};

	frappe.urllib = {
		// get argument from url
		get_arg: function(name) {
			name = name.replace(/[[]/, "\\[").replace(/[\]]/,"\\]");
			var regexS = "[\\?&]"+name+"=([^&#]*)";
			var regex = new RegExp( regexS );
			var results = regex.exec( window.location.href );
			if( results == null )
				{ return ""; }
			else
				{ return decodeURIComponent(results[1]); }
		},

		// returns url dictionary
		get_dict: function() {
			var d = {};
			var t = window.location.href.split('?')[1];
			if(!t) { return d; }

			if(t.indexOf('#')!=-1) { t = t.split('#')[0]; }
			if(!t) { return d; }

			t = t.split('&');
			for(var i=0; i<t.length; i++) {
				var a = t[i].split('=');
				d[decodeURIComponent(a[0])] = decodeURIComponent(a[1]);
			}
			return d;
		},

		// returns the base url with http + domain + path (-index.cgi or # or ?)
		get_base_url: function() {
			// var url= (frappe.base_url || window.location.href).split('#')[0].split('?')[0].split('desk')[0];
			var url = (frappe.base_url || window.location.origin);
			if(url.substr(url.length-1, 1)=='/') { url = url.substr(0, url.length-1); }
			return url;
		},

		// returns absolute url
		get_full_url: function(url) {
			if(url.indexOf("http://")===0 || url.indexOf("https://")===0) {
				return url;
			}
			return url.substr(0,1)==="/" ?
				(frappe.urllib.get_base_url() + url) :
				(frappe.urllib.get_base_url() + "/" + url);
		}
	};

	window.open_url_post = function open_url_post(URL, PARAMS, new_window) {
		if (window.cordova) {
			var url = URL + 'api/method/' + PARAMS.cmd + frappe.utils.make_query_string(PARAMS, false);
			window.location.href = url;
		} else {
			// call a url as POST
			var temp=document.createElement("form");
			temp.action=URL;
			temp.method="POST";
			temp.style.display="none";
			if(new_window){
				temp.target = '_blank';
			}
			PARAMS["csrf_token"] = frappe.csrf_token;
			for(var x in PARAMS) {
				var opt=document.createElement("textarea");
				opt.name=x;
				var val = PARAMS[x];
				if(typeof val!='string')
					{ val = JSON.stringify(val); }
				opt.value=val;
				temp.appendChild(opt);
			}
			document.body.appendChild(temp);
			temp.submit();
			return temp;
		}
	};

	window.get_url_arg = frappe.urllib.get_arg;
	window.get_url_dict = frappe.urllib.get_dict;

	function prettyDate(date, mini) {
		if (!date) { return ''; }

		if (typeof (date) == "string") {
			date = frappe.datetime.convert_to_user_tz(date);
			date = new Date((date || "").replace(/-/g, "/").replace(/[TZ]/g, " ").replace(/\.[0-9]*/, ""));
		}

		var diff = (((new Date()).getTime() - date.getTime()) / 1000);
		var day_diff = Math.floor(diff / 86400);

		if (isNaN(day_diff) || day_diff < 0) { return ''; }

		if (mini) {
			// Return short format of time difference
			if (day_diff == 0) {
				if (diff < 60) {
					return __("now");
				} else if (diff < 3600) {
					return __("{0} m", [Math.floor(diff / 60)]);
				} else if (diff < 86400) {
					return __("{0} h", [Math.floor(diff / 3600)]);
				}
			} else {
				if (day_diff < 7) {
					return __("{0} d", [day_diff]);
				} else if (day_diff < 31) {
					return __("{0} w", [Math.ceil(day_diff / 7)]);
				} else if (day_diff < 365) {
					return __("{0} M", [Math.ceil(day_diff / 30)]);
				} else {
					return __("{0} y", [Math.ceil(day_diff / 365)]);
				}
			}
		} else {
			// Return long format of time difference
			if (day_diff == 0) {
				if (diff < 60) {
					return __("just now");
				} else if (diff < 120) {
					return __("1 minute ago");
				} else if (diff < 3600) {
					return __("{0} minutes ago", [Math.floor(diff / 60)]);
				} else if (diff < 7200) {
					return __("1 hour ago");
				} else if (diff < 86400) {
					return __("{0} hours ago", [Math.floor(diff / 3600)]);
				}
			} else {
				if (day_diff == 1) {
					return __("yesterday");
				} else if (day_diff < 7) {
					return __("{0} days ago", [day_diff]);
				} else if (day_diff < 14) {
					return __("1 week ago");
				} else if (day_diff < 31) {
					return __("{0} weeks ago", [Math.ceil(day_diff / 7)]);
				} else if (day_diff < 62) {
					return __("1 month ago");
				} else if (day_diff < 365) {
					return __("{0} months ago", [Math.ceil(day_diff / 30)]);
				} else if (day_diff < 730) {
					return __("1 year ago");
				} else {
					return __("{0} years ago", [Math.ceil(day_diff / 365)]);
				}
			}
		}
	}

	frappe.provide("frappe.datetime");
	window.comment_when = function(datetime, mini) {
		var timestamp = frappe.datetime.str_to_user ?
			frappe.datetime.str_to_user(datetime) : datetime;
		return '<span class="frappe-timestamp '
			+ (mini ? " mini" : "") + '" data-timestamp="' + datetime
			+ '" title="' + timestamp + '">'
			+ prettyDate(datetime, mini) + '</span>';
	};
	frappe.datetime.comment_when = comment_when;
	frappe.datetime.prettyDate = prettyDate;

	frappe.datetime.refresh_when = function() {
		if (jQuery) {
			$(".frappe-timestamp").each(function() {
				$(this).html(prettyDate($(this).attr("data-timestamp"), $(this).hasClass("mini")));
			});
		}
	};

	setInterval(function() {
		frappe.datetime.refresh_when();
	}, 60000); // refresh every minute

	var showdown = createCommonjsModule(function (module) {
	(function(){
	/**
	 * Created by Tivie on 13-07-2015.
	 */

	function getDefaultOpts (simple) {

	  var defaultOptions = {
	    omitExtraWLInCodeBlocks: {
	      defaultValue: false,
	      describe: 'Omit the default extra whiteline added to code blocks',
	      type: 'boolean'
	    },
	    noHeaderId: {
	      defaultValue: false,
	      describe: 'Turn on/off generated header id',
	      type: 'boolean'
	    },
	    prefixHeaderId: {
	      defaultValue: false,
	      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
	      type: 'string'
	    },
	    rawPrefixHeaderId: {
	      defaultValue: false,
	      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
	      type: 'boolean'
	    },
	    ghCompatibleHeaderId: {
	      defaultValue: false,
	      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
	      type: 'boolean'
	    },
	    rawHeaderId: {
	      defaultValue: false,
	      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
	      type: 'boolean'
	    },
	    headerLevelStart: {
	      defaultValue: false,
	      describe: 'The header blocks level start',
	      type: 'integer'
	    },
	    parseImgDimensions: {
	      defaultValue: false,
	      describe: 'Turn on/off image dimension parsing',
	      type: 'boolean'
	    },
	    simplifiedAutoLink: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM autolink style',
	      type: 'boolean'
	    },
	    excludeTrailingPunctuationFromURLs: {
	      defaultValue: false,
	      describe: 'Excludes trailing punctuation from links generated with autoLinking',
	      type: 'boolean'
	    },
	    literalMidWordUnderscores: {
	      defaultValue: false,
	      describe: 'Parse midword underscores as literal underscores',
	      type: 'boolean'
	    },
	    literalMidWordAsterisks: {
	      defaultValue: false,
	      describe: 'Parse midword asterisks as literal asterisks',
	      type: 'boolean'
	    },
	    strikethrough: {
	      defaultValue: false,
	      describe: 'Turn on/off strikethrough support',
	      type: 'boolean'
	    },
	    tables: {
	      defaultValue: false,
	      describe: 'Turn on/off tables support',
	      type: 'boolean'
	    },
	    tablesHeaderId: {
	      defaultValue: false,
	      describe: 'Add an id to table headers',
	      type: 'boolean'
	    },
	    ghCodeBlocks: {
	      defaultValue: true,
	      describe: 'Turn on/off GFM fenced code blocks support',
	      type: 'boolean'
	    },
	    tasklists: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM tasklist support',
	      type: 'boolean'
	    },
	    smoothLivePreview: {
	      defaultValue: false,
	      describe: 'Prevents weird effects in live previews due to incomplete input',
	      type: 'boolean'
	    },
	    smartIndentationFix: {
	      defaultValue: false,
	      description: 'Tries to smartly fix indentation in es6 strings',
	      type: 'boolean'
	    },
	    disableForced4SpacesIndentedSublists: {
	      defaultValue: false,
	      description: 'Disables the requirement of indenting nested sublists by 4 spaces',
	      type: 'boolean'
	    },
	    simpleLineBreaks: {
	      defaultValue: false,
	      description: 'Parses simple line breaks as <br> (GFM Style)',
	      type: 'boolean'
	    },
	    requireSpaceBeforeHeadingText: {
	      defaultValue: false,
	      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
	      type: 'boolean'
	    },
	    ghMentions: {
	      defaultValue: false,
	      description: 'Enables github @mentions',
	      type: 'boolean'
	    },
	    ghMentionsLink: {
	      defaultValue: 'https://github.com/{u}',
	      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
	      type: 'string'
	    },
	    encodeEmails: {
	      defaultValue: true,
	      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
	      type: 'boolean'
	    },
	    openLinksInNewWindow: {
	      defaultValue: false,
	      description: 'Open all links in new windows',
	      type: 'boolean'
	    },
	    backslashEscapesHTMLTags: {
	      defaultValue: false,
	      description: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
	      type: 'boolean'
	    },
	    emoji: {
	      defaultValue: false,
	      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',
	      type: 'boolean'
	    },
	    underline: {
	      defaultValue: false,
	      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
	      type: 'boolean'
	    },
	    completeHTMLDocument: {
	      defaultValue: false,
	      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
	      type: 'boolean'
	    },
	    metadata: {
	      defaultValue: false,
	      description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
	      type: 'boolean'
	    },
	    splitAdjacentBlockquotes: {
	      defaultValue: false,
	      description: 'Split adjacent blockquote blocks',
	      type: 'boolean'
	    }
	  };
	  if (simple === false) {
	    return JSON.parse(JSON.stringify(defaultOptions));
	  }
	  var ret = {};
	  for (var opt in defaultOptions) {
	    if (defaultOptions.hasOwnProperty(opt)) {
	      ret[opt] = defaultOptions[opt].defaultValue;
	    }
	  }
	  return ret;
	}

	function allOptionsOn () {
	  var options = getDefaultOpts(true),
	      ret = {};
	  for (var opt in options) {
	    if (options.hasOwnProperty(opt)) {
	      ret[opt] = true;
	    }
	  }
	  return ret;
	}

	/**
	 * Created by Tivie on 06-01-2015.
	 */

	// Private properties
	var showdown = {},
	    parsers = {},
	    extensions = {},
	    globalOptions = getDefaultOpts(true),
	    setFlavor = 'vanilla',
	    flavor = {
	      github: {
	        omitExtraWLInCodeBlocks:              true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        disableForced4SpacesIndentedSublists: true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghCompatibleHeaderId:                 true,
	        ghMentions:                           true,
	        backslashEscapesHTMLTags:             true,
	        emoji:                                true,
	        splitAdjacentBlockquotes:             true
	      },
	      original: {
	        noHeaderId:                           true,
	        ghCodeBlocks:                         false
	      },
	      ghost: {
	        omitExtraWLInCodeBlocks:              true,
	        parseImgDimensions:                   true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        smoothLivePreview:                    true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghMentions:                           false,
	        encodeEmails:                         true
	      },
	      vanilla: getDefaultOpts(true),
	      allOn: allOptionsOn()
	    };

	/**
	 * helper namespace
	 * @type {{}}
	 */
	showdown.helper = {};

	/**
	 * TODO LEGACY SUPPORT CODE
	 * @type {{}}
	 */
	showdown.extensions = {};

	/**
	 * Set a global option
	 * @static
	 * @param {string} key
	 * @param {*} value
	 * @returns {showdown}
	 */
	showdown.setOption = function (key, value) {
	  globalOptions[key] = value;
	  return this;
	};

	/**
	 * Get a global option
	 * @static
	 * @param {string} key
	 * @returns {*}
	 */
	showdown.getOption = function (key) {
	  return globalOptions[key];
	};

	/**
	 * Get the global options
	 * @static
	 * @returns {{}}
	 */
	showdown.getOptions = function () {
	  return globalOptions;
	};

	/**
	 * Reset global options to the default values
	 * @static
	 */
	showdown.resetOptions = function () {
	  globalOptions = getDefaultOpts(true);
	};

	/**
	 * Set the flavor showdown should use as default
	 * @param {string} name
	 */
	showdown.setFlavor = function (name) {
	  if (!flavor.hasOwnProperty(name)) {
	    throw Error(name + ' flavor was not found');
	  }
	  showdown.resetOptions();
	  var preset = flavor[name];
	  setFlavor = name;
	  for (var option in preset) {
	    if (preset.hasOwnProperty(option)) {
	      globalOptions[option] = preset[option];
	    }
	  }
	};

	/**
	 * Get the currently set flavor
	 * @returns {string}
	 */
	showdown.getFlavor = function () {
	  return setFlavor;
	};

	/**
	 * Get the options of a specified flavor. Returns undefined if the flavor was not found
	 * @param {string} name Name of the flavor
	 * @returns {{}|undefined}
	 */
	showdown.getFlavorOptions = function (name) {
	  if (flavor.hasOwnProperty(name)) {
	    return flavor[name];
	  }
	};

	/**
	 * Get the default options
	 * @static
	 * @param {boolean} [simple=true]
	 * @returns {{}}
	 */
	showdown.getDefaultOptions = function (simple) {
	  return getDefaultOpts(simple);
	};

	/**
	 * Get or set a subParser
	 *
	 * subParser(name)       - Get a registered subParser
	 * subParser(name, func) - Register a subParser
	 * @static
	 * @param {string} name
	 * @param {function} [func]
	 * @returns {*}
	 */
	showdown.subParser = function (name, func) {
	  if (showdown.helper.isString(name)) {
	    if (typeof func !== 'undefined') {
	      parsers[name] = func;
	    } else {
	      if (parsers.hasOwnProperty(name)) {
	        return parsers[name];
	      } else {
	        throw Error('SubParser named ' + name + ' not registered!');
	      }
	    }
	  }
	};

	/**
	 * Gets or registers an extension
	 * @static
	 * @param {string} name
	 * @param {object|function=} ext
	 * @returns {*}
	 */
	showdown.extension = function (name, ext) {

	  if (!showdown.helper.isString(name)) {
	    throw Error('Extension \'name\' must be a string');
	  }

	  name = showdown.helper.stdExtName(name);

	  // Getter
	  if (showdown.helper.isUndefined(ext)) {
	    if (!extensions.hasOwnProperty(name)) {
	      throw Error('Extension named ' + name + ' is not registered!');
	    }
	    return extensions[name];

	    // Setter
	  } else {
	    // Expand extension if it's wrapped in a function
	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    // Ensure extension is an array
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExtension = validate(ext, name);

	    if (validExtension.valid) {
	      extensions[name] = ext;
	    } else {
	      throw Error(validExtension.error);
	    }
	  }
	};

	/**
	 * Gets all extensions registered
	 * @returns {{}}
	 */
	showdown.getAllExtensions = function () {
	  return extensions;
	};

	/**
	 * Remove an extension
	 * @param {string} name
	 */
	showdown.removeExtension = function (name) {
	  delete extensions[name];
	};

	/**
	 * Removes all extensions
	 */
	showdown.resetExtensions = function () {
	  extensions = {};
	};

	/**
	 * Validate extension
	 * @param {array} extension
	 * @param {string} name
	 * @returns {{valid: boolean, error: string}}
	 */
	function validate (extension, name) {

	  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
	      ret = {
	        valid: true,
	        error: ''
	      };

	  if (!showdown.helper.isArray(extension)) {
	    extension = [extension];
	  }

	  for (var i = 0; i < extension.length; ++i) {
	    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
	        ext = extension[i];
	    if (typeof ext !== 'object') {
	      ret.valid = false;
	      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
	      return ret;
	    }

	    if (!showdown.helper.isString(ext.type)) {
	      ret.valid = false;
	      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
	      return ret;
	    }

	    var type = ext.type = ext.type.toLowerCase();

	    // normalize extension type
	    if (type === 'language') {
	      type = ext.type = 'lang';
	    }

	    if (type === 'html') {
	      type = ext.type = 'output';
	    }

	    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
	      ret.valid = false;
	      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
	      return ret;
	    }

	    if (type === 'listener') {
	      if (showdown.helper.isUndefined(ext.listeners)) {
	        ret.valid = false;
	        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
	        return ret;
	      }
	    } else {
	      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
	        ret.valid = false;
	        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
	        return ret;
	      }
	    }

	    if (ext.listeners) {
	      if (typeof ext.listeners !== 'object') {
	        ret.valid = false;
	        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
	        return ret;
	      }
	      for (var ln in ext.listeners) {
	        if (ext.listeners.hasOwnProperty(ln)) {
	          if (typeof ext.listeners[ln] !== 'function') {
	            ret.valid = false;
	            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
	              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
	            return ret;
	          }
	        }
	      }
	    }

	    if (ext.filter) {
	      if (typeof ext.filter !== 'function') {
	        ret.valid = false;
	        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
	        return ret;
	      }
	    } else if (ext.regex) {
	      if (showdown.helper.isString(ext.regex)) {
	        ext.regex = new RegExp(ext.regex, 'g');
	      }
	      if (!(ext.regex instanceof RegExp)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
	        return ret;
	      }
	      if (showdown.helper.isUndefined(ext.replace)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
	        return ret;
	      }
	    }
	  }
	  return ret;
	}

	/**
	 * Validate extension
	 * @param {object} ext
	 * @returns {boolean}
	 */
	showdown.validateExtension = function (ext) {

	  var validateExtension = validate(ext, null);
	  if (!validateExtension.valid) {
	    console.warn(validateExtension.error);
	    return false;
	  }
	  return true;
	};

	/**
	 * showdownjs helper functions
	 */

	if (!showdown.hasOwnProperty('helper')) {
	  showdown.helper = {};
	}

	/**
	 * Check if var is string
	 * @static
	 * @param {string} a
	 * @returns {boolean}
	 */
	showdown.helper.isString = function (a) {
	  return (typeof a === 'string' || a instanceof String);
	};

	/**
	 * Check if var is a function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isFunction = function (a) {
	  var getType = {};
	  return a && getType.toString.call(a) === '[object Function]';
	};

	/**
	 * isArray helper function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isArray = function (a) {
	  return Array.isArray(a);
	};

	/**
	 * Check if value is undefined
	 * @static
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 */
	showdown.helper.isUndefined = function (value) {
	  return typeof value === 'undefined';
	};

	/**
	 * ForEach helper function
	 * Iterates over Arrays and Objects (own properties only)
	 * @static
	 * @param {*} obj
	 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
	 */
	showdown.helper.forEach = function (obj, callback) {
	  // check if obj is defined
	  if (showdown.helper.isUndefined(obj)) {
	    throw new Error('obj param is required');
	  }

	  if (showdown.helper.isUndefined(callback)) {
	    throw new Error('callback param is required');
	  }

	  if (!showdown.helper.isFunction(callback)) {
	    throw new Error('callback param must be a function/closure');
	  }

	  if (typeof obj.forEach === 'function') {
	    obj.forEach(callback);
	  } else if (showdown.helper.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      callback(obj[i], i, obj);
	    }
	  } else if (typeof (obj) === 'object') {
	    for (var prop in obj) {
	      if (obj.hasOwnProperty(prop)) {
	        callback(obj[prop], prop, obj);
	      }
	    }
	  } else {
	    throw new Error('obj does not seem to be an array or an iterable object');
	  }
	};

	/**
	 * Standardidize extension name
	 * @static
	 * @param {string} s extension name
	 * @returns {string}
	 */
	showdown.helper.stdExtName = function (s) {
	  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
	};

	function escapeCharactersCallback (wholeMatch, m1) {
	  var charCodeToEscape = m1.charCodeAt(0);
	  return '¨E' + charCodeToEscape + 'E';
	}

	/**
	 * Callback used to escape characters when passing through String.replace
	 * @static
	 * @param {string} wholeMatch
	 * @param {string} m1
	 * @returns {string}
	 */
	showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

	/**
	 * Escape characters in a string
	 * @static
	 * @param {string} text
	 * @param {string} charsToEscape
	 * @param {boolean} afterBackslash
	 * @returns {XML|string|void|*}
	 */
	showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
	  // First we have to escape the escape characters so that
	  // we can build a character class out of them
	  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

	  if (afterBackslash) {
	    regexString = '\\\\' + regexString;
	  }

	  var regex = new RegExp(regexString, 'g');
	  text = text.replace(regex, escapeCharactersCallback);

	  return text;
	};

	/**
	 * Unescape HTML entities
	 * @param txt
	 * @returns {string}
	 */
	showdown.helper.unescapeHTMLEntities = function (txt) {

	  return txt
	    .replace(/&quot;/g, '"')
	    .replace(/&lt;/g, '<')
	    .replace(/&gt;/g, '>')
	    .replace(/&amp;/g, '&');
	};

	var rgxFindMatchPos = function (str, left, right, flags) {
	  var f = flags || '',
	      g = f.indexOf('g') > -1,
	      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
	      l = new RegExp(left, f.replace(/g/g, '')),
	      pos = [],
	      t, s, m, start, end;

	  do {
	    t = 0;
	    while ((m = x.exec(str))) {
	      if (l.test(m[0])) {
	        if (!(t++)) {
	          s = x.lastIndex;
	          start = s - m[0].length;
	        }
	      } else if (t) {
	        if (!--t) {
	          end = m.index + m[0].length;
	          var obj = {
	            left: {start: start, end: s},
	            match: {start: s, end: m.index},
	            right: {start: m.index, end: end},
	            wholeMatch: {start: start, end: end}
	          };
	          pos.push(obj);
	          if (!g) {
	            return pos;
	          }
	        }
	      }
	    }
	  } while (t && (x.lastIndex = s));

	  return pos;
	};

	/**
	 * matchRecursiveRegExp
	 *
	 * (c) 2007 Steven Levithan <stevenlevithan.com>
	 * MIT License
	 *
	 * Accepts a string to search, a left and right format delimiter
	 * as regex patterns, and optional regex flags. Returns an array
	 * of matches, allowing nested instances of left/right delimiters.
	 * Use the "g" flag to return all matches, otherwise only the
	 * first is returned. Be careful to ensure that the left and
	 * right format delimiters produce mutually exclusive matches.
	 * Backreferences are not supported within the right delimiter
	 * due to how it is internally combined with the left delimiter.
	 * When matching strings whose format delimiters are unbalanced
	 * to the left or right, the output is intentionally as a
	 * conventional regex library with recursion support would
	 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
	 * "<" and ">" as the delimiters (both strings contain a single,
	 * balanced instance of "<x>").
	 *
	 * examples:
	 * matchRecursiveRegExp("test", "\\(", "\\)")
	 * returns: []
	 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
	 * returns: ["t<<e>><s>", ""]
	 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
	 * returns: ["test"]
	 */
	showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {

	  var matchPos = rgxFindMatchPos (str, left, right, flags),
	      results = [];

	  for (var i = 0; i < matchPos.length; ++i) {
	    results.push([
	      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	      str.slice(matchPos[i].match.start, matchPos[i].match.end),
	      str.slice(matchPos[i].left.start, matchPos[i].left.end),
	      str.slice(matchPos[i].right.start, matchPos[i].right.end)
	    ]);
	  }
	  return results;
	};

	/**
	 *
	 * @param {string} str
	 * @param {string|function} replacement
	 * @param {string} left
	 * @param {string} right
	 * @param {string} flags
	 * @returns {string}
	 */
	showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {

	  if (!showdown.helper.isFunction(replacement)) {
	    var repStr = replacement;
	    replacement = function () {
	      return repStr;
	    };
	  }

	  var matchPos = rgxFindMatchPos(str, left, right, flags),
	      finalStr = str,
	      lng = matchPos.length;

	  if (lng > 0) {
	    var bits = [];
	    if (matchPos[0].wholeMatch.start !== 0) {
	      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
	    }
	    for (var i = 0; i < lng; ++i) {
	      bits.push(
	        replacement(
	          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	          str.slice(matchPos[i].match.start, matchPos[i].match.end),
	          str.slice(matchPos[i].left.start, matchPos[i].left.end),
	          str.slice(matchPos[i].right.start, matchPos[i].right.end)
	        )
	      );
	      if (i < lng - 1) {
	        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
	      }
	    }
	    if (matchPos[lng - 1].wholeMatch.end < str.length) {
	      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
	    }
	    finalStr = bits.join('');
	  }
	  return finalStr;
	};

	/**
	 * Returns the index within the passed String object of the first occurrence of the specified regex,
	 * starting the search at fromIndex. Returns -1 if the value is not found.
	 *
	 * @param {string} str string to search
	 * @param {RegExp} regex Regular expression to search
	 * @param {int} [fromIndex = 0] Index to start the search
	 * @returns {Number}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  if (regex instanceof RegExp === false) {
	    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
	  }
	  var indexOf = str.substring(fromIndex || 0).search(regex);
	  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
	};

	/**
	 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
	 * @param {string} str string to split
	 * @param {int} index index to split string at
	 * @returns {[string,string]}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.splitAtIndex = function (str, index) {
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  return [str.substring(0, index), str.substring(index)];
	};

	/**
	 * Obfuscate an e-mail address through the use of Character Entities,
	 * transforming ASCII characters into their equivalent decimal or hex entities.
	 *
	 * Since it has a random component, subsequent calls to this function produce different results
	 *
	 * @param {string} mail
	 * @returns {string}
	 */
	showdown.helper.encodeEmailAddress = function (mail) {
	  var encode = [
	    function (ch) {
	      return '&#' + ch.charCodeAt(0) + ';';
	    },
	    function (ch) {
	      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
	    },
	    function (ch) {
	      return ch;
	    }
	  ];

	  mail = mail.replace(/./g, function (ch) {
	    if (ch === '@') {
	      // this *must* be encoded. I insist.
	      ch = encode[Math.floor(Math.random() * 2)](ch);
	    } else {
	      var r = Math.random();
	      // roughly 10% raw, 45% hex, 45% dec
	      ch = (
	        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
	      );
	    }
	    return ch;
	  });

	  return mail;
	};

	/**
	 *
	 * @param str
	 * @param targetLength
	 * @param padString
	 * @returns {string}
	 */
	showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
	  /*jshint bitwise: false*/
	  // eslint-disable-next-line space-infix-ops
	  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
	  /*jshint bitwise: true*/
	  padString = String(padString || ' ');
	  if (str.length > targetLength) {
	    return String(str);
	  } else {
	    targetLength = targetLength - str.length;
	    if (targetLength > padString.length) {
	      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
	    }
	    return String(str) + padString.slice(0,targetLength);
	  }
	};

	/**
	 * POLYFILLS
	 */
	// use this instead of builtin is undefined for IE8 compatibility
	if (typeof console === 'undefined') {
	  console = {
	    warn: function (msg) {
	      alert(msg);
	    },
	    log: function (msg) {
	      alert(msg);
	    },
	    error: function (msg) {
	      throw msg;
	    }
	  };
	}

	/**
	 * Common regexes.
	 * We declare some common regexes to improve performance
	 */
	showdown.helper.regexes = {
	  asteriskDashAndColon: /([*_:~])/g
	};

	/**
	 * EMOJIS LIST
	 */
	showdown.helper.emojis = {
	  '+1':'\ud83d\udc4d',
	  '-1':'\ud83d\udc4e',
	  '100':'\ud83d\udcaf',
	  '1234':'\ud83d\udd22',
	  '1st_place_medal':'\ud83e\udd47',
	  '2nd_place_medal':'\ud83e\udd48',
	  '3rd_place_medal':'\ud83e\udd49',
	  '8ball':'\ud83c\udfb1',
	  'a':'\ud83c\udd70\ufe0f',
	  'ab':'\ud83c\udd8e',
	  'abc':'\ud83d\udd24',
	  'abcd':'\ud83d\udd21',
	  'accept':'\ud83c\ude51',
	  'aerial_tramway':'\ud83d\udea1',
	  'airplane':'\u2708\ufe0f',
	  'alarm_clock':'\u23f0',
	  'alembic':'\u2697\ufe0f',
	  'alien':'\ud83d\udc7d',
	  'ambulance':'\ud83d\ude91',
	  'amphora':'\ud83c\udffa',
	  'anchor':'\u2693\ufe0f',
	  'angel':'\ud83d\udc7c',
	  'anger':'\ud83d\udca2',
	  'angry':'\ud83d\ude20',
	  'anguished':'\ud83d\ude27',
	  'ant':'\ud83d\udc1c',
	  'apple':'\ud83c\udf4e',
	  'aquarius':'\u2652\ufe0f',
	  'aries':'\u2648\ufe0f',
	  'arrow_backward':'\u25c0\ufe0f',
	  'arrow_double_down':'\u23ec',
	  'arrow_double_up':'\u23eb',
	  'arrow_down':'\u2b07\ufe0f',
	  'arrow_down_small':'\ud83d\udd3d',
	  'arrow_forward':'\u25b6\ufe0f',
	  'arrow_heading_down':'\u2935\ufe0f',
	  'arrow_heading_up':'\u2934\ufe0f',
	  'arrow_left':'\u2b05\ufe0f',
	  'arrow_lower_left':'\u2199\ufe0f',
	  'arrow_lower_right':'\u2198\ufe0f',
	  'arrow_right':'\u27a1\ufe0f',
	  'arrow_right_hook':'\u21aa\ufe0f',
	  'arrow_up':'\u2b06\ufe0f',
	  'arrow_up_down':'\u2195\ufe0f',
	  'arrow_up_small':'\ud83d\udd3c',
	  'arrow_upper_left':'\u2196\ufe0f',
	  'arrow_upper_right':'\u2197\ufe0f',
	  'arrows_clockwise':'\ud83d\udd03',
	  'arrows_counterclockwise':'\ud83d\udd04',
	  'art':'\ud83c\udfa8',
	  'articulated_lorry':'\ud83d\ude9b',
	  'artificial_satellite':'\ud83d\udef0',
	  'astonished':'\ud83d\ude32',
	  'athletic_shoe':'\ud83d\udc5f',
	  'atm':'\ud83c\udfe7',
	  'atom_symbol':'\u269b\ufe0f',
	  'avocado':'\ud83e\udd51',
	  'b':'\ud83c\udd71\ufe0f',
	  'baby':'\ud83d\udc76',
	  'baby_bottle':'\ud83c\udf7c',
	  'baby_chick':'\ud83d\udc24',
	  'baby_symbol':'\ud83d\udebc',
	  'back':'\ud83d\udd19',
	  'bacon':'\ud83e\udd53',
	  'badminton':'\ud83c\udff8',
	  'baggage_claim':'\ud83d\udec4',
	  'baguette_bread':'\ud83e\udd56',
	  'balance_scale':'\u2696\ufe0f',
	  'balloon':'\ud83c\udf88',
	  'ballot_box':'\ud83d\uddf3',
	  'ballot_box_with_check':'\u2611\ufe0f',
	  'bamboo':'\ud83c\udf8d',
	  'banana':'\ud83c\udf4c',
	  'bangbang':'\u203c\ufe0f',
	  'bank':'\ud83c\udfe6',
	  'bar_chart':'\ud83d\udcca',
	  'barber':'\ud83d\udc88',
	  'baseball':'\u26be\ufe0f',
	  'basketball':'\ud83c\udfc0',
	  'basketball_man':'\u26f9\ufe0f',
	  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
	  'bat':'\ud83e\udd87',
	  'bath':'\ud83d\udec0',
	  'bathtub':'\ud83d\udec1',
	  'battery':'\ud83d\udd0b',
	  'beach_umbrella':'\ud83c\udfd6',
	  'bear':'\ud83d\udc3b',
	  'bed':'\ud83d\udecf',
	  'bee':'\ud83d\udc1d',
	  'beer':'\ud83c\udf7a',
	  'beers':'\ud83c\udf7b',
	  'beetle':'\ud83d\udc1e',
	  'beginner':'\ud83d\udd30',
	  'bell':'\ud83d\udd14',
	  'bellhop_bell':'\ud83d\udece',
	  'bento':'\ud83c\udf71',
	  'biking_man':'\ud83d\udeb4',
	  'bike':'\ud83d\udeb2',
	  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
	  'bikini':'\ud83d\udc59',
	  'biohazard':'\u2623\ufe0f',
	  'bird':'\ud83d\udc26',
	  'birthday':'\ud83c\udf82',
	  'black_circle':'\u26ab\ufe0f',
	  'black_flag':'\ud83c\udff4',
	  'black_heart':'\ud83d\udda4',
	  'black_joker':'\ud83c\udccf',
	  'black_large_square':'\u2b1b\ufe0f',
	  'black_medium_small_square':'\u25fe\ufe0f',
	  'black_medium_square':'\u25fc\ufe0f',
	  'black_nib':'\u2712\ufe0f',
	  'black_small_square':'\u25aa\ufe0f',
	  'black_square_button':'\ud83d\udd32',
	  'blonde_man':'\ud83d\udc71',
	  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
	  'blossom':'\ud83c\udf3c',
	  'blowfish':'\ud83d\udc21',
	  'blue_book':'\ud83d\udcd8',
	  'blue_car':'\ud83d\ude99',
	  'blue_heart':'\ud83d\udc99',
	  'blush':'\ud83d\ude0a',
	  'boar':'\ud83d\udc17',
	  'boat':'\u26f5\ufe0f',
	  'bomb':'\ud83d\udca3',
	  'book':'\ud83d\udcd6',
	  'bookmark':'\ud83d\udd16',
	  'bookmark_tabs':'\ud83d\udcd1',
	  'books':'\ud83d\udcda',
	  'boom':'\ud83d\udca5',
	  'boot':'\ud83d\udc62',
	  'bouquet':'\ud83d\udc90',
	  'bowing_man':'\ud83d\ude47',
	  'bow_and_arrow':'\ud83c\udff9',
	  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
	  'bowling':'\ud83c\udfb3',
	  'boxing_glove':'\ud83e\udd4a',
	  'boy':'\ud83d\udc66',
	  'bread':'\ud83c\udf5e',
	  'bride_with_veil':'\ud83d\udc70',
	  'bridge_at_night':'\ud83c\udf09',
	  'briefcase':'\ud83d\udcbc',
	  'broken_heart':'\ud83d\udc94',
	  'bug':'\ud83d\udc1b',
	  'building_construction':'\ud83c\udfd7',
	  'bulb':'\ud83d\udca1',
	  'bullettrain_front':'\ud83d\ude85',
	  'bullettrain_side':'\ud83d\ude84',
	  'burrito':'\ud83c\udf2f',
	  'bus':'\ud83d\ude8c',
	  'business_suit_levitating':'\ud83d\udd74',
	  'busstop':'\ud83d\ude8f',
	  'bust_in_silhouette':'\ud83d\udc64',
	  'busts_in_silhouette':'\ud83d\udc65',
	  'butterfly':'\ud83e\udd8b',
	  'cactus':'\ud83c\udf35',
	  'cake':'\ud83c\udf70',
	  'calendar':'\ud83d\udcc6',
	  'call_me_hand':'\ud83e\udd19',
	  'calling':'\ud83d\udcf2',
	  'camel':'\ud83d\udc2b',
	  'camera':'\ud83d\udcf7',
	  'camera_flash':'\ud83d\udcf8',
	  'camping':'\ud83c\udfd5',
	  'cancer':'\u264b\ufe0f',
	  'candle':'\ud83d\udd6f',
	  'candy':'\ud83c\udf6c',
	  'canoe':'\ud83d\udef6',
	  'capital_abcd':'\ud83d\udd20',
	  'capricorn':'\u2651\ufe0f',
	  'car':'\ud83d\ude97',
	  'card_file_box':'\ud83d\uddc3',
	  'card_index':'\ud83d\udcc7',
	  'card_index_dividers':'\ud83d\uddc2',
	  'carousel_horse':'\ud83c\udfa0',
	  'carrot':'\ud83e\udd55',
	  'cat':'\ud83d\udc31',
	  'cat2':'\ud83d\udc08',
	  'cd':'\ud83d\udcbf',
	  'chains':'\u26d3',
	  'champagne':'\ud83c\udf7e',
	  'chart':'\ud83d\udcb9',
	  'chart_with_downwards_trend':'\ud83d\udcc9',
	  'chart_with_upwards_trend':'\ud83d\udcc8',
	  'checkered_flag':'\ud83c\udfc1',
	  'cheese':'\ud83e\uddc0',
	  'cherries':'\ud83c\udf52',
	  'cherry_blossom':'\ud83c\udf38',
	  'chestnut':'\ud83c\udf30',
	  'chicken':'\ud83d\udc14',
	  'children_crossing':'\ud83d\udeb8',
	  'chipmunk':'\ud83d\udc3f',
	  'chocolate_bar':'\ud83c\udf6b',
	  'christmas_tree':'\ud83c\udf84',
	  'church':'\u26ea\ufe0f',
	  'cinema':'\ud83c\udfa6',
	  'circus_tent':'\ud83c\udfaa',
	  'city_sunrise':'\ud83c\udf07',
	  'city_sunset':'\ud83c\udf06',
	  'cityscape':'\ud83c\udfd9',
	  'cl':'\ud83c\udd91',
	  'clamp':'\ud83d\udddc',
	  'clap':'\ud83d\udc4f',
	  'clapper':'\ud83c\udfac',
	  'classical_building':'\ud83c\udfdb',
	  'clinking_glasses':'\ud83e\udd42',
	  'clipboard':'\ud83d\udccb',
	  'clock1':'\ud83d\udd50',
	  'clock10':'\ud83d\udd59',
	  'clock1030':'\ud83d\udd65',
	  'clock11':'\ud83d\udd5a',
	  'clock1130':'\ud83d\udd66',
	  'clock12':'\ud83d\udd5b',
	  'clock1230':'\ud83d\udd67',
	  'clock130':'\ud83d\udd5c',
	  'clock2':'\ud83d\udd51',
	  'clock230':'\ud83d\udd5d',
	  'clock3':'\ud83d\udd52',
	  'clock330':'\ud83d\udd5e',
	  'clock4':'\ud83d\udd53',
	  'clock430':'\ud83d\udd5f',
	  'clock5':'\ud83d\udd54',
	  'clock530':'\ud83d\udd60',
	  'clock6':'\ud83d\udd55',
	  'clock630':'\ud83d\udd61',
	  'clock7':'\ud83d\udd56',
	  'clock730':'\ud83d\udd62',
	  'clock8':'\ud83d\udd57',
	  'clock830':'\ud83d\udd63',
	  'clock9':'\ud83d\udd58',
	  'clock930':'\ud83d\udd64',
	  'closed_book':'\ud83d\udcd5',
	  'closed_lock_with_key':'\ud83d\udd10',
	  'closed_umbrella':'\ud83c\udf02',
	  'cloud':'\u2601\ufe0f',
	  'cloud_with_lightning':'\ud83c\udf29',
	  'cloud_with_lightning_and_rain':'\u26c8',
	  'cloud_with_rain':'\ud83c\udf27',
	  'cloud_with_snow':'\ud83c\udf28',
	  'clown_face':'\ud83e\udd21',
	  'clubs':'\u2663\ufe0f',
	  'cocktail':'\ud83c\udf78',
	  'coffee':'\u2615\ufe0f',
	  'coffin':'\u26b0\ufe0f',
	  'cold_sweat':'\ud83d\ude30',
	  'comet':'\u2604\ufe0f',
	  'computer':'\ud83d\udcbb',
	  'computer_mouse':'\ud83d\uddb1',
	  'confetti_ball':'\ud83c\udf8a',
	  'confounded':'\ud83d\ude16',
	  'confused':'\ud83d\ude15',
	  'congratulations':'\u3297\ufe0f',
	  'construction':'\ud83d\udea7',
	  'construction_worker_man':'\ud83d\udc77',
	  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
	  'control_knobs':'\ud83c\udf9b',
	  'convenience_store':'\ud83c\udfea',
	  'cookie':'\ud83c\udf6a',
	  'cool':'\ud83c\udd92',
	  'policeman':'\ud83d\udc6e',
	  'copyright':'\u00a9\ufe0f',
	  'corn':'\ud83c\udf3d',
	  'couch_and_lamp':'\ud83d\udecb',
	  'couple':'\ud83d\udc6b',
	  'couple_with_heart_woman_man':'\ud83d\udc91',
	  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
	  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
	  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
	  'couplekiss_man_woman':'\ud83d\udc8f',
	  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
	  'cow':'\ud83d\udc2e',
	  'cow2':'\ud83d\udc04',
	  'cowboy_hat_face':'\ud83e\udd20',
	  'crab':'\ud83e\udd80',
	  'crayon':'\ud83d\udd8d',
	  'credit_card':'\ud83d\udcb3',
	  'crescent_moon':'\ud83c\udf19',
	  'cricket':'\ud83c\udfcf',
	  'crocodile':'\ud83d\udc0a',
	  'croissant':'\ud83e\udd50',
	  'crossed_fingers':'\ud83e\udd1e',
	  'crossed_flags':'\ud83c\udf8c',
	  'crossed_swords':'\u2694\ufe0f',
	  'crown':'\ud83d\udc51',
	  'cry':'\ud83d\ude22',
	  'crying_cat_face':'\ud83d\ude3f',
	  'crystal_ball':'\ud83d\udd2e',
	  'cucumber':'\ud83e\udd52',
	  'cupid':'\ud83d\udc98',
	  'curly_loop':'\u27b0',
	  'currency_exchange':'\ud83d\udcb1',
	  'curry':'\ud83c\udf5b',
	  'custard':'\ud83c\udf6e',
	  'customs':'\ud83d\udec3',
	  'cyclone':'\ud83c\udf00',
	  'dagger':'\ud83d\udde1',
	  'dancer':'\ud83d\udc83',
	  'dancing_women':'\ud83d\udc6f',
	  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
	  'dango':'\ud83c\udf61',
	  'dark_sunglasses':'\ud83d\udd76',
	  'dart':'\ud83c\udfaf',
	  'dash':'\ud83d\udca8',
	  'date':'\ud83d\udcc5',
	  'deciduous_tree':'\ud83c\udf33',
	  'deer':'\ud83e\udd8c',
	  'department_store':'\ud83c\udfec',
	  'derelict_house':'\ud83c\udfda',
	  'desert':'\ud83c\udfdc',
	  'desert_island':'\ud83c\udfdd',
	  'desktop_computer':'\ud83d\udda5',
	  'male_detective':'\ud83d\udd75\ufe0f',
	  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
	  'diamonds':'\u2666\ufe0f',
	  'disappointed':'\ud83d\ude1e',
	  'disappointed_relieved':'\ud83d\ude25',
	  'dizzy':'\ud83d\udcab',
	  'dizzy_face':'\ud83d\ude35',
	  'do_not_litter':'\ud83d\udeaf',
	  'dog':'\ud83d\udc36',
	  'dog2':'\ud83d\udc15',
	  'dollar':'\ud83d\udcb5',
	  'dolls':'\ud83c\udf8e',
	  'dolphin':'\ud83d\udc2c',
	  'door':'\ud83d\udeaa',
	  'doughnut':'\ud83c\udf69',
	  'dove':'\ud83d\udd4a',
	  'dragon':'\ud83d\udc09',
	  'dragon_face':'\ud83d\udc32',
	  'dress':'\ud83d\udc57',
	  'dromedary_camel':'\ud83d\udc2a',
	  'drooling_face':'\ud83e\udd24',
	  'droplet':'\ud83d\udca7',
	  'drum':'\ud83e\udd41',
	  'duck':'\ud83e\udd86',
	  'dvd':'\ud83d\udcc0',
	  'e-mail':'\ud83d\udce7',
	  'eagle':'\ud83e\udd85',
	  'ear':'\ud83d\udc42',
	  'ear_of_rice':'\ud83c\udf3e',
	  'earth_africa':'\ud83c\udf0d',
	  'earth_americas':'\ud83c\udf0e',
	  'earth_asia':'\ud83c\udf0f',
	  'egg':'\ud83e\udd5a',
	  'eggplant':'\ud83c\udf46',
	  'eight_pointed_black_star':'\u2734\ufe0f',
	  'eight_spoked_asterisk':'\u2733\ufe0f',
	  'electric_plug':'\ud83d\udd0c',
	  'elephant':'\ud83d\udc18',
	  'email':'\u2709\ufe0f',
	  'end':'\ud83d\udd1a',
	  'envelope_with_arrow':'\ud83d\udce9',
	  'euro':'\ud83d\udcb6',
	  'european_castle':'\ud83c\udff0',
	  'european_post_office':'\ud83c\udfe4',
	  'evergreen_tree':'\ud83c\udf32',
	  'exclamation':'\u2757\ufe0f',
	  'expressionless':'\ud83d\ude11',
	  'eye':'\ud83d\udc41',
	  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
	  'eyeglasses':'\ud83d\udc53',
	  'eyes':'\ud83d\udc40',
	  'face_with_head_bandage':'\ud83e\udd15',
	  'face_with_thermometer':'\ud83e\udd12',
	  'fist_oncoming':'\ud83d\udc4a',
	  'factory':'\ud83c\udfed',
	  'fallen_leaf':'\ud83c\udf42',
	  'family_man_woman_boy':'\ud83d\udc6a',
	  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'fast_forward':'\u23e9',
	  'fax':'\ud83d\udce0',
	  'fearful':'\ud83d\ude28',
	  'feet':'\ud83d\udc3e',
	  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
	  'ferris_wheel':'\ud83c\udfa1',
	  'ferry':'\u26f4',
	  'field_hockey':'\ud83c\udfd1',
	  'file_cabinet':'\ud83d\uddc4',
	  'file_folder':'\ud83d\udcc1',
	  'film_projector':'\ud83d\udcfd',
	  'film_strip':'\ud83c\udf9e',
	  'fire':'\ud83d\udd25',
	  'fire_engine':'\ud83d\ude92',
	  'fireworks':'\ud83c\udf86',
	  'first_quarter_moon':'\ud83c\udf13',
	  'first_quarter_moon_with_face':'\ud83c\udf1b',
	  'fish':'\ud83d\udc1f',
	  'fish_cake':'\ud83c\udf65',
	  'fishing_pole_and_fish':'\ud83c\udfa3',
	  'fist_raised':'\u270a',
	  'fist_left':'\ud83e\udd1b',
	  'fist_right':'\ud83e\udd1c',
	  'flags':'\ud83c\udf8f',
	  'flashlight':'\ud83d\udd26',
	  'fleur_de_lis':'\u269c\ufe0f',
	  'flight_arrival':'\ud83d\udeec',
	  'flight_departure':'\ud83d\udeeb',
	  'floppy_disk':'\ud83d\udcbe',
	  'flower_playing_cards':'\ud83c\udfb4',
	  'flushed':'\ud83d\ude33',
	  'fog':'\ud83c\udf2b',
	  'foggy':'\ud83c\udf01',
	  'football':'\ud83c\udfc8',
	  'footprints':'\ud83d\udc63',
	  'fork_and_knife':'\ud83c\udf74',
	  'fountain':'\u26f2\ufe0f',
	  'fountain_pen':'\ud83d\udd8b',
	  'four_leaf_clover':'\ud83c\udf40',
	  'fox_face':'\ud83e\udd8a',
	  'framed_picture':'\ud83d\uddbc',
	  'free':'\ud83c\udd93',
	  'fried_egg':'\ud83c\udf73',
	  'fried_shrimp':'\ud83c\udf64',
	  'fries':'\ud83c\udf5f',
	  'frog':'\ud83d\udc38',
	  'frowning':'\ud83d\ude26',
	  'frowning_face':'\u2639\ufe0f',
	  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
	  'frowning_woman':'\ud83d\ude4d',
	  'middle_finger':'\ud83d\udd95',
	  'fuelpump':'\u26fd\ufe0f',
	  'full_moon':'\ud83c\udf15',
	  'full_moon_with_face':'\ud83c\udf1d',
	  'funeral_urn':'\u26b1\ufe0f',
	  'game_die':'\ud83c\udfb2',
	  'gear':'\u2699\ufe0f',
	  'gem':'\ud83d\udc8e',
	  'gemini':'\u264a\ufe0f',
	  'ghost':'\ud83d\udc7b',
	  'gift':'\ud83c\udf81',
	  'gift_heart':'\ud83d\udc9d',
	  'girl':'\ud83d\udc67',
	  'globe_with_meridians':'\ud83c\udf10',
	  'goal_net':'\ud83e\udd45',
	  'goat':'\ud83d\udc10',
	  'golf':'\u26f3\ufe0f',
	  'golfing_man':'\ud83c\udfcc\ufe0f',
	  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
	  'gorilla':'\ud83e\udd8d',
	  'grapes':'\ud83c\udf47',
	  'green_apple':'\ud83c\udf4f',
	  'green_book':'\ud83d\udcd7',
	  'green_heart':'\ud83d\udc9a',
	  'green_salad':'\ud83e\udd57',
	  'grey_exclamation':'\u2755',
	  'grey_question':'\u2754',
	  'grimacing':'\ud83d\ude2c',
	  'grin':'\ud83d\ude01',
	  'grinning':'\ud83d\ude00',
	  'guardsman':'\ud83d\udc82',
	  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
	  'guitar':'\ud83c\udfb8',
	  'gun':'\ud83d\udd2b',
	  'haircut_woman':'\ud83d\udc87',
	  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
	  'hamburger':'\ud83c\udf54',
	  'hammer':'\ud83d\udd28',
	  'hammer_and_pick':'\u2692',
	  'hammer_and_wrench':'\ud83d\udee0',
	  'hamster':'\ud83d\udc39',
	  'hand':'\u270b',
	  'handbag':'\ud83d\udc5c',
	  'handshake':'\ud83e\udd1d',
	  'hankey':'\ud83d\udca9',
	  'hatched_chick':'\ud83d\udc25',
	  'hatching_chick':'\ud83d\udc23',
	  'headphones':'\ud83c\udfa7',
	  'hear_no_evil':'\ud83d\ude49',
	  'heart':'\u2764\ufe0f',
	  'heart_decoration':'\ud83d\udc9f',
	  'heart_eyes':'\ud83d\ude0d',
	  'heart_eyes_cat':'\ud83d\ude3b',
	  'heartbeat':'\ud83d\udc93',
	  'heartpulse':'\ud83d\udc97',
	  'hearts':'\u2665\ufe0f',
	  'heavy_check_mark':'\u2714\ufe0f',
	  'heavy_division_sign':'\u2797',
	  'heavy_dollar_sign':'\ud83d\udcb2',
	  'heavy_heart_exclamation':'\u2763\ufe0f',
	  'heavy_minus_sign':'\u2796',
	  'heavy_multiplication_x':'\u2716\ufe0f',
	  'heavy_plus_sign':'\u2795',
	  'helicopter':'\ud83d\ude81',
	  'herb':'\ud83c\udf3f',
	  'hibiscus':'\ud83c\udf3a',
	  'high_brightness':'\ud83d\udd06',
	  'high_heel':'\ud83d\udc60',
	  'hocho':'\ud83d\udd2a',
	  'hole':'\ud83d\udd73',
	  'honey_pot':'\ud83c\udf6f',
	  'horse':'\ud83d\udc34',
	  'horse_racing':'\ud83c\udfc7',
	  'hospital':'\ud83c\udfe5',
	  'hot_pepper':'\ud83c\udf36',
	  'hotdog':'\ud83c\udf2d',
	  'hotel':'\ud83c\udfe8',
	  'hotsprings':'\u2668\ufe0f',
	  'hourglass':'\u231b\ufe0f',
	  'hourglass_flowing_sand':'\u23f3',
	  'house':'\ud83c\udfe0',
	  'house_with_garden':'\ud83c\udfe1',
	  'houses':'\ud83c\udfd8',
	  'hugs':'\ud83e\udd17',
	  'hushed':'\ud83d\ude2f',
	  'ice_cream':'\ud83c\udf68',
	  'ice_hockey':'\ud83c\udfd2',
	  'ice_skate':'\u26f8',
	  'icecream':'\ud83c\udf66',
	  'id':'\ud83c\udd94',
	  'ideograph_advantage':'\ud83c\ude50',
	  'imp':'\ud83d\udc7f',
	  'inbox_tray':'\ud83d\udce5',
	  'incoming_envelope':'\ud83d\udce8',
	  'tipping_hand_woman':'\ud83d\udc81',
	  'information_source':'\u2139\ufe0f',
	  'innocent':'\ud83d\ude07',
	  'interrobang':'\u2049\ufe0f',
	  'iphone':'\ud83d\udcf1',
	  'izakaya_lantern':'\ud83c\udfee',
	  'jack_o_lantern':'\ud83c\udf83',
	  'japan':'\ud83d\uddfe',
	  'japanese_castle':'\ud83c\udfef',
	  'japanese_goblin':'\ud83d\udc7a',
	  'japanese_ogre':'\ud83d\udc79',
	  'jeans':'\ud83d\udc56',
	  'joy':'\ud83d\ude02',
	  'joy_cat':'\ud83d\ude39',
	  'joystick':'\ud83d\udd79',
	  'kaaba':'\ud83d\udd4b',
	  'key':'\ud83d\udd11',
	  'keyboard':'\u2328\ufe0f',
	  'keycap_ten':'\ud83d\udd1f',
	  'kick_scooter':'\ud83d\udef4',
	  'kimono':'\ud83d\udc58',
	  'kiss':'\ud83d\udc8b',
	  'kissing':'\ud83d\ude17',
	  'kissing_cat':'\ud83d\ude3d',
	  'kissing_closed_eyes':'\ud83d\ude1a',
	  'kissing_heart':'\ud83d\ude18',
	  'kissing_smiling_eyes':'\ud83d\ude19',
	  'kiwi_fruit':'\ud83e\udd5d',
	  'koala':'\ud83d\udc28',
	  'koko':'\ud83c\ude01',
	  'label':'\ud83c\udff7',
	  'large_blue_circle':'\ud83d\udd35',
	  'large_blue_diamond':'\ud83d\udd37',
	  'large_orange_diamond':'\ud83d\udd36',
	  'last_quarter_moon':'\ud83c\udf17',
	  'last_quarter_moon_with_face':'\ud83c\udf1c',
	  'latin_cross':'\u271d\ufe0f',
	  'laughing':'\ud83d\ude06',
	  'leaves':'\ud83c\udf43',
	  'ledger':'\ud83d\udcd2',
	  'left_luggage':'\ud83d\udec5',
	  'left_right_arrow':'\u2194\ufe0f',
	  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
	  'lemon':'\ud83c\udf4b',
	  'leo':'\u264c\ufe0f',
	  'leopard':'\ud83d\udc06',
	  'level_slider':'\ud83c\udf9a',
	  'libra':'\u264e\ufe0f',
	  'light_rail':'\ud83d\ude88',
	  'link':'\ud83d\udd17',
	  'lion':'\ud83e\udd81',
	  'lips':'\ud83d\udc44',
	  'lipstick':'\ud83d\udc84',
	  'lizard':'\ud83e\udd8e',
	  'lock':'\ud83d\udd12',
	  'lock_with_ink_pen':'\ud83d\udd0f',
	  'lollipop':'\ud83c\udf6d',
	  'loop':'\u27bf',
	  'loud_sound':'\ud83d\udd0a',
	  'loudspeaker':'\ud83d\udce2',
	  'love_hotel':'\ud83c\udfe9',
	  'love_letter':'\ud83d\udc8c',
	  'low_brightness':'\ud83d\udd05',
	  'lying_face':'\ud83e\udd25',
	  'm':'\u24c2\ufe0f',
	  'mag':'\ud83d\udd0d',
	  'mag_right':'\ud83d\udd0e',
	  'mahjong':'\ud83c\udc04\ufe0f',
	  'mailbox':'\ud83d\udceb',
	  'mailbox_closed':'\ud83d\udcea',
	  'mailbox_with_mail':'\ud83d\udcec',
	  'mailbox_with_no_mail':'\ud83d\udced',
	  'man':'\ud83d\udc68',
	  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
	  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
	  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
	  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
	  'man_dancing':'\ud83d\udd7a',
	  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
	  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
	  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
	  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
	  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
	  'man_in_tuxedo':'\ud83e\udd35',
	  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
	  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
	  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
	  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
	  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
	  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
	  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
	  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
	  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
	  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
	  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
	  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
	  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
	  'man_with_gua_pi_mao':'\ud83d\udc72',
	  'man_with_turban':'\ud83d\udc73',
	  'tangerine':'\ud83c\udf4a',
	  'mans_shoe':'\ud83d\udc5e',
	  'mantelpiece_clock':'\ud83d\udd70',
	  'maple_leaf':'\ud83c\udf41',
	  'martial_arts_uniform':'\ud83e\udd4b',
	  'mask':'\ud83d\ude37',
	  'massage_woman':'\ud83d\udc86',
	  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
	  'meat_on_bone':'\ud83c\udf56',
	  'medal_military':'\ud83c\udf96',
	  'medal_sports':'\ud83c\udfc5',
	  'mega':'\ud83d\udce3',
	  'melon':'\ud83c\udf48',
	  'memo':'\ud83d\udcdd',
	  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
	  'menorah':'\ud83d\udd4e',
	  'mens':'\ud83d\udeb9',
	  'metal':'\ud83e\udd18',
	  'metro':'\ud83d\ude87',
	  'microphone':'\ud83c\udfa4',
	  'microscope':'\ud83d\udd2c',
	  'milk_glass':'\ud83e\udd5b',
	  'milky_way':'\ud83c\udf0c',
	  'minibus':'\ud83d\ude90',
	  'minidisc':'\ud83d\udcbd',
	  'mobile_phone_off':'\ud83d\udcf4',
	  'money_mouth_face':'\ud83e\udd11',
	  'money_with_wings':'\ud83d\udcb8',
	  'moneybag':'\ud83d\udcb0',
	  'monkey':'\ud83d\udc12',
	  'monkey_face':'\ud83d\udc35',
	  'monorail':'\ud83d\ude9d',
	  'moon':'\ud83c\udf14',
	  'mortar_board':'\ud83c\udf93',
	  'mosque':'\ud83d\udd4c',
	  'motor_boat':'\ud83d\udee5',
	  'motor_scooter':'\ud83d\udef5',
	  'motorcycle':'\ud83c\udfcd',
	  'motorway':'\ud83d\udee3',
	  'mount_fuji':'\ud83d\uddfb',
	  'mountain':'\u26f0',
	  'mountain_biking_man':'\ud83d\udeb5',
	  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
	  'mountain_cableway':'\ud83d\udea0',
	  'mountain_railway':'\ud83d\ude9e',
	  'mountain_snow':'\ud83c\udfd4',
	  'mouse':'\ud83d\udc2d',
	  'mouse2':'\ud83d\udc01',
	  'movie_camera':'\ud83c\udfa5',
	  'moyai':'\ud83d\uddff',
	  'mrs_claus':'\ud83e\udd36',
	  'muscle':'\ud83d\udcaa',
	  'mushroom':'\ud83c\udf44',
	  'musical_keyboard':'\ud83c\udfb9',
	  'musical_note':'\ud83c\udfb5',
	  'musical_score':'\ud83c\udfbc',
	  'mute':'\ud83d\udd07',
	  'nail_care':'\ud83d\udc85',
	  'name_badge':'\ud83d\udcdb',
	  'national_park':'\ud83c\udfde',
	  'nauseated_face':'\ud83e\udd22',
	  'necktie':'\ud83d\udc54',
	  'negative_squared_cross_mark':'\u274e',
	  'nerd_face':'\ud83e\udd13',
	  'neutral_face':'\ud83d\ude10',
	  'new':'\ud83c\udd95',
	  'new_moon':'\ud83c\udf11',
	  'new_moon_with_face':'\ud83c\udf1a',
	  'newspaper':'\ud83d\udcf0',
	  'newspaper_roll':'\ud83d\uddde',
	  'next_track_button':'\u23ed',
	  'ng':'\ud83c\udd96',
	  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
	  'no_good_woman':'\ud83d\ude45',
	  'night_with_stars':'\ud83c\udf03',
	  'no_bell':'\ud83d\udd15',
	  'no_bicycles':'\ud83d\udeb3',
	  'no_entry':'\u26d4\ufe0f',
	  'no_entry_sign':'\ud83d\udeab',
	  'no_mobile_phones':'\ud83d\udcf5',
	  'no_mouth':'\ud83d\ude36',
	  'no_pedestrians':'\ud83d\udeb7',
	  'no_smoking':'\ud83d\udead',
	  'non-potable_water':'\ud83d\udeb1',
	  'nose':'\ud83d\udc43',
	  'notebook':'\ud83d\udcd3',
	  'notebook_with_decorative_cover':'\ud83d\udcd4',
	  'notes':'\ud83c\udfb6',
	  'nut_and_bolt':'\ud83d\udd29',
	  'o':'\u2b55\ufe0f',
	  'o2':'\ud83c\udd7e\ufe0f',
	  'ocean':'\ud83c\udf0a',
	  'octopus':'\ud83d\udc19',
	  'oden':'\ud83c\udf62',
	  'office':'\ud83c\udfe2',
	  'oil_drum':'\ud83d\udee2',
	  'ok':'\ud83c\udd97',
	  'ok_hand':'\ud83d\udc4c',
	  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
	  'ok_woman':'\ud83d\ude46',
	  'old_key':'\ud83d\udddd',
	  'older_man':'\ud83d\udc74',
	  'older_woman':'\ud83d\udc75',
	  'om':'\ud83d\udd49',
	  'on':'\ud83d\udd1b',
	  'oncoming_automobile':'\ud83d\ude98',
	  'oncoming_bus':'\ud83d\ude8d',
	  'oncoming_police_car':'\ud83d\ude94',
	  'oncoming_taxi':'\ud83d\ude96',
	  'open_file_folder':'\ud83d\udcc2',
	  'open_hands':'\ud83d\udc50',
	  'open_mouth':'\ud83d\ude2e',
	  'open_umbrella':'\u2602\ufe0f',
	  'ophiuchus':'\u26ce',
	  'orange_book':'\ud83d\udcd9',
	  'orthodox_cross':'\u2626\ufe0f',
	  'outbox_tray':'\ud83d\udce4',
	  'owl':'\ud83e\udd89',
	  'ox':'\ud83d\udc02',
	  'package':'\ud83d\udce6',
	  'page_facing_up':'\ud83d\udcc4',
	  'page_with_curl':'\ud83d\udcc3',
	  'pager':'\ud83d\udcdf',
	  'paintbrush':'\ud83d\udd8c',
	  'palm_tree':'\ud83c\udf34',
	  'pancakes':'\ud83e\udd5e',
	  'panda_face':'\ud83d\udc3c',
	  'paperclip':'\ud83d\udcce',
	  'paperclips':'\ud83d\udd87',
	  'parasol_on_ground':'\u26f1',
	  'parking':'\ud83c\udd7f\ufe0f',
	  'part_alternation_mark':'\u303d\ufe0f',
	  'partly_sunny':'\u26c5\ufe0f',
	  'passenger_ship':'\ud83d\udef3',
	  'passport_control':'\ud83d\udec2',
	  'pause_button':'\u23f8',
	  'peace_symbol':'\u262e\ufe0f',
	  'peach':'\ud83c\udf51',
	  'peanuts':'\ud83e\udd5c',
	  'pear':'\ud83c\udf50',
	  'pen':'\ud83d\udd8a',
	  'pencil2':'\u270f\ufe0f',
	  'penguin':'\ud83d\udc27',
	  'pensive':'\ud83d\ude14',
	  'performing_arts':'\ud83c\udfad',
	  'persevere':'\ud83d\ude23',
	  'person_fencing':'\ud83e\udd3a',
	  'pouting_woman':'\ud83d\ude4e',
	  'phone':'\u260e\ufe0f',
	  'pick':'\u26cf',
	  'pig':'\ud83d\udc37',
	  'pig2':'\ud83d\udc16',
	  'pig_nose':'\ud83d\udc3d',
	  'pill':'\ud83d\udc8a',
	  'pineapple':'\ud83c\udf4d',
	  'ping_pong':'\ud83c\udfd3',
	  'pisces':'\u2653\ufe0f',
	  'pizza':'\ud83c\udf55',
	  'place_of_worship':'\ud83d\uded0',
	  'plate_with_cutlery':'\ud83c\udf7d',
	  'play_or_pause_button':'\u23ef',
	  'point_down':'\ud83d\udc47',
	  'point_left':'\ud83d\udc48',
	  'point_right':'\ud83d\udc49',
	  'point_up':'\u261d\ufe0f',
	  'point_up_2':'\ud83d\udc46',
	  'police_car':'\ud83d\ude93',
	  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
	  'poodle':'\ud83d\udc29',
	  'popcorn':'\ud83c\udf7f',
	  'post_office':'\ud83c\udfe3',
	  'postal_horn':'\ud83d\udcef',
	  'postbox':'\ud83d\udcee',
	  'potable_water':'\ud83d\udeb0',
	  'potato':'\ud83e\udd54',
	  'pouch':'\ud83d\udc5d',
	  'poultry_leg':'\ud83c\udf57',
	  'pound':'\ud83d\udcb7',
	  'rage':'\ud83d\ude21',
	  'pouting_cat':'\ud83d\ude3e',
	  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
	  'pray':'\ud83d\ude4f',
	  'prayer_beads':'\ud83d\udcff',
	  'pregnant_woman':'\ud83e\udd30',
	  'previous_track_button':'\u23ee',
	  'prince':'\ud83e\udd34',
	  'princess':'\ud83d\udc78',
	  'printer':'\ud83d\udda8',
	  'purple_heart':'\ud83d\udc9c',
	  'purse':'\ud83d\udc5b',
	  'pushpin':'\ud83d\udccc',
	  'put_litter_in_its_place':'\ud83d\udeae',
	  'question':'\u2753',
	  'rabbit':'\ud83d\udc30',
	  'rabbit2':'\ud83d\udc07',
	  'racehorse':'\ud83d\udc0e',
	  'racing_car':'\ud83c\udfce',
	  'radio':'\ud83d\udcfb',
	  'radio_button':'\ud83d\udd18',
	  'radioactive':'\u2622\ufe0f',
	  'railway_car':'\ud83d\ude83',
	  'railway_track':'\ud83d\udee4',
	  'rainbow':'\ud83c\udf08',
	  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
	  'raised_back_of_hand':'\ud83e\udd1a',
	  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
	  'raised_hands':'\ud83d\ude4c',
	  'raising_hand_woman':'\ud83d\ude4b',
	  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
	  'ram':'\ud83d\udc0f',
	  'ramen':'\ud83c\udf5c',
	  'rat':'\ud83d\udc00',
	  'record_button':'\u23fa',
	  'recycle':'\u267b\ufe0f',
	  'red_circle':'\ud83d\udd34',
	  'registered':'\u00ae\ufe0f',
	  'relaxed':'\u263a\ufe0f',
	  'relieved':'\ud83d\ude0c',
	  'reminder_ribbon':'\ud83c\udf97',
	  'repeat':'\ud83d\udd01',
	  'repeat_one':'\ud83d\udd02',
	  'rescue_worker_helmet':'\u26d1',
	  'restroom':'\ud83d\udebb',
	  'revolving_hearts':'\ud83d\udc9e',
	  'rewind':'\u23ea',
	  'rhinoceros':'\ud83e\udd8f',
	  'ribbon':'\ud83c\udf80',
	  'rice':'\ud83c\udf5a',
	  'rice_ball':'\ud83c\udf59',
	  'rice_cracker':'\ud83c\udf58',
	  'rice_scene':'\ud83c\udf91',
	  'right_anger_bubble':'\ud83d\uddef',
	  'ring':'\ud83d\udc8d',
	  'robot':'\ud83e\udd16',
	  'rocket':'\ud83d\ude80',
	  'rofl':'\ud83e\udd23',
	  'roll_eyes':'\ud83d\ude44',
	  'roller_coaster':'\ud83c\udfa2',
	  'rooster':'\ud83d\udc13',
	  'rose':'\ud83c\udf39',
	  'rosette':'\ud83c\udff5',
	  'rotating_light':'\ud83d\udea8',
	  'round_pushpin':'\ud83d\udccd',
	  'rowing_man':'\ud83d\udea3',
	  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
	  'rugby_football':'\ud83c\udfc9',
	  'running_man':'\ud83c\udfc3',
	  'running_shirt_with_sash':'\ud83c\udfbd',
	  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
	  'sa':'\ud83c\ude02\ufe0f',
	  'sagittarius':'\u2650\ufe0f',
	  'sake':'\ud83c\udf76',
	  'sandal':'\ud83d\udc61',
	  'santa':'\ud83c\udf85',
	  'satellite':'\ud83d\udce1',
	  'saxophone':'\ud83c\udfb7',
	  'school':'\ud83c\udfeb',
	  'school_satchel':'\ud83c\udf92',
	  'scissors':'\u2702\ufe0f',
	  'scorpion':'\ud83e\udd82',
	  'scorpius':'\u264f\ufe0f',
	  'scream':'\ud83d\ude31',
	  'scream_cat':'\ud83d\ude40',
	  'scroll':'\ud83d\udcdc',
	  'seat':'\ud83d\udcba',
	  'secret':'\u3299\ufe0f',
	  'see_no_evil':'\ud83d\ude48',
	  'seedling':'\ud83c\udf31',
	  'selfie':'\ud83e\udd33',
	  'shallow_pan_of_food':'\ud83e\udd58',
	  'shamrock':'\u2618\ufe0f',
	  'shark':'\ud83e\udd88',
	  'shaved_ice':'\ud83c\udf67',
	  'sheep':'\ud83d\udc11',
	  'shell':'\ud83d\udc1a',
	  'shield':'\ud83d\udee1',
	  'shinto_shrine':'\u26e9',
	  'ship':'\ud83d\udea2',
	  'shirt':'\ud83d\udc55',
	  'shopping':'\ud83d\udecd',
	  'shopping_cart':'\ud83d\uded2',
	  'shower':'\ud83d\udebf',
	  'shrimp':'\ud83e\udd90',
	  'signal_strength':'\ud83d\udcf6',
	  'six_pointed_star':'\ud83d\udd2f',
	  'ski':'\ud83c\udfbf',
	  'skier':'\u26f7',
	  'skull':'\ud83d\udc80',
	  'skull_and_crossbones':'\u2620\ufe0f',
	  'sleeping':'\ud83d\ude34',
	  'sleeping_bed':'\ud83d\udecc',
	  'sleepy':'\ud83d\ude2a',
	  'slightly_frowning_face':'\ud83d\ude41',
	  'slightly_smiling_face':'\ud83d\ude42',
	  'slot_machine':'\ud83c\udfb0',
	  'small_airplane':'\ud83d\udee9',
	  'small_blue_diamond':'\ud83d\udd39',
	  'small_orange_diamond':'\ud83d\udd38',
	  'small_red_triangle':'\ud83d\udd3a',
	  'small_red_triangle_down':'\ud83d\udd3b',
	  'smile':'\ud83d\ude04',
	  'smile_cat':'\ud83d\ude38',
	  'smiley':'\ud83d\ude03',
	  'smiley_cat':'\ud83d\ude3a',
	  'smiling_imp':'\ud83d\ude08',
	  'smirk':'\ud83d\ude0f',
	  'smirk_cat':'\ud83d\ude3c',
	  'smoking':'\ud83d\udeac',
	  'snail':'\ud83d\udc0c',
	  'snake':'\ud83d\udc0d',
	  'sneezing_face':'\ud83e\udd27',
	  'snowboarder':'\ud83c\udfc2',
	  'snowflake':'\u2744\ufe0f',
	  'snowman':'\u26c4\ufe0f',
	  'snowman_with_snow':'\u2603\ufe0f',
	  'sob':'\ud83d\ude2d',
	  'soccer':'\u26bd\ufe0f',
	  'soon':'\ud83d\udd1c',
	  'sos':'\ud83c\udd98',
	  'sound':'\ud83d\udd09',
	  'space_invader':'\ud83d\udc7e',
	  'spades':'\u2660\ufe0f',
	  'spaghetti':'\ud83c\udf5d',
	  'sparkle':'\u2747\ufe0f',
	  'sparkler':'\ud83c\udf87',
	  'sparkles':'\u2728',
	  'sparkling_heart':'\ud83d\udc96',
	  'speak_no_evil':'\ud83d\ude4a',
	  'speaker':'\ud83d\udd08',
	  'speaking_head':'\ud83d\udde3',
	  'speech_balloon':'\ud83d\udcac',
	  'speedboat':'\ud83d\udea4',
	  'spider':'\ud83d\udd77',
	  'spider_web':'\ud83d\udd78',
	  'spiral_calendar':'\ud83d\uddd3',
	  'spiral_notepad':'\ud83d\uddd2',
	  'spoon':'\ud83e\udd44',
	  'squid':'\ud83e\udd91',
	  'stadium':'\ud83c\udfdf',
	  'star':'\u2b50\ufe0f',
	  'star2':'\ud83c\udf1f',
	  'star_and_crescent':'\u262a\ufe0f',
	  'star_of_david':'\u2721\ufe0f',
	  'stars':'\ud83c\udf20',
	  'station':'\ud83d\ude89',
	  'statue_of_liberty':'\ud83d\uddfd',
	  'steam_locomotive':'\ud83d\ude82',
	  'stew':'\ud83c\udf72',
	  'stop_button':'\u23f9',
	  'stop_sign':'\ud83d\uded1',
	  'stopwatch':'\u23f1',
	  'straight_ruler':'\ud83d\udccf',
	  'strawberry':'\ud83c\udf53',
	  'stuck_out_tongue':'\ud83d\ude1b',
	  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
	  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
	  'studio_microphone':'\ud83c\udf99',
	  'stuffed_flatbread':'\ud83e\udd59',
	  'sun_behind_large_cloud':'\ud83c\udf25',
	  'sun_behind_rain_cloud':'\ud83c\udf26',
	  'sun_behind_small_cloud':'\ud83c\udf24',
	  'sun_with_face':'\ud83c\udf1e',
	  'sunflower':'\ud83c\udf3b',
	  'sunglasses':'\ud83d\ude0e',
	  'sunny':'\u2600\ufe0f',
	  'sunrise':'\ud83c\udf05',
	  'sunrise_over_mountains':'\ud83c\udf04',
	  'surfing_man':'\ud83c\udfc4',
	  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
	  'sushi':'\ud83c\udf63',
	  'suspension_railway':'\ud83d\ude9f',
	  'sweat':'\ud83d\ude13',
	  'sweat_drops':'\ud83d\udca6',
	  'sweat_smile':'\ud83d\ude05',
	  'sweet_potato':'\ud83c\udf60',
	  'swimming_man':'\ud83c\udfca',
	  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
	  'symbols':'\ud83d\udd23',
	  'synagogue':'\ud83d\udd4d',
	  'syringe':'\ud83d\udc89',
	  'taco':'\ud83c\udf2e',
	  'tada':'\ud83c\udf89',
	  'tanabata_tree':'\ud83c\udf8b',
	  'taurus':'\u2649\ufe0f',
	  'taxi':'\ud83d\ude95',
	  'tea':'\ud83c\udf75',
	  'telephone_receiver':'\ud83d\udcde',
	  'telescope':'\ud83d\udd2d',
	  'tennis':'\ud83c\udfbe',
	  'tent':'\u26fa\ufe0f',
	  'thermometer':'\ud83c\udf21',
	  'thinking':'\ud83e\udd14',
	  'thought_balloon':'\ud83d\udcad',
	  'ticket':'\ud83c\udfab',
	  'tickets':'\ud83c\udf9f',
	  'tiger':'\ud83d\udc2f',
	  'tiger2':'\ud83d\udc05',
	  'timer_clock':'\u23f2',
	  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
	  'tired_face':'\ud83d\ude2b',
	  'tm':'\u2122\ufe0f',
	  'toilet':'\ud83d\udebd',
	  'tokyo_tower':'\ud83d\uddfc',
	  'tomato':'\ud83c\udf45',
	  'tongue':'\ud83d\udc45',
	  'top':'\ud83d\udd1d',
	  'tophat':'\ud83c\udfa9',
	  'tornado':'\ud83c\udf2a',
	  'trackball':'\ud83d\uddb2',
	  'tractor':'\ud83d\ude9c',
	  'traffic_light':'\ud83d\udea5',
	  'train':'\ud83d\ude8b',
	  'train2':'\ud83d\ude86',
	  'tram':'\ud83d\ude8a',
	  'triangular_flag_on_post':'\ud83d\udea9',
	  'triangular_ruler':'\ud83d\udcd0',
	  'trident':'\ud83d\udd31',
	  'triumph':'\ud83d\ude24',
	  'trolleybus':'\ud83d\ude8e',
	  'trophy':'\ud83c\udfc6',
	  'tropical_drink':'\ud83c\udf79',
	  'tropical_fish':'\ud83d\udc20',
	  'truck':'\ud83d\ude9a',
	  'trumpet':'\ud83c\udfba',
	  'tulip':'\ud83c\udf37',
	  'tumbler_glass':'\ud83e\udd43',
	  'turkey':'\ud83e\udd83',
	  'turtle':'\ud83d\udc22',
	  'tv':'\ud83d\udcfa',
	  'twisted_rightwards_arrows':'\ud83d\udd00',
	  'two_hearts':'\ud83d\udc95',
	  'two_men_holding_hands':'\ud83d\udc6c',
	  'two_women_holding_hands':'\ud83d\udc6d',
	  'u5272':'\ud83c\ude39',
	  'u5408':'\ud83c\ude34',
	  'u55b6':'\ud83c\ude3a',
	  'u6307':'\ud83c\ude2f\ufe0f',
	  'u6708':'\ud83c\ude37\ufe0f',
	  'u6709':'\ud83c\ude36',
	  'u6e80':'\ud83c\ude35',
	  'u7121':'\ud83c\ude1a\ufe0f',
	  'u7533':'\ud83c\ude38',
	  'u7981':'\ud83c\ude32',
	  'u7a7a':'\ud83c\ude33',
	  'umbrella':'\u2614\ufe0f',
	  'unamused':'\ud83d\ude12',
	  'underage':'\ud83d\udd1e',
	  'unicorn':'\ud83e\udd84',
	  'unlock':'\ud83d\udd13',
	  'up':'\ud83c\udd99',
	  'upside_down_face':'\ud83d\ude43',
	  'v':'\u270c\ufe0f',
	  'vertical_traffic_light':'\ud83d\udea6',
	  'vhs':'\ud83d\udcfc',
	  'vibration_mode':'\ud83d\udcf3',
	  'video_camera':'\ud83d\udcf9',
	  'video_game':'\ud83c\udfae',
	  'violin':'\ud83c\udfbb',
	  'virgo':'\u264d\ufe0f',
	  'volcano':'\ud83c\udf0b',
	  'volleyball':'\ud83c\udfd0',
	  'vs':'\ud83c\udd9a',
	  'vulcan_salute':'\ud83d\udd96',
	  'walking_man':'\ud83d\udeb6',
	  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
	  'waning_crescent_moon':'\ud83c\udf18',
	  'waning_gibbous_moon':'\ud83c\udf16',
	  'warning':'\u26a0\ufe0f',
	  'wastebasket':'\ud83d\uddd1',
	  'watch':'\u231a\ufe0f',
	  'water_buffalo':'\ud83d\udc03',
	  'watermelon':'\ud83c\udf49',
	  'wave':'\ud83d\udc4b',
	  'wavy_dash':'\u3030\ufe0f',
	  'waxing_crescent_moon':'\ud83c\udf12',
	  'wc':'\ud83d\udebe',
	  'weary':'\ud83d\ude29',
	  'wedding':'\ud83d\udc92',
	  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
	  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
	  'whale':'\ud83d\udc33',
	  'whale2':'\ud83d\udc0b',
	  'wheel_of_dharma':'\u2638\ufe0f',
	  'wheelchair':'\u267f\ufe0f',
	  'white_check_mark':'\u2705',
	  'white_circle':'\u26aa\ufe0f',
	  'white_flag':'\ud83c\udff3\ufe0f',
	  'white_flower':'\ud83d\udcae',
	  'white_large_square':'\u2b1c\ufe0f',
	  'white_medium_small_square':'\u25fd\ufe0f',
	  'white_medium_square':'\u25fb\ufe0f',
	  'white_small_square':'\u25ab\ufe0f',
	  'white_square_button':'\ud83d\udd33',
	  'wilted_flower':'\ud83e\udd40',
	  'wind_chime':'\ud83c\udf90',
	  'wind_face':'\ud83c\udf2c',
	  'wine_glass':'\ud83c\udf77',
	  'wink':'\ud83d\ude09',
	  'wolf':'\ud83d\udc3a',
	  'woman':'\ud83d\udc69',
	  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
	  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
	  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
	  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
	  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
	  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
	  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
	  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
	  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
	  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
	  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
	  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
	  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
	  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
	  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
	  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
	  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
	  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
	  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
	  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
	  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
	  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
	  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
	  'womans_clothes':'\ud83d\udc5a',
	  'womans_hat':'\ud83d\udc52',
	  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
	  'womens':'\ud83d\udeba',
	  'world_map':'\ud83d\uddfa',
	  'worried':'\ud83d\ude1f',
	  'wrench':'\ud83d\udd27',
	  'writing_hand':'\u270d\ufe0f',
	  'x':'\u274c',
	  'yellow_heart':'\ud83d\udc9b',
	  'yen':'\ud83d\udcb4',
	  'yin_yang':'\u262f\ufe0f',
	  'yum':'\ud83d\ude0b',
	  'zap':'\u26a1\ufe0f',
	  'zipper_mouth_face':'\ud83e\udd10',
	  'zzz':'\ud83d\udca4',

	  /* special emojis :P */
	  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
	  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
	};

	/**
	 * Created by Estevao on 31-05-2015.
	 */

	/**
	 * Showdown Converter class
	 * @class
	 * @param {object} [converterOptions]
	 * @returns {Converter}
	 */
	showdown.Converter = function (converterOptions) {

	  var
	      /**
	       * Options used by this converter
	       * @private
	       * @type {{}}
	       */
	      options = {},

	      /**
	       * Language extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      langExtensions = [],

	      /**
	       * Output modifiers extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      outputModifiers = [],

	      /**
	       * Event listeners
	       * @private
	       * @type {{}}
	       */
	      listeners = {},

	      /**
	       * The flavor set in this converter
	       */
	      setConvFlavor = setFlavor,

	      /**
	       * Metadata of the document
	       * @type {{parsed: {}, raw: string, format: string}}
	       */
	      metadata = {
	        parsed: {},
	        raw: '',
	        format: ''
	      };

	  _constructor();

	  /**
	   * Converter constructor
	   * @private
	   */
	  function _constructor () {
	    converterOptions = converterOptions || {};

	    for (var gOpt in globalOptions) {
	      if (globalOptions.hasOwnProperty(gOpt)) {
	        options[gOpt] = globalOptions[gOpt];
	      }
	    }

	    // Merge options
	    if (typeof converterOptions === 'object') {
	      for (var opt in converterOptions) {
	        if (converterOptions.hasOwnProperty(opt)) {
	          options[opt] = converterOptions[opt];
	        }
	      }
	    } else {
	      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
	      ' was passed instead.');
	    }

	    if (options.extensions) {
	      showdown.helper.forEach(options.extensions, _parseExtension);
	    }
	  }

	  /**
	   * Parse extension
	   * @param {*} ext
	   * @param {string} [name='']
	   * @private
	   */
	  function _parseExtension (ext, name) {

	    name = name || null;
	    // If it's a string, the extension was previously loaded
	    if (showdown.helper.isString(ext)) {
	      ext = showdown.helper.stdExtName(ext);
	      name = ext;

	      // LEGACY_SUPPORT CODE
	      if (showdown.extensions[ext]) {
	        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
	          'Please inform the developer that the extension should be updated!');
	        legacyExtensionLoading(showdown.extensions[ext], ext);
	        return;
	        // END LEGACY SUPPORT CODE

	      } else if (!showdown.helper.isUndefined(extensions[ext])) {
	        ext = extensions[ext];

	      } else {
	        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
	      }
	    }

	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExt = validate(ext, name);
	    if (!validExt.valid) {
	      throw Error(validExt.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {

	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;

	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	      }
	      if (ext[i].hasOwnProperty('listeners')) {
	        for (var ln in ext[i].listeners) {
	          if (ext[i].listeners.hasOwnProperty(ln)) {
	            listen(ln, ext[i].listeners[ln]);
	          }
	        }
	      }
	    }

	  }

	  /**
	   * LEGACY_SUPPORT
	   * @param {*} ext
	   * @param {string} name
	   */
	  function legacyExtensionLoading (ext, name) {
	    if (typeof ext === 'function') {
	      ext = ext(new showdown.Converter());
	    }
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }
	    var valid = validate(ext, name);

	    if (!valid.valid) {
	      throw Error(valid.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {
	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;
	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	        default:// should never reach here
	          throw Error('Extension loader error: Type unrecognized!!!');
	      }
	    }
	  }

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   */
	  function listen (name, callback) {
	    if (!showdown.helper.isString(name)) {
	      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
	    }

	    if (typeof callback !== 'function') {
	      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
	    }

	    if (!listeners.hasOwnProperty(name)) {
	      listeners[name] = [];
	    }
	    listeners[name].push(callback);
	  }

	  function rTrimInputText (text) {
	    var rsp = text.match(/^\s*/)[0].length,
	        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
	    return text.replace(rgx, '');
	  }

	  /**
	   * Dispatch an event
	   * @private
	   * @param {string} evtName Event name
	   * @param {string} text Text
	   * @param {{}} options Converter Options
	   * @param {{}} globals
	   * @returns {string}
	   */
	  this._dispatch = function dispatch (evtName, text, options, globals) {
	    if (listeners.hasOwnProperty(evtName)) {
	      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
	        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
	        if (nText && typeof nText !== 'undefined') {
	          text = nText;
	        }
	      }
	    }
	    return text;
	  };

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   * @returns {showdown.Converter}
	   */
	  this.listen = function (name, callback) {
	    listen(name, callback);
	    return this;
	  };

	  /**
	   * Converts a markdown string into HTML
	   * @param {string} text
	   * @returns {*}
	   */
	  this.makeHtml = function (text) {
	    //check if text is not falsy
	    if (!text) {
	      return text;
	    }

	    var globals = {
	      gHtmlBlocks:     [],
	      gHtmlMdBlocks:   [],
	      gHtmlSpans:      [],
	      gUrls:           {},
	      gTitles:         {},
	      gDimensions:     {},
	      gListLevel:      0,
	      hashLinkCounts:  {},
	      langExtensions:  langExtensions,
	      outputModifiers: outputModifiers,
	      converter:       this,
	      ghCodeBlocks:    [],
	      metadata: {
	        parsed: {},
	        raw: '',
	        format: ''
	      }
	    };

	    // This lets us use ¨ trema as an escape char to avoid md5 hashes
	    // The choice of character is arbitrary; anything that isn't
	    // magic in Markdown will work.
	    text = text.replace(/¨/g, '¨T');

	    // Replace $ with ¨D
	    // RegExp interprets $ as a special character
	    // when it's in a replacement string
	    text = text.replace(/\$/g, '¨D');

	    // Standardize line endings
	    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
	    text = text.replace(/\r/g, '\n'); // Mac to Unix

	    // Stardardize line spaces
	    text = text.replace(/\u00A0/g, '&nbsp;');

	    if (options.smartIndentationFix) {
	      text = rTrimInputText(text);
	    }

	    // Make sure text begins and ends with a couple of newlines:
	    text = '\n\n' + text + '\n\n';

	    // detab
	    text = showdown.subParser('detab')(text, options, globals);

	    /**
	     * Strip any lines consisting only of spaces and tabs.
	     * This makes subsequent regexs easier to write, because we can
	     * match consecutive blank lines with /\n+/ instead of something
	     * contorted like /[ \t]*\n+/
	     */
	    text = text.replace(/^[ \t]+$/mg, '');

	    //run languageExtensions
	    showdown.helper.forEach(langExtensions, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // run the sub parsers
	    text = showdown.subParser('metadata')(text, options, globals);
	    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
	    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
	    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	    text = showdown.subParser('hashCodeTags')(text, options, globals);
	    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
	    text = showdown.subParser('blockGamut')(text, options, globals);
	    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
	    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

	    // attacklab: Restore dollar signs
	    text = text.replace(/¨D/g, '$$');

	    // attacklab: Restore tremas
	    text = text.replace(/¨T/g, '¨');

	    // render a complete html document instead of a partial if the option is enabled
	    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

	    // Run output modifiers
	    showdown.helper.forEach(outputModifiers, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // update metadata
	    metadata = globals.metadata;
	    return text;
	  };

	  /**
	   * Converts an HTML string into a markdown string
	   * @param src
	   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
	   * @returns {string}
	   */
	  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

	    // replace \r\n with \n
	    src = src.replace(/\r\n/g, '\n');
	    src = src.replace(/\r/g, '\n'); // old macs

	    // due to an edge case, we need to find this: > <
	    // to prevent removing of non silent white spaces
	    // ex: <em>this is</em> <strong>sparta</strong>
	    src = src.replace(/>[ \t]+</, '>¨NBSP;<');

	    if (!HTMLParser) {
	      if (window && window.document) {
	        HTMLParser = window.document;
	      } else {
	        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
	      }
	    }

	    var doc = HTMLParser.createElement('div');
	    doc.innerHTML = src;

	    var globals = {
	      preList: substitutePreCodeTags(doc)
	    };

	    // remove all newlines and collapse spaces
	    clean(doc);

	    // some stuff, like accidental reference links must now be escaped
	    // TODO
	    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

	    var nodes = doc.childNodes,
	        mdDoc = '';

	    for (var i = 0; i < nodes.length; i++) {
	      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
	    }

	    function clean (node) {
	      for (var n = 0; n < node.childNodes.length; ++n) {
	        var child = node.childNodes[n];
	        if (child.nodeType === 3) {
	          if (!/\S/.test(child.nodeValue)) {
	            node.removeChild(child);
	            --n;
	          } else {
	            child.nodeValue = child.nodeValue.split('\n').join(' ');
	            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
	          }
	        } else if (child.nodeType === 1) {
	          clean(child);
	        }
	      }
	    }

	    // find all pre tags and replace contents with placeholder
	    // we need this so that we can remove all indentation from html
	    // to ease up parsing
	    function substitutePreCodeTags (doc) {

	      var pres = doc.querySelectorAll('pre'),
	          presPH = [];

	      for (var i = 0; i < pres.length; ++i) {

	        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
	          var content = pres[i].firstChild.innerHTML.trim(),
	              language = pres[i].firstChild.getAttribute('data-language') || '';

	          // if data-language attribute is not defined, then we look for class language-*
	          if (language === '') {
	            var classes = pres[i].firstChild.className.split(' ');
	            for (var c = 0; c < classes.length; ++c) {
	              var matches = classes[c].match(/^language-(.+)$/);
	              if (matches !== null) {
	                language = matches[1];
	                break;
	              }
	            }
	          }

	          // unescape html entities in content
	          content = showdown.helper.unescapeHTMLEntities(content);

	          presPH.push(content);
	          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
	        } else {
	          presPH.push(pres[i].innerHTML);
	          pres[i].innerHTML = '';
	          pres[i].setAttribute('prenum', i.toString());
	        }
	      }
	      return presPH;
	    }

	    return mdDoc;
	  };

	  /**
	   * Set an option of this Converter instance
	   * @param {string} key
	   * @param {*} value
	   */
	  this.setOption = function (key, value) {
	    options[key] = value;
	  };

	  /**
	   * Get the option of this Converter instance
	   * @param {string} key
	   * @returns {*}
	   */
	  this.getOption = function (key) {
	    return options[key];
	  };

	  /**
	   * Get the options of this Converter instance
	   * @returns {{}}
	   */
	  this.getOptions = function () {
	    return options;
	  };

	  /**
	   * Add extension to THIS converter
	   * @param {{}} extension
	   * @param {string} [name=null]
	   */
	  this.addExtension = function (extension, name) {
	    name = name || null;
	    _parseExtension(extension, name);
	  };

	  /**
	   * Use a global registered extension with THIS converter
	   * @param {string} extensionName Name of the previously registered extension
	   */
	  this.useExtension = function (extensionName) {
	    _parseExtension(extensionName);
	  };

	  /**
	   * Set the flavor THIS converter should use
	   * @param {string} name
	   */
	  this.setFlavor = function (name) {
	    if (!flavor.hasOwnProperty(name)) {
	      throw Error(name + ' flavor was not found');
	    }
	    var preset = flavor[name];
	    setConvFlavor = name;
	    for (var option in preset) {
	      if (preset.hasOwnProperty(option)) {
	        options[option] = preset[option];
	      }
	    }
	  };

	  /**
	   * Get the currently set flavor of this converter
	   * @returns {string}
	   */
	  this.getFlavor = function () {
	    return setConvFlavor;
	  };

	  /**
	   * Remove an extension from THIS converter.
	   * Note: This is a costly operation. It's better to initialize a new converter
	   * and specify the extensions you wish to use
	   * @param {Array} extension
	   */
	  this.removeExtension = function (extension) {
	    if (!showdown.helper.isArray(extension)) {
	      extension = [extension];
	    }
	    for (var a = 0; a < extension.length; ++a) {
	      var ext = extension[a];
	      for (var i = 0; i < langExtensions.length; ++i) {
	        if (langExtensions[i] === ext) {
	          langExtensions[i].splice(i, 1);
	        }
	      }
	      for (var ii = 0; ii < outputModifiers.length; ++i) {
	        if (outputModifiers[ii] === ext) {
	          outputModifiers[ii].splice(i, 1);
	        }
	      }
	    }
	  };

	  /**
	   * Get all extension of THIS converter
	   * @returns {{language: Array, output: Array}}
	   */
	  this.getAllExtensions = function () {
	    return {
	      language: langExtensions,
	      output: outputModifiers
	    };
	  };

	  /**
	   * Get the metadata of the previously parsed document
	   * @param raw
	   * @returns {string|{}}
	   */
	  this.getMetadata = function (raw) {
	    if (raw) {
	      return metadata.raw;
	    } else {
	      return metadata.parsed;
	    }
	  };

	  /**
	   * Get the metadata format of the previously parsed document
	   * @returns {string}
	   */
	  this.getMetadataFormat = function () {
	    return metadata.format;
	  };

	  /**
	   * Private: set a single key, value metadata pair
	   * @param {string} key
	   * @param {string} value
	   */
	  this._setMetadataPair = function (key, value) {
	    metadata.parsed[key] = value;
	  };

	  /**
	   * Private: set metadata format
	   * @param {string} format
	   */
	  this._setMetadataFormat = function (format) {
	    metadata.format = format;
	  };

	  /**
	   * Private: set metadata raw text
	   * @param {string} raw
	   */
	  this._setMetadataRaw = function (raw) {
	    metadata.raw = raw;
	  };
	};

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('anchors', function (text, options, globals) {

	  text = globals.converter._dispatch('anchors.before', text, options, globals);

	  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
	    if (showdown.helper.isUndefined(title)) {
	      title = '';
	    }
	    linkId = linkId.toLowerCase();

	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';
	    } else if (!url) {
	      if (!linkId) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
	        url = globals.gUrls[linkId];
	        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
	          title = globals.gTitles[linkId];
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

	    var result = '<a href="' + url + '"';

	    if (title !== '' && title !== null) {
	      title = title.replace(/"/g, '&quot;');
	      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
	      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    // optionLinksInNewWindow only applies
	    // to external links. Hash links (#) open in same page
	    if (options.openLinksInNewWindow && !/^#/.test(url)) {
	      // escaped _
	      result += ' rel="noopener noreferrer" target="¨E95Eblank"';
	    }

	    result += '>' + linkText + '</a>';

	    return result;
	  };

	  // First, handle reference-style links: [link text] [id]
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

	  // Next, inline-style links: [link text](url "optional title")
	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // normal cases
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // handle reference-style shortcuts: [link text]
	  // These must come last in case you've also got [link test][1]
	  // or [link test](/foo)
	  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

	  // Lastly handle GithubMentions if option is enabled
	  if (options.ghMentions) {
	    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
	      if (escape === '\\') {
	        return st + mentions;
	      }

	      //check if options.ghMentionsLink is a string
	      if (!showdown.helper.isString(options.ghMentionsLink)) {
	        throw new Error('ghMentionsLink option must be a string');
	      }
	      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
	          target = '';
	      if (options.openLinksInNewWindow) {
	        target = ' rel="noopener noreferrer" target="¨E95Eblank"';
	      }
	      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
	    });
	  }

	  text = globals.converter._dispatch('anchors.after', text, options, globals);
	  return text;
	});

	// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

	var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
	    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
	    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
	    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
	    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

	    replaceLink = function (options) {
	      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
	        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	        var lnkTxt = link,
	            append = '',
	            target = '',
	            lmc    = leadingMagicChars || '',
	            tmc    = trailingMagicChars || '';
	        if (/^www\./i.test(link)) {
	          link = link.replace(/^www\./i, 'http://www.');
	        }
	        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
	          append = trailingPunctuation;
	        }
	        if (options.openLinksInNewWindow) {
	          target = ' rel="noopener noreferrer" target="¨E95Eblank"';
	        }
	        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
	      };
	    },

	    replaceMail = function (options, globals) {
	      return function (wholeMatch, b, mail) {
	        var href = 'mailto:';
	        b = b || '';
	        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
	        if (options.encodeEmails) {
	          href = showdown.helper.encodeEmailAddress(href + mail);
	          mail = showdown.helper.encodeEmailAddress(mail);
	        } else {
	          href = href + mail;
	        }
	        return b + '<a href="' + href + '">' + mail + '</a>';
	      };
	    };

	showdown.subParser('autoLinks', function (text, options, globals) {

	  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

	  text = text.replace(delimUrlRegex, replaceLink(options));
	  text = text.replace(delimMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

	  return text;
	});

	showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {

	  if (!options.simplifiedAutoLink) {
	    return text;
	  }

	  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

	  if (options.excludeTrailingPunctuationFromURLs) {
	    text = text.replace(simpleURLRegex2, replaceLink(options));
	  } else {
	    text = text.replace(simpleURLRegex, replaceLink(options));
	  }
	  text = text.replace(simpleMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

	  return text;
	});

	/**
	 * These are all the transformations that form block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('blockGamut', function (text, options, globals) {

	  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

	  // we parse blockquotes first so that we can have headings and hrs
	  // inside blockquotes
	  text = showdown.subParser('blockQuotes')(text, options, globals);
	  text = showdown.subParser('headers')(text, options, globals);

	  // Do Horizontal Rules:
	  text = showdown.subParser('horizontalRule')(text, options, globals);

	  text = showdown.subParser('lists')(text, options, globals);
	  text = showdown.subParser('codeBlocks')(text, options, globals);
	  text = showdown.subParser('tables')(text, options, globals);

	  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
	  // was to escape raw HTML in the original Markdown source. This time,
	  // we're escaping the markup we've just created, so that we don't wrap
	  // <p> tags around block-level tags.
	  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	  text = showdown.subParser('paragraphs')(text, options, globals);

	  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

	  return text;
	});

	showdown.subParser('blockQuotes', function (text, options, globals) {

	  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

	  // add a couple extra lines after the text and endtext mark
	  text = text + '\n\n';

	  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

	  if (options.splitAdjacentBlockquotes) {
	    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
	  }

	  text = text.replace(rgx, function (bq) {
	    // attacklab: hack around Konqueror 3.5.4 bug:
	    // "----------bug".replace(/^-/g,"") == "bug"
	    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

	    // attacklab: clean up hack
	    bq = bq.replace(/¨0/g, '');

	    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
	    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
	    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

	    bq = bq.replace(/(^|\n)/g, '$1  ');
	    // These leading spaces screw with <pre> content, so we need to fix that:
	    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
	      var pre = m1;
	      // attacklab: hack around Konqueror 3.5.4 bug:
	      pre = pre.replace(/^  /mg, '¨0');
	      pre = pre.replace(/¨0/g, '');
	      return pre;
	    });

	    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
	  });

	  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
	  return text;
	});

	/**
	 * Process Markdown `<pre><code>` blocks.
	 */
	showdown.subParser('codeBlocks', function (text, options, globals) {

	  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

	  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '¨0';

	  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
	  text = text.replace(pattern, function (wholeMatch, m1, m2) {
	    var codeblock = m1,
	        nextChar = m2,
	        end = '\n';

	    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

	    if (options.omitExtraWLInCodeBlocks) {
	      end = '';
	    }

	    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

	    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
	  });

	  // strip sentinel
	  text = text.replace(/¨0/, '');

	  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 *   *  Backtick quotes are used for <code></code> spans.
	 *
	 *   *  You can use multiple backticks as the delimiters if you want to
	 *     include literal backticks in the code span. So, this input:
	 *
	 *         Just type ``foo `bar` baz`` at the prompt.
	 *
	 *       Will translate to:
	 *
	 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
	 *
	 *    There's no arbitrary limit to the number of backticks you
	 *    can use as delimters. If you need three consecutive backticks
	 *    in your code, use four for delimiters, etc.
	 *
	 *  *  You can use spaces to get literal backticks at the edges:
	 *
	 *         ... type `` `bar` `` ...
	 *
	 *       Turns to:
	 *
	 *         ... type <code>`bar`</code> ...
	 */
	showdown.subParser('codeSpans', function (text, options, globals) {

	  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

	  if (typeof text === 'undefined') {
	    text = '';
	  }
	  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
	    function (wholeMatch, m1, m2, m3) {
	      var c = m3;
	      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
	      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
	      c = showdown.subParser('encodeCode')(c, options, globals);
	      c = m1 + '<code>' + c + '</code>';
	      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
	      return c;
	    }
	  );

	  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Create a full HTML document from the processed markdown
	 */
	showdown.subParser('completeHTMLDocument', function (text, options, globals) {

	  if (!options.completeHTMLDocument) {
	    return text;
	  }

	  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

	  var doctype = 'html',
	      doctypeParsed = '<!DOCTYPE HTML>\n',
	      title = '',
	      charset = '<meta charset="utf-8">\n',
	      lang = '',
	      metadata = '';

	  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
	    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
	    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
	    if (doctype === 'html' || doctype === 'html5') {
	      charset = '<meta charset="utf-8">';
	    }
	  }

	  for (var meta in globals.metadata.parsed) {
	    if (globals.metadata.parsed.hasOwnProperty(meta)) {
	      switch (meta.toLowerCase()) {
	        case 'doctype':
	          break;

	        case 'title':
	          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
	          break;

	        case 'charset':
	          if (doctype === 'html' || doctype === 'html5') {
	            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
	          } else {
	            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
	          }
	          break;

	        case 'language':
	        case 'lang':
	          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	          break;

	        default:
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	      }
	    }
	  }

	  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

	  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
	  return text;
	});

	/**
	 * Convert all tabs to spaces
	 */
	showdown.subParser('detab', function (text, options, globals) {
	  text = globals.converter._dispatch('detab.before', text, options, globals);

	  // expand first n-1 tabs
	  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

	  // replace the nth with two sentinels
	  text = text.replace(/\t/g, '¨A¨B');

	  // use the sentinel to anchor our regex so it doesn't explode
	  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
	    var leadingText = m1,
	        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

	    // there *must* be a better way to do this:
	    for (var i = 0; i < numSpaces; i++) {
	      leadingText += ' ';
	    }

	    return leadingText;
	  });

	  // clean up sentinels
	  text = text.replace(/¨A/g, '    ');  // g_tab_width
	  text = text.replace(/¨B/g, '');

	  text = globals.converter._dispatch('detab.after', text, options, globals);
	  return text;
	});

	showdown.subParser('ellipsis', function (text, options, globals) {

	  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

	  text = text.replace(/\.\.\./g, '…');

	  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

	  return text;
	});

	/**
	 * Turn emoji codes into emojis
	 *
	 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
	 */
	showdown.subParser('emoji', function (text, options, globals) {

	  if (!options.emoji) {
	    return text;
	  }

	  text = globals.converter._dispatch('emoji.before', text, options, globals);

	  var emojiRgx = /:([\S]+?):/g;

	  text = text.replace(emojiRgx, function (wm, emojiCode) {
	    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
	      return showdown.helper.emojis[emojiCode];
	    }
	    return wm;
	  });

	  text = globals.converter._dispatch('emoji.after', text, options, globals);

	  return text;
	});

	/**
	 * Smart processing for ampersands and angle brackets that need to be encoded.
	 */
	showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
	  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

	  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
	  // http://bumppo.net/projects/amputator/
	  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

	  // Encode naked <'s
	  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

	  // Encode <
	  text = text.replace(/</g, '&lt;');

	  // Encode >
	  text = text.replace(/>/g, '&gt;');

	  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
	  return text;
	});

	/**
	 * Returns the string, with after processing the following backslash escape sequences.
	 *
	 * attacklab: The polite way to do this is with the new escapeCharacters() function:
	 *
	 *    text = escapeCharacters(text,"\\",true);
	 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
	 *
	 * ...but we're sidestepping its use of the (slow) RegExp constructor
	 * as an optimization for Firefox.  This function gets called a LOT.
	 */
	showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
	  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

	  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
	  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
	  return text;
	});

	/**
	 * Encode/escape certain characters inside Markdown code runs.
	 * The point is that in code, these characters are literals,
	 * and lose their special Markdown meanings.
	 */
	showdown.subParser('encodeCode', function (text, options, globals) {

	  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

	  // Encode all ampersands; HTML entities are not
	  // entities within a Markdown code span.
	  text = text
	    .replace(/&/g, '&amp;')
	  // Do the angle bracket song and dance:
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	  // Now, escape characters that are magic in Markdown:
	    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
	  return text;
	});

	/**
	 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
	 * don't conflict with their use in Markdown for code, italics and strong.
	 */
	showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

	  // Build a regex to find HTML tags.
	  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
	      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

	  text = text.replace(tags, function (wholeMatch) {
	    return wholeMatch
	      .replace(/(.)<\/?code>(?=.)/g, '$1`')
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = text.replace(comments, function (wholeMatch) {
	    return wholeMatch
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
	  return text;
	});

	/**
	 * Handle github codeblocks prior to running HashHTML so that
	 * HTML contained within the codeblock gets escaped properly
	 * Example:
	 * ```ruby
	 *     def hello_world(x)
	 *       puts "Hello, #{x}"
	 *     end
	 * ```
	 */
	showdown.subParser('githubCodeBlocks', function (text, options, globals) {

	  // early exit if option is not enabled
	  if (!options.ghCodeBlocks) {
	    return text;
	  }

	  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

	  text += '¨0';

	  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
	    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

	    // First parse the github code block
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

	    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

	    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

	    // Since GHCodeblocks can be false positives, we need to
	    // store the primitive text and the parsed text in a global var,
	    // and then return a token
	    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  });

	  // attacklab: strip sentinel
	  text = text.replace(/¨0/, '');

	  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
	});

	showdown.subParser('hashBlock', function (text, options, globals) {
	  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
	  text = text.replace(/(^\n+|\n+$)/g, '');
	  text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
	  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashCodeTags', function (text, options, globals) {
	  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
	  };

	  // Hash naked <code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

	  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('hashElement', function (text, options, globals) {

	  return function (wholeMatch, m1) {
	    var blockText = m1;

	    // Undo double lines
	    blockText = blockText.replace(/\n\n/g, '\n');
	    blockText = blockText.replace(/^\n/, '');

	    // strip trailing blank lines
	    blockText = blockText.replace(/\n+$/g, '');

	    // Replace the element text with a marker ("¨KxK" where x is its key)
	    blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

	    return blockText;
	  };
	});

	showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
	  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

	  var blockTags = [
	        'pre',
	        'div',
	        'h1',
	        'h2',
	        'h3',
	        'h4',
	        'h5',
	        'h6',
	        'blockquote',
	        'table',
	        'dl',
	        'ol',
	        'ul',
	        'script',
	        'noscript',
	        'form',
	        'fieldset',
	        'iframe',
	        'math',
	        'style',
	        'section',
	        'header',
	        'footer',
	        'nav',
	        'article',
	        'aside',
	        'address',
	        'audio',
	        'canvas',
	        'figure',
	        'hgroup',
	        'output',
	        'video',
	        'p'
	      ],
	      repFunc = function (wholeMatch, match, left, right) {
	        var txt = wholeMatch;
	        // check if this html element is marked as markdown
	        // if so, it's contents should be parsed as markdown
	        if (left.search(/\bmarkdown\b/) !== -1) {
	          txt = left + globals.converter.makeHtml(match) + right;
	        }
	        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	      };

	  if (options.backslashEscapesHTMLTags) {
	    // encode backslash escaped HTML tags
	    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
	      return '&lt;' + inside + '&gt;';
	    });
	  }

	  // hash HTML Blocks
	  for (var i = 0; i < blockTags.length; ++i) {

	    var opTagPos,
	        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
	        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
	        patRight = '</' + blockTags[i] + '>';
	    // 1. Look for the first position of the first opening HTML tag in the text
	    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

	      // if the HTML tag is \ escaped, we need to escape it and break


	      //2. Split the text in that position
	      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
	          //3. Match recursively
	          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

	      // prevent an infinite loop
	      if (newSubText1 === subTexts[1]) {
	        break;
	      }
	      text = subTexts[0].concat(newSubText1);
	    }
	  }
	  // HR SPECIAL CASE
	  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  // Special case for standalone HTML comments
	  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
	    return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	  }, '^ {0,3}<!--', '-->', 'gm');

	  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
	  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash span elements that should not be parsed as markdown
	 */
	showdown.subParser('hashHTMLSpans', function (text, options, globals) {
	  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

	  function hashHTMLSpan (html) {
	    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
	  }

	  // Hash Self Closing tags
	  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags without properties
	  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags with properties
	  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash self closing tags without />
	  text = text.replace(/<[^>]+?>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

	  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Unhash HTML spans
	 */
	showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
	  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

	  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
	    var repText = globals.gHtmlSpans[i],
	        // limiter to prevent infinite loop (assume 10 as limit for recurse)
	        limit = 0;

	    while (/¨C(\d+)C/.test(repText)) {
	      var num = RegExp.$1;
	      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
	      if (limit === 10) {
	        console.error('maximum nesting of 10 spans reached!!!');
	        break;
	      }
	      ++limit;
	    }
	    text = text.replace('¨C' + i + 'C', repText);
	  }

	  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <pre><code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashPreCodeTags', function (text, options, globals) {
	  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    // encode html entities
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  };

	  // Hash <pre><code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

	  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('headers', function (text, options, globals) {

	  text = globals.converter._dispatch('headers.before', text, options, globals);

	  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

	      // Set text-style headers:
	      //	Header 1
	      //	========
	      //
	      //	Header 2
	      //	--------
	      //
	      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
	      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

	  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  text = text.replace(setextRegexH2, function (matchFound, m1) {
	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart + 1,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  // atx-style headers:
	  //  # Header 1
	  //  ## Header 2
	  //  ## Header 2 with closing hashes ##
	  //  ...
	  //  ###### Header 6
	  //
	  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

	  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
	    var hText = m2;
	    if (options.customizedHeaderId) {
	      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
	    }

	    var span = showdown.subParser('spanGamut')(hText, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
	        hLevel = headerLevelStart - 1 + m1.length,
	        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

	    return showdown.subParser('hashBlock')(header, options, globals);
	  });

	  function headerId (m) {
	    var title,
	        prefix;

	    // It is separate from other options to allow combining prefix and customized
	    if (options.customizedHeaderId) {
	      var match = m.match(/\{([^{]+?)}\s*$/);
	      if (match && match[1]) {
	        m = match[1];
	      }
	    }

	    title = m;

	    // Prefix id to prevent causing inadvertent pre-existing style matches.
	    if (showdown.helper.isString(options.prefixHeaderId)) {
	      prefix = options.prefixHeaderId;
	    } else if (options.prefixHeaderId === true) {
	      prefix = 'section-';
	    } else {
	      prefix = '';
	    }

	    if (!options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (options.ghCompatibleHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&, ¨ and $)
	        .replace(/&amp;/g, '')
	        .replace(/¨T/g, '')
	        .replace(/¨D/g, '')
	        // replace rest of the chars (&~$ are repeated as they might have been escaped)
	        // borrowed from github's redcarpet (some they should produce similar results)
	        .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
	        .toLowerCase();
	    } else if (options.rawHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&, ¨ and $)
	        .replace(/&amp;/g, '&')
	        .replace(/¨T/g, '¨')
	        .replace(/¨D/g, '$')
	        // replace " and '
	        .replace(/["']/g, '-')
	        .toLowerCase();
	    } else {
	      title = title
	        .replace(/[^\w]/g, '')
	        .toLowerCase();
	    }

	    if (options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (globals.hashLinkCounts[title]) {
	      title = title + '-' + (globals.hashLinkCounts[title]++);
	    } else {
	      globals.hashLinkCounts[title] = 1;
	    }
	    return title;
	  }

	  text = globals.converter._dispatch('headers.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('horizontalRule', function (text, options, globals) {
	  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

	  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
	  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

	  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown image shortcuts into <img> tags.
	 */
	showdown.subParser('images', function (text, options, globals) {

	  text = globals.converter._dispatch('images.before', text, options, globals);

	  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
	      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
	      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

	  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
	    url = url.replace(/\s/g, '');
	    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
	  }

	  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

	    var gUrls   = globals.gUrls,
	        gTitles = globals.gTitles,
	        gDims   = globals.gDimensions;

	    linkId = linkId.toLowerCase();

	    if (!title) {
	      title = '';
	    }
	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';

	    } else if (url === '' || url === null) {
	      if (linkId === '' || linkId === null) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(gUrls[linkId])) {
	        url = gUrls[linkId];
	        if (!showdown.helper.isUndefined(gTitles[linkId])) {
	          title = gTitles[linkId];
	        }
	        if (!showdown.helper.isUndefined(gDims[linkId])) {
	          width = gDims[linkId].width;
	          height = gDims[linkId].height;
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    altText = altText
	      .replace(/"/g, '&quot;')
	    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
	      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    //url = showdown.helper.escapeCharacters(url, '*_', false);
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    var result = '<img src="' + url + '" alt="' + altText + '"';

	    if (title && showdown.helper.isString(title)) {
	      title = title
	        .replace(/"/g, '&quot;')
	      //title = showdown.helper.escapeCharacters(title, '*_', false);
	        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    if (width && height) {
	      width  = (width === '*') ? 'auto' : width;
	      height = (height === '*') ? 'auto' : height;

	      result += ' width="' + width + '"';
	      result += ' height="' + height + '"';
	    }

	    result += ' />';

	    return result;
	  }

	  // First, handle reference-style labeled images: ![alt text][id]
	  text = text.replace(referenceRegExp, writeImageTag);

	  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

	  // base64 encoded images
	  text = text.replace(base64RegExp, writeImageTagBase64);

	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(crazyRegExp, writeImageTag);

	  // normal cases
	  text = text.replace(inlineRegExp, writeImageTag);

	  // handle reference-style shortcuts: ![img text]
	  text = text.replace(refShortcutRegExp, writeImageTag);

	  text = globals.converter._dispatch('images.after', text, options, globals);
	  return text;
	});

	showdown.subParser('italicsAndBold', function (text, options, globals) {

	  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

	  // it's faster to have 3 separate regexes for each case than have just one
	  // because of backtracing, in some cases, it could lead to an exponential effect
	  // called "catastrophic backtrace". Ominous!

	  function parseInside (txt, left, right) {
	    /*
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    */
	    return left + txt + right;
	  }

	  // Parse underscores
	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong>', '</strong>');
	    });
	    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
	      return parseInside (txt, '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
	      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }

	  // Now parse asterisks
	  if (options.literalMidWordAsterisks) {
	    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong>', '</strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
	      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }


	  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
	  return text;
	});

	/**
	 * Form HTML ordered (numbered) and unordered (bulleted) lists.
	 */
	showdown.subParser('lists', function (text, options, globals) {

	  /**
	   * Process the contents of a single ordered or unordered list, splitting it
	   * into individual list items.
	   * @param {string} listStr
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function processListItems (listStr, trimTrailing) {
	    // The $g_list_level global keeps track of when we're inside a list.
	    // Each time we enter a list, we increment it; when we leave a list,
	    // we decrement. If it's zero, we're not in a list anymore.
	    //
	    // We do this because when we're not inside a list, we want to treat
	    // something like this:
	    //
	    //    I recommend upgrading to version
	    //    8. Oops, now this line is treated
	    //    as a sub-list.
	    //
	    // As a single paragraph, despite the fact that the second line starts
	    // with a digit-period-space sequence.
	    //
	    // Whereas when we're inside a list (or sub-list), that line will be
	    // treated as the start of a sub-list. What a kludge, huh? This is
	    // an aspect of Markdown's syntax that's hard to parse perfectly
	    // without resorting to mind-reading. Perhaps the solution is to
	    // change the syntax rules such that sub-lists must start with a
	    // starting cardinal number; e.g. "1." or "a.".
	    globals.gListLevel++;

	    // trim trailing blank lines:
	    listStr = listStr.replace(/\n{2,}$/, '\n');

	    // attacklab: add sentinel to emulate \z
	    listStr += '¨0';

	    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
	        isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

	    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
	    // which is a syntax breaking change
	    // activating this option reverts to old behavior
	    if (options.disableForced4SpacesIndentedSublists) {
	      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
	    }

	    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
	      checked = (checked && checked.trim() !== '');

	      var item = showdown.subParser('outdent')(m4, options, globals),
	          bulletStyle = '';

	      // Support for github tasklists
	      if (taskbtn && options.tasklists) {
	        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
	        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
	          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
	          if (checked) {
	            otp += ' checked';
	          }
	          otp += '>';
	          return otp;
	        });
	      }

	      // ISSUE #312
	      // This input: - - - a
	      // causes trouble to the parser, since it interprets it as:
	      // <ul><li><li><li>a</li></li></li></ul>
	      // instead of:
	      // <ul><li>- - a</li></ul>
	      // So, to prevent it, we will put a marker (¨A)in the beginning of the line
	      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
	      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
	        return '¨A' + wm2;
	      });

	      // m1 - Leading line or
	      // Has a double return (multi paragraph) or
	      // Has sublist
	      if (m1 || (item.search(/\n{2,}/) > -1)) {
	        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
	        item = showdown.subParser('blockGamut')(item, options, globals);
	      } else {
	        // Recursion for sub-lists:
	        item = showdown.subParser('lists')(item, options, globals);
	        item = item.replace(/\n$/, ''); // chomp(item)
	        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

	        // Colapse double linebreaks
	        item = item.replace(/\n\n+/g, '\n\n');
	        if (isParagraphed) {
	          item = showdown.subParser('paragraphs')(item, options, globals);
	        } else {
	          item = showdown.subParser('spanGamut')(item, options, globals);
	        }
	      }

	      // now we need to remove the marker (¨A)
	      item = item.replace('¨A', '');
	      // we can finally wrap the line in list item tags
	      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

	      return item;
	    });

	    // attacklab: strip sentinel
	    listStr = listStr.replace(/¨0/g, '');

	    globals.gListLevel--;

	    if (trimTrailing) {
	      listStr = listStr.replace(/\s+$/, '');
	    }

	    return listStr;
	  }

	  function styleStartNumber (list, listType) {
	    // check if ol and starts by a number different than 1
	    if (listType === 'ol') {
	      var res = list.match(/^ *(\d+)\./);
	      if (res && res[1] !== '1') {
	        return ' start="' + res[1] + '"';
	      }
	    }
	    return '';
	  }

	  /**
	   * Check and parse consecutive lists (better fix for issue #142)
	   * @param {string} list
	   * @param {string} listType
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function parseConsecutiveLists (list, listType, trimTrailing) {
	    // check if we caught 2 or more consecutive lists by mistake
	    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
	    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
	        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
	        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
	        result = '';

	    if (list.search(counterRxg) !== -1) {
	      (function parseCL (txt) {
	        var pos = txt.search(counterRxg),
	            style = styleStartNumber(list, listType);
	        if (pos !== -1) {
	          // slice
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

	          // invert counterType and listType
	          listType = (listType === 'ul') ? 'ol' : 'ul';
	          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

	          //recurse
	          parseCL(txt.slice(pos));
	        } else {
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
	        }
	      })(list);
	    } else {
	      var style = styleStartNumber(list, listType);
	      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
	    }

	    return result;
	  }

	  /** Start of list parsing **/
	  text = globals.converter._dispatch('lists.before', text, options, globals);
	  // add sentinel to hack around khtml/safari bug:
	  // http://bugs.webkit.org/show_bug.cgi?id=11231
	  text += '¨0';

	  if (globals.gListLevel) {
	    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, list, m2) {
	        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, true);
	      }
	    );
	  } else {
	    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, m1, list, m3) {
	        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, false);
	      }
	    );
	  }

	  // strip sentinel
	  text = text.replace(/¨0/, '');
	  text = globals.converter._dispatch('lists.after', text, options, globals);
	  return text;
	});

	/**
	 * Parse metadata at the top of the document
	 */
	showdown.subParser('metadata', function (text, options, globals) {

	  if (!options.metadata) {
	    return text;
	  }

	  text = globals.converter._dispatch('metadata.before', text, options, globals);

	  function parseMetadataContents (content) {
	    // raw is raw so it's not changed in any way
	    globals.metadata.raw = content;

	    // escape chars forbidden in html attributes
	    // double quotes
	    content = content
	      // ampersand first
	      .replace(/&/g, '&amp;')
	      // double quotes
	      .replace(/"/g, '&quot;');

	    content = content.replace(/\n {4}/g, ' ');
	    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
	      globals.metadata.parsed[key] = value;
	      return '';
	    });
	  }

	  text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
	    parseMetadataContents(content);
	    return '¨M';
	  });

	  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
	    if (format) {
	      globals.metadata.format = format;
	    }
	    parseMetadataContents(content);
	    return '¨M';
	  });

	  text = text.replace(/¨M/g, '');

	  text = globals.converter._dispatch('metadata.after', text, options, globals);
	  return text;
	});

	/**
	 * Remove one level of line-leading tabs or spaces
	 */
	showdown.subParser('outdent', function (text, options, globals) {
	  text = globals.converter._dispatch('outdent.before', text, options, globals);

	  // attacklab: hack around Konqueror 3.5.4 bug:
	  // "----------bug".replace(/^-/g,"") == "bug"
	  text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

	  // attacklab: clean up hack
	  text = text.replace(/¨0/g, '');

	  text = globals.converter._dispatch('outdent.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 */
	showdown.subParser('paragraphs', function (text, options, globals) {

	  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');

	  var grafs = text.split(/\n{2,}/g),
	      grafsOut = [],
	      end = grafs.length; // Wrap <p> tags

	  for (var i = 0; i < end; i++) {
	    var str = grafs[i];
	    // if this is an HTML marker, copy it
	    if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
	      grafsOut.push(str);

	    // test for presence of characters to prevent empty lines being parsed
	    // as paragraphs (resulting in undesired extra empty paragraphs)
	    } else if (str.search(/\S/) >= 0) {
	      str = showdown.subParser('spanGamut')(str, options, globals);
	      str = str.replace(/^([ \t]*)/g, '<p>');
	      str += '</p>';
	      grafsOut.push(str);
	    }
	  }

	  /** Unhashify HTML blocks */
	  end = grafsOut.length;
	  for (i = 0; i < end; i++) {
	    var blockText = '',
	        grafsOutIt = grafsOut[i],
	        codeFlag = false;
	    // if this is a marker for an html block...
	    // use RegExp.test instead of string.search because of QML bug
	    while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
	      var delim = RegExp.$1,
	          num   = RegExp.$2;

	      if (delim === 'K') {
	        blockText = globals.gHtmlBlocks[num];
	      } else {
	        // we need to check if ghBlock is a false positive
	        if (codeFlag) {
	          // use encoded version of all text
	          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
	        } else {
	          blockText = globals.ghCodeBlocks[num].codeblock;
	        }
	      }
	      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

	      grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
	      // Check if grafsOutIt is a pre->code
	      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
	        codeFlag = true;
	      }
	    }
	    grafsOut[i] = grafsOutIt;
	  }
	  text = grafsOut.join('\n');
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');
	  return globals.converter._dispatch('paragraphs.after', text, options, globals);
	});

	/**
	 * Run extension
	 */
	showdown.subParser('runExtension', function (ext, text, options, globals) {

	  if (ext.filter) {
	    text = ext.filter(text, globals.converter, options);

	  } else if (ext.regex) {
	    // TODO remove this when old extension loading mechanism is deprecated
	    var re = ext.regex;
	    if (!(re instanceof RegExp)) {
	      re = new RegExp(re, 'g');
	    }
	    text = text.replace(re, ext.replace);
	  }

	  return text;
	});

	/**
	 * These are all the transformations that occur *within* block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('spanGamut', function (text, options, globals) {

	  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
	  text = showdown.subParser('codeSpans')(text, options, globals);
	  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
	  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

	  // Process anchor and image tags. Images must come first,
	  // because ![foo][f] looks like an anchor.
	  text = showdown.subParser('images')(text, options, globals);
	  text = showdown.subParser('anchors')(text, options, globals);

	  // Make links out of things like `<http://example.com/>`
	  // Must come after anchors, because you can use < and >
	  // delimiters in inline links like [this](<url>).
	  text = showdown.subParser('autoLinks')(text, options, globals);
	  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
	  text = showdown.subParser('emoji')(text, options, globals);
	  text = showdown.subParser('underline')(text, options, globals);
	  text = showdown.subParser('italicsAndBold')(text, options, globals);
	  text = showdown.subParser('strikethrough')(text, options, globals);
	  text = showdown.subParser('ellipsis')(text, options, globals);

	  // we need to hash HTML tags inside spans
	  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

	  // now we encode amps and angles
	  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

	  // Do hard breaks
	  if (options.simpleLineBreaks) {
	    // GFM style hard breaks
	    // only add line breaks if the text does not contain a block (special case for lists)
	    if (!/\n\n¨K/.test(text)) {
	      text = text.replace(/\n+/g, '<br />\n');
	    }
	  } else {
	    // Vanilla hard breaks
	    text = text.replace(/  +\n/g, '<br />\n');
	  }

	  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
	  return text;
	});

	showdown.subParser('strikethrough', function (text, options, globals) {

	  function parseInside (txt) {
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    return '<del>' + txt + '</del>';
	  }

	  if (options.strikethrough) {
	    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
	    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
	    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
	  }

	  return text;
	});

	/**
	 * Strips link definitions from text, stores the URLs and titles in
	 * hash references.
	 * Link defs are in the form: ^[id]: url "optional title"
	 */
	showdown.subParser('stripLinkDefinitions', function (text, options, globals) {

	  var regex       = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
	      base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

	  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '¨0';

	  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {
	    linkId = linkId.toLowerCase();
	    if (url.match(/^data:.+?\/.+?;base64,/)) {
	      // remove newlines
	      globals.gUrls[linkId] = url.replace(/\s/g, '');
	    } else {
	      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
	    }

	    if (blankLines) {
	      // Oops, found blank lines, so it's not a title.
	      // Put back the parenthetical statement we stole.
	      return blankLines + title;

	    } else {
	      if (title) {
	        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
	      }
	      if (options.parseImgDimensions && width && height) {
	        globals.gDimensions[linkId] = {
	          width:  width,
	          height: height
	        };
	      }
	    }
	    // Completely remove the definition from the text
	    return '';
	  };

	  // first we try to find base64 link references
	  text = text.replace(base64Regex, replaceFunc);

	  text = text.replace(regex, replaceFunc);

	  // attacklab: strip sentinel
	  text = text.replace(/¨0/, '');

	  return text;
	});

	showdown.subParser('tables', function (text, options, globals) {

	  if (!options.tables) {
	    return text;
	  }

	  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
	      //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
	      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

	  function parseStyles (sLine) {
	    if (/^:[ \t]*--*$/.test(sLine)) {
	      return ' style="text-align:left;"';
	    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
	      return ' style="text-align:right;"';
	    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
	      return ' style="text-align:center;"';
	    } else {
	      return '';
	    }
	  }

	  function parseHeaders (header, style) {
	    var id = '';
	    header = header.trim();
	    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
	    if (options.tablesHeaderId || options.tableHeaderId) {
	      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
	    }
	    header = showdown.subParser('spanGamut')(header, options, globals);

	    return '<th' + id + style + '>' + header + '</th>\n';
	  }

	  function parseCells (cell, style) {
	    var subText = showdown.subParser('spanGamut')(cell, options, globals);
	    return '<td' + style + '>' + subText + '</td>\n';
	  }

	  function buildTable (headers, cells) {
	    var tb = '<table>\n<thead>\n<tr>\n',
	        tblLgn = headers.length;

	    for (var i = 0; i < tblLgn; ++i) {
	      tb += headers[i];
	    }
	    tb += '</tr>\n</thead>\n<tbody>\n';

	    for (i = 0; i < cells.length; ++i) {
	      tb += '<tr>\n';
	      for (var ii = 0; ii < tblLgn; ++ii) {
	        tb += cells[i][ii];
	      }
	      tb += '</tr>\n';
	    }
	    tb += '</tbody>\n</table>\n';
	    return tb;
	  }

	  function parseTable (rawTable) {
	    var i, tableLines = rawTable.split('\n');

	    for (i = 0; i < tableLines.length; ++i) {
	      // strip wrong first and last column if wrapped tables are used
	      if (/^ {0,3}\|/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
	      }
	      if (/\|[ \t]*$/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
	      }
	      // parse code spans first, but we only support one line code spans
	      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
	    }

	    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
	        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
	        rawCells = [],
	        headers = [],
	        styles = [],
	        cells = [];

	    tableLines.shift();
	    tableLines.shift();

	    for (i = 0; i < tableLines.length; ++i) {
	      if (tableLines[i].trim() === '') {
	        continue;
	      }
	      rawCells.push(
	        tableLines[i]
	          .split('|')
	          .map(function (s) {
	            return s.trim();
	          })
	      );
	    }

	    if (rawHeaders.length < rawStyles.length) {
	      return rawTable;
	    }

	    for (i = 0; i < rawStyles.length; ++i) {
	      styles.push(parseStyles(rawStyles[i]));
	    }

	    for (i = 0; i < rawHeaders.length; ++i) {
	      if (showdown.helper.isUndefined(styles[i])) {
	        styles[i] = '';
	      }
	      headers.push(parseHeaders(rawHeaders[i], styles[i]));
	    }

	    for (i = 0; i < rawCells.length; ++i) {
	      var row = [];
	      for (var ii = 0; ii < headers.length; ++ii) {
	        if (showdown.helper.isUndefined(rawCells[i][ii])) ;
	        row.push(parseCells(rawCells[i][ii], styles[ii]));
	      }
	      cells.push(row);
	    }

	    return buildTable(headers, cells);
	  }

	  text = globals.converter._dispatch('tables.before', text, options, globals);

	  // find escaped pipe characters
	  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

	  // parse multi column tables
	  text = text.replace(tableRgx, parseTable);

	  // parse one column tables
	  text = text.replace(singeColTblRgx, parseTable);

	  text = globals.converter._dispatch('tables.after', text, options, globals);

	  return text;
	});

	showdown.subParser('underline', function (text, options, globals) {

	  if (!options.underline) {
	    return text;
	  }

	  text = globals.converter._dispatch('underline.before', text, options, globals);

	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	  }

	  // escape remaining underscores to prevent them being parsed by italic and bold
	  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('underline.after', text, options, globals);

	  return text;
	});

	/**
	 * Swap back in all the special characters we've hidden.
	 */
	showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
	  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

	  text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
	    var charCodeToReplace = parseInt(m1);
	    return String.fromCharCode(charCodeToReplace);
	  });

	  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
	  return text;
	});

	showdown.subParser('makeMarkdown.blockquote', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

	      if (innerTxt === '') {
	        continue;
	      }
	      txt += innerTxt;
	    }
	  }
	  // cleanup
	  txt = txt.trim();
	  txt = '> ' + txt.split('\n').join('\n> ');
	  return txt;
	});

	showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {

	  var lang = node.getAttribute('language'),
	      num  = node.getAttribute('precodenum');
	  return '```' + lang + '\n' + globals.preList[num] + '\n```';
	});

	showdown.subParser('makeMarkdown.codeSpan', function (node) {

	  return '`' + node.innerHTML + '`';
	});

	showdown.subParser('makeMarkdown.emphasis', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '*';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '*';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {

	  var headerMark = new Array(headerLevel + 1).join('#'),
	      txt = '';

	  if (node.hasChildNodes()) {
	    txt = headerMark + ' ';
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.hr', function () {

	  return '---';
	});

	showdown.subParser('makeMarkdown.image', function (node) {

	  var txt = '';
	  if (node.hasAttribute('src')) {
	    txt += '![' + node.getAttribute('alt') + '](';
	    txt += '<' + node.getAttribute('src') + '>';
	    if (node.hasAttribute('width') && node.hasAttribute('height')) {
	      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
	    }

	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.links', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes() && node.hasAttribute('href')) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    txt = '[';
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '](';
	    txt += '<' + node.getAttribute('href') + '>';
	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.list', function (node, globals, type) {

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var listItems       = node.childNodes,
	      listItemsLenght = listItems.length,
	      listNum = node.getAttribute('start') || 1;

	  for (var i = 0; i < listItemsLenght; ++i) {
	    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
	      continue;
	    }

	    // define the bullet to use in list
	    var bullet = '';
	    if (type === 'ol') {
	      bullet = listNum.toString() + '. ';
	    } else {
	      bullet = '- ';
	    }

	    // parse list item
	    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
	    ++listNum;
	  }

	  // add comment at the end to prevent consecutive lists to be parsed as one
	  txt += '\n<!-- -->\n';
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.listItem', function (node, globals) {

	  var listItemTxt = '';

	  var children = node.childNodes,
	      childrenLenght = children.length;

	  for (var i = 0; i < childrenLenght; ++i) {
	    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	  }
	  // if it's only one liner, we need to add a newline at the end
	  if (!/\n$/.test(listItemTxt)) {
	    listItemTxt += '\n';
	  } else {
	    // it's multiparagraph, so we need to indent
	    listItemTxt = listItemTxt
	      .split('\n')
	      .join('\n    ')
	      .replace(/^ {4}$/gm, '')
	      .replace(/\n\n+/g, '\n\n');
	  }

	  return listItemTxt;
	});



	showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {

	  spansOnly = spansOnly || false;

	  var txt = '';

	  // edge case of text without wrapper paragraph
	  if (node.nodeType === 3) {
	    return showdown.subParser('makeMarkdown.txt')(node, globals);
	  }

	  // HTML comment
	  if (node.nodeType === 8) {
	    return '<!--' + node.data + '-->\n\n';
	  }

	  // process only node elements
	  if (node.nodeType !== 1) {
	    return '';
	  }

	  var tagName = node.tagName.toLowerCase();

	  switch (tagName) {

	    //
	    // BLOCKS
	    //
	    case 'h1':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
	      break;
	    case 'h2':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
	      break;
	    case 'h3':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
	      break;
	    case 'h4':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
	      break;
	    case 'h5':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
	      break;
	    case 'h6':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
	      break;

	    case 'p':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
	      break;

	    case 'blockquote':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
	      break;

	    case 'hr':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
	      break;

	    case 'ol':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
	      break;

	    case 'ul':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
	      break;

	    case 'precode':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
	      break;

	    case 'pre':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
	      break;

	    case 'table':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
	      break;

	    //
	    // SPANS
	    //
	    case 'code':
	      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
	      break;

	    case 'em':
	    case 'i':
	      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
	      break;

	    case 'strong':
	    case 'b':
	      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
	      break;

	    case 'del':
	      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
	      break;

	    case 'a':
	      txt = showdown.subParser('makeMarkdown.links')(node, globals);
	      break;

	    case 'img':
	      txt = showdown.subParser('makeMarkdown.image')(node, globals);
	      break;

	    default:
	      txt = node.outerHTML + '\n\n';
	  }

	  // common normalization
	  // TODO eventually

	  return txt;
	});

	showdown.subParser('makeMarkdown.paragraph', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }

	  // some text normalization
	  txt = txt.trim();

	  return txt;
	});

	showdown.subParser('makeMarkdown.pre', function (node, globals) {

	  var num  = node.getAttribute('prenum');
	  return '<pre>' + globals.preList[num] + '</pre>';
	});

	showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '~~';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '~~';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.strong', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '**';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '**';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.table', function (node, globals) {

	  var txt = '',
	      tableArray = [[], []],
	      headings   = node.querySelectorAll('thead>tr>th'),
	      rows       = node.querySelectorAll('tbody>tr'),
	      i, ii;
	  for (i = 0; i < headings.length; ++i) {
	    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
	        allign = '---';

	    if (headings[i].hasAttribute('style')) {
	      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
	      switch (style) {
	        case 'text-align:left;':
	          allign = ':---';
	          break;
	        case 'text-align:right;':
	          allign = '---:';
	          break;
	        case 'text-align:center;':
	          allign = ':---:';
	          break;
	      }
	    }
	    tableArray[0][i] = headContent.trim();
	    tableArray[1][i] = allign;
	  }

	  for (i = 0; i < rows.length; ++i) {
	    var r = tableArray.push([]) - 1,
	        cols = rows[i].getElementsByTagName('td');

	    for (ii = 0; ii < headings.length; ++ii) {
	      var cellContent = ' ';
	      if (typeof cols[ii] !== 'undefined') {
	        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
	      }
	      tableArray[r].push(cellContent);
	    }
	  }

	  var cellSpacesCount = 3;
	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      var strLen = tableArray[i][ii].length;
	      if (strLen > cellSpacesCount) {
	        cellSpacesCount = strLen;
	      }
	    }
	  }

	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      if (i === 1) {
	        if (tableArray[i][ii].slice(-1) === ':') {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
	        } else {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
	        }
	      } else {
	        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
	      }
	    }
	    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
	  }

	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.tableCell', function (node, globals) {

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var children = node.childNodes,
	      childrenLength = children.length;

	  for (var i = 0; i < childrenLength; ++i) {
	    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
	  }
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.txt', function (node) {

	  var txt = node.nodeValue;

	  // multiple spaces are collapsed
	  txt = txt.replace(/ +/g, ' ');

	  // replace the custom ¨NBSP; with a space
	  txt = txt.replace(/¨NBSP;/g, ' ');

	  // ", <, > and & should replace escaped html entities
	  txt = showdown.helper.unescapeHTMLEntities(txt);

	  // escape markdown magic characters
	  // emphasis, strong and strikethrough - can appear everywhere
	  // we also escape pipe (|) because of tables
	  // and escape ` because of code blocks and spans
	  txt = txt.replace(/([*_~|`])/g, '\\$1');

	  // escape > because of blockquotes
	  txt = txt.replace(/^(\s*)>/g, '\\$1>');

	  // hash character, only troublesome at the beginning of a line because of headers
	  txt = txt.replace(/^#/gm, '\\#');

	  // horizontal rules
	  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

	  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
	  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

	  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
	  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

	  // images and links, ] followed by ( is problematic, so we escape it
	  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

	  // reference URIs must also be escaped
	  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

	  return txt;
	});

	var root = this;

	// AMD Loader
	if (module.exports) {
	  module.exports = showdown;

	// Regular Browser loader
	} else {
	  root.showdown = showdown;
	}
	}).call(commonjsGlobal);


	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide("frappe.tools");

	frappe.tools.downloadify = function(data, roles, title) {
		if(roles && roles.length && !has_common(roles, roles)) {
			frappe.msgprint(__("Export not allowed. You need {0} role to export.", [frappe.utils.comma_or(roles)]));
			return;
		}

		var filename = title + ".csv";
		var csv_data = frappe.tools.to_csv(data);
		var a = document.createElement('a');

		if ("download" in a) {
			// Used Blob object, because it can handle large files
			var blob_object = new Blob([csv_data], { type: 'text/csv;charset=UTF-8' });
			a.href = URL.createObjectURL(blob_object);
			a.download = filename;

		} else {
			// use old method
			a.href = 'data:attachment/csv,' + encodeURIComponent(csv_data);
			a.download = filename;
			a.target = "_blank";
		}

		document.body.appendChild(a);
		a.click();

		document.body.removeChild(a);
	};

	frappe.markdown = function(txt) {
		if(!frappe.md2html) {
			frappe.md2html = new showdown.Converter();
		}

		while(txt.substr(0,1)==="\n") {
			txt = txt.substr(1);
		}

		// remove leading tab (if they exist in the first line)
		var whitespace_len = 0,
			first_line = txt.split("\n")[0];

		while(["\n", "\t"].indexOf(first_line.substr(0,1))!== -1) {
			whitespace_len++;
			first_line = first_line.substr(1);
		}

		if(whitespace_len && whitespace_len != first_line.length) {
			var txt1 = [];
			$.each(txt.split("\n"), function(i, t) {
				txt1.push(t.substr(whitespace_len));
			});
			txt = txt1.join("\n");
		}

		return frappe.md2html.makeHtml(txt);
	};

	frappe.tools.to_csv = function(data) {
		var res = [];
		$.each(data, function(i, row) {
			row = $.map(row, function(col) {
				if (col === null || col === undefined) { col = ''; }
				return typeof col === "string" ? ('"' + $('<i>').html(col.replace(/"/g, '""')).text() + '"') : col;
			});
			res.push(row.join(","));
		});
		return res.join("\n");
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.datetime');

	frappe.defaultDateFormat = "YYYY-MM-DD";
	frappe.defaultTimeFormat = "HH:mm:ss";
	frappe.defaultDatetimeFormat = frappe.defaultDateFormat + " " + frappe.defaultTimeFormat;
	moment.defaultFormat = frappe.defaultDateFormat;

	frappe.provide("frappe.datetime");

	$.extend(frappe.datetime, {
		convert_to_user_tz: function(date, format) {
			// format defaults to true
			if(frappe.sys_defaults.time_zone) {
				var date_obj = moment.tz(date, frappe.sys_defaults.time_zone).local();
			} else {
				var date_obj = moment(date);
			}

			return (format===false) ? date_obj : date_obj.format(frappe.defaultDatetimeFormat);
		},

		convert_to_system_tz: function(date, format) {
			// format defaults to true

			if(frappe.sys_defaults.time_zone) {
				var date_obj = moment(date).tz(frappe.sys_defaults.time_zone);
			} else {
				var date_obj = moment(date);
			}

			return (format===false) ? date_obj : date_obj.format(frappe.defaultDatetimeFormat);
		},

		is_timezone_same: function() {
			if(frappe.sys_defaults.time_zone) {
				return moment().tz(frappe.sys_defaults.time_zone).utcOffset() === moment().utcOffset();
			} else {
				return true;
			}
		},

		str_to_obj: function(d) {
			return moment(d, frappe.defaultDatetimeFormat)._d;
		},

		obj_to_str: function(d) {
			return moment(d).locale("en").format();
		},

		obj_to_user: function(d) {
			return moment(d).format(frappe.datetime.get_user_date_fmt().toUpperCase());
		},

		get_diff: function(d1, d2) {
			return moment(d1).diff(d2, "days");
		},

		get_hour_diff: function(d1, d2) {
			return moment(d1).diff(d2, "hours");
		},

		get_day_diff: function(d1, d2) {
			return moment(d1).diff(d2, "days");
		},

		add_days: function(d, days) {
			return moment(d).add(days, "days").format();
		},

		add_months: function(d, months) {
			return moment(d).add(months, "months").format();
		},

		week_start: function() {
			return moment().startOf("week").format();
		},

		week_end: function() {
			return moment().endOf("week").format();
		},

		month_start: function() {
			return moment().startOf("month").format();
		},

		month_end: function() {
			return moment().endOf("month").format();
		},

		quarter_start: function() {
			return moment().startOf("quarter").format();
		},

		quarter_end: function() {
			return moment().endOf("quarter").format();
		},

		year_start: function(){
			return moment().startOf("year").format();
		},

		year_end: function(){
			return moment().endOf("year").format();
		},

		get_user_time_fmt: function() {
			return frappe.sys_defaults && frappe.sys_defaults.time_format || "HH:mm:ss";
		},

		get_user_date_fmt: function() {
			return frappe.sys_defaults && frappe.sys_defaults.date_format || "yyyy-mm-dd";
		},

		get_user_fmt: function() {  // For backwards compatibility only
			return frappe.sys_defaults && frappe.sys_defaults.date_format || "yyyy-mm-dd";
		},

		str_to_user: function(val, only_time) {
			if ( only_time === void 0 ) only_time = false;

			if(!val) { return ""; }

			var user_time_fmt = frappe.datetime.get_user_time_fmt();
			if(only_time) {
				return moment(val, frappe.defaultTimeFormat)
					.format(user_time_fmt);
			}

			var user_date_fmt = frappe.datetime.get_user_date_fmt().toUpperCase();
			if(typeof val !== "string" || val.indexOf(" ")===-1) {
				return moment(val).format(user_date_fmt);
			} else {
				return moment(val, "YYYY-MM-DD HH:mm:ss").format(user_date_fmt + " " + user_time_fmt);
			}
		},

		get_datetime_as_string: function(d) {
			return moment(d).format("YYYY-MM-DD HH:mm:ss");
		},

		user_to_str: function(val, only_time) {
			if ( only_time === void 0 ) only_time = false;


			var user_time_fmt = frappe.datetime.get_user_time_fmt();
			if(only_time) {
				return moment(val, user_time_fmt)
					.format(frappe.defaultTimeFormat);
			}

			var user_fmt = frappe.datetime.get_user_date_fmt().toUpperCase();
			var system_fmt = "YYYY-MM-DD";

			if(val.indexOf(" ")!==-1) {
				user_fmt += " " + user_time_fmt;
				system_fmt += " HH:mm:ss";
			}

			// user_fmt.replace("YYYY", "YY")? user might only input 2 digits of the year, which should also be parsed
			return moment(val, [user_fmt.replace("YYYY", "YY"),
				user_fmt]).locale("en").format(system_fmt);
		},

		user_to_obj: function(d) {
			return frappe.datetime.str_to_obj(frappe.datetime.user_to_str(d));
		},

		global_date_format: function(d) {
			var m = moment(d);
			if(m._f && m._f.indexOf("HH")!== -1) {
				return m.format("Do MMMM YYYY, h:mma")
			} else {
				return m.format('Do MMMM YYYY');
			}
		},

		now_date: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultDateFormat, as_obj);
		},

		now_time: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultTimeFormat, as_obj);
		},

		now_datetime: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultDatetimeFormat, as_obj);
		},

		_date: function(format, as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			var time_zone = frappe.sys_defaults && frappe.sys_defaults.time_zone;
			var date;
			if (time_zone) {
				date = moment.tz(time_zone);
			} else {
				date = moment();
			}
			if (as_obj) {
				return frappe.datetime.moment_to_date_obj(date);
			} else {
				return date.format(format);
			}
		},

		moment_to_date_obj: function(moment) {
			var date_obj = new Date();
			var date_array = moment.toArray();
			date_obj.setFullYear(date_array[0]);
			date_obj.setMonth(date_array[1]);
			date_obj.setDate(date_array[2]);
			date_obj.setHours(date_array[3]);
			date_obj.setMinutes(date_array[4]);
			date_obj.setSeconds(date_array[5]);
			date_obj.setMilliseconds(date_array[6]);
			return date_obj;
		},

		nowdate: function() {
			return frappe.datetime.now_date();
		},

		get_today: function() {
			return frappe.datetime.now_date();
		},

		get_time: function (timestamp) {
			// return time with AM/PM
			return moment(timestamp).format('hh:mm A');
		},

		validate: function(d) {
			return moment(d, [
				frappe.defaultDateFormat,
				frappe.defaultDatetimeFormat,
				frappe.defaultTimeFormat
			], true).isValid();
		},

	});

	// Proxy for dateutil and get_today
	Object.defineProperties(window, {
		'dateutil': {
			get: function() {
				console.warn('Please use `frappe.datetime` instead of `dateutil`. It will be deprecated soon.');
				return frappe.datetime;
			}
		},
		'date': {
			get: function() {
				console.warn('Please use `frappe.datetime` instead of `date`. It will be deprecated soon.');
				return frappe.datetime;
			}
		},
		'get_today': {
			get: function() {
				console.warn('Please use `frappe.datetime.get_today` instead of `get_today`. It will be deprecated soon.');
				return frappe.datetime.get_today;
			}
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	window.cstr = function(s) {
		if(s==null){ return ''; }
		return s+'';
	};

	window.cint = function(v, def) {
		if (v === true)
			{ return 1; }
		if (v === false)
			{ return 0; }
		v = v + '';
		if (v !== "0") { v = lstrip(v, ['0']); }
		v = parseInt(v); // eslint-ignore-line
		if (isNaN(v)) { v = def === undefined ? 0 : def; }
		return v;
	};

	// to title case
	window.toTitle = function(str){
		var word_in = str.split(" ");
		var word_out = [];

		for(var w in word_in){
			word_out[w] = word_in[w].charAt(0).toUpperCase() + word_in[w].slice(1);
		}

		return word_out.join(" ");
	};

	window.is_null = function(v) {
		if(v===null || v===undefined || cstr(v).trim()==="") { return true; }
	};

	window.copy_dict = function(d) {
		var n = {};
		for(var k in d) { n[k] = d[k]; }
		return n;
	};

	window.validate_email = function(txt) {
		return frappe.utils.validate_type(txt, "email");
	};

	window.validate_phone = function(txt) {
		return frappe.utils.validate_type(txt, "phone");
	};

	window.validate_name = function(txt) {
		return frappe.utils.validate_type(txt, "name");
	};

	window.validate_url = function(txt) {
		return frappe.utils.validate_type(txt, "url");
	};

	window.nth = function(number) {
		number = cint(number);
		var s = 'th';
		if((number+'').substr(-1)=='1') { s = 'st'; }
		if((number+'').substr(-1)=='2') { s = 'nd'; }
		if((number+'').substr(-1)=='3') { s = 'rd'; }
		return number+s;
	};

	window.has_words = function(list, item) {
		if(!item) { return true; }
		if(!list) { return false; }
		for(var i=0, j=list.length; i<j; i++) {
			if(item.indexOf(list[i])!=-1)
				{ return true; }
		}
		return false;
	};

	window.has_common = function(list1, list2) {
		if(!list1 || !list2) { return false; }
		for(var i=0, j=list1.length; i<j; i++) {
			if(in_list(list2, list1[i])){ return true; }
		}
		return false;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	if (!window.frappe) { window.frappe = {}; }

	function flt$1(v, decimals, number_format) {
		if (v == null || v == '') { return 0; }

		if (!(typeof v === "number" || String(parseFloat(v)) == v)) {
			// cases in which this block should not run
			// 1. 'v' is already a number
			// 2. v is already parsed but in string form
			// if (typeof v !== "number") {

			v = v + "";

			// strip currency symbol if exists
			if (v.indexOf(" ") != -1) {
				// using slice(1).join(" ") because space could also be a group separator
				var parts = v.split(" ");
				v = isNaN(parseFloat(parts[0])) ? parts.slice(parts.length - 1).join(" ") : v;
			}

			v = strip_number_groups(v, number_format);

			v = parseFloat(v);
			if (isNaN(v))
				{ v = 0; }
		}

		v = parseFloat(v);
		if (decimals != null)
			{ return _round(v, decimals); }
		return v;
	}

	function strip_number_groups(v, number_format) {
		if (!number_format) { number_format = get_number_format$1(); }
		var info = get_number_format_info$1(number_format);

		// strip groups (,)
		var group_regex = new RegExp(info.group_sep === "." ? "\\." : info.group_sep, "g");
		v = v.replace(group_regex, "");

		// replace decimal separator with (.)
		if (info.decimal_str !== "." && info.decimal_str !== "") {
			var decimal_regex = new RegExp(info.decimal_str, "g");
			v = v.replace(decimal_regex, ".");
		}

		return v;
	}


	frappe.number_format_info = {
		"#,###.##": { decimal_str: ".", group_sep: "," },
		"#.###,##": { decimal_str: ",", group_sep: "." },
		"# ###.##": { decimal_str: ".", group_sep: " " },
		"# ###,##": { decimal_str: ",", group_sep: " " },
		"#'###.##": { decimal_str: ".", group_sep: "'" },
		"#, ###.##": { decimal_str: ".", group_sep: ", " },
		"#,##,###.##": { decimal_str: ".", group_sep: "," },
		"#,###.###": { decimal_str: ".", group_sep: "," },
		"#.###": { decimal_str: "", group_sep: "." },
		"#,###": { decimal_str: "", group_sep: "," },
	};

	window.format_number = function (v, format, decimals) {
		if (!format) {
			format = get_number_format$1();
			if (decimals == null) { decimals = cint(frappe.defaults.get_default("float_precision")) || 3; }
		}

		var info = get_number_format_info$1(format);

		// Fix the decimal first, toFixed will auto fill trailing zero.
		if (decimals == null) { decimals = info.precision; }

		v = flt$1(v, decimals, format);

		var is_negative = false;
		if (v < 0) { is_negative = true; }
		v = Math.abs(v);

		v = v.toFixed(decimals);

		var part = v.split('.');

		// get group position and parts
		var group_position = info.group_sep ? 3 : 0;

		if (group_position) {
			var integer = part[0];
			var str = '';
			var offset = integer.length % group_position;
			for (var i = integer.length; i >= 0; i--) {
				var l = replace_all(str, info.group_sep, "").length;
				if (format == "#,##,###.##" && str.indexOf(",") != -1) { // INR
					group_position = 2;
					l += 1;
				}

				str += integer.charAt(i);

				if (l && !((l + 1) % group_position) && i != 0) {
					str += info.group_sep;
				}
			}
			part[0] = str.split("").reverse().join("");
		}
		if (part[0] + "" == "") {
			part[0] = "0";
		}

		// join decimal
		part[1] = (part[1] && info.decimal_str) ? (info.decimal_str + part[1]) : "";

		// join
		return (is_negative ? "-" : "") + part[0] + part[1];
	};

	function format_currency$1(v, currency, decimals) {
		var format = get_number_format$1(currency);
		var symbol = get_currency_symbol(currency);
		if(decimals === undefined) {
			decimals = frappe.boot.sysdefaults.currency_precision || null;
		}

		if (symbol)
			{ return symbol + " " + format_number(v, format, decimals); }
		else
			{ return format_number(v, format, decimals); }
	}

	function get_currency_symbol(currency) {
		if (frappe.boot) {
			if (frappe.boot.sysdefaults && frappe.boot.sysdefaults.hide_currency_symbol == "Yes")
				{ return null; }

			if (!currency)
				{ currency = frappe.boot.sysdefaults.currency; }

			return frappe.model.get_value(":Currency", currency, "symbol") || currency;
		} else {
			// load in template
			return frappe.currency_symbols[currency];
		}
	}

	function get_number_format$1(currency) {
		return (frappe.boot && frappe.boot.sysdefaults && frappe.boot.sysdefaults.number_format) || "#,###.##";
	}

	function get_number_format_info$1(format) {
		var info = frappe.number_format_info[format];

		if (!info) {
			info = { decimal_str: ".", group_sep: "," };
		}

		// get the precision from the number format
		info.precision = format.split(info.decimal_str).slice(1)[0].length;

		return info;
	}

	function _round(num, precision) {
		var is_negative = num < 0 ? true : false;
		var d = cint(precision);
		var m = Math.pow(10, d);
		var n = +(d ? Math.abs(num) * m : Math.abs(num)).toFixed(8); // Avoid rounding errors
		var i = Math.floor(n), f = n - i;
		var r = ((!precision && f == 0.5) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n));
		r = d ? r / m : r;
		return is_negative ? -r : r;

	}

	function roundNumber(num, precision) {
		// backward compatibility
		return _round(num, precision);
	}

	function precision$1(fieldname, doc) {
		if (cur_frm) {
			if (!doc) { doc = cur_frm.doc; }
			var df = frappe.meta.get_docfield(doc.doctype, fieldname, doc.parent || doc.name);
			if (!df) { console.log(fieldname + ": could not find docfield in method precision()"); }
			return frappe.meta.get_field_precision(df, doc);
		} else {
			return frappe.boot.sysdefaults.float_precision
		}
	}

	function in_list$1(list, item) {
		return list.includes(item);
	}

	function remainder(numerator, denominator, precision) {
		precision = cint(precision);
		var multiplier = Math.pow(10, precision);
		if (precision) {
			var _remainder = ((numerator * multiplier) % (denominator * multiplier)) / multiplier;
		} else {
			var _remainder = numerator % denominator;
		}

		return flt$1(_remainder, precision);
	}

	function round_based_on_smallest_currency_fraction(value, currency, precision) {
		var smallest_currency_fraction_value = flt$1(frappe.model.get_value(":Currency",
			currency, "smallest_currency_fraction_value"));

		if (smallest_currency_fraction_value) {
			var remainder_val = remainder(value, smallest_currency_fraction_value, precision);
			if (remainder_val > (smallest_currency_fraction_value / 2)) {
				value += (smallest_currency_fraction_value - remainder_val);
			} else {
				value -= remainder_val;
			}
		} else {
			value = _round(value);
		}
		return value;
	}

	function fmt_money(v, format){
		// deprecated!
		// for backward compatibility
		return format_currency$1(v, format);
	}


	Object.assign(window, {
		flt: flt$1,
		cint: cint,
		strip_number_groups: strip_number_groups,
		format_currency: format_currency$1,
		fmt_money: fmt_money,
		get_currency_symbol: get_currency_symbol,
		get_number_format: get_number_format$1,
		get_number_format_info: get_number_format_info$1,
		_round: _round,
		roundNumber: roundNumber,
		precision: precision$1,
		remainder: remainder,
		round_based_on_smallest_currency_fraction: round_based_on_smallest_currency_fraction,
		in_list: in_list$1
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.help");

	frappe.help.youtube_id = {};

	frappe.help.has_help = function (doctype) {
		return frappe.help.youtube_id[doctype];
	};

	frappe.help.show = function (doctype) {
		if (frappe.help.youtube_id[doctype]) {
			frappe.help.show_video(frappe.help.youtube_id[doctype]);
		}
	};

	frappe.help.show_video = function (youtube_id, title) {
		if (frappe.utils.is_url(youtube_id)) {
			var expression = '(?:youtube.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu.be/)([^"&?\\s]{11})';
			youtube_id = youtube_id.match(expression)[1];
		}

		// (frappe.help_feedback_link || "")
		var dialog = new frappe.ui.Dialog({
			title: title || __("Help"),
			size: 'large'
		});

		var video = $(("<div class=\"video-player\" data-plyr-provider=\"youtube\" data-plyr-embed-id=\"" + youtube_id + "\"></div>"));
		video.appendTo(dialog.body);

		dialog.show();
		dialog.$wrapper.addClass("video-modal");

		var plyr = new frappe.Plyr(video[0], {
			hideControls: true,
			resetOnEnd: true,
		});

		dialog.onhide = function () {
			plyr.destroy();
		};
	};

	$("body").on("click", "a.help-link", function () {
		var doctype = $(this).attr("data-doctype");
		doctype && frappe.help.show(doctype);
	});

	frappe.provide('frappe.help.help_links');

	frappe.help.help_links['data-import-tool'] = [
		{ label: 'Importing and Exporting Data', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/data/data-import-tool.html' } ];

	frappe.help.help_links['modules/Setup'] = [
		{ label: 'Users and Permissions', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/' },
		{ label: 'Settings', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/settings/' },
		{ label: 'Data Management', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/data/' },
		{ label: 'Email', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/email/' },
		{ label: 'Printing', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/print/' } ];

	frappe.help.help_links['List/User'] = [
		{ label: 'Adding Users', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/adding-users' },
		{ label: 'Rename User', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/articles/rename-user' } ];

	frappe.help.help_links['permission-manager'] = [
		{ label: 'Role Permissions Manager', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/role-based-permissions' } ];

	frappe.help.help_links['user-permissions'] = [
		{ label: 'User Permissions', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/user-permissions' } ];

	frappe.help.help_links['Form/System Settings'] = [
		{ label: 'System Settings', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/settings/system-settings' } ];

	frappe.help.help_links['List/Email Account'] = [
		{ label: 'Email Account', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/email/email-account' } ];

	frappe.help.help_links['List/Notification'] = [
		{ label: 'Notification', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/email/email-alerts' } ];

	frappe.help.help_links['Form/Print Settings'] = [
		{ label: 'Print Settings', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/print/print-settings' } ];

	frappe.help.help_links['print-format-builder'] = [
		{ label: 'Print Format Builder', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/print/print-format-builder' } ];

	frappe.provide('frappe.contacts');

	$.extend(frappe.contacts, {
		clear_address_and_contact: function(frm) {
			$(frm.fields_dict['address_html'].wrapper).html("");
			frm.fields_dict['contact_html'] && $(frm.fields_dict['contact_html'].wrapper).html("");
		},

		render_address_and_contact: function(frm) {
			// render address
			if(frm.fields_dict['address_html'] && "addr_list" in frm.doc.__onload) {
				$(frm.fields_dict['address_html'].wrapper)
					.html(frappe.render_template("address_list",
						frm.doc.__onload))
					.find(".btn-address").on("click", function() {
						frappe.new_doc("Address");
					});
			}

			// render contact
			if(frm.fields_dict['contact_html'] && "contact_list" in frm.doc.__onload) {
				$(frm.fields_dict['contact_html'].wrapper)
					.html(frappe.render_template("contact_list",
						frm.doc.__onload))
					.find(".btn-contact").on("click", function() {
						frappe.new_doc("Contact");
					}
				);
			}
		},
		get_last_doc: function(frm) {
			var reverse_routes = frappe.route_history.reverse();
			var last_route = reverse_routes.find(function (route) {
				return route[0] === 'Form' && route[1] !== frm.doctype
			});
			var doctype = last_route && last_route[1];
			var docname = last_route && last_route[2];

			if (last_route && last_route.length > 3)
				{ docname = last_route.slice(2).join("/"); }

			return {
				doctype: doctype,
				docname: docname
			}
		}
	});

	frappe.preview_email = function(template, args, header, with_container, only_html) {
		if ( with_container === void 0 ) with_container=false;
		if ( only_html === void 0 ) only_html=false;

		return frappe
			.call({
				method: 'frappe.email.email_body.get_email_html',
				args: {
					subject: 'Test',
					template: template,
					args: args,
					header: header,
					with_container: with_container
				}
			})
			.then(function (r) {
				var html = r.message;
				html = html.replace(/embed=/, 'src=');
				if (only_html) {
					return html;
				}
				var d = frappe.msgprint({
					message:
						'<iframe width="100%" height="600px" style="border: none;"></iframe>',
					wide: true
				});

				setTimeout(function () {
					d.$wrapper
						.find('iframe')
						.contents()
						.find('html')
						.html(html);
					d.$wrapper.find('.modal-dialog').css('width', '70%');
				}, 1000);
			});
	};

	frappe.provide('frappe.file_manager');

	frappe.file_manager = function() {
		var files_to_move = [];
		var	old_folder = null;
		var new_folder = null;

		function cut(files, old_folder_) {
			files_to_move = files;
			old_folder = old_folder_;
		}

		function paste(new_folder_) {
			return new Promise(function (resolve, reject) {
				if (files_to_move.length === 0 || !old_folder) {
					reset();
					resolve();
					return;
				}
				new_folder = new_folder_;

				frappe.call({
					method:"frappe.core.doctype.file.file.move_file",
					args: {
						file_list: files_to_move,
						new_parent: new_folder,
						old_parent: old_folder
					},
					callback: function (r) {
						reset();
						resolve(r);
					}
				}).fail(reject);
			});
		}

		function reset() {
			files_to_move = [];
			old_folder = null;
			new_folder = null;
		}

		return {
			cut: cut,
			paste: paste,
			get can_paste() {
				return Boolean(files_to_move.length > 0 && old_folder);
			},
			get old_folder() {
				return old_folder;
			},
			get files_to_move() {
				return files_to_move;
			}
		};
	}();

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script = {
		name: "ProgressRing",
		props: {
			primary: String,
			secondary: String,
			radius: Number,
			progress: Number,
			stroke: Number
		},
		data: function data() {
			var normalizedRadius = this.radius - this.stroke * 2;
			var circumference = normalizedRadius * 2 * Math.PI;

			return {
				normalizedRadius: normalizedRadius,
				circumference: circumference
			};
		},
		computed: {
			strokeDashoffset: function strokeDashoffset() {
				return (
					this.circumference - (this.progress / 100) * this.circumference
				);
			}
		}
	};

	/* script */
	            var __vue_script__ = script;
	            
	/* template */
	var __vue_render__ = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "svg",
	    { attrs: { height: _vm.radius * 2, width: _vm.radius * 2 } },
	    [
	      _c("circle", {
	        style: {
	          stroke: _vm.secondary,
	          strokeDashoffset: 0
	        },
	        attrs: {
	          "stroke-dasharray": _vm.circumference + " " + _vm.circumference,
	          "stroke-width": _vm.stroke,
	          fill: "transparent",
	          r: _vm.normalizedRadius,
	          cx: _vm.radius,
	          cy: _vm.radius
	        }
	      }),
	      _vm._v(" "),
	      _c("circle", {
	        style: {
	          stroke: _vm.primary,
	          strokeDashoffset: _vm.strokeDashoffset
	        },
	        attrs: {
	          "stroke-dasharray": _vm.circumference + " " + _vm.circumference,
	          "stroke-width": _vm.stroke,
	          fill: "transparent",
	          r: _vm.normalizedRadius,
	          cx: _vm.radius,
	          cy: _vm.radius
	        }
	      }),
	      _vm._v(" "),
	      _c(
	        "text",
	        {
	          style: {
	            color: "var(--text-color)",
	            fontSize: "var(--text-xs)",
	            fontWeight: "var(--text-bold)"
	          },
	          attrs: {
	            "dominant-baseline": "middle",
	            "text-anchor": "middle",
	            x: _vm.radius,
	            y: _vm.radius
	          }
	        },
	        [_vm._v("\n\t\t" + _vm._s(_vm.progress) + "%\n\t")]
	      )
	    ]
	  )
	};
	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;

	  /* style */
	  var __vue_inject_styles__ = function (inject) {
	    if (!inject) { return }
	    inject("data-v-2680a937_0", { source: "\ncircle[data-v-2680a937] {\n\ttransition: stroke-dashoffset 0.35s;\n\ttransform: rotate(-90deg);\n\ttransform-origin: 50% 50%;\n}\n", map: {"version":3,"sources":["/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/ProgressRing.vue"],"names":[],"mappings":";AAsEA;CACA,mCAAA;CACA,yBAAA;CACA,yBAAA;AACA","file":"ProgressRing.vue","sourcesContent":["<template>\n\t<svg :height=\"radius * 2\" :width=\"radius * 2\">\n\t\t<circle\n\t\t\t:stroke-dasharray=\"circumference + ' ' + circumference\"\n\t\t\t:style=\"{\n\t\t\t\tstroke: secondary,\n\t\t\t\tstrokeDashoffset: 0\n\t\t\t}\"\n\t\t\t:stroke-width=\"stroke\"\n\t\t\tfill=\"transparent\"\n\t\t\t:r=\"normalizedRadius\"\n\t\t\t:cx=\"radius\"\n\t\t\t:cy=\"radius\"\n\t\t/>\n\t\t<circle\n\t\t\t:stroke-dasharray=\"circumference + ' ' + circumference\"\n\t\t\t:style=\"{\n\t\t\t\tstroke: primary,\n\t\t\t\tstrokeDashoffset: strokeDashoffset\n\t\t\t}\"\n\t\t\t:stroke-width=\"stroke\"\n\t\t\tfill=\"transparent\"\n\t\t\t:r=\"normalizedRadius\"\n\t\t\t:cx=\"radius\"\n\t\t\t:cy=\"radius\"\n\t\t/>\n\t\t<text\n\t\t\tdominant-baseline=\"middle\"\n\t\t\ttext-anchor=\"middle\"\n\t\t\t:x=\"radius\"\n\t\t\t:y=\"radius\"\n\t\t\t:style=\"{\n\t\t\t\tcolor: 'var(--text-color)',\n\t\t\t\tfontSize: 'var(--text-xs)',\n\t\t\t\tfontWeight: 'var(--text-bold)'\n\t\t\t}\"\n\t\t>\n\t\t\t{{ progress }}%\n\t\t</text>\n\t</svg>\n</template>\n<script>\nexport default {\n\tname: \"ProgressRing\",\n\tprops: {\n\t\tprimary: String,\n\t\tsecondary: String,\n\t\tradius: Number,\n\t\tprogress: Number,\n\t\tstroke: Number\n\t},\n\tdata() {\n\t\tconst normalizedRadius = this.radius - this.stroke * 2;\n\t\tconst circumference = normalizedRadius * 2 * Math.PI;\n\n\t\treturn {\n\t\t\tnormalizedRadius,\n\t\t\tcircumference\n\t\t};\n\t},\n\tcomputed: {\n\t\tstrokeDashoffset() {\n\t\t\treturn (\n\t\t\t\tthis.circumference - (this.progress / 100) * this.circumference\n\t\t\t);\n\t\t}\n\t}\n};\n</script>\n<style scoped>\ncircle {\n\ttransition: stroke-dashoffset 0.35s;\n\ttransform: rotate(-90deg);\n\ttransform-origin: 50% 50%;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__ = "data-v-2680a937";
	  /* module identifier */
	  var __vue_module_identifier__ = undefined;
	  /* functional template */
	  var __vue_is_functional_template__ = false;
	  /* component normalizer */
	  function __vue_normalize__(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/ProgressRing.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var ProgressRing = __vue_normalize__(
	    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	    __vue_inject_styles__,
	    __vue_script__,
	    __vue_scope_id__,
	    __vue_is_functional_template__,
	    __vue_module_identifier__,
	    __vue_create_injector__,
	    undefined
	  );

	//
	var script$1 = {
		name: 'FilePreview',
		props: ['file'],
		components: {
			ProgressRing: ProgressRing
		},
		data: function data() {
			return {
				src: null
			}
		},
		mounted: function mounted() {
			var this$1 = this;

			if (this.is_image) {
				if (window.FileReader) {
					var fr = new FileReader();
					fr.onload = function () { return this$1.src = fr.result; };
					fr.readAsDataURL(this.file.file_obj);
				}
			}
		},
		filters: {
			file_size: function file_size(value) {
				return frappe.form.formatters.FileSize(value);
			},
			file_name: function file_name(value) {
				return value;
				// return frappe.utils.file_name_ellipsis(value, 9);
			}
		},
		computed: {
			private_icon: function private_icon() {
				return frappe.utils.icon(this.is_private ? 'lock' : 'unlock');
			},
			is_private: function is_private() {
				return this.file.doc ? this.file.doc.is_private : this.file.private;
			},
			uploaded: function uploaded() {
				return this.file.total && this.file.total === this.file.progress && !this.file.failed;
			},
			is_image: function is_image() {
				return this.file.file_obj.type.startsWith('image');
			},
			progress: function progress() {
				var value = Math.round((this.file.progress * 100) / this.file.total);
				if (isNaN(value)) {
					value = 0;
				}
				return value;
			}
		}
	};

	/* script */
	            var __vue_script__$1 = script$1;
	            
	/* template */
	var __vue_render__$1 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-preview" }, [
	    _c("div", { staticClass: "file-icon" }, [
	      _vm.is_image
	        ? _c("img", { attrs: { src: _vm.src, alt: _vm.file.name } })
	        : _c("div", {
	            staticClass: "fallback",
	            domProps: { innerHTML: _vm._s(_vm.frappe.utils.icon("file", "md")) }
	          })
	    ]),
	    _vm._v(" "),
	    _c("div", [
	      _c("div", [
	        _vm.file.doc
	          ? _c(
	              "a",
	              {
	                staticClass: "flex",
	                attrs: { href: _vm.file.doc.file_url, target: "_blank" }
	              },
	              [
	                _c("span", { staticClass: "file-name" }, [
	                  _vm._v(_vm._s(_vm._f("file_name")(_vm.file.name)))
	                ]),
	                _vm._v(" "),
	                _c("div", {
	                  staticClass: "ml-2",
	                  domProps: { innerHTML: _vm._s(_vm.private_icon) }
	                })
	              ]
	            )
	          : _c("span", { staticClass: "flex" }, [
	              _c("span", { staticClass: "file-name" }, [
	                _vm._v(_vm._s(_vm._f("file_name")(_vm.file.name)))
	              ]),
	              _vm._v(" "),
	              _c(
	                "button",
	                {
	                  staticClass: "ml-2 btn-reset",
	                  attrs: { title: _vm.__("Toggle Public/Private") },
	                  on: {
	                    click: function($event) {
	                      return _vm.$emit("toggle_private")
	                    }
	                  }
	                },
	                [
	                  _c("div", {
	                    domProps: { innerHTML: _vm._s(_vm.private_icon) }
	                  })
	                ]
	              )
	            ])
	      ]),
	      _vm._v(" "),
	      _c("div", [
	        _c("span", { staticClass: "file-size" }, [
	          _vm._v(
	            "\n\t\t\t\t" +
	              _vm._s(_vm._f("file_size")(_vm.file.file_obj.size)) +
	              "\n\t\t\t"
	          )
	        ])
	      ])
	    ]),
	    _vm._v(" "),
	    _c(
	      "div",
	      { staticClass: "file-actions" },
	      [
	        _c("ProgressRing", {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value: _vm.file.uploading && !_vm.uploaded,
	              expression: "file.uploading && !uploaded"
	            }
	          ],
	          attrs: {
	            primary: "var(--primary-color)",
	            secondary: "var(--gray-200)",
	            radius: "24",
	            progress: _vm.progress,
	            stroke: "3"
	          }
	        }),
	        _vm._v(" "),
	        _vm.uploaded
	          ? _c("div", {
	              domProps: {
	                innerHTML: _vm._s(_vm.frappe.utils.icon("solid-success", "lg"))
	              }
	            })
	          : _vm._e(),
	        _vm._v(" "),
	        _vm.file.failed
	          ? _c("div", {
	              domProps: {
	                innerHTML: _vm._s(_vm.frappe.utils.icon("solid-red", "lg"))
	              }
	            })
	          : _vm._e(),
	        _vm._v(" "),
	        !_vm.uploaded && !_vm.file.uploading
	          ? _c("button", {
	              staticClass: "btn",
	              domProps: {
	                innerHTML: _vm._s(_vm.frappe.utils.icon("delete", "md"))
	              },
	              on: {
	                click: function($event) {
	                  return _vm.$emit("remove")
	                }
	              }
	            })
	          : _vm._e()
	      ],
	      1
	    )
	  ])
	};
	var __vue_staticRenderFns__$1 = [];
	__vue_render__$1._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$1 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-11d5dd1a_0", { source: "\n.file-preview {\n\tdisplay: flex;\n\talign-items: center;\n\tpadding: 0.75rem;\n\tborder: 1px solid transparent;\n}\n.file-preview + .file-preview {\n\tborder-top-color: var(--border-color);\n}\n.file-preview:hover {\n\tbackground-color: var(--bg-color);\n\tborder-color: var(--dark-border-color);\n\tborder-radius: var(--border-radius);\n}\n.file-preview:hover + .file-preview {\n\tborder-top-color: transparent;\n}\n.file-icon {\n\tborder-radius: var(--border-radius);\n\twidth: 2.625rem;\n\theight: 2.625rem;\n\toverflow: hidden;\n\tmargin-right: var(--margin-md);\n\tflex-shrink: 0;\n}\n.file-icon img {\n\twidth: 100%;\n\theight: 100%;\n\tobject-fit: cover;\n}\n.file-icon .fallback {\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tborder: 1px solid var(--border-color);\n\tborder-radius: var(--border-radius);\n}\n.file-name {\n\tfont-size: var(--text-base);\n\tfont-weight: var(--text-bold);\n\tcolor: var(--text-color);\n\tdisplay: -webkit-box;\n\t-webkit-line-clamp: 1;\n\t-webkit-box-orient: vertical;\n\toverflow: hidden;\n}\n.file-size {\n\tfont-size: var(--text-sm);\n\tcolor: var(--text-light);\n}\n.file-actions {\n\twidth: 3rem;\n\tflex-shrink: 0;\n\tmargin-left: auto;\n\ttext-align: center;\n}\n.file-actions .btn {\n\tpadding: var(--padding-xs);\n\tbox-shadow: none;\n}\n", map: {"version":3,"sources":["/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/FilePreview.vue"],"names":[],"mappings":";AAuGA;CACA,aAAA;CACA,mBAAA;CACA,gBAAA;CACA,6BAAA;AACA;AAEA;CACA,qCAAA;AACA;AAEA;CACA,iCAAA;CACA,sCAAA;CACA,mCAAA;AACA;AAEA;CACA,6BAAA;AACA;AAEA;CACA,mCAAA;CACA,eAAA;CACA,gBAAA;CACA,gBAAA;CACA,8BAAA;CACA,cAAA;AACA;AAEA;CACA,WAAA;CACA,YAAA;CACA,iBAAA;AACA;AAEA;CACA,WAAA;CACA,YAAA;CACA,aAAA;CACA,mBAAA;CACA,uBAAA;CACA,qCAAA;CACA,mCAAA;AACA;AAEA;CACA,2BAAA;CACA,6BAAA;CACA,wBAAA;CACA,oBAAA;CACA,qBAAA;CACA,4BAAA;CACA,gBAAA;AACA;AAEA;CACA,yBAAA;CACA,wBAAA;AACA;AAEA;CACA,WAAA;CACA,cAAA;CACA,iBAAA;CACA,kBAAA;AACA;AAEA;CACA,0BAAA;CACA,gBAAA;AACA","file":"FilePreview.vue","sourcesContent":["<template>\n\t<div class=\"file-preview\">\n\t\t<div class=\"file-icon\">\n\t\t\t<img\n\t\t\t\tv-if=\"is_image\"\n\t\t\t\t:src=\"src\"\n\t\t\t\t:alt=\"file.name\"\n\t\t\t>\n\t\t\t<div class=\"fallback\" v-else v-html=\"frappe.utils.icon('file', 'md')\">\n\t\t\t</div>\n\t\t</div>\n\t\t<div>\n\t\t\t<div>\n\t\t\t\t<a class=\"flex\" :href=\"file.doc.file_url\" v-if=\"file.doc\" target=\"_blank\">\n\t\t\t\t\t<span class=\"file-name\">{{ file.name | file_name }}</span>\n\t\t\t\t\t<div class=\"ml-2\" v-html=\"private_icon\"></div>\n\t\t\t\t</a>\n\t\t\t\t<span class=\"flex\" v-else>\n\t\t\t\t\t<span class=\"file-name\">{{ file.name | file_name }}</span>\n\t\t\t\t\t<button class=\"ml-2 btn-reset\" @click=\"$emit('toggle_private')\" :title=\"__('Toggle Public/Private')\">\n\t\t\t\t\t\t<div v-html=\"private_icon\"></div>\n\t\t\t\t\t</button>\n\t\t\t\t</span>\n\t\t\t</div>\n\n\t\t\t<div>\n\t\t\t\t<span class=\"file-size\">\n\t\t\t\t\t{{ file.file_obj.size | file_size }}\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"file-actions\">\n\t\t\t<ProgressRing\n\t\t\t\tv-show=\"file.uploading && !uploaded\"\n\t\t\t\tprimary=\"var(--primary-color)\"\n\t\t\t\tsecondary=\"var(--gray-200)\"\n\t\t\t\tradius=\"24\"\n\t\t\t\t:progress=\"progress\"\n\t\t\t\tstroke=\"3\"\n\t\t\t/>\n\t\t\t<div v-if=\"uploaded\" v-html=\"frappe.utils.icon('solid-success', 'lg')\"></div>\n\t\t\t<div v-if=\"file.failed\" v-html=\"frappe.utils.icon('solid-red', 'lg')\"></div>\n\t\t\t<button v-if=\"!uploaded && !file.uploading\" class=\"btn\" @click=\"$emit('remove')\" v-html=\"frappe.utils.icon('delete', 'md')\"></button>\n\t\t</div>\n\t</div>\n</template>\n\n<script>\nimport ProgressRing from './ProgressRing.vue';\nexport default {\n\tname: 'FilePreview',\n\tprops: ['file'],\n\tcomponents: {\n\t\tProgressRing\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tsrc: null\n\t\t}\n\t},\n\tmounted() {\n\t\tif (this.is_image) {\n\t\t\tif (window.FileReader) {\n\t\t\t\tlet fr = new FileReader();\n\t\t\t\tfr.onload = () => this.src = fr.result;\n\t\t\t\tfr.readAsDataURL(this.file.file_obj);\n\t\t\t}\n\t\t}\n\t},\n\tfilters: {\n\t\tfile_size(value) {\n\t\t\treturn frappe.form.formatters.FileSize(value);\n\t\t},\n\t\tfile_name(value) {\n\t\t\treturn value;\n\t\t\t// return frappe.utils.file_name_ellipsis(value, 9);\n\t\t}\n\t},\n\tcomputed: {\n\t\tprivate_icon() {\n\t\t\treturn frappe.utils.icon(this.is_private ? 'lock' : 'unlock');\n\t\t},\n\t\tis_private() {\n\t\t\treturn this.file.doc ? this.file.doc.is_private : this.file.private;\n\t\t},\n\t\tuploaded() {\n\t\t\treturn this.file.total && this.file.total === this.file.progress && !this.file.failed;\n\t\t},\n\t\tis_image() {\n\t\t\treturn this.file.file_obj.type.startsWith('image');\n\t\t},\n\t\tprogress() {\n\t\t\tlet value = Math.round((this.file.progress * 100) / this.file.total);\n\t\t\tif (isNaN(value)) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}\n</script>\n\n<style>\n.file-preview {\n\tdisplay: flex;\n\talign-items: center;\n\tpadding: 0.75rem;\n\tborder: 1px solid transparent;\n}\n\n.file-preview + .file-preview {\n\tborder-top-color: var(--border-color);\n}\n\n.file-preview:hover {\n\tbackground-color: var(--bg-color);\n\tborder-color: var(--dark-border-color);\n\tborder-radius: var(--border-radius);\n}\n\n.file-preview:hover + .file-preview {\n\tborder-top-color: transparent;\n}\n\n.file-icon {\n\tborder-radius: var(--border-radius);\n\twidth: 2.625rem;\n\theight: 2.625rem;\n\toverflow: hidden;\n\tmargin-right: var(--margin-md);\n\tflex-shrink: 0;\n}\n\n.file-icon img {\n\twidth: 100%;\n\theight: 100%;\n\tobject-fit: cover;\n}\n\n.file-icon .fallback {\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tborder: 1px solid var(--border-color);\n\tborder-radius: var(--border-radius);\n}\n\n.file-name {\n\tfont-size: var(--text-base);\n\tfont-weight: var(--text-bold);\n\tcolor: var(--text-color);\n\tdisplay: -webkit-box;\n\t-webkit-line-clamp: 1;\n\t-webkit-box-orient: vertical;\n\toverflow: hidden;\n}\n\n.file-size {\n\tfont-size: var(--text-sm);\n\tcolor: var(--text-light);\n}\n\n.file-actions {\n\twidth: 3rem;\n\tflex-shrink: 0;\n\tmargin-left: auto;\n\ttext-align: center;\n}\n\n.file-actions .btn {\n\tpadding: var(--padding-xs);\n\tbox-shadow: none;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$1 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$1 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$1 = false;
	  /* component normalizer */
	  function __vue_normalize__$1(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/FilePreview.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$1() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FilePreview = __vue_normalize__$1(
	    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
	    __vue_inject_styles__$1,
	    __vue_script__$1,
	    __vue_scope_id__$1,
	    __vue_is_functional_template__$1,
	    __vue_module_identifier__$1,
	    __vue_create_injector__$1,
	    undefined
	  );

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script$2 = {
		name: "TreeNode",
		props: ["node", "selected_node"],
		components: {
			TreeNode: function () { return frappe.ui.components.TreeNode; }
		},
		computed: {
			icon: function icon() {
				var icons = {
					open: frappe.utils.icon("folder-open", "md"),
					closed: frappe.utils.icon("folder-normal", "md"),
					leaf: frappe.utils.icon("primitive-dot", "xs"),
					search: frappe.utils.icon("search")
				};

				if (this.node.by_search) { return icons.search; }
				if (this.node.is_leaf) { return icons.leaf; }
				if (this.node.open) { return icons.open; }
				return icons.closed;
			}
		}
	};

	/* script */
	            var __vue_script__$2 = script$2;
	            
	/* template */
	var __vue_render__$2 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    { staticClass: "tree-node", class: { opened: _vm.node.open } },
	    [
	      _c(
	        "span",
	        {
	          staticClass: "tree-link",
	          class: { active: _vm.node.value === _vm.selected_node.value },
	          attrs: { disabled: _vm.node.fetching },
	          on: {
	            click: function($event) {
	              return _vm.$emit("node-click", _vm.node)
	            }
	          }
	        },
	        [
	          _c("div", { domProps: { innerHTML: _vm._s(_vm.icon) } }),
	          _vm._v(" "),
	          _c("a", { staticClass: "tree-label" }, [
	            _vm._v(_vm._s(_vm.node.label))
	          ])
	        ]
	      ),
	      _vm._v(" "),
	      _c(
	        "ul",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value: _vm.node.open,
	              expression: "node.open"
	            }
	          ],
	          staticClass: "tree-children"
	        },
	        [
	          _vm._l(_vm.node.children, function(n) {
	            return _c("TreeNode", {
	              key: n.value,
	              attrs: { node: n, selected_node: _vm.selected_node },
	              on: {
	                "node-click": function(n) {
	                  return _vm.$emit("node-click", n)
	                },
	                "load-more": function(n) {
	                  return _vm.$emit("load-more", n)
	                }
	              }
	            })
	          }),
	          _vm._v(" "),
	          _vm.node.has_more_children
	            ? _c(
	                "button",
	                {
	                  staticClass: "btn btn-xs btn-load-more",
	                  attrs: { disabled: _vm.node.children_loading },
	                  on: {
	                    click: function($event) {
	                      return _vm.$emit("load-more", _vm.node)
	                    }
	                  }
	                },
	                [
	                  _vm._v(
	                    "\n\t\t\t" +
	                      _vm._s(
	                        _vm.node.children_loading
	                          ? _vm.__("Loading...")
	                          : _vm.__("Load more")
	                      ) +
	                      "\n\t\t"
	                  )
	                ]
	              )
	            : _vm._e()
	        ],
	        2
	      )
	    ]
	  )
	};
	var __vue_staticRenderFns__$2 = [];
	__vue_render__$2._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$2 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-3f0b42c6_0", { source: "\n.btn-load-more[data-v-3f0b42c6] {\n\tmargin-left: 1.6rem;\n\tmargin-top: 0.5rem;\n}\n", map: {"version":3,"sources":["/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/TreeNode.vue"],"names":[],"mappings":";AAwDA;CACA,mBAAA;CACA,kBAAA;AACA","file":"TreeNode.vue","sourcesContent":["<template>\n\t<div class=\"tree-node\" :class=\"{ opened: node.open }\">\n\t\t<span\n\t\t\tclass=\"tree-link\"\n\t\t\t@click=\"$emit('node-click', node)\"\n\t\t\t:class=\"{ active: node.value === selected_node.value }\"\n\t\t\t:disabled=\"node.fetching\"\n\t\t>\n\t\t\t<div v-html=\"icon\"></div>\n\t\t\t<a class=\"tree-label\">{{ node.label }}</a>\n\t\t</span>\n\t\t<ul class=\"tree-children\" v-show=\"node.open\">\n\t\t\t<TreeNode\n\t\t\t\tv-for=\"n in node.children\"\n\t\t\t\t:key=\"n.value\"\n\t\t\t\t:node=\"n\"\n\t\t\t\t:selected_node=\"selected_node\"\n\t\t\t\t@node-click=\"n => $emit('node-click', n)\"\n\t\t\t\t@load-more=\"n => $emit('load-more', n)\"\n\t\t\t/>\n\t\t\t<button\n\t\t\t\tclass=\"btn btn-xs btn-load-more\"\n\t\t\t\tv-if=\"node.has_more_children\"\n\t\t\t\t@click=\"$emit('load-more', node)\"\n\t\t\t\t:disabled=\"node.children_loading\"\n\t\t\t>\n\t\t\t\t{{ node.children_loading ? __(\"Loading...\") : __(\"Load more\") }}\n\t\t\t</button>\n\t\t</ul>\n\t</div>\n</template>\n<script>\nexport default {\n\tname: \"TreeNode\",\n\tprops: [\"node\", \"selected_node\"],\n\tcomponents: {\n\t\tTreeNode: () => frappe.ui.components.TreeNode\n\t},\n\tcomputed: {\n\t\ticon() {\n\t\t\tlet icons = {\n\t\t\t\topen: frappe.utils.icon(\"folder-open\", \"md\"),\n\t\t\t\tclosed: frappe.utils.icon(\"folder-normal\", \"md\"),\n\t\t\t\tleaf: frappe.utils.icon(\"primitive-dot\", \"xs\"),\n\t\t\t\tsearch: frappe.utils.icon(\"search\")\n\t\t\t};\n\n\t\t\tif (this.node.by_search) return icons.search;\n\t\t\tif (this.node.is_leaf) return icons.leaf;\n\t\t\tif (this.node.open) return icons.open;\n\t\t\treturn icons.closed;\n\t\t}\n\t}\n};\n</script>\n<style scoped>\n.btn-load-more {\n\tmargin-left: 1.6rem;\n\tmargin-top: 0.5rem;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$2 = "data-v-3f0b42c6";
	  /* module identifier */
	  var __vue_module_identifier__$2 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$2 = false;
	  /* component normalizer */
	  function __vue_normalize__$2(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/TreeNode.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$2() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var TreeNode = __vue_normalize__$2(
	    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
	    __vue_inject_styles__$2,
	    __vue_script__$2,
	    __vue_scope_id__$2,
	    __vue_is_functional_template__$2,
	    __vue_module_identifier__$2,
	    __vue_create_injector__$2,
	    undefined
	  );

	//

	var script$3 = {
		name: "FileBrowser",
		components: {
			TreeNode: TreeNode
		},
		data: function data() {
			return {
				node: {
					label: __("Home"),
					value: "Home",
					children: [],
					children_start: 0,
					children_loading: false,
					is_leaf: false,
					fetching: false,
					fetched: false,
					open: false,
					filtered: true
				},
				selected_node: {},
				search_text: "",
				page_length: 10
			};
		},
		mounted: function mounted() {
			this.toggle_node(this.node);
		},
		methods: {
			toggle_node: function toggle_node(node) {
				var this$1 = this;

				if (!node.fetched && !node.is_leaf) {
					node.fetching = true;
					node.children_start = 0;
					node.children_loading = false;
					this.get_files_in_folder(node.value, 0).then(
						function (ref) {
							var files = ref.files;
							var has_more = ref.has_more;

							node.open = true;
							node.children = files;
							node.fetched = true;
							node.fetching = false;
							node.children_start += this$1.page_length;
							node.has_more_children = has_more;
						}
					);
				} else {
					node.open = !node.open;
					this.select_node(node);
				}
			},
			load_more: function load_more(node) {
				var this$1 = this;

				if (node.has_more_children) {
					var start = node.children_start;
					node.children_loading = true;
					this.get_files_in_folder(node.value, start).then(
						function (ref) {
							var files = ref.files;
							var has_more = ref.has_more;

							node.children = node.children.concat(files);
							node.children_start += this$1.page_length;
							node.has_more_children = has_more;
							node.children_loading = false;
						}
					);
				}
			},
			select_node: function select_node(node) {
				if (node.is_leaf) {
					this.selected_node = node;
				}
			},
			get_files_in_folder: function get_files_in_folder(folder, start) {
				var this$1 = this;

				return frappe
					.call("frappe.core.doctype.file.file.get_files_in_folder", {
						folder: folder,
						start: start,
						page_length: this.page_length
					})
					.then(function (r) {
						var ref = r.message || {};
						var files = ref.files; if ( files === void 0 ) files = [];
						var has_more = ref.has_more; if ( has_more === void 0 ) has_more = false;
						files.sort(function (a, b) {
							if (a.is_folder && b.is_folder) {
								return a.modified < b.modified ? -1 : 1;
							}
							if (a.is_folder) {
								return -1;
							}
							if (b.is_folder) {
								return 1;
							}
							return 0;
						});
						files = files.map(function (file) { return this$1.make_file_node(file); });
						return { files: files, has_more: has_more };
					});
			},
			search_by_name: frappe.utils.debounce(function() {
				var this$1 = this;

				if (this.search_text === "") {
					this.node = this.folder_node;
					return;
				}
				if (this.search_text.length < 3) { return; }
				frappe
					.call(
						"frappe.core.doctype.file.file.get_files_by_search_text",
						{
							text: this.search_text
						}
					)
					.then(function (r) {
						var files = r.message || [];
						files = files.map(function (file) { return this$1.make_file_node(file); });
						if (!this$1.folder_node) {
							this$1.folder_node = this$1.node;
						}
						this$1.node = {
							label: __("Search Results"),
							value: "",
							children: files,
							by_search: true,
							open: true,
							filtered: true
						};
					});
			}, 300),
			make_file_node: function make_file_node(file) {
				var filename = file.file_name || file.name;
				var label = frappe.utils.file_name_ellipsis(filename, 40);
				return {
					label: label,
					filename: filename,
					file_url: file.file_url,
					value: file.name,
					is_leaf: !file.is_folder,
					fetched: !file.is_folder, // fetched if node is leaf
					children: [],
					children_loading: false,
					children_start: 0,
					open: false,
					fetching: false,
					filtered: true
				};
			}
		}
	};

	/* script */
	            var __vue_script__$3 = script$3;
	            
	/* template */
	var __vue_render__$3 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-browser" }, [
	    _c("div", [
	      _c(
	        "a",
	        {
	          staticClass: "text-muted text-medium",
	          attrs: { href: "" },
	          on: {
	            click: function($event) {
	              $event.preventDefault();
	              return _vm.$emit("hide-browser")
	            }
	          }
	        },
	        [
	          _vm._v(
	            "\n\t\t\t" + _vm._s(_vm.__("← Back to upload files")) + "\n\t\t"
	          )
	        ]
	      )
	    ]),
	    _vm._v(" "),
	    _c(
	      "div",
	      { staticClass: "file-browser-list" },
	      [
	        _c("div", { staticClass: "file-filter" }, [
	          _c("input", {
	            directives: [
	              {
	                name: "model",
	                rawName: "v-model",
	                value: _vm.search_text,
	                expression: "search_text"
	              }
	            ],
	            staticClass: "form-control input-xs",
	            attrs: {
	              type: "search",
	              placeholder: _vm.__("Search by filename or extension")
	            },
	            domProps: { value: _vm.search_text },
	            on: {
	              input: [
	                function($event) {
	                  if ($event.target.composing) {
	                    return
	                  }
	                  _vm.search_text = $event.target.value;
	                },
	                _vm.search_by_name
	              ]
	            }
	          })
	        ]),
	        _vm._v(" "),
	        _c("TreeNode", {
	          staticClass: "tree with-skeleton",
	          attrs: { node: _vm.node, selected_node: _vm.selected_node },
	          on: {
	            "node-click": function(n) {
	              return _vm.toggle_node(n)
	            },
	            "load-more": function(n) {
	              return _vm.load_more(n)
	            }
	          }
	        })
	      ],
	      1
	    )
	  ])
	};
	var __vue_staticRenderFns__$3 = [];
	__vue_render__$3._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$3 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-c1219b2a_0", { source: "\n.file-browser-list {\n\theight: 300px;\n\toverflow: hidden;\n\tmargin-top: 10px;\n}\n.file-filter {\n\tpadding: 3px;\n}\n.tree {\n\toverflow: auto;\n\theight: 100%;\n\tpadding-left: 0;\n\tpadding-right: 0;\n\tpadding-bottom: 4rem;\n}\n", map: {"version":3,"sources":["/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/FileBrowser.vue"],"names":[],"mappings":";AAkLA;CACA,aAAA;CACA,gBAAA;CACA,gBAAA;AACA;AAEA;CACA,YAAA;AACA;AAEA;CACA,cAAA;CACA,YAAA;CACA,eAAA;CACA,gBAAA;CACA,oBAAA;AACA","file":"FileBrowser.vue","sourcesContent":["<template>\n\t<div class=\"file-browser\">\n\t\t<div>\n\t\t\t<a\n\t\t\t\thref=\"\"\n\t\t\t\tclass=\"text-muted text-medium\"\n\t\t\t\t@click.prevent=\"$emit('hide-browser')\"\n\t\t\t>\n\t\t\t\t{{ __(\"← Back to upload files\") }}\n\t\t\t</a>\n\t\t</div>\n\t\t<div class=\"file-browser-list\">\n\t\t\t<div class=\"file-filter\">\n\t\t\t\t<input\n\t\t\t\t\ttype=\"search\"\n\t\t\t\t\tclass=\"form-control input-xs\"\n\t\t\t\t\t:placeholder=\"__('Search by filename or extension')\"\n\t\t\t\t\tv-model=\"search_text\"\n\t\t\t\t\t@input=\"search_by_name\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<TreeNode\n\t\t\t\tclass=\"tree with-skeleton\"\n\t\t\t\t:node=\"node\"\n\t\t\t\t:selected_node=\"selected_node\"\n\t\t\t\t@node-click=\"n => toggle_node(n)\"\n\t\t\t\t@load-more=\"n => load_more(n)\"\n\t\t\t/>\n\t\t</div>\n\t</div>\n</template>\n<script>\nimport TreeNode from \"./TreeNode.vue\";\n\nexport default {\n\tname: \"FileBrowser\",\n\tcomponents: {\n\t\tTreeNode\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tnode: {\n\t\t\t\tlabel: __(\"Home\"),\n\t\t\t\tvalue: \"Home\",\n\t\t\t\tchildren: [],\n\t\t\t\tchildren_start: 0,\n\t\t\t\tchildren_loading: false,\n\t\t\t\tis_leaf: false,\n\t\t\t\tfetching: false,\n\t\t\t\tfetched: false,\n\t\t\t\topen: false,\n\t\t\t\tfiltered: true\n\t\t\t},\n\t\t\tselected_node: {},\n\t\t\tsearch_text: \"\",\n\t\t\tpage_length: 10\n\t\t};\n\t},\n\tmounted() {\n\t\tthis.toggle_node(this.node);\n\t},\n\tmethods: {\n\t\ttoggle_node(node) {\n\t\t\tif (!node.fetched && !node.is_leaf) {\n\t\t\t\tnode.fetching = true;\n\t\t\t\tnode.children_start = 0;\n\t\t\t\tnode.children_loading = false;\n\t\t\t\tthis.get_files_in_folder(node.value, 0).then(\n\t\t\t\t\t({ files, has_more }) => {\n\t\t\t\t\t\tnode.open = true;\n\t\t\t\t\t\tnode.children = files;\n\t\t\t\t\t\tnode.fetched = true;\n\t\t\t\t\t\tnode.fetching = false;\n\t\t\t\t\t\tnode.children_start += this.page_length;\n\t\t\t\t\t\tnode.has_more_children = has_more;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tnode.open = !node.open;\n\t\t\t\tthis.select_node(node);\n\t\t\t}\n\t\t},\n\t\tload_more(node) {\n\t\t\tif (node.has_more_children) {\n\t\t\t\tlet start = node.children_start;\n\t\t\t\tnode.children_loading = true;\n\t\t\t\tthis.get_files_in_folder(node.value, start).then(\n\t\t\t\t\t({ files, has_more }) => {\n\t\t\t\t\t\tnode.children = node.children.concat(files);\n\t\t\t\t\t\tnode.children_start += this.page_length;\n\t\t\t\t\t\tnode.has_more_children = has_more;\n\t\t\t\t\t\tnode.children_loading = false;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tselect_node(node) {\n\t\t\tif (node.is_leaf) {\n\t\t\t\tthis.selected_node = node;\n\t\t\t}\n\t\t},\n\t\tget_files_in_folder(folder, start) {\n\t\t\treturn frappe\n\t\t\t\t.call(\"frappe.core.doctype.file.file.get_files_in_folder\", {\n\t\t\t\t\tfolder,\n\t\t\t\t\tstart,\n\t\t\t\t\tpage_length: this.page_length\n\t\t\t\t})\n\t\t\t\t.then(r => {\n\t\t\t\t\tlet { files = [], has_more = false } = r.message || {};\n\t\t\t\t\tfiles.sort((a, b) => {\n\t\t\t\t\t\tif (a.is_folder && b.is_folder) {\n\t\t\t\t\t\t\treturn a.modified < b.modified ? -1 : 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a.is_folder) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b.is_folder) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t\tfiles = files.map(file => this.make_file_node(file));\n\t\t\t\t\treturn { files, has_more };\n\t\t\t\t});\n\t\t},\n\t\tsearch_by_name: frappe.utils.debounce(function() {\n\t\t\tif (this.search_text === \"\") {\n\t\t\t\tthis.node = this.folder_node;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.search_text.length < 3) return;\n\t\t\tfrappe\n\t\t\t\t.call(\n\t\t\t\t\t\"frappe.core.doctype.file.file.get_files_by_search_text\",\n\t\t\t\t\t{\n\t\t\t\t\t\ttext: this.search_text\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t.then(r => {\n\t\t\t\t\tlet files = r.message || [];\n\t\t\t\t\tfiles = files.map(file => this.make_file_node(file));\n\t\t\t\t\tif (!this.folder_node) {\n\t\t\t\t\t\tthis.folder_node = this.node;\n\t\t\t\t\t}\n\t\t\t\t\tthis.node = {\n\t\t\t\t\t\tlabel: __(\"Search Results\"),\n\t\t\t\t\t\tvalue: \"\",\n\t\t\t\t\t\tchildren: files,\n\t\t\t\t\t\tby_search: true,\n\t\t\t\t\t\topen: true,\n\t\t\t\t\t\tfiltered: true\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t}, 300),\n\t\tmake_file_node(file) {\n\t\t\tlet filename = file.file_name || file.name;\n\t\t\tlet label = frappe.utils.file_name_ellipsis(filename, 40);\n\t\t\treturn {\n\t\t\t\tlabel: label,\n\t\t\t\tfilename: filename,\n\t\t\t\tfile_url: file.file_url,\n\t\t\t\tvalue: file.name,\n\t\t\t\tis_leaf: !file.is_folder,\n\t\t\t\tfetched: !file.is_folder, // fetched if node is leaf\n\t\t\t\tchildren: [],\n\t\t\t\tchildren_loading: false,\n\t\t\t\tchildren_start: 0,\n\t\t\t\topen: false,\n\t\t\t\tfetching: false,\n\t\t\t\tfiltered: true\n\t\t\t};\n\t\t}\n\t}\n};\n</script>\n\n<style>\n.file-browser-list {\n\theight: 300px;\n\toverflow: hidden;\n\tmargin-top: 10px;\n}\n\n.file-filter {\n\tpadding: 3px;\n}\n\n.tree {\n\toverflow: auto;\n\theight: 100%;\n\tpadding-left: 0;\n\tpadding-right: 0;\n\tpadding-bottom: 4rem;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$3 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$3 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$3 = false;
	  /* component normalizer */
	  function __vue_normalize__$3(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/FileBrowser.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$3() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FileBrowser = __vue_normalize__$3(
	    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
	    __vue_inject_styles__$3,
	    __vue_script__$3,
	    __vue_scope_id__$3,
	    __vue_is_functional_template__$3,
	    __vue_module_identifier__$3,
	    __vue_create_injector__$3,
	    undefined
	  );

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script$4 = {
		name: 'WebLink',
		data: function data() {
			return {
				url: '',
			}
		}
	};

	/* script */
	            var __vue_script__$4 = script$4;
	            
	/* template */
	var __vue_render__$4 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-web-link margin-bottom" }, [
	    _c(
	      "a",
	      {
	        staticClass: "text-muted text-medium",
	        attrs: { href: "" },
	        on: {
	          click: function($event) {
	            $event.preventDefault();
	            return _vm.$emit("hide-web-link")
	          }
	        }
	      },
	      [_vm._v("\n\t\t" + _vm._s(_vm.__("← Back to upload files")) + "\n\t")]
	    ),
	    _vm._v(" "),
	    _c("div", { staticClass: "input-group" }, [
	      _c("input", {
	        directives: [
	          {
	            name: "model",
	            rawName: "v-model",
	            value: _vm.url,
	            expression: "url"
	          }
	        ],
	        staticClass: "form-control",
	        attrs: { type: "text", placeholder: _vm.__("Attach a web link") },
	        domProps: { value: _vm.url },
	        on: {
	          input: function($event) {
	            if ($event.target.composing) {
	              return
	            }
	            _vm.url = $event.target.value;
	          }
	        }
	      })
	    ])
	  ])
	};
	var __vue_staticRenderFns__$4 = [];
	__vue_render__$4._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$4 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-f740938a_0", { source: "\n.file-web-link .input-group {\n\tmargin-top: 10px;\n}\n", map: {"version":3,"sources":["/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/WebLink.vue"],"names":[],"mappings":";AA6BA;CACA,gBAAA;AACA","file":"WebLink.vue","sourcesContent":["<template>\n\t<div class=\"file-web-link margin-bottom\">\n\t\t<a href class=\"text-muted text-medium\"\n\t\t\t@click.prevent=\"$emit('hide-web-link')\"\n\t\t>\n\t\t\t{{ __('← Back to upload files') }}\n\t\t</a>\n\t\t<div class=\"input-group\">\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tclass=\"form-control\"\n\t\t\t\t:placeholder=\"__('Attach a web link')\"\n\t\t\t\tv-model=\"url\"\n\t\t\t>\n\t\t</div>\n\t</div>\n</template>\n<script>\nexport default {\n\tname: 'WebLink',\n\tdata() {\n\t\treturn {\n\t\t\turl: '',\n\t\t}\n\t}\n}\n</script>\n\n<style>\n.file-web-link .input-group {\n\tmargin-top: 10px;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$4 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$4 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$4 = false;
	  /* component normalizer */
	  function __vue_normalize__$4(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/WebLink.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$4() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var WebLink = __vue_normalize__$4(
	    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
	    __vue_inject_styles__$4,
	    __vue_script__$4,
	    __vue_scope_id__$4,
	    __vue_is_functional_template__$4,
	    __vue_module_identifier__$4,
	    __vue_create_injector__$4,
	    undefined
	  );

	//

	var script$5 = {
		name: 'FileUploader',
		props: {
			show_upload_button: {
				default: true
			},
			disable_file_browser: {
				default: false
			},
			allow_multiple: {
				default: true
			},
			as_dataurl: {
				default: false
			},
			doctype: {
				default: null
			},
			docname: {
				default: null
			},
			fieldname: {
				default: null
			},
			folder: {
				default: 'Home'
			},
			method: {
				default: null
			},
			on_success: {
				default: null
			},
			restrictions: {
				default: function () { return ({
					max_file_size: null, // 2048 -> 2KB
					max_number_of_files: null,
					allowed_file_types: [] // ['image/*', 'video/*', '.jpg', '.gif', '.pdf']
				}); }
			},
			upload_notes: {
				default: null // "Images or video, upto 2MB"
			}
		},
		components: {
			FilePreview: FilePreview,
			FileBrowser: FileBrowser,
			WebLink: WebLink
		},
		data: function data() {
			return {
				files: [],
				is_dragging: false,
				currently_uploading: -1,
				show_file_browser: false,
				show_web_link: false,
			}
		},
		watch: {
			files: function files(newvalue, oldvalue) {
				if (!this.allow_multiple && newvalue.length > 1) {
					this.files = [newvalue[newvalue.length - 1]];
				}
			}
		},
		computed: {
			upload_complete: function upload_complete() {
				return this.files.length > 0
					&& this.files.every(
						function (file) { return file.total !== 0 && file.progress === file.total; });
			},
			allow_take_photo: function allow_take_photo() {
				return window.navigator.mediaDevices;
			}
		},
		methods: {
			dragover: function dragover() {
				this.is_dragging = true;
			},
			dragleave: function dragleave() {
				this.is_dragging = false;
			},
			dropfiles: function dropfiles(e) {
				this.is_dragging = false;
				this.add_files(e.dataTransfer.files);
			},
			browse_files: function browse_files() {
				this.$refs.file_input.click();
			},
			on_file_input: function on_file_input(e) {
				this.add_files(this.$refs.file_input.files);
			},
			remove_file: function remove_file(file) {
				this.files = this.files.filter(function (f) { return f !== file; });
			},
			toggle_all_private: function toggle_all_private() {
				var flag;
				var private_values = this.files.filter(function (file) { return file.private; });
				if (private_values.length < this.files.length) {
					// there are some private and some public
					// set all to private
					flag = true;
				} else {
					// all are private, set all to public
					flag = false;
				}
				this.files = this.files.map(function (file) {
					file.private = flag;
					return file;
				});
			},
			add_files: function add_files(file_array) {
				var files = Array.from(file_array)
					.filter(this.check_restrictions)
					.map(function (file) {
						var is_image = file.type.startsWith('image');
						return {
							file_obj: file,
							name: file.name,
							doc: null,
							progress: 0,
							total: 0,
							failed: false,
							uploading: false,
							private: !is_image
						}
					});
				this.files = this.files.concat(files);
			},
			check_restrictions: function check_restrictions(file) {
				var ref = this.restrictions;
				var max_file_size = ref.max_file_size;
				var allowed_file_types = ref.allowed_file_types;

				var mime_type = file.type;
				var extension = '.' + file.name.split('.').pop();

				var is_correct_type = true;
				var valid_file_size = true;

				if (allowed_file_types.length) {
					is_correct_type = allowed_file_types.some(function (type) {
						// is this is a mime-type
						if (type.includes('/')) {
							if (!file.type) { return false; }
							return file.type.match(type);
						}

						// otherwise this is likely an extension
						if (type[0] === '.') {
							return file.name.endsWith(type);
						}
						return false;
					});
				}

				if (max_file_size && file.size != null) {
					valid_file_size = file.size < max_file_size;
				}

				if (!is_correct_type) {
					console.warn('File skipped because of invalid file type', file);
				}
				if (!valid_file_size) {
					console.warn('File skipped because of invalid file size', file.size, file);
				}

				return is_correct_type && valid_file_size;
			},
			upload_files: function upload_files() {
				var this$1 = this;

				if (this.show_file_browser) {
					return this.upload_via_file_browser();
				}
				if (this.show_web_link) {
					return this.upload_via_web_link();
				}
				if (this.as_dataurl) {
					return this.return_as_dataurl();
				}
				return frappe.run_serially(
					this.files.map(
						function (file, i) { return function () { return this$1.upload_file(file, i); }; }
					)
				);
			},
			upload_via_file_browser: function upload_via_file_browser() {
				var selected_file = this.$refs.file_browser.selected_node;
				if (!selected_file.value) {
					frappe.msgprint(__('Click on a file to select it.'));
					return Promise.reject();
				}

				return this.upload_file({
					file_url: selected_file.file_url
				});
			},
			upload_via_web_link: function upload_via_web_link() {
				var file_url = this.$refs.web_link.url;
				if (!file_url) {
					frappe.msgprint(__('Invalid URL'));
					return Promise.reject();
				}
				file_url = decodeURI(file_url);
				return this.upload_file({
					file_url: file_url
				});
			},
			return_as_dataurl: function return_as_dataurl() {
				var this$1 = this;

				var promises = this.files.map(function (file) { return frappe.dom.file_to_base64(file.file_obj)
						.then(function (dataurl) {
							file.dataurl = dataurl;
							this$1.on_success && this$1.on_success(file);
						}); }
				);
				return Promise.all(promises);
			},
			upload_file: function upload_file(file, i) {
				var this$1 = this;

				this.currently_uploading = i;

				return new Promise(function (resolve, reject) {
					var xhr = new XMLHttpRequest();
					xhr.upload.addEventListener('loadstart', function (e) {
						file.uploading = true;
					});
					xhr.upload.addEventListener('progress', function (e) {
						if (e.lengthComputable) {
							file.progress = e.loaded;
							file.total = e.total;
						}
					});
					xhr.upload.addEventListener('load', function (e) {
						file.uploading = false;
						resolve();
					});
					xhr.addEventListener('error', function (e) {
						file.failed = true;
						reject();
					});
					xhr.onreadystatechange = function () {
						if (xhr.readyState == XMLHttpRequest.DONE) {
							if (xhr.status === 200) {
								var r = null;
								var file_doc = null;
								try {
									r = JSON.parse(xhr.responseText);
									if (r.message.doctype === 'File') {
										file_doc = r.message;
									}
								} catch(e) {
									r = xhr.responseText;
								}

								file.doc = file_doc;

								if (this$1.on_success) {
									this$1.on_success(file_doc, r);
								}
							} else if (xhr.status === 403) {
								var response = JSON.parse(xhr.responseText);
								frappe.msgprint({
									title: __('Not permitted'),
									indicator: 'red',
									message: response._error_message
								});
							} else {
								file.failed = true;
								var error = null;
								try {
									error = JSON.parse(xhr.responseText);
								} catch(e) {
									// pass
								}
								frappe.request.cleanup({}, error);
							}
						}
					};
					xhr.open('POST', '/api/method/upload_file', true);
					xhr.setRequestHeader('Accept', 'application/json');
					xhr.setRequestHeader('X-Frappe-CSRF-Token', frappe.csrf_token);

					var form_data = new FormData();
					if (file.file_obj) {
						form_data.append('file', file.file_obj, file.name);
					}
					form_data.append('is_private', +file.private);
					form_data.append('folder', this$1.folder);

					if (file.file_url) {
						form_data.append('file_url', file.file_url);
					}

					if (this$1.doctype && this$1.docname) {
						form_data.append('doctype', this$1.doctype);
						form_data.append('docname', this$1.docname);
					}

					if (this$1.fieldname) {
						form_data.append('fieldname', this$1.fieldname);
					}

					if (this$1.method) {
						form_data.append('method', this$1.method);
					}

					xhr.send(form_data);
				});
			},
			capture_image: function capture_image() {
				var this$1 = this;

				var capture = new frappe.ui.Capture({
					animate: false,
					error: true
				});
				capture.show();
				capture.submit(function (data_url) {
					var filename = "capture_" + (frappe.datetime.now_datetime().replaceAll(/[: -]/g, '_')) + ".png";
					this$1.url_to_file(data_url, filename, 'image/png').then(function (file) { return this$1.add_files([file]); }
					);
				});
			},
			url_to_file: function url_to_file(url, filename, mime_type) {
				return fetch(url)
						.then(function (res) { return res.arrayBuffer(); })
						.then(function (buffer) { return new File([buffer], filename, { type: mime_type }); });
			},
		}
	};

	/* script */
	            var __vue_script__$5 = script$5;
	            
	/* template */
	var __vue_render__$5 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      staticClass: "file-uploader",
	      on: {
	        dragover: function($event) {
	          $event.preventDefault();
	          return _vm.dragover($event)
	        },
	        dragleave: function($event) {
	          $event.preventDefault();
	          return _vm.dragleave($event)
	        },
	        drop: function($event) {
	          $event.preventDefault();
	          return _vm.dropfiles($event)
	        }
	      }
	    },
	    [
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value:
	                _vm.files.length === 0 &&
	                !_vm.show_file_browser &&
	                !_vm.show_web_link,
	              expression:
	                "files.length === 0 && !show_file_browser && !show_web_link"
	            }
	          ],
	          staticClass: "file-upload-area"
	        },
	        [
	          !_vm.is_dragging
	            ? _c("div", [
	                _c("div", { staticClass: "text-center" }, [
	                  _vm._v(
	                    "\n\t\t\t\t" +
	                      _vm._s(
	                        _vm.__("Drag and drop files here or upload from")
	                      ) +
	                      "\n\t\t\t"
	                  )
	                ]),
	                _vm._v(" "),
	                _c("div", { staticClass: "mt-2 text-center" }, [
	                  _c(
	                    "button",
	                    {
	                      staticClass: "btn btn-file-upload",
	                      on: { click: _vm.browse_files }
	                    },
	                    [
	                      _c(
	                        "svg",
	                        {
	                          attrs: {
	                            width: "30",
	                            height: "30",
	                            viewBox: "0 0 30 30",
	                            fill: "none",
	                            xmlns: "http://www.w3.org/2000/svg"
	                          }
	                        },
	                        [
	                          _c("circle", {
	                            attrs: {
	                              cx: "15",
	                              cy: "15",
	                              r: "15",
	                              fill: "url(#paint0_linear)"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d: "M13.5 22V19",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d: "M16.5 22V19",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d: "M10.5 22H19.5",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d: "M7.5 16H22.5",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d:
	                                "M21 8H9C8.17157 8 7.5 8.67157 7.5 9.5V17.5C7.5 18.3284 8.17157 19 9 19H21C21.8284 19 22.5 18.3284 22.5 17.5V9.5C22.5 8.67157 21.8284 8 21 8Z",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c(
	                            "defs",
	                            [
	                              _c(
	                                "linearGradient",
	                                {
	                                  attrs: {
	                                    id: "paint0_linear",
	                                    x1: "0",
	                                    y1: "0",
	                                    x2: "0",
	                                    y2: "30",
	                                    gradientUnits: "userSpaceOnUse"
	                                  }
	                                },
	                                [
	                                  _c("stop", {
	                                    attrs: { "stop-color": "#2C9AF1" }
	                                  }),
	                                  _vm._v(" "),
	                                  _c("stop", {
	                                    attrs: {
	                                      offset: "1",
	                                      "stop-color": "#2490EF"
	                                    }
	                                  })
	                                ],
	                                1
	                              )
	                            ],
	                            1
	                          )
	                        ]
	                      ),
	                      _vm._v(" "),
	                      _c("div", { staticClass: "mt-1" }, [
	                        _vm._v(_vm._s(_vm.__("My Device")))
	                      ])
	                    ]
	                  ),
	                  _vm._v(" "),
	                  _c("input", {
	                    ref: "file_input",
	                    staticClass: "hidden",
	                    attrs: {
	                      type: "file",
	                      multiple: _vm.allow_multiple,
	                      accept: _vm.restrictions.allowed_file_types.join(", ")
	                    },
	                    on: { change: _vm.on_file_input }
	                  }),
	                  _vm._v(" "),
	                  !_vm.disable_file_browser
	                    ? _c(
	                        "button",
	                        {
	                          staticClass: "btn btn-file-upload",
	                          on: {
	                            click: function($event) {
	                              _vm.show_file_browser = true;
	                            }
	                          }
	                        },
	                        [
	                          _c(
	                            "svg",
	                            {
	                              attrs: {
	                                width: "30",
	                                height: "30",
	                                viewBox: "0 0 30 30",
	                                fill: "none",
	                                xmlns: "http://www.w3.org/2000/svg"
	                              }
	                            },
	                            [
	                              _c("circle", {
	                                attrs: {
	                                  cx: "15",
	                                  cy: "15",
	                                  r: "15",
	                                  fill: "#48BB74"
	                                }
	                              }),
	                              _vm._v(" "),
	                              _c("path", {
	                                attrs: {
	                                  d:
	                                    "M13.0245 11.5H8C7.72386 11.5 7.5 11.7239 7.5 12V20C7.5 21.1046 8.39543 22 9.5 22H20.5C21.6046 22 22.5 21.1046 22.5 20V14.5C22.5 14.2239 22.2761 14 22 14H15.2169C15.0492 14 14.8926 13.9159 14.8 13.776L13.4414 11.724C13.3488 11.5841 13.1922 11.5 13.0245 11.5Z",
	                                  stroke: "white",
	                                  "stroke-miterlimit": "10",
	                                  "stroke-linecap": "square"
	                                }
	                              }),
	                              _vm._v(" "),
	                              _c("path", {
	                                attrs: {
	                                  d:
	                                    "M8.87939 9.5V8.5C8.87939 8.22386 9.10325 8 9.37939 8H20.6208C20.8969 8 21.1208 8.22386 21.1208 8.5V12",
	                                  stroke: "white",
	                                  "stroke-miterlimit": "10",
	                                  "stroke-linecap": "round",
	                                  "stroke-linejoin": "round"
	                                }
	                              })
	                            ]
	                          ),
	                          _vm._v(" "),
	                          _c("div", { staticClass: "mt-1" }, [
	                            _vm._v(_vm._s(_vm.__("Library")))
	                          ])
	                        ]
	                      )
	                    : _vm._e(),
	                  _vm._v(" "),
	                  _c(
	                    "button",
	                    {
	                      staticClass: "btn btn-file-upload",
	                      on: {
	                        click: function($event) {
	                          _vm.show_web_link = true;
	                        }
	                      }
	                    },
	                    [
	                      _c(
	                        "svg",
	                        {
	                          attrs: {
	                            width: "30",
	                            height: "30",
	                            viewBox: "0 0 30 30",
	                            fill: "none",
	                            xmlns: "http://www.w3.org/2000/svg"
	                          }
	                        },
	                        [
	                          _c("circle", {
	                            attrs: {
	                              cx: "15",
	                              cy: "15",
	                              r: "15",
	                              fill: "#ECAC4B"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d: "M12.0469 17.9543L17.9558 12.0454",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d:
	                                "M13.8184 11.4547L15.7943 9.47873C16.4212 8.85205 17.2714 8.5 18.1578 8.5C19.0443 8.5 19.8945 8.85205 20.5214 9.47873V9.47873C21.1481 10.1057 21.5001 10.9558 21.5001 11.8423C21.5001 12.7287 21.1481 13.5789 20.5214 14.2058L18.5455 16.1818",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          }),
	                          _vm._v(" "),
	                          _c("path", {
	                            attrs: {
	                              d:
	                                "M11.4547 13.8184L9.47873 15.7943C8.85205 16.4212 8.5 17.2714 8.5 18.1578C8.5 19.0443 8.85205 19.8945 9.47873 20.5214V20.5214C10.1057 21.1481 10.9558 21.5001 11.8423 21.5001C12.7287 21.5001 13.5789 21.1481 14.2058 20.5214L16.1818 18.5455",
	                              stroke: "white",
	                              "stroke-linecap": "round",
	                              "stroke-linejoin": "round"
	                            }
	                          })
	                        ]
	                      ),
	                      _vm._v(" "),
	                      _c("div", { staticClass: "mt-1" }, [
	                        _vm._v(_vm._s(_vm.__("Link")))
	                      ])
	                    ]
	                  ),
	                  _vm._v(" "),
	                  _vm.allow_take_photo
	                    ? _c(
	                        "button",
	                        {
	                          staticClass: "btn btn-file-upload",
	                          on: { click: _vm.capture_image }
	                        },
	                        [
	                          _c(
	                            "svg",
	                            {
	                              attrs: {
	                                width: "30",
	                                height: "30",
	                                viewBox: "0 0 30 30",
	                                fill: "none",
	                                xmlns: "http://www.w3.org/2000/svg"
	                              }
	                            },
	                            [
	                              _c("circle", {
	                                attrs: {
	                                  cx: "15",
	                                  cy: "15",
	                                  r: "15",
	                                  fill: "#CE315B"
	                                }
	                              }),
	                              _vm._v(" "),
	                              _c("path", {
	                                attrs: {
	                                  d:
	                                    "M11.5 10.5H9.5C8.67157 10.5 8 11.1716 8 12V20C8 20.8284 8.67157 21.5 9.5 21.5H20.5C21.3284 21.5 22 20.8284 22 20V12C22 11.1716 21.3284 10.5 20.5 10.5H18.5L17.3 8.9C17.1111 8.64819 16.8148 8.5 16.5 8.5H13.5C13.1852 8.5 12.8889 8.64819 12.7 8.9L11.5 10.5Z",
	                                  stroke: "white",
	                                  "stroke-linejoin": "round"
	                                }
	                              }),
	                              _vm._v(" "),
	                              _c("circle", {
	                                attrs: {
	                                  cx: "15",
	                                  cy: "16",
	                                  r: "2.5",
	                                  stroke: "white"
	                                }
	                              })
	                            ]
	                          ),
	                          _vm._v(" "),
	                          _c("div", { staticClass: "mt-1" }, [
	                            _vm._v(_vm._s(_vm.__("Camera")))
	                          ])
	                        ]
	                      )
	                    : _vm._e()
	                ]),
	                _vm._v(" "),
	                _c("div", { staticClass: "text-muted text-medium" }, [
	                  _vm._v("\n\t\t\t\t" + _vm._s(_vm.upload_notes) + "\n\t\t\t")
	                ])
	              ])
	            : _c("div", [
	                _vm._v(
	                  "\n\t\t\t" + _vm._s(_vm.__("Drop files here")) + "\n\t\t"
	                )
	              ])
	        ]
	      ),
	      _vm._v(" "),
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value:
	                _vm.files.length &&
	                !_vm.show_file_browser &&
	                !_vm.show_web_link,
	              expression: "files.length && !show_file_browser && !show_web_link"
	            }
	          ],
	          staticClass: "file-preview-area"
	        },
	        [
	          _c(
	            "div",
	            { staticClass: "file-preview-container" },
	            _vm._l(_vm.files, function(file, i) {
	              return _c("FilePreview", {
	                key: file.name,
	                attrs: { file: file },
	                on: {
	                  remove: function($event) {
	                    return _vm.remove_file(file)
	                  },
	                  toggle_private: function($event) {
	                    file.private = !file.private;
	                  }
	                }
	              })
	            }),
	            1
	          ),
	          _vm._v(" "),
	          _vm.show_upload_button && _vm.currently_uploading === -1
	            ? _c("div", { staticClass: "flex align-center" }, [
	                _c(
	                  "button",
	                  {
	                    staticClass: "btn btn-primary btn-sm margin-right",
	                    on: { click: _vm.upload_files }
	                  },
	                  [
	                    _vm.files.length === 1
	                      ? _c("span", [
	                          _vm._v(
	                            "\n\t\t\t\t\t" +
	                              _vm._s(_vm.__("Upload file")) +
	                              "\n\t\t\t\t"
	                          )
	                        ])
	                      : _c("span", [
	                          _vm._v(
	                            "\n\t\t\t\t\t" +
	                              _vm._s(
	                                _vm.__("Upload {0} files", [_vm.files.length])
	                              ) +
	                              "\n\t\t\t\t"
	                          )
	                        ])
	                  ]
	                ),
	                _vm._v(" "),
	                _c("div", { staticClass: "text-muted text-medium" }, [
	                  _vm._v(
	                    "\n\t\t\t\t" +
	                      _vm._s(
	                        _vm.__(
	                          "Click on the lock icon to toggle public/private"
	                        )
	                      ) +
	                      "\n\t\t\t"
	                  )
	                ])
	              ])
	            : _vm._e()
	        ]
	      ),
	      _vm._v(" "),
	      _vm.show_file_browser && !_vm.disable_file_browser
	        ? _c("FileBrowser", {
	            ref: "file_browser",
	            on: {
	              "hide-browser": function($event) {
	                _vm.show_file_browser = false;
	              }
	            }
	          })
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.show_web_link
	        ? _c("WebLink", {
	            ref: "web_link",
	            on: {
	              "hide-web-link": function($event) {
	                _vm.show_web_link = false;
	              }
	            }
	          })
	        : _vm._e()
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$5 = [];
	__vue_render__$5._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$5 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-0dbe907c_0", { source: "\n.file-upload-area {\n\tmin-height: 16rem;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tborder: 1px dashed var(--dark-border-color);\n\tborder-radius: var(--border-radius);\n\tcursor: pointer;\n\tbackground-color: var(--bg-color);\n}\n.btn-file-upload {\n\tbackground-color: transparent;\n\tborder: none;\n\tbox-shadow: none;\n\tfont-size: var(--text-xs);\n}\n", map: {"version":3,"sources":["/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/FileUploader.vue"],"names":[],"mappings":";AAgcA;CACA,iBAAA;CACA,aAAA;CACA,mBAAA;CACA,uBAAA;CACA,2CAAA;CACA,mCAAA;CACA,eAAA;CACA,iCAAA;AACA;AAEA;CACA,6BAAA;CACA,YAAA;CACA,gBAAA;CACA,yBAAA;AACA","file":"FileUploader.vue","sourcesContent":["<template>\n\t<div class=\"file-uploader\"\n\t\t@dragover.prevent=\"dragover\"\n\t\t@dragleave.prevent=\"dragleave\"\n\t\t@drop.prevent=\"dropfiles\"\n\t>\n\t\t<div\n\t\t\tclass=\"file-upload-area\"\n\t\t\tv-show=\"files.length === 0 && !show_file_browser && !show_web_link\"\n\t\t>\n\t\t\t<div v-if=\"!is_dragging\">\n\t\t\t\t<div class=\"text-center\">\n\t\t\t\t\t{{ __('Drag and drop files here or upload from') }}\n\t\t\t\t</div>\n\t\t\t\t<div class=\"mt-2 text-center\">\n\t\t\t\t\t<button class=\"btn btn-file-upload\" @click=\"browse_files\">\n\t\t\t\t\t\t<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<circle cx=\"15\" cy=\"15\" r=\"15\" fill=\"url(#paint0_linear)\"/>\n\t\t\t\t\t\t\t<path d=\"M13.5 22V19\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<path d=\"M16.5 22V19\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<path d=\"M10.5 22H19.5\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<path d=\"M7.5 16H22.5\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<path d=\"M21 8H9C8.17157 8 7.5 8.67157 7.5 9.5V17.5C7.5 18.3284 8.17157 19 9 19H21C21.8284 19 22.5 18.3284 22.5 17.5V9.5C22.5 8.67157 21.8284 8 21 8Z\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<defs>\n\t\t\t\t\t\t\t<linearGradient id=\"paint0_linear\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"30\" gradientUnits=\"userSpaceOnUse\">\n\t\t\t\t\t\t\t<stop stop-color=\"#2C9AF1\"/>\n\t\t\t\t\t\t\t<stop offset=\"1\" stop-color=\"#2490EF\"/>\n\t\t\t\t\t\t\t</linearGradient>\n\t\t\t\t\t\t\t</defs>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t<div class=\"mt-1\">{{ __('My Device') }}</div>\n\t\t\t\t\t</button>\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\tclass=\"hidden\"\n\t\t\t\t\t\tref=\"file_input\"\n\t\t\t\t\t\t@change=\"on_file_input\"\n\t\t\t\t\t\t:multiple=\"allow_multiple\"\n\t\t\t\t\t\t:accept=\"restrictions.allowed_file_types.join(', ')\"\n\t\t\t\t\t>\n\t\t\t\t\t<button class=\"btn btn-file-upload\" v-if=\"!disable_file_browser\" @click=\"show_file_browser = true\">\n\t\t\t\t\t\t<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<circle cx=\"15\" cy=\"15\" r=\"15\" fill=\"#48BB74\"/>\n\t\t\t\t\t\t\t<path d=\"M13.0245 11.5H8C7.72386 11.5 7.5 11.7239 7.5 12V20C7.5 21.1046 8.39543 22 9.5 22H20.5C21.6046 22 22.5 21.1046 22.5 20V14.5C22.5 14.2239 22.2761 14 22 14H15.2169C15.0492 14 14.8926 13.9159 14.8 13.776L13.4414 11.724C13.3488 11.5841 13.1922 11.5 13.0245 11.5Z\" stroke=\"white\" stroke-miterlimit=\"10\" stroke-linecap=\"square\"/>\n\t\t\t\t\t\t\t<path d=\"M8.87939 9.5V8.5C8.87939 8.22386 9.10325 8 9.37939 8H20.6208C20.8969 8 21.1208 8.22386 21.1208 8.5V12\" stroke=\"white\" stroke-miterlimit=\"10\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t<div class=\"mt-1\">{{ __('Library') }}</div>\n\t\t\t\t\t</button>\n\t\t\t\t\t<button class=\"btn btn-file-upload\" @click=\"show_web_link = true\">\n\t\t\t\t\t\t<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<circle cx=\"15\" cy=\"15\" r=\"15\" fill=\"#ECAC4B\"/>\n\t\t\t\t\t\t\t<path d=\"M12.0469 17.9543L17.9558 12.0454\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<path d=\"M13.8184 11.4547L15.7943 9.47873C16.4212 8.85205 17.2714 8.5 18.1578 8.5C19.0443 8.5 19.8945 8.85205 20.5214 9.47873V9.47873C21.1481 10.1057 21.5001 10.9558 21.5001 11.8423C21.5001 12.7287 21.1481 13.5789 20.5214 14.2058L18.5455 16.1818\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<path d=\"M11.4547 13.8184L9.47873 15.7943C8.85205 16.4212 8.5 17.2714 8.5 18.1578C8.5 19.0443 8.85205 19.8945 9.47873 20.5214V20.5214C10.1057 21.1481 10.9558 21.5001 11.8423 21.5001C12.7287 21.5001 13.5789 21.1481 14.2058 20.5214L16.1818 18.5455\" stroke=\"white\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t<div class=\"mt-1\">{{ __('Link') }}</div>\n\t\t\t\t\t</button>\n\t\t\t\t\t<button v-if=\"allow_take_photo\" class=\"btn btn-file-upload\" @click=\"capture_image\">\n\t\t\t\t\t\t<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t\t\t\t<circle cx=\"15\" cy=\"15\" r=\"15\" fill=\"#CE315B\"/>\n\t\t\t\t\t\t\t<path d=\"M11.5 10.5H9.5C8.67157 10.5 8 11.1716 8 12V20C8 20.8284 8.67157 21.5 9.5 21.5H20.5C21.3284 21.5 22 20.8284 22 20V12C22 11.1716 21.3284 10.5 20.5 10.5H18.5L17.3 8.9C17.1111 8.64819 16.8148 8.5 16.5 8.5H13.5C13.1852 8.5 12.8889 8.64819 12.7 8.9L11.5 10.5Z\" stroke=\"white\" stroke-linejoin=\"round\"/>\n\t\t\t\t\t\t\t<circle cx=\"15\" cy=\"16\" r=\"2.5\" stroke=\"white\"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t<div class=\"mt-1\">{{ __('Camera') }}</div>\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"text-muted text-medium\">\n\t\t\t\t\t{{ upload_notes }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div v-else>\n\t\t\t\t{{ __('Drop files here') }}\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"file-preview-area\" v-show=\"files.length && !show_file_browser && !show_web_link\">\n\t\t\t<div class=\"file-preview-container\">\n\t\t\t\t<FilePreview\n\t\t\t\t\tv-for=\"(file, i) in files\"\n\t\t\t\t\t:key=\"file.name\"\n\t\t\t\t\t:file=\"file\"\n\t\t\t\t\t@remove=\"remove_file(file)\"\n\t\t\t\t\t@toggle_private=\"file.private = !file.private\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div class=\"flex align-center\" v-if=\"show_upload_button && currently_uploading === -1\">\n\t\t\t\t<button\n\t\t\t\t\tclass=\"btn btn-primary btn-sm margin-right\"\n\t\t\t\t\t@click=\"upload_files\"\n\t\t\t\t>\n\t\t\t\t\t<span v-if=\"files.length === 1\">\n\t\t\t\t\t\t{{ __('Upload file') }}\n\t\t\t\t\t</span>\n\t\t\t\t\t<span v-else>\n\t\t\t\t\t\t{{ __('Upload {0} files', [files.length]) }}\n\t\t\t\t\t</span>\n\t\t\t\t</button>\n\t\t\t\t<div class=\"text-muted text-medium\">\n\t\t\t\t\t{{ __('Click on the lock icon to toggle public/private') }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<FileBrowser\n\t\t\tref=\"file_browser\"\n\t\t\tv-if=\"show_file_browser && !disable_file_browser\"\n\t\t\t@hide-browser=\"show_file_browser = false\"\n\t\t/>\n\t\t<WebLink\n\t\t\tref=\"web_link\"\n\t\t\tv-if=\"show_web_link\"\n\t\t\t@hide-web-link=\"show_web_link = false\"\n\t\t/>\n\t</div>\n</template>\n\n<script>\nimport FilePreview from './FilePreview.vue';\nimport FileBrowser from './FileBrowser.vue';\nimport WebLink from './WebLink.vue';\n\nexport default {\n\tname: 'FileUploader',\n\tprops: {\n\t\tshow_upload_button: {\n\t\t\tdefault: true\n\t\t},\n\t\tdisable_file_browser: {\n\t\t\tdefault: false\n\t\t},\n\t\tallow_multiple: {\n\t\t\tdefault: true\n\t\t},\n\t\tas_dataurl: {\n\t\t\tdefault: false\n\t\t},\n\t\tdoctype: {\n\t\t\tdefault: null\n\t\t},\n\t\tdocname: {\n\t\t\tdefault: null\n\t\t},\n\t\tfieldname: {\n\t\t\tdefault: null\n\t\t},\n\t\tfolder: {\n\t\t\tdefault: 'Home'\n\t\t},\n\t\tmethod: {\n\t\t\tdefault: null\n\t\t},\n\t\ton_success: {\n\t\t\tdefault: null\n\t\t},\n\t\trestrictions: {\n\t\t\tdefault: () => ({\n\t\t\t\tmax_file_size: null, // 2048 -> 2KB\n\t\t\t\tmax_number_of_files: null,\n\t\t\t\tallowed_file_types: [] // ['image/*', 'video/*', '.jpg', '.gif', '.pdf']\n\t\t\t})\n\t\t},\n\t\tupload_notes: {\n\t\t\tdefault: null // \"Images or video, upto 2MB\"\n\t\t}\n\t},\n\tcomponents: {\n\t\tFilePreview,\n\t\tFileBrowser,\n\t\tWebLink\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tfiles: [],\n\t\t\tis_dragging: false,\n\t\t\tcurrently_uploading: -1,\n\t\t\tshow_file_browser: false,\n\t\t\tshow_web_link: false,\n\t\t}\n\t},\n\twatch: {\n\t\tfiles(newvalue, oldvalue) {\n\t\t\tif (!this.allow_multiple && newvalue.length > 1) {\n\t\t\t\tthis.files = [newvalue[newvalue.length - 1]];\n\t\t\t}\n\t\t}\n\t},\n\tcomputed: {\n\t\tupload_complete() {\n\t\t\treturn this.files.length > 0\n\t\t\t\t&& this.files.every(\n\t\t\t\t\tfile => file.total !== 0 && file.progress === file.total);\n\t\t},\n\t\tallow_take_photo() {\n\t\t\treturn window.navigator.mediaDevices;\n\t\t}\n\t},\n\tmethods: {\n\t\tdragover() {\n\t\t\tthis.is_dragging = true;\n\t\t},\n\t\tdragleave() {\n\t\t\tthis.is_dragging = false;\n\t\t},\n\t\tdropfiles(e) {\n\t\t\tthis.is_dragging = false;\n\t\t\tthis.add_files(e.dataTransfer.files);\n\t\t},\n\t\tbrowse_files() {\n\t\t\tthis.$refs.file_input.click();\n\t\t},\n\t\ton_file_input(e) {\n\t\t\tthis.add_files(this.$refs.file_input.files);\n\t\t},\n\t\tremove_file(file) {\n\t\t\tthis.files = this.files.filter(f => f !== file);\n\t\t},\n\t\ttoggle_all_private() {\n\t\t\tlet flag;\n\t\t\tlet private_values = this.files.filter(file => file.private);\n\t\t\tif (private_values.length < this.files.length) {\n\t\t\t\t// there are some private and some public\n\t\t\t\t// set all to private\n\t\t\t\tflag = true;\n\t\t\t} else {\n\t\t\t\t// all are private, set all to public\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tthis.files = this.files.map(file => {\n\t\t\t\tfile.private = flag;\n\t\t\t\treturn file;\n\t\t\t});\n\t\t},\n\t\tadd_files(file_array) {\n\t\t\tlet files = Array.from(file_array)\n\t\t\t\t.filter(this.check_restrictions)\n\t\t\t\t.map(file => {\n\t\t\t\t\tlet is_image = file.type.startsWith('image');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfile_obj: file,\n\t\t\t\t\t\tname: file.name,\n\t\t\t\t\t\tdoc: null,\n\t\t\t\t\t\tprogress: 0,\n\t\t\t\t\t\ttotal: 0,\n\t\t\t\t\t\tfailed: false,\n\t\t\t\t\t\tuploading: false,\n\t\t\t\t\t\tprivate: !is_image\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.files = this.files.concat(files);\n\t\t},\n\t\tcheck_restrictions(file) {\n\t\t\tlet { max_file_size, allowed_file_types } = this.restrictions;\n\n\t\t\tlet mime_type = file.type;\n\t\t\tlet extension = '.' + file.name.split('.').pop();\n\n\t\t\tlet is_correct_type = true;\n\t\t\tlet valid_file_size = true;\n\n\t\t\tif (allowed_file_types.length) {\n\t\t\t\tis_correct_type = allowed_file_types.some((type) => {\n\t\t\t\t\t// is this is a mime-type\n\t\t\t\t\tif (type.includes('/')) {\n\t\t\t\t\t\tif (!file.type) return false;\n\t\t\t\t\t\treturn file.type.match(type);\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise this is likely an extension\n\t\t\t\t\tif (type[0] === '.') {\n\t\t\t\t\t\treturn file.name.endsWith(type);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (max_file_size && file.size != null) {\n\t\t\t\tvalid_file_size = file.size < max_file_size;\n\t\t\t}\n\n\t\t\tif (!is_correct_type) {\n\t\t\t\tconsole.warn('File skipped because of invalid file type', file);\n\t\t\t}\n\t\t\tif (!valid_file_size) {\n\t\t\t\tconsole.warn('File skipped because of invalid file size', file.size, file);\n\t\t\t}\n\n\t\t\treturn is_correct_type && valid_file_size;\n\t\t},\n\t\tupload_files() {\n\t\t\tif (this.show_file_browser) {\n\t\t\t\treturn this.upload_via_file_browser();\n\t\t\t}\n\t\t\tif (this.show_web_link) {\n\t\t\t\treturn this.upload_via_web_link();\n\t\t\t}\n\t\t\tif (this.as_dataurl) {\n\t\t\t\treturn this.return_as_dataurl();\n\t\t\t}\n\t\t\treturn frappe.run_serially(\n\t\t\t\tthis.files.map(\n\t\t\t\t\t(file, i) =>\n\t\t\t\t\t\t() => this.upload_file(file, i)\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\tupload_via_file_browser() {\n\t\t\tlet selected_file = this.$refs.file_browser.selected_node;\n\t\t\tif (!selected_file.value) {\n\t\t\t\tfrappe.msgprint(__('Click on a file to select it.'));\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\n\t\t\treturn this.upload_file({\n\t\t\t\tfile_url: selected_file.file_url\n\t\t\t});\n\t\t},\n\t\tupload_via_web_link() {\n\t\t\tlet file_url = this.$refs.web_link.url;\n\t\t\tif (!file_url) {\n\t\t\t\tfrappe.msgprint(__('Invalid URL'));\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\t\t\tfile_url = decodeURI(file_url)\n\t\t\treturn this.upload_file({\n\t\t\t\tfile_url\n\t\t\t});\n\t\t},\n\t\treturn_as_dataurl() {\n\t\t\tlet promises = this.files.map(file =>\n\t\t\t\tfrappe.dom.file_to_base64(file.file_obj)\n\t\t\t\t\t.then(dataurl => {\n\t\t\t\t\t\tfile.dataurl = dataurl;\n\t\t\t\t\t\tthis.on_success && this.on_success(file);\n\t\t\t\t\t})\n\t\t\t);\n\t\t\treturn Promise.all(promises);\n\t\t},\n\t\tupload_file(file, i) {\n\t\t\tthis.currently_uploading = i;\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet xhr = new XMLHttpRequest();\n\t\t\t\txhr.upload.addEventListener('loadstart', (e) => {\n\t\t\t\t\tfile.uploading = true;\n\t\t\t\t})\n\t\t\t\txhr.upload.addEventListener('progress', (e) => {\n\t\t\t\t\tif (e.lengthComputable) {\n\t\t\t\t\t\tfile.progress = e.loaded;\n\t\t\t\t\t\tfile.total = e.total;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\txhr.upload.addEventListener('load', (e) => {\n\t\t\t\t\tfile.uploading = false;\n\t\t\t\t\tresolve();\n\t\t\t\t})\n\t\t\t\txhr.addEventListener('error', (e) => {\n\t\t\t\t\tfile.failed = true;\n\t\t\t\t\treject();\n\t\t\t\t})\n\t\t\t\txhr.onreadystatechange = () => {\n\t\t\t\t\tif (xhr.readyState == XMLHttpRequest.DONE) {\n\t\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\t\tlet r = null;\n\t\t\t\t\t\t\tlet file_doc = null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tr = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t\tif (r.message.doctype === 'File') {\n\t\t\t\t\t\t\t\t\tfile_doc = r.message;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\tr = xhr.responseText;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfile.doc = file_doc;\n\n\t\t\t\t\t\t\tif (this.on_success) {\n\t\t\t\t\t\t\t\tthis.on_success(file_doc, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (xhr.status === 403) {\n\t\t\t\t\t\t\tlet response = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\tfrappe.msgprint({\n\t\t\t\t\t\t\t\ttitle: __('Not permitted'),\n\t\t\t\t\t\t\t\tindicator: 'red',\n\t\t\t\t\t\t\t\tmessage: response._error_message\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfile.failed = true;\n\t\t\t\t\t\t\tlet error = null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\terror = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\t// pass\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfrappe.request.cleanup({}, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txhr.open('POST', '/api/method/upload_file', true);\n\t\t\t\txhr.setRequestHeader('Accept', 'application/json');\n\t\t\t\txhr.setRequestHeader('X-Frappe-CSRF-Token', frappe.csrf_token);\n\n\t\t\t\tlet form_data = new FormData();\n\t\t\t\tif (file.file_obj) {\n\t\t\t\t\tform_data.append('file', file.file_obj, file.name);\n\t\t\t\t}\n\t\t\t\tform_data.append('is_private', +file.private);\n\t\t\t\tform_data.append('folder', this.folder);\n\n\t\t\t\tif (file.file_url) {\n\t\t\t\t\tform_data.append('file_url', file.file_url);\n\t\t\t\t}\n\n\t\t\t\tif (this.doctype && this.docname) {\n\t\t\t\t\tform_data.append('doctype', this.doctype);\n\t\t\t\t\tform_data.append('docname', this.docname);\n\t\t\t\t}\n\n\t\t\t\tif (this.fieldname) {\n\t\t\t\t\tform_data.append('fieldname', this.fieldname);\n\t\t\t\t}\n\n\t\t\t\tif (this.method) {\n\t\t\t\t\tform_data.append('method', this.method);\n\t\t\t\t}\n\n\t\t\t\txhr.send(form_data);\n\t\t\t});\n\t\t},\n\t\tcapture_image() {\n\t\t\tconst capture = new frappe.ui.Capture({\n\t\t\t\tanimate: false,\n\t\t\t\terror: true\n\t\t\t});\n\t\t\tcapture.show();\n\t\t\tcapture.submit(data_url => {\n\t\t\t\tlet filename = `capture_${frappe.datetime.now_datetime().replaceAll(/[: -]/g, '_')}.png`;\n\t\t\t\tthis.url_to_file(data_url, filename, 'image/png').then((file) =>\n\t\t\t\t\tthis.add_files([file])\n\t\t\t\t);\n\t\t\t});\n\t\t},\n\t\turl_to_file(url, filename, mime_type) {\n\t\t\treturn fetch(url)\n\t\t\t\t\t.then(res => res.arrayBuffer())\n\t\t\t\t\t.then(buffer => new File([buffer], filename, { type: mime_type }));\n\t\t},\n\t}\n}\n</script>\n<style>\n.file-upload-area {\n\tmin-height: 16rem;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tborder: 1px dashed var(--dark-border-color);\n\tborder-radius: var(--border-radius);\n\tcursor: pointer;\n\tbackground-color: var(--bg-color);\n}\n\n.btn-file-upload {\n\tbackground-color: transparent;\n\tborder: none;\n\tbox-shadow: none;\n\tfont-size: var(--text-xs);\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$5 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$5 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$5 = false;
	  /* component normalizer */
	  function __vue_normalize__$5(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/user/erpnext-pro/erp-next/apps/frappe/frappe/public/js/frappe/file_uploader/FileUploader.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$5() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FileUploaderComponent = __vue_normalize__$5(
	    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
	    __vue_inject_styles__$5,
	    __vue_script__$5,
	    __vue_scope_id__$5,
	    __vue_is_functional_template__$5,
	    __vue_module_identifier__$5,
	    __vue_create_injector__$5,
	    undefined
	  );

	class FileUploader {
		constructor(ref) {
		var this$1 = this;
		if ( ref === void 0 ) ref = {};
		var wrapper = ref.wrapper;
		var method = ref.method;
		var on_success = ref.on_success;
		var doctype = ref.doctype;
		var docname = ref.docname;
		var fieldname = ref.fieldname;
		var files = ref.files;
		var folder = ref.folder;
		var restrictions = ref.restrictions;
		var upload_notes = ref.upload_notes;
		var allow_multiple = ref.allow_multiple;
		var as_dataurl = ref.as_dataurl;
		var disable_file_browser = ref.disable_file_browser;
		var frm = ref.frm;


			frm && frm.attachments.max_reached(true);

			if (!wrapper) {
				this.make_dialog();
			} else {
				this.wrapper = wrapper.get ? wrapper.get(0) : wrapper;
			}

			this.$fileuploader = new Vue({
				el: this.wrapper,
				render: function (h) { return h(FileUploaderComponent, {
					props: {
						show_upload_button: !Boolean(this$1.dialog),
						doctype: doctype,
						docname: docname,
						fieldname: fieldname,
						method: method,
						folder: folder,
						on_success: on_success,
						restrictions: restrictions,
						upload_notes: upload_notes,
						allow_multiple: allow_multiple,
						as_dataurl: as_dataurl,
						disable_file_browser: disable_file_browser,
					}
				}); }
			});

			this.uploader = this.$fileuploader.$children[0];

			this.uploader.$watch('files', function (files) {
				var all_private = files.every(function (file) { return file.private; });
				if (this$1.dialog) {
					this$1.dialog.set_secondary_action_label(all_private ? __('Set all public') : __('Set all private'));
				}
			}, { deep: true });

			if (files && files.length) {
				this.uploader.add_files(files);
			}
		}

		upload_files() {
			var this$1 = this;

			this.dialog && this.dialog.get_primary_btn().prop('disabled', true);
			return this.uploader.upload_files()
				.then(function () {
					this$1.dialog && this$1.dialog.hide();
				});
		}

		make_dialog() {
			var this$1 = this;

			this.dialog = new frappe.ui.Dialog({
				title: __('Upload'),
				primary_action_label: __('Upload'),
				primary_action: function () { return this$1.upload_files(); },
				secondary_action_label: __('Set all private'),
				secondary_action: function () {
					this$1.uploader.toggle_all_private();
				}
			});

			this.wrapper = this.dialog.body;
			this.dialog.show();
			this.dialog.$wrapper.on('hidden.bs.modal', function() {
				$(this).data('bs.modal', null);
				$(this).remove();
			});
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.ui');
	frappe.ui.FileUploader = FileUploader;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.ui');

	frappe.ui.Tree = class {
		constructor(ref) {
		var parent = ref.parent;
		var label = ref.label;
		var root_value = ref.root_value;
		var icon_set = ref.icon_set;
		var toolbar = ref.toolbar;
		var expandable = ref.expandable;
		var with_skeleton = ref.with_skeleton; if ( with_skeleton === void 0 ) with_skeleton = 1;
		var args = ref.args;
		var method = ref.method;
		var get_label = ref.get_label;
		var on_render = ref.on_render;
		var on_click = ref.on_click;

			$.extend(this, arguments[0]);
			if (root_value == null) {
				this.root_value = label;
			}
			this.setup_treenode_class();
			this.nodes = {};
			this.wrapper = $('<div class="tree">').appendTo(this.parent);
			if (with_skeleton) { this.wrapper.addClass('with-skeleton'); }

			if (!icon_set) {
				this.icon_set = {
					open: frappe.utils.icon('folder-open', 'md'),
					closed: frappe.utils.icon('folder-normal', 'md'),
					leaf: frappe.utils.icon('primitive-dot', 'xs')
				};
			}

			this.setup_root_node();
		}

		get_nodes(value, is_root) {
			var this$1 = this;

			var args = Object.assign({}, this.args);
			args.parent = value;
			args.is_root = is_root;

			return new Promise(function (resolve) {
				frappe.call({
					method: this$1.method,
					args: args,
					callback: function (r) {
						resolve(r.message);
					}
				});
			});
		}

		get_all_nodes(value, is_root, label) {
			var args = Object.assign({}, this.args);
			args.label = label || value;
			args.parent = value;
			args.is_root = is_root;

			args.tree_method = this.method;

			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.desk.treeview.get_all_nodes',
					args: args,
					callback: function (r) {
						resolve(r.message);
					}
				});
			});
		}

		setup_treenode_class() {
			var tree = this;
			this.TreeNode = class {
				constructor(ref) {
				var parent = ref.parent;
				var label = ref.label;
				var parent_label = ref.parent_label;
				var expandable = ref.expandable;
				var is_root = ref.is_root;
				var data = ref.data;

					$.extend(this, arguments[0]);
					this.loaded = 0;
					this.expanded = 0;
					if(this.parent_label){
						this.parent_node = tree.nodes[this.parent_label];
					}

					tree.nodes[this.label] = this;
					tree.make_node_element(this);
					tree.on_render && tree.on_render(this);
				}
			};
		}

		setup_root_node() {
			this.root_node = new this.TreeNode({
				parent: this.wrapper,
				label: this.label,
				parent_label: null,
				expandable: true,
				is_root: true,
				data: {
					value: this.root_value
				}
			});
			this.expand_node(this.root_node, false);
		}

		refresh() {
			this.selected_node.parent_node &&
				this.load_children(this.selected_node.parent_node, true);
		}

		make_node_element(node) {
			node.$tree_link = $('<span class="tree-link">')
				.attr('data-label', node.label)
				.data('node', node)
				.appendTo(node.parent);

			node.$ul = $('<ul class="tree-children">')
				.hide().appendTo(node.parent);

			this.make_icon_and_label(node);
			if(this.toolbar) {
				node.$toolbar = this.get_toolbar(node).insertAfter(node.$tree_link);
			}
		}

		add_node(node, data) {
			var $li = $('<li class="tree-node">');

			return new this.TreeNode({
				parent: $li.appendTo(node.$ul),
				parent_label: node.label,
				label: data.value,
				title: data.title,
				expandable: data.expandable,
				data: data
			});
		}

		reload_node(node) {
			this.load_children(node);
		}

		toggle() {
			this.get_selected_node().toggle();
		}

		get_selected_node() {
			return this.selected_node;
		}

		set_selected_node(node) {
			this.selected_node = node;
		}

		load_children(node, deep) {
			var this$1 = this;
			if ( deep === void 0 ) deep=false;

			var lab = node.label, value = node.data.value, is_root = node.is_root;

			if(!deep) {
				frappe.run_serially([
					function () { return this$1.get_nodes(value, is_root); },
					function (data_set) { return this$1.render_node_children(node, data_set); },
					function () { return this$1.set_selected_node(node); }
				]);
			} else {
				frappe.run_serially([
					function () { return this$1.get_all_nodes(value, is_root, lab); },
					function (data_list) { return this$1.render_children_of_all_nodes(data_list); },
					function () { return this$1.set_selected_node(node); }
				]);
			}
		}

		render_children_of_all_nodes(data_list) {
			var this$1 = this;

			data_list.map(function (d) { return this$1.render_node_children(this$1.nodes[d.parent], d.data); });
		}

		render_node_children(node, data_set) {
			var this$1 = this;

			node.$ul.empty();
			if (data_set) {
				$.each(data_set, function (i, data) {
					var child_node = this$1.add_node(node, data);
					child_node.$tree_link
						.data('node-data', data)
						.data('node', child_node);
				});
			}

			node.expanded = false;

			// As children loaded
			node.loaded = true;
			this.expand_node(node);
		}

		on_node_click(node) {
			this.expand_node(node);
			frappe.dom.activate(this.wrapper, node.$tree_link, 'tree-link');
			if(node.$toolbar) { this.show_toolbar(node); }
		}

		expand_node(node, click) {
			if ( click === void 0 ) click = true;

			this.set_selected_node(node);

			if(click) {
				this.on_click && this.on_click(node);
			}

			if(node.expandable) {
				this.toggle_node(node);
			}
			this.select_link(node);

			node.expanded = !node.expanded;
			node.parent.toggleClass('opened', node.expanded);
		}

		toggle_node(node) {
			if(node.expandable && this.get_nodes && !node.loaded) {
				return this.load_children(node);
			}

			// expand children
			if(node.$ul) {
				if(node.$ul.children().length) {
					node.$ul.toggle(!node.expanded);
				}

				// open close icon
				if(this.icon_set) {
					if(!node.expanded) {
						node.$tree_link.find('.icon').parent().html(this.icon_set.open);
					} else {
						node.$tree_link.find('.icon').parent().addClass('node-parent').html(this.icon_set.closed);
					}
				}
			}
		}

		select_link(node) {
			this.wrapper.find('.selected')
				.removeClass('selected');
			node.$tree_link.toggleClass('selected');
		}

		show_toolbar(node) {
			if(this.cur_toolbar)
				{ $(this.cur_toolbar).hide(); }
			this.cur_toolbar = node.$toolbar;
			node.$toolbar.show();
		}

		get_node_label(node) {
			if(this.get_label) {
				return this.get_label(node);
			}
			if (node.title && node.title != node.label) {
				return __(node.title) + " <span class='text-muted'>(" + (node.label) + ")</span>";
			} else {
				return __(node.title || node.label);
			}
		}

		make_icon_and_label(node) {
			var this$1 = this;

			var icon_html = '';
			if(this.icon_set) {
				if(node.expandable) {
					icon_html = "<span class=\"node-parent\">" + (this.icon_set.closed) + "</span>";
				} else {
					icon_html = "<span>" + (this.icon_set.leaf) + "</span>";
				}
			}

			$(icon_html).appendTo(node.$tree_link);
			$(("<a class=\"tree-label\"> " + (this.get_node_label(node)) + "</a>")).appendTo(node.$tree_link);

			node.$tree_link.on('click', function () {
				setTimeout(function () {this$1.on_node_click(node);}, 100);
			});

			node.$tree_link.hover(
				function() {
					$(this).parent().addClass('hover-active');
				},
				function() {
					$(this).parent().removeClass('hover-active');
				}
			);
		}

		get_toolbar(node) {
			var this$1 = this;

			var $toolbar = $('<span class="tree-node-toolbar btn-group"></span>').hide();

			Object.keys(this.toolbar).map(function (key) {
				var obj = this$1.toolbar[key];
				if(!obj.label) { return; }
				if(obj.condition && !obj.condition(node)) { return; }

				var label = obj.get_label ? obj.get_label() : obj.label;
				var $link = $("<button class='btn btn-default btn-xs'></button>")
					.html(label)
					.addClass('tree-toolbar-button ' + (obj.btnClass || ''))
					.appendTo($toolbar);
				$link.on('click', function () {
					obj.click(node);
					this$1.refresh();
				});
			});

			return $toolbar;
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// page container
	frappe.provide('frappe.pages');
	frappe.provide('frappe.views');

	window.cur_page = null;
	frappe.views.Container = Class.extend({
		_intro: "Container contains pages inside `#container` and manages \
			page creation, switching",
		init: function() {
			this.container = $('#body').get(0);
			this.page = null; // current page
			this.pagewidth = $(this.container).width();
			this.pagemargin = 50;

			var me = this;

			$(document).on("page-change", function() {
				// set data-route in body
				var route_str = frappe.get_route_str();
				$("body").attr("data-route", route_str);
				$("body").attr("data-sidebar", me.has_sidebar() ? 1 : 0);
			});

			$(document).bind('rename', function(event, dt, old_name, new_name) {
				frappe.breadcrumbs.rename(dt, old_name, new_name);
			});
		},
		add_page: function(label) {
			var page = $('<div class="content page-container"></div>')
				.attr('id', "page-" + label)
				.attr("data-page-route", label)
				.hide()
				.appendTo(this.container).get(0);
			page.label = label;
			frappe.pages[label] = page;

			return page;
		},
		change_to: function(label) {
			cur_page = this;
			if(this.page && this.page.label === label) {
				$(this.page).trigger('show');
				return;
			}
			if(label.tagName) {
				// if sent the div, get the table
				var page = label;
			} else {
				var page = frappe.pages[label];
			}
			if(!page) {
				console.log(__('Page not found')+ ': ' + label);
				return;
			}

			// hide dialog
			if(window.cur_dialog && cur_dialog.display && !cur_dialog.keep_open) {
				if (!cur_dialog.minimizable) {
					cur_dialog.hide();
				} else if (!cur_dialog.is_minimized) {
					cur_dialog.toggle_minimize();
				}
			}

			// hide current
			if(this.page && this.page != page) {
				$(this.page).hide();
				$(this.page).trigger('hide');
			}

			// show new
			if(!this.page || this.page != page) {
				this.page = page;
				// $(this.page).fadeIn(300);
				$(this.page).show();
			}

			$(document).trigger("page-change");

			this.page._route = frappe.router.get_sub_path();
			$(this.page).trigger('show');
			!this.page.disable_scroll_to_top && frappe.utils.scroll_to(0);
			frappe.breadcrumbs.update();

			return this.page;
		},
		has_sidebar: function() {
			var flag = 0;
			var route_str = frappe.get_route_str();
			// check in frappe.ui.pages
			flag = frappe.ui.pages[route_str] && !frappe.ui.pages[route_str].single_column;

			// sometimes frappe.ui.pages is updated later,
			// so check the dom directly
			if(!flag) {
				var page_route = route_str.split('/').slice(0, 2).join('/');
				flag = $((".page-container[data-page-route=\"" + page_route + "\"] .layout-side-section")).length ? 1 : 0;
			}

			return flag;
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.breadcrumbs = {
		all: {},

		preferred: {
			"File": "",
			"Dashboard": "Customization",
			"Dashboard Chart": "Customization",
			"Dashboard Chart Source": "Customization"
		},

		module_map: {
			'Core': 'Settings',
			'Email': 'Settings',
			'Custom': 'Settings',
			'Workflow': 'Settings',
			'Printing': 'Settings',
			'Setup': 'Settings',
			'Event Streaming': 'Tools',
			'Automation': 'Tools',
		},

		set_doctype_module: function set_doctype_module(doctype, module) {
			localStorage["preferred_breadcrumbs:" + doctype] = module;
		},

		get_doctype_module: function get_doctype_module(doctype) {
			return localStorage["preferred_breadcrumbs:" + doctype];
		},

		add: function add(module, doctype, type) {
			var obj;
			if (typeof module === 'object') {
				obj = module;
			} else {
				obj = {
					module:module,
					doctype:doctype,
					type:type
				};
			}

			this.all[frappe.breadcrumbs.current_page()] = obj;
			this.update();
		},

		current_page: function current_page() {
			return frappe.get_route_str();
		},

		update: function update() {
			var breadcrumbs = this.all[frappe.breadcrumbs.current_page()];

			this.clear();
			if (!breadcrumbs) { return this.toggle(false); }

			if (breadcrumbs.type === 'Custom') {
				this.set_custom_breadcrumbs(breadcrumbs);
			} else {
				// workspace
				this.set_workspace_breadcrumb(breadcrumbs);

				// form / print
				var view = frappe.get_route()[0];
				view = view ? view.toLowerCase() : null;
				if (breadcrumbs.doctype && ["print", "form"].includes(view)) {
					this.set_list_breadcrumb(breadcrumbs);
					this.set_form_breadcrumb(breadcrumbs, view);
				} else if (breadcrumbs.doctype && view === 'list') {
					this.set_list_breadcrumb(breadcrumbs);
				}
			}

			this.toggle(true);
		},

		set_custom_breadcrumbs: function set_custom_breadcrumbs(breadcrumbs) {
			var html = "<li><a href=\"" + (breadcrumbs.route) + "\">" + (breadcrumbs.label) + "</a></li>";
			this.$breadcrumbs.append(html);
		},

		set_workspace_breadcrumb: function set_workspace_breadcrumb(breadcrumbs) {
			// get preferred module for breadcrumbs, based on sent via module

			if (!breadcrumbs.workspace) {
				this.set_workspace(breadcrumbs);
			}

			if (breadcrumbs.workspace) {
				if (!breadcrumbs.module_info.blocked && frappe.visible_modules.includes(breadcrumbs.module_info.module)) {
					$(("<li><a href=\"/app/" + (frappe.router.slug(breadcrumbs.workspace)) + "\">" + (__(breadcrumbs.workspace)) + "</a></li>"))
						.appendTo(this.$breadcrumbs);
				}
			}

		},

		set_workspace: function set_workspace(breadcrumbs) {
			// try and get module from doctype or other settings
			// then get the workspace for that module

			this.setup_modules();
			var from_module = this.get_doctype_module(breadcrumbs.doctype);

			if (from_module) {
				breadcrumbs.module = from_module;
			} else if (this.preferred[breadcrumbs.doctype]!==undefined) {
				// get preferred module for breadcrumbs
				breadcrumbs.module = this.preferred[breadcrumbs.doctype];
			}

			if (breadcrumbs.module) {
				if (this.module_map[breadcrumbs.module]) {
					breadcrumbs.module = this.module_map[breadcrumbs.module];
				}

				breadcrumbs.module_info = frappe.get_module(breadcrumbs.module);

				// set workspace
				if (breadcrumbs.module_info && frappe.boot.module_page_map[breadcrumbs.module]) {
					breadcrumbs.workspace = frappe.boot.module_page_map[breadcrumbs.module];
				}
			}
		},

		set_list_breadcrumb: function set_list_breadcrumb(breadcrumbs) {
			var doctype = breadcrumbs.doctype;
			var doctype_meta = frappe.get_doc('DocType', doctype);
			if ((doctype==="User" && !frappe.user.has_role('System Manager'))
				|| (doctype_meta && doctype_meta.issingle)) ; else {
				var route;
				var doctype_route = frappe.router.slug(frappe.router.doctype_layout || doctype);
				if (frappe.boot.treeviews.indexOf(doctype) !== -1) {
					var view = frappe.model.user_settings[doctype].last_view || 'Tree';
					route = doctype_route + "/view/" + view;
				} else {
					route = doctype_route;
				}
				$(("<li><a href=\"/app/" + route + "\">" + (__(doctype)) + "</a></li>"))
					.appendTo(this.$breadcrumbs);
			}
		},

		set_form_breadcrumb: function set_form_breadcrumb(breadcrumbs, view) {
			var doctype = breadcrumbs.doctype;
			var docname = frappe.get_route()[2];
			var form_route = "/app/" + (frappe.router.slug(doctype)) + "/" + docname;
			$(("<li><a href=\"" + form_route + "\">" + (__(docname)) + "</a></li>"))
				.appendTo(this.$breadcrumbs);

			if (view === "form") {
				var last_crumb = this.$breadcrumbs.find('li').last();
				last_crumb.addClass('disabled');
				last_crumb.css("cursor", "copy");
				last_crumb.click(function (event) {
					event.stopImmediatePropagation();
					frappe.utils.copy_to_clipboard(last_crumb.text());
				});
			}

		},

		setup_modules: function setup_modules() {
			if (!frappe.visible_modules) {
				frappe.visible_modules = $.map(frappe.boot.allowed_workspaces, function (m) {
					return m.module;
				});
			}
		},

		rename: function rename(doctype, old_name, new_name) {
			var old_route_str = ["Form", doctype, old_name].join("/");
			var new_route_str = ["Form", doctype, new_name].join("/");
			this.all[new_route_str] = this.all[old_route_str];
			delete frappe.breadcrumbs.all[old_route_str];
			this.update();
		},

		clear: function clear() {
			this.$breadcrumbs = $("#navbar-breadcrumbs").empty();
		},

		toggle: function toggle(show) {
			if (show) {
				$("body").addClass("no-breadcrumbs");
			} else {
				$("body").removeClass("no-breadcrumbs");
			}
		}

	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.pages');
	frappe.provide('frappe.views');

	frappe.views.Factory = class Factory {
		constructor(opts) {
			$.extend(this, opts);
		}

		show() {
			var page_name = frappe.get_route_str(),
				me = this;

			if (frappe.pages[page_name]) {
				frappe.container.change_to(page_name);
				if(me.on_show) {
					me.on_show();
				}
			} else {
				var route = frappe.get_route();
				if(route[1]) {
					me.make(route);
				} else {
					frappe.show_not_found(route);
				}
			}
		}

		make_page(double_column, page_name) {
			return frappe.make_page(double_column, page_name);
		}
	};

	frappe.make_page = function(double_column, page_name) {
		if(!page_name) {
			var page_name = frappe.get_route_str();
		}
		var page = frappe.container.add_page(page_name);

		frappe.ui.make_app_page({
			parent: page,
			single_column: !double_column
		});
		frappe.container.change_to(page_name);
		return page;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.views.pageview');
	frappe.provide("frappe.standard_pages");

	frappe.views.pageview = {
		with_page: function(name, callback) {
			if (frappe.standard_pages[name]) {
				if (!frappe.pages[name]) {
					frappe.standard_pages[name]();
				}
				callback();
				return;
			}

			if ((locals.Page && locals.Page[name] && locals.Page[name].script) || name==window.page_name) {
				// already loaded
				callback();
			} else if (localStorage["_page:" + name] && frappe.boot.developer_mode!=1) {
				// cached in local storage
				frappe.model.sync(JSON.parse(localStorage["_page:" + name]));
				callback();
			} else if (name) {
				// get fresh
				return frappe.call({
					method: 'frappe.desk.desk_page.getpage',
					args: {'name':name },
					callback: function(r) {
						if (!r.docs._dynamic_page) {
							localStorage["_page:" + name] = JSON.stringify(r.docs);
						}
						callback();
					},
					freeze: true,
				});
			}
		},

		show: function(name) {
			if (!name) {
				name = (frappe.boot ? frappe.boot.home_page : window.page_name);
			}
			frappe.model.with_doctype("Page", function() {
				frappe.views.pageview.with_page(name, function(r) {
					if (r && r.exc) {
						if (!r['403'])
							{ frappe.show_not_found(name); }
					} else if (!frappe.pages[name]) {
						new frappe.views.Page(name);
					}
					frappe.container.change_to(name);
				});
			});
		}
	};

	frappe.views.Page = class Page {
		constructor(name) {
			this.name = name;
			var me = this;

			// web home page
			if (name==window.page_name) {
				this.wrapper = document.getElementById('page-' + name);
				this.wrapper.label = document.title || window.page_name;
				this.wrapper.page_name = window.page_name;
				frappe.pages[window.page_name] = this.wrapper;
			} else {
				this.pagedoc = locals.Page[this.name];
				if (!this.pagedoc) {
					frappe.show_not_found(name);
					return;
				}
				this.wrapper = frappe.container.add_page(this.name);
				this.wrapper.page_name = this.pagedoc.name;

				// set content, script and style
				if (this.pagedoc.content)
					{ this.wrapper.innerHTML = this.pagedoc.content; }
				frappe.dom.eval(this.pagedoc.__script || this.pagedoc.script || '');
				frappe.dom.set_style(this.pagedoc.style || '');

				// set breadcrumbs
				frappe.breadcrumbs.add(this.pagedoc.module || null);
			}

			this.trigger_page_event('on_page_load');

			// set events
			$(this.wrapper).on('show', function() {
				window.cur_frm = null;
				me.trigger_page_event('on_page_show');
				me.trigger_page_event('refresh');
			});
		}

		trigger_page_event(eventname) {
			var me = this;
			if (me.wrapper[eventname]) {
				me.wrapper[eventname](me.wrapper);
			}
		}
	};

	frappe.show_not_found = function(page_name) {
		frappe.show_message_page({
			page_name: page_name,
			message: __("Sorry! I could not find what you were looking for."),
			img: "/assets/frappe/images/ui/bubble-tea-sorry.svg"
		});
	};

	frappe.show_not_permitted = function(page_name) {
		frappe.show_message_page({
			page_name: page_name,
			message: __("Sorry! You are not permitted to view this page."),
			img: "/assets/frappe/images/ui/bubble-tea-sorry.svg",
			// icon: "octicon octicon-circle-slash"
		});
	};

	frappe.show_message_page = function(opts) {
		// opts can include `page_name`, `message`, `icon` or `img`
		if (!opts.page_name) {
			opts.page_name = frappe.get_route_str();
		}

		if (opts.icon) {
			opts.img = repl('<span class="%(icon)s message-page-icon"></span> ', opts);
		} else if (opts.img) {
			opts.img = repl('<img src="%(img)s" class="message-page-image">', opts);
		}

		var page = frappe.pages[opts.page_name] || frappe.container.add_page(opts.page_name);
		$(page).html(
			repl('<div class="page message-page">\
			<div class="text-center message-page-content">\
				%(img)s\
				<p class="lead">%(message)s</p>\
				<a class="btn btn-default btn-sm btn-home" href="#">%(home)s</a>\
			</div>\
		</div>', {
					img: opts.img || "",
					message: opts.message || "",
					home: __("Home")
				})
		);

		frappe.container.change_to(opts.page_name);
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt
	frappe.provide('frappe.search');
	frappe.provide('frappe.tags');

	frappe.search.AwesomeBar = Class.extend({
		setup: function(element) {
			var me = this;

			$('.search-bar').removeClass('hidden');
			var $input = $(element);
			var input = $input.get(0);

			this.options = [];
			this.global_results = [];

			var awesomplete = new Awesomplete(input, {
				minChars: 0,
				maxItems: 99,
				autoFirst: true,
				list: [],
				filter: function(text, term) {
					return true;
				},
				data: function(item, input) {
					return {
						label: (item.index || ""),
						value: item.value
					};
				},
				item: function(item, term) {
					var d = this.get_item(item.value);
					var name = __(d.label || d.value);
					var html = '<span>' + name + '</span>';
					if(d.description && d.value!==d.description) {
						html += '<br><span class="text-muted ellipsis">' + __(d.description) + '</span>';
					}
					return $('<li></li>')
						.data('item.autocomplete', d)
						.html(("<a style=\"font-weight:normal\">" + html + "</a>"))
						.get(0);
				},
				sort: function(a, b) {
					return (b.label - a.label);
				}
			});

			// Added to aid UI testing of global search
			input.awesomplete = awesomplete;

			this.awesomplete = awesomplete;

			$input.on("input", function(e) {
				var value = e.target.value;
				var txt = value.trim().replace(/\s\s+/g, ' ');
				var last_space = txt.lastIndexOf(' ');
				me.global_results = [];
				// if(txt && txt.length > 1) {
				// 	me.global.get_awesome_bar_options(txt.toLowerCase(), me);
				// }

				var $this = $(this);
				clearTimeout($this.data('timeout'));

				$this.data('timeout', setTimeout(function(){
					me.options = [];
					if(txt && txt.length > 1) {
						if(last_space !== -1) {
							me.set_specifics(txt.slice(0,last_space), txt.slice(last_space+1));
						}
						me.add_defaults(txt);
						me.options = me.options.concat(me.build_options(txt));
						me.options = me.options.concat(me.global_results);
					} else {
						me.options = me.options.concat(
							me.deduplicate(frappe.search.utils.get_recent_pages(txt || "")));
						me.options = me.options.concat(frappe.search.utils.get_frequent_links());
					}
					me.add_help();

					awesomplete.list = me.deduplicate(me.options);
				}, 100));

			});

			var open_recent = function() {
				if (!this.autocomplete_open) {
					$(this).trigger("input");
				}
			};
			$input.on("focus", open_recent);

			$input.on("awesomplete-open", function(e) {
				me.autocomplete_open = e.target;
			});

			$input.on("awesomplete-close", function(e) {
				me.autocomplete_open = false;
			});

			$input.on("awesomplete-select", function(e) {
				var o = e.originalEvent;
				var value = o.text.value;
				var item = awesomplete.get_item(value);

				if(item.route_options) {
					frappe.route_options = item.route_options;
				}

				if(item.onclick) {
					item.onclick(item.match);
				} else {
					frappe.set_route(item.route);
				}
				$input.val("");
			});

			$input.on("awesomplete-selectcomplete", function(e) {
				$input.val("");
			});

			$input.on("keydown", null, 'esc', function() {
				$input.blur();
			});
			frappe.search.utils.setup_recent();
			frappe.tags.utils.fetch_tags();
		},

		add_help: function() {
			this.options.push({
				value: __("Help on Search"),
				index: -10,
				default: "Help",
				onclick: function() {
					var txt = '<table class="table table-bordered">\
					<tr><td style="width: 50%">'+__('Create a new record')+'</td><td>'+
							__("new type of document")+'</td></tr>\
					<tr><td>'+__("List a document type")+'</td><td>'+
							__("document type..., e.g. customer")+'</td></tr>\
					<tr><td>'+__("Search in a document type")+'</td><td>'+
							__("text in document type")+'</td></tr>\
					<tr><td>'+__("Tags")+'</td><td>'+
							__("tag name..., e.g. #tag")+'</td></tr>\
					<tr><td>'+__("Open a module or tool")+'</td><td>'+
							__("module name...")+'</td></tr>\
					<tr><td>'+__("Calculate")+'</td><td>'+
							__("e.g. (55 + 434) / 4 or =Math.sin(Math.PI/2)...")+'</td></tr>\
				</table>';
					frappe.msgprint(txt, __("Search Help"));
				}
			});
		},

		set_specifics: function(txt, end_txt) {
			var me = this;
			var results = this.build_options(txt);
			results.forEach(function(r) {
				if(r.type && (r.type).toLowerCase().indexOf(end_txt.toLowerCase()) === 0) {
					me.options.push(r);
				}
			});
		},

		add_defaults: function(txt) {
			this.make_global_search(txt);
			this.make_search_in_current(txt);
			this.make_calculator(txt);
			this.make_random(txt);
		},

		build_options: function(txt) {
			var options = frappe.search.utils.get_creatables(txt).concat(
				frappe.search.utils.get_search_in_list(txt),
				frappe.search.utils.get_doctypes(txt),
				frappe.search.utils.get_reports(txt),
				frappe.search.utils.get_pages(txt),
				frappe.search.utils.get_workspaces(txt),
				frappe.search.utils.get_dashboards(txt),
				frappe.search.utils.get_recent_pages(txt || ""),
				frappe.search.utils.get_executables(txt)
			);
			if (txt.charAt(0) === "#") {
				options = frappe.tags.utils.get_tags(txt);
			}
			var out = this.deduplicate(options);
			return out.sort(function(a, b) {
				return b.index - a.index;
			});
		},

		deduplicate: function(options) {
			var out = [], routes = [];
			options.forEach(function(option) {
				if(option.route) {
					if (
						option.route[0] === "List" &&
						option.route[2] !== 'Report' &&
						option.route[2] !== 'Inbox'
					) {
						option.route.splice(2);
					}

					var str_route = (typeof option.route==='string') ?
						option.route : option.route.join('/');
					if(routes.indexOf(str_route)===-1) {
						out.push(option);
						routes.push(str_route);
					} else {
						var old = routes.indexOf(str_route);
						if(out[old].index < option.index && !option.recent) {
							out[old] = option;
						}
					}
				} else {
					out.push(option);
					routes.push("");
				}
			});
			return out;
		},

		set_global_results: function(global_results, txt) {
			this.global_results = this.global_results.concat(global_results);
		},

		make_global_search: function(txt) {
			// let search_text = $(this.awesomplete.ul).find('.search-text');

			// if (txt.charAt(0) === "#" || !txt) {
			// 	search_text && search_text.remove();
			// 	return;
			// }

			// if (!search_text.length) {
			// 	search_text = $(this.awesomplete.ul).prepend(`
			// 		<div class="search-text">
			// 			<span class="search-text"></span>
			// 		<div>`
			// 	).find(".search-text");
			// }

			// search_text.html(`
			// 	<span class="flex justify-between">
			// 		<span class="ellipsis">Search for ${frappe.utils.xss_sanitise(txt).bold()}</span>
			// 		<kbd>↵</kbd>
			// 	</span>
			// `);

			// search_text.click(() => {
			// 	frappe.searchdialog.search.init_search(txt, "global_search");
			// });

			// REDESIGN TODO: Remove this as a selectable option
			if (txt.charAt(0) === "#") {
				return;
			}

			this.options.push({
				label: ("\n\t\t\t\t<span class=\"flex justify-between text-medium\">\n\t\t\t\t\t<span class=\"ellipsis\">" + (__('Search for {0}', [frappe.utils.xss_sanitise(txt).bold()])) + "</span>\n\t\t\t\t\t<kbd>↵</kbd>\n\t\t\t\t</span>\n\t\t\t"),
				value: __("Search for {0}", [txt]),
				match: txt,
				index: 100,
				default: "Search",
				onclick: function() {
					frappe.searchdialog.search.init_search(txt, "global_search");
				}
			});
		},

		make_search_in_current: function(txt) {
			var route = frappe.get_route();
			if(route[0]==="List" && txt.indexOf(" in") === -1) {
				// search in title field
				var meta = frappe.get_meta(frappe.container.page.list_view.doctype);
				var search_field = meta.title_field || "name";
				var options = {};
				options[search_field] = ["like", "%" + txt + "%"];
				this.options.push({
					label: __('Find {0} in {1}', [txt.bold(), __(route[1]).bold()]),
					value: __('Find {0} in {1}', [txt, __(route[1])]),
					route_options: options,
					onclick: function() {
						cur_list.show();
					},
					index: 90,
					default: "Current",
					match: txt
				});
			}
		},

		make_calculator: function(txt) {
			var first = txt.substr(0,1);
			if(first==parseInt(first) || first==="(" || first==="=") {
				if(first==="=") {
					txt = txt.substr(1);
				}
				try {
					var val = eval(txt);
					var formatted_value = __('{0} = {1}', [txt, (val + '').bold()]);
					this.options.push({
						label: formatted_value,
						value: __('{0} = {1}', [txt, val]),
						match: val,
						index: 80,
						default: "Calculator",
						onclick: function() {
							frappe.msgprint(formatted_value, "Result");
						}
					});
				} catch(e) {
					// pass
				}
			}
		},

		make_random: function(txt) {
			if(txt.toLowerCase().includes('random')) {
				this.options.push({
					label: "Generate Random Password",
					value: frappe.utils.get_random(16),
					onclick: function() {
						frappe.msgprint(frappe.utils.get_random(16), "Result");
					}
				});
			}
		}
	});

	frappe.provide('frappe.search');

	frappe.ui.Notifications = class Notifications {
		constructor() {
			this.tabs = {};
			this.notification_settings = frappe.boot.notification_settings;
			this.make();
		}

		make() {
			this.dropdown = $('.navbar').find('.dropdown-notifications').removeClass('hidden');
			this.dropdown_list = this.dropdown.find('.notifications-list');
			this.header_items = this.dropdown_list.find('.header-items');
			this.header_actions = this.dropdown_list.find('.header-actions');
			this.body = this.dropdown_list.find('.notification-list-body');
			this.panel_events = this.dropdown_list.find('.panel-events');
			this.panel_notifications = this.dropdown_list.find('.panel-notifications');

			this.user = frappe.session.user;

			this.setup_headers();
			this.setup_dropdown_events();
		}

		setup_headers() {
			var this$1 = this;

			// Add header actions
			$(("<span class=\"notification-settings pull-right\" data-action=\"go_to_settings\">\n\t\t\t" + (frappe.utils.icon('setting-gear')) + "\n\t\t</span>"))
				.on('click', function (e) {
					e.stopImmediatePropagation();
					this$1.dropdown.dropdown('hide');
					frappe.set_route('Form', 'Notification Settings', frappe.session.user);
				}).appendTo(this.header_actions)
				.attr('title', __("Notification Settings"))
				.tooltip({ delay: { "show": 600, "hide": 100}, trigger: "hover"  });

			$(("<span class=\"mark-all-read pull-right\" data-action=\"mark_all_as_read\">\n\t\t\t" + (frappe.utils.icon('mark-as-read')) + "\n\t\t</span>"))
				.on('click', function (e) { return this$1.mark_all_as_read(e); })
				.appendTo(this.header_actions)
				.attr('title', __("Mark all as read"))
				.tooltip({ delay: { "show": 600, "hide": 100 }, trigger: "hover" });

			this.categories = [
				{
					label: __("Notifications"),
					id: "notifications",
					view: NotificationsView,
					el: this.panel_notifications,
				},
				{
					label: __("Today's Events"),
					id: "todays_events",
					view: EventsView,
					el: this.panel_events,
				}
			];

			var get_headers_html = function (item) {
				var active = item.id == "notifications" ? 'active' : '';

				var html = "<li class=\"notifications-category " + active + "\"\n\t\t\t\t\tid=\"" + (item.id) + "\"\n\t\t\t\t\tdata-toggle=\"collapse\"\n\t\t\t\t>" + (item.label) + "</li>";

				return html;
			};

			var navitem = $("<ul class=\"notification-item-tabs nav nav-tabs\" role=\"tablist\"></ul>");
			this.categories = this.categories.map(function (item) {
				item.$tab = $(get_headers_html(item));
				item.$tab.on('click', function (e) {
					e.stopImmediatePropagation();
					this$1.switch_tab(item);
				});
				navitem.append(item.$tab);

				return item;
			});
			navitem.appendTo(this.header_items);
			this.categories.forEach(function (category) {
				this$1.make_tab_view(category);
			});
			this.switch_tab(this.categories[0]);
		}

		switch_tab(item) {
			var this$1 = this;

			// Set active tab
			this.categories.forEach(function (item) {
				item.$tab.removeClass("active");
			});

			item.$tab.addClass("active");

			// Hide other tabs
			Object.keys(this.tabs).forEach(function (tab_name) { return this$1.tabs[tab_name].hide(); });
			this.tabs[item.id].show();
		}

		make_tab_view(item) {
			var tabView = new item.view(
				item.el,
				this.dropdown,
				this.notification_settings
			);
			this.tabs[item.id] = tabView;
		}

		mark_all_as_read(e) {
			e.stopImmediatePropagation();
			this.dropdown_list.find('.unread').removeClass('unread');
			frappe.call(
				'frappe.desk.doctype.notification_log.notification_log.mark_all_as_read'
			);
		}

		setup_dropdown_events() {
			this.dropdown.on('hide.bs.dropdown', function (e) {
				var hide = $(e.currentTarget).data('closable');
				$(e.currentTarget).data('closable', true);
				return hide;
			});

			this.dropdown.on('click', function (e) {
				$(e.currentTarget).data('closable', true);
			});
		}
	};


	frappe.ui.notifications = {
		get_notification_config: function get_notification_config() {
			return frappe.xcall('frappe.desk.notifications.get_notification_info').then(function (r) {
				frappe.ui.notifications.config = r;
				return r;
			});
		},

		show_open_count_list: function show_open_count_list(doctype) {
			var this$1 = this;

			if (!frappe.ui.notifications.config) {
				this.get_notification_config().then(function () {
					this$1.route_to_list_with_filters(doctype);
				});
			} else {
				this.route_to_list_with_filters(doctype);
			}
		},

		route_to_list_with_filters: function route_to_list_with_filters(doctype) {
			var filters = frappe.ui.notifications.config['conditions'][doctype];
			if (filters && $.isPlainObject(filters)) {
				if (!frappe.route_options) {
					frappe.route_options = {};
				}
				$.extend(frappe.route_options, filters);
			}
			frappe.set_route('List', doctype);
		}
	};

	class BaseNotificationsView {
		constructor(wrapper, parent, settings) {
			// wrapper, max_length
			this.wrapper = wrapper;
			this.parent = parent;
			this.settings = settings;
			this.max_length = 20;
			this.container = $("<div></div>").appendTo(this.wrapper);
			this.make();
		}

		show() {
			this.container.show();
		}

		hide() {
			this.container.hide();
		}
	}

	class NotificationsView extends BaseNotificationsView {
		make() {
			var this$1 = this;

			this.notifications_icon = this.parent.find('.notifications-icon');
			this.notifications_icon.attr("title", __('Notifications')).tooltip(
				{ delay: { "show": 600, "hide": 100},  trigger: "hover" }
			);

			this.setup_notification_listeners();
			this.get_notifications_list(this.max_length).then(function (list) {
				this$1.dropdown_items = list;
				this$1.render_notifications_dropdown();
				if (this$1.settings.seen == 0) {
					this$1.toggle_notification_icon(false);
				}
			});

		}

		update_dropdown() {
			var this$1 = this;

			this.get_notifications_list(1).then(function (r) {
				var new_item = r[0];
				this$1.dropdown_items.unshift(new_item);
				if (this$1.dropdown_items.length > this$1.max_length) {
					this$1.container
						.find('.recent-notification')
						.last()
						.remove();
					this$1.dropdown_items.pop();
				}

				this$1.insert_into_dropdown();
			});
		}

		change_activity_status() {
			if (this.container.find('.activity-status')) {
				this.container.find('.activity-status').replaceWith(
					("<a class=\"recent-item text-center text-muted\"\n\t\t\t\t\thref=\"/app/List/Notification Log\">\n\t\t\t\t\t<div class=\"full-log-btn\">" + (__('View Full Log')) + "</div>\n\t\t\t\t</a>")
				);
			}
		}

		mark_as_read(docname, $el) {
			frappe.call(
				'frappe.desk.doctype.notification_log.notification_log.mark_as_read',
				{ docname: docname }
			).then(function () {
				$el.removeClass('unread');
			});
		}

		insert_into_dropdown() {
			var new_item = this.dropdown_items[0];
			var new_item_html = this.get_dropdown_item_html(new_item);
			$(new_item_html).prependTo(this.container);
			this.change_activity_status();
		}

		get_dropdown_item_html(field) {
			var this$1 = this;

			var doc_link = this.get_item_link(field);

			var read_class = field.read ? '' : 'unread';
			var message = field.subject;

			var title = message.match(/<b class="subject-title">(.*?)<\/b>/);
			message = title ? message.replace(title[1], frappe.ellipsis(strip_html(title[1]), 100)) : message;

			var timestamp = frappe.datetime.comment_when(field.creation);
			var message_html = "<div class=\"message\">\n\t\t\t<div>" + message + "</div>\n\t\t\t<div class=\"notification-timestamp text-muted\">\n\t\t\t\t" + timestamp + "\n\t\t\t</div>\n\t\t</div>";

			var user = field.from_user;
			var user_avatar = frappe.avatar(user, 'avatar-medium user-avatar');

			var item_html =
				$(("<a class=\"recent-item notification-item " + read_class + "\"\n\t\t\t\thref=\"" + doc_link + "\"\n\t\t\t\tdata-name=\"" + (field.name) + "\"\n\t\t\t>\n\t\t\t\t<div class=\"notification-body\">\n\t\t\t\t\t" + user_avatar + "\n\t\t\t\t\t" + message_html + "\n\t\t\t\t</div>\n\t\t\t\t<div class=\"mark-as-read\" title=\"" + (__("Mark as Read")) + "\">\n\t\t\t\t</div>\n\t\t\t</a>"));

			if (!field.read) {
				var mark_btn = item_html.find(".mark-as-read");
				mark_btn.tooltip({ delay: { "show": 600, "hide": 100 }, trigger: "hover" });
				mark_btn.on('click', function (e) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this$1.mark_as_read(field.name, item_html);
				});

				item_html.on('click', function () {
					this$1.mark_as_read(field.name, item_html);
				});
			}

			return item_html;
		}

		render_notifications_dropdown() {
			var this$1 = this;

			if (this.settings && !this.settings.enabled) {
				this.container.html(("<li class=\"recent-item notification-item\">\n\t\t\t\t<span class=\"text-muted\">\n\t\t\t\t\t" + (__('Notifications Disabled')) + "\n\t\t\t\t</span></li>"));
			} else {
				if (this.dropdown_items.length) {
					this.container.empty();
					this.dropdown_items.forEach(function (field) {
						this$1.container.append(this$1.get_dropdown_item_html(field));
					});
					this.container.append(("<a class=\"list-footer\"\n\t\t\t\t\thref=\"/app/List/Notification Log\">\n\t\t\t\t\t\t<div class=\"full-log-btn\">" + (__('See all Activity')) + "</div>\n\t\t\t\t\t</a>"));
				} else {
					this.container.append($(("<div class=\"notification-null-state\">\n\t\t\t\t\t<div class=\"text-center\">\n\t\t\t\t\t\t<img src=\"/assets/frappe/images/ui-states/notification-empty-state.svg\" alt=\"Generic Empty State\" class=\"null-state\">\n\t\t\t\t\t\t<div class=\"title\">" + (__('No New notifications')) + "</div>\n\t\t\t\t\t\t<div class=\"subtitle\">\n\t\t\t\t\t\t\t" + (__('Looks like you haven’t received any notifications.')) + "\n\t\t\t\t\t</div></div></div>")));
				}
			}
		}

		get_notifications_list(limit) {
			return frappe.db.get_list('Notification Log', {
				fields: ['*'],
				limit: limit,
				order_by: 'creation desc'
			});
		}

		get_item_link(notification_doc) {
			var link_doctype =
				notification_doc.type == 'Alert' ? 'Notification Log' : notification_doc.document_type;
			var link_docname =
				notification_doc.type == 'Alert' ? notification_doc.name : notification_doc.document_name;
			return frappe.utils.get_form_link(
				link_doctype,
				link_docname
			);
		}

		toggle_notification_icon(seen) {
			this.notifications_icon.find('.notifications-seen').toggle(seen);
			this.notifications_icon.find('.notifications-unseen').toggle(!seen);
		}

		toggle_seen(flag) {
			frappe.call(
				'frappe.desk.doctype.notification_settings.notification_settings.set_seen_value',
				{
					value: cint(flag),
					user: frappe.session.user
				}
			);
		}

		setup_notification_listeners() {
			var this$1 = this;

			frappe.realtime.on('notification', function () {
				this$1.toggle_notification_icon(false);
				this$1.update_dropdown();
			});

			frappe.realtime.on('indicator_hide', function () {
				this$1.toggle_notification_icon(true);
			});

			this.parent.on('show.bs.dropdown', function () {
				this$1.toggle_seen(true);
				if (this$1.notifications_icon.find('.notifications-unseen').is(':visible')) {
					this$1.toggle_notification_icon(true);
					frappe.call(
						'frappe.desk.doctype.notification_log.notification_log.trigger_indicator_hide'
					);
				}
			});

		}
	}

	class EventsView extends BaseNotificationsView {
		make() {
			var this$1 = this;

			var today = frappe.datetime.get_today();
			frappe.xcall('frappe.desk.doctype.event.event.get_events', {
				start: today,
				end: today
			}).then(function (event_list) {
				this$1.render_events_html(event_list);
			});
		}

		render_events_html(event_list) {
			var html = '';
			if (event_list.length) {
				var get_event_html = function (event) {
					var time = __("All Day");
					if (!event.all_day) {
						var start_time = frappe.datetime.get_time(event.starts_on);
						var days_diff = frappe.datetime.get_day_diff(event.ends_on, event.starts_on);
						var end_time = frappe.datetime.get_time(event.ends_on);
						if (days_diff > 1) {
							end_time = __("Rest of the day");
						}
						time = start_time + " - " + end_time;
					}

					// REDESIGN-TODO: Add Participants to get_events query
					var particpants = '';
					if (event.particpants) {
						particpants = frappe.avatar_group(event.particpants, 3);
					}

					// REDESIGN-TODO: Add location to calendar field
					var location = '';
					if (event.location) {
						location = ", " + (event.location);
					}

					return ("<a class=\"recent-item event\" href=\"/app/event/" + (event.name) + "\">\n\t\t\t\t\t<div class=\"event-border\" style=\"border-color: " + (event.color) + "\"></div>\n\t\t\t\t\t<div class=\"event-item\">\n\t\t\t\t\t\t<div class=\"event-subject\">" + (event.subject) + "</div>\n\t\t\t\t\t\t<div class=\"event-time\">" + time + location + "</div>\n\t\t\t\t\t\t" + particpants + "\n\t\t\t\t\t</div>\n\t\t\t\t</a>");
				};
				html = event_list.map(get_event_html).join('');
			} else {
				html = "\n\t\t\t\t<div class=\"notification-null-state\">\n\t\t\t\t\t<div class=\"text-center\">\n\t\t\t\t\t<img src=\"/assets/frappe/images/ui-states/event-empty-state.svg\" alt=\"Generic Empty State\" class=\"null-state\">\n\t\t\t\t\t<div class=\"title\">" + (__('No Upcoming Events')) + "</div>\n\t\t\t\t\t<div class=\"subtitle\">\n\t\t\t\t\t\t" + (__('There are no upcoming events for you.')) + "\n\t\t\t\t</div></div></div>\n\t\t\t";
			}

			this.container.html(html);
		}
	}

	frappe.provide("frappe.search");

	frappe.search.SearchDialog = class {
		constructor(opts) {
			$.extend(this, opts);
			this.make();
		}

		make() {
			this.search_dialog = new frappe.ui.Dialog({
				minimizable: true,
				size: "large"
			});
			this.set_header();
			this.$wrapper = $(this.search_dialog.$wrapper).addClass(
				"search-dialog"
			);
			this.$body = $(this.search_dialog.body);
			this.$input = this.$wrapper.find(".search-input");
			this.setup();
		}

		set_header() {
			this.search_dialog.header
				.addClass("search-header")
				.find(".title-section")
				.html(
					("<div class=\"input-group text-muted\">\n\t\t\t\t\t<input type=\"text\" class=\"form-control search-input\">\n\t\t\t\t</div>\n\t\t\t\t<span class=\"search-icon\">\n\t\t\t\t\t" + (frappe.utils.icon("search")) + "\n\t\t\t\t</span>")
				);
		}

		setup() {
			this.modal_state = 0;
			this.current_keyword = "";
			this.more_count = 20;
			this.full_lists = {};
			this.nav_lists = {};
			this.init_search_objects();
			this.bind_input();
			this.bind_events();
		}

		init_search_objects() {
			this.searches = {
				global_search: {
					input_placeholder: __("Search"),
					empty_state_text: __("Search for anything"),
					no_results_status: function () { return __("No Results found"); },
					get_results: function (keywords, callback) {
						var start = 0,
							limit = 1000;
						var results = frappe.search.utils.get_nav_results(keywords);
						frappe.search.utils
							.get_global_results(keywords, start, limit)
							.then(
								function (global_results) {
									results = results.concat(global_results);
									callback(results, keywords);
								},
								function (err) {
									// eslint-disable-next-line no-console
									console.error(err);
								}
							);
					}
				},
				tags: {
					input_placeholder: __("Search"),
					empty_state_text: __("Search for anything"),
					no_results_status: function (keyword) { return "<div>" +
						__("No documents found tagged with {0}", [keyword]) +
						"</div>"; },
					get_results: function (keywords, callback) {
						var results = frappe.search.utils.get_nav_results(keywords);
						frappe.tags.utils.get_tag_results(keywords).then(
							function (global_results) {
								results = results.concat(global_results);
								callback(results, keywords);
							},
							function (err) {
								// eslint-disable-next-line no-console
								console.error(err);
							}
						);
					}
				}
			};
		}

		update($r) {
			this.$wrapper.find(".loading-state").addClass("hide");
			this.$body.append($r);
			if (this.$body.find(".search-results").length > 1) {
				this.$body
					.find(".search-results")
					.first()
					.addClass("hide");
				$r.removeClass("hide");
				this.$body
					.find(".search-results")
					.first()
					.remove();
			} else {
				$r.removeClass("hide");
			}
		}

		put_placeholder(status_text) {
			var $placeholder = $(("<div class=\"row search-results hide\">\n\t\t\t<div class=\"empty-state\">\n\t\t\t\t<div class=\"text-center\">\n\t\t\t\t\t<img src=\"/assets/frappe/images/ui-states/search-empty-state.svg\"\n\t\t\t\t\t\talt=\"Generic Empty State\"\n\t\t\t\t\t\tclass=\"null-state\"\n\t\t\t\t\t>\n\t\t\t\t\t<div class=\"empty-state-text\">" + status_text + "</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>"));
			this.update($placeholder);
		}

		bind_input() {
			var this$1 = this;

			this.$input.on("input", function (e) {
				var $el = $(e.currentTarget);
				clearTimeout($el.data("timeout"));
				$el.data(
					"timeout",
					setTimeout(function () {
						if (this$1.$input.val() === this$1.current_keyword) { return; }
						var keywords = this$1.$input.val();
						if (keywords.length > 1) {
							this$1.get_results(keywords);
						} else {
							this$1.current_keyword = "";
							this$1.put_placeholder(this$1.search.empty_state_text);
						}
					}, 300)
				);
			});
		}

		bind_events() {
			var this$1 = this;

			// Sidebar
			this.$body.on("click", ".list-link", function (e) {
				var $link = $(e.currentTarget);
				this$1.$body
					.find(".search-sidebar")
					.find(".list-link")
					.removeClass("active selected");
				$link.addClass("active selected");
				var type = $link.attr("data-category");
				this$1.$body
					.find(".results-area")
					.empty()
					.html(this$1.full_lists[type]);
				this$1.$body
					.find(".module-section-link")
					.first()
					.focus();
			});

			// Summary more links
			this.$body.on("click", ".section-more", function (e) {
				var $section = $(e.currentTarget);
				var type = $section.attr("data-category");
				this$1.$body
					.find(".search-sidebar")
					.find('*[data-category="' + type + '"]')
					.trigger("click");
			});

			// Back-links (mobile-view)
			this.$body.on("click", ".all-results-link", function () {
				this$1.$body
					.find(".search-sidebar")
					.find('*[data-category="All Results"]')
					.trigger("click");
			});

			// Full list more links
			this.$body.on("click", ".list-more", function (e) {
				var $el = $(e.currentTarget);
				var type = $el.attr("data-category");
				var fetch_type = $el.attr("data-search");
				var current_count = this$1.$body.find(".result").length;
				if (fetch_type === "Global") {
					frappe.search.utils
						.get_global_results(
							this$1.current_keyword,
							current_count,
							this$1.more_count,
							type
						)
						.then(
							function (doctype_results) {
								doctype_results.length &&
									this$1.add_more_results(doctype_results);
							},
							function (err) {
								// eslint-disable-next-line no-console
								console.error(err);
							}
						);
				} else {
					var results = this$1.nav_lists[type].slice(0, this$1.more_count);
					this$1.nav_lists[type].splice(0, this$1.more_count);
					this$1.add_more_results([{ title: type, results: results }]);
				}
			});

			// Switch to global search link
			this.$body.on("click", ".switch-to-global-search", function () {
				this$1.search = this$1.searches["global_search"];
				this$1.$input.attr("placeholder", this$1.search.input_placeholder);
				this$1.put_placeholder(this$1.search.empty_state_text);
				this$1.get_results(this$1.current_keyword);
			});
		}

		init_search(keywords, search_type) {
			var this$1 = this;

			this.search = this.searches[search_type];
			this.$input.attr("placeholder", this.search.input_placeholder);
			this.put_placeholder(this.search.empty_state_text);
			this.get_results(keywords);
			this.search_dialog.show();
			this.$input.val(keywords);
			setTimeout(function () { return this$1.$input.select(); }, 500);
		}

		get_results(keywords) {
			this.current_keyword = keywords;
			if (this.$body.find(".empty-state").length > 0) {
				this.put_placeholder(__("Searching ..."));
			} else {
				this.$wrapper.find(".loading-state").removeClass("hide");
			}

			if (this.current_keyword.charAt(0) === "#") {
				this.search = this.searches["tags"];
			} else {
				this.search = this.searches["global_search"];
			}

			this.search.get_results(keywords, this.parse_results.bind(this));
		}

		parse_results(result_sets, keyword) {
			result_sets = result_sets.filter(function(set) {
				return set.results.length > 0;
			});
			if (result_sets.length > 0) {
				this.render_data(result_sets);
			} else {
				this.put_placeholder(this.search.no_results_status(keyword));
			}
		}

		render_data(result_sets) {
			var this$1 = this;

			var $search_results = $(frappe.render_template("search")).addClass(
				"hide"
			);
			var $sidebar = $search_results.find(".search-sidebar").empty();
			var sidebar_item_html =
				'<li class="search-sidebar-item standard-sidebar-item list-link" data-category="{0}">' +
				'<a><span class="ellipsis">{1}</span></a></li>';

			this.modal_state = 0;
			this.full_lists = {
				"All Results": $('<div class="results-summary"></div>')
			};
			this.nav_lists = {};

			result_sets.forEach(function (set) {
				$sidebar.append($(__(sidebar_item_html, [set.title, __(set.title)])));
				this$1.add_section_to_summary(set.title, set.results);
				this$1.full_lists[set.title] = this$1.render_full_list(
					set.title,
					set.results,
					set.fetch_type
				);
			});

			if (result_sets.length > 1) {
				$sidebar.prepend($(__(sidebar_item_html, ['All Results', __('All Results')])));
			}

			this.update($search_results.clone());
			this.$body
				.find(".list-link")
				.first()
				.trigger("click");
		}

		render_full_list(type, results, fetch_type) {
			var this$1 = this;

			var max_length = 20;

			var $results_list = $(("<div class=\"results-summary\">\n\t\t\t<div class=\"result-section full-list " + type + "-section col-sm-12\">\n\t\t\t\t<div class=\"result-title\"> " + (__(type)) + "</div>\n\t\t\t\t<div class=\"result-body\">\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>"));

			results.slice(0, max_length).forEach(function (result) {
				$results_list
					.find(".result-body")
					.append(this$1.render_result(type, result));
			});

			if (results.length > 0) {
				if (fetch_type === "Nav") { this.nav_lists[type] = results; }

				if (results.length > max_length) {
					$(("<a class=\"list-more\" data-search=\"" + fetch_type + "\"\n\t\t\t\t\tdata-category=\"" + type + "\" data-count=\"" + max_length + "\">\n\t\t\t\t\t\t" + (__("More")) + "\n\t\t\t\t</a>")).appendTo($results_list.find(".result-body"));
				}
			}
			return $results_list;
		}

		add_section_to_summary(type, results) {
			var this$1 = this;

			var section_length = 4;
			var more_html = "";
			var get_result_html = function (result) { return this$1.render_result(type, result); };

			if (results.length > section_length) {
				more_html = "<div>\n\t\t\t\t<a class=\"section-more\" data-category=\"" + type + "\">" + (__("More")) + "</a>\n\t\t\t</div>";
			}

			var $result_section = $(("<div class=\"col-sm-12 result-section\" data-type=\"" + type + "\">\n\t\t\t<div class=\"result-title\">" + (__(type)) + "</div>\n\t\t\t<div class=\"result-body\">\n\t\t\t\t" + more_html + "\n\t\t\t</div>\n\t\t</div>")).appendTo(this.full_lists["All Results"]);

			$result_section
				.find(".result-body")
				.prepend(results.slice(0, section_length).map(get_result_html));
		}

		get_link(result) {
			var link = "";
			if (result.route) {
				link = "href=\"#" + (result.route.join("/")) + "\"";
			} else if (result.data_path) {
				link = "data-path=" + (result.data_path) + "\"";
			}
			return link;
		}

		render_result(type, result) {
			var image_html = "";
			if (result.image !== undefined) {
				var avatar_html = frappe.get_avatar(
					"avatar-medium",
					result.label,
					result.image
				);
				image_html = "<a " + (this.get_link(result)) + ">\n\t\t\t\t<div class=\"result-image\">\n\t\t\t\t\t" + avatar_html + "\n\t\t\t\t</div>\n\t\t\t</a>";
			}

			var link_html = "<a " + (this.get_link(
				result
			)) + " class=\"result-section-link\">" + (result.label) + "</a>";
			var title_html = !result.description
				? link_html
				: ("<b>" + link_html + "</b><div class=\"description\"> " + (result.description) + " </div>");

			var result_text = "<div class=\"result-text\">\n\t\t\t" + title_html + "\n\t\t</div>";

			var $result = $(("<div class=\"result " + type + "-result\">\n\t\t\t" + image_html + "\n\t\t\t" + result_text + "\n\t\t\t" + (result.subtypes || "") + "\n\t\t</div>"));

			if (!result.description) {
				this.handle_result_click(result, $result);
			}

			return $result;
		}

		handle_result_click(result, $result) {
			if (result.route_options) {
				frappe.route_options = result.route_options;
			}
			$result.on("click", function () {
				// this.toggle_minimize();
				if (result.onclick) {
					result.onclick(result.match);
				} else {
					var previous_hash = window.location.hash;
					frappe.set_route(result.route);
					// hashchange didn't fire!
					if (window.location.hash == previous_hash) {
						frappe.router.route();
					}
				}
			});
		}

		add_more_results(results_set) {
			var this$1 = this;

			var more_results = $('<div class="more-results last"></div>');
			if (results_set[0].results) {
				results_set[0].results.forEach(function (result) {
					more_results.append(
						this$1.render_result(results_set[0].title, result)
					);
				});
			}
			this.$body.find(".list-more").before(more_results);

			if (results_set[0].results.length < this.more_count) {
				// hide more button and add a result count
				this.$body.find(".list-more").hide();
				var no_of_results = this.$body.find(".result").length;
				var no_of_results_cue = $(
					'<div class="results-status">' +
						no_of_results +
						" results found</div>"
				);
				this.$body.find(".more-results:last").append(no_of_results_cue);
			}
			this.$body.find(".more-results.last").slideDown(200, function() {});
		}
	};

	// Copyright (c) 2019, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.tags");

	frappe.tags.utils = {
		get_tags: function(txt) {
			txt = txt.slice(1);
			var out = [];

			var loop = function ( i ) {
				var tag = frappe.tags.tags[i];
				var level = frappe.search.utils.fuzzy_search(txt, tag);
				if (level) {
					out.push({
						type: "Tag",
						label: __("#{0}", [frappe.search.utils.bolden_match_part(__(tag), txt)]),
						value: __("#{0}", [__(tag)]),
						index: 1 + level,
						match: tag,
						onclick: function onclick() {
							// Use Global Search Dialog for tag search too.
							frappe.searchdialog.search.init_search("#".concat(tag), "tags");
						}
					});
				}
			};

			for (var i in frappe.tags.tags) loop( i );

			return out;
		},

		fetch_tags: function fetch_tags() {
			frappe.call({
				method: "frappe.desk.doctype.tag.tag.get_tags_list_for_awesomebar",
				callback: function(r) {
					if (r && r.message) {
						frappe.tags.tags = $.extend([], r.message);
					}
				}
			});
		},

		get_tag_results: function(tag) {
			function get_results_sets(data) {
				var results_sets = [], result, set;
				function get_existing_set(doctype) {
					return results_sets.find(function(set) {
						return set.title === doctype;
					});
				}

				function make_description(content) {
					var field_length = 110;
					var field_value = null;
					if (content.length > field_length) {
						field_value = content.slice(0, field_length) + "...";
					} else {
						var length = content.length;
						field_value = content.slice(0, length) + "...";
					}
					return field_value;
				}

				data.forEach(function(d) {
					// more properties
					var description = "";
					if (d.content) {
						description = make_description(d.content);
					}
					result = {
						label: d.name,
						value: d.name,
						description: description,
						route: ['Form', d.doctype, d.name],

					};
					set = get_existing_set(d.doctype);
					if (set) {
						set.results.push(result);
					} else {
						set = {
							title: d.doctype,
							results: [result],
							fetch_type: "Global"
						};
						results_sets.push(set);
					}

				});
				return results_sets;
			}
			return new Promise(function(resolve) {
				frappe.call({
					method: "frappe.desk.doctype.tag.tag.get_documents_for_tag",
					args: {
						tag: tag
					},
					callback: function(r) {
						if (r.message) {
							resolve(get_results_sets(r.message));
						} else {
							resolve([]);
						}
					}
				});
			});
		},
	};

	frappe.templates['search'] = '<div class="search-results flex">  <div class="col-md-3 col-sm-3 hidden-xs layout-side-section">   <ul class="overlay-sidebar list-unstyled search-sidebar"></ul>  </div>  <div class="col-md-9 col-sm-9 layout-main-section results-area">   </div> </div> ';

	frappe.provide('frappe.search');

	frappe.search.utils = {
		setup_recent: function() {
			this.recent = JSON.parse(frappe.boot.user.recent || "[]") || [];
		},

		get_recent_pages: function(keywords) {
			if (keywords === null) { keywords = ''; }
			var me = this, values = [], options = [];

			function find(list, keywords, process) {
				list.forEach(function(item, i) {
					var _item = ($.isArray(item)) ? item[0] : item;
					_item = __(_item || '').toLowerCase().replace(/-/g, " ");

					if(keywords===_item || _item.indexOf(keywords) !== -1) {
						var option = process(item);

						if(option) {
							if($.isPlainObject(option)) {
								option = [option];
							}
							option.forEach(function(o) {
								o.match = item; o.recent = true;
							});

							options = option.concat(options);
						}
					}
				});
			}

			me.recent.forEach(function(doctype, i) {
				values.push([doctype[1], ['Form', doctype[0], doctype[1]]]);
			});

			values = values.reverse();

			frappe.route_history.forEach(function(route, i) {
				if(route[0]==='Form') {
					values.push([route[2], route]);
				} else if(['List', 'Tree', 'Workspaces', 'query-report'].includes(route[0]) || route[2]==='Report') {
					if(route[1]) {
						values.push([route[1], route]);
					}
				} else if(route[0]) {
					values.push([frappe.route_titles[route.join('/')] || route[0], route]);
				}
			});

			find(values, keywords, function(match) {
				var out = {
					route: match[1]
				};
				if (match[1][0]==='Form') {
					if (match[1].length > 2 && match[1][1] !== match[1][2]) {
						out.label = __(match[1][1]) + " " + match[1][2].bold();
						out.value = __(match[1][1]) + " " + match[1][2];
					} else {
						out.label = __(match[1][1]).bold();
						out.value = __(match[1][1]);
					}
				} else if (['List', 'Tree', 'Workspaces', 'query-report'].includes(match[1][0]) && (match[1].length > 1)) {
					var type = match[1][0], label = type;
					if(type==='Workspaces') { label = 'Workspace'; }
					else if(type==='query-report' || match[1][2] ==='Report') { label = 'Report'; }
					out.label = __(match[1][1]).bold() + " " + __(label);
					out.value = __(match[1][1]) + " " + __(label);
				} else if (match[0]) {
					out.label = match[0].bold();
					out.value = match[0];
				} else {
					// eslint-disable-next-line
					console.log('Illegal match', match);
				}
				out.index = 80;
				return out;
			});

			return options;
		},

		get_frequent_links: function get_frequent_links() {
			var options = [];
			frappe.boot.frequently_visited_links.forEach(function (link) {
				var label = frappe.utils.get_route_label(link.route);
				options.push({
					'route': link.route,
					'label': label,
					'value': label,
					'index': link.count,
				});
			});
			if (!options.length) {
				return this.get_recent_pages('');
			}
			return options;
		},

		get_search_in_list: function(keywords) {
			var me = this;
			var out = [];
			if(in_list(keywords.split(" "), "in") && (keywords.slice(-2) !== "in")) {
				var parts = keywords.split(" in ");
				frappe.boot.user.can_read.forEach(function(item) {
					if(frappe.boot.user.can_search.includes(item)) {
						var level = me.fuzzy_search(parts[1], item);
						if(level) {
							out.push({
								type: "In List",
								label: __('Find {0} in {1}', [__(parts[0]), me.bolden_match_part(__(item), parts[1])]),
								value: __('Find {0} in {1}', [__(parts[0]), __(item)]),
								route_options: {"name": ["like", "%" + parts[0] + "%"]},
								index: 1 + level,
								route: ["List", item]
							});
						}
					}
				});
			}
			return out;
		},

		get_creatables: function(keywords) {
			var me = this;
			var out = [];
			var firstKeyword = keywords.split(" ")[0];
			if(firstKeyword.toLowerCase() === __("new")) {
				frappe.boot.user.can_create.forEach(function(item) {
					var level = me.fuzzy_search(keywords.substr(4), item);
					if(level) {
						out.push({
							type: "New",
							label: __("New {0}", [me.bolden_match_part(__(item), keywords.substr(4))]),
							value: __("New {0}", [__(item)]),
							index: 1 + level,
							match: item,
							onclick: function() {
								frappe.new_doc(item, true);
							}
						});
					}
				});
			}
			return out;
		},

		get_doctypes: function(keywords) {
			var me = this;
			var out = [];

			var level, target;
			var option = function(type, route, order) {
				// check to skip extra list in the text
				// eg. Price List List should be only Price List
				var skip_list = type === 'List' && target.endsWith('List');
				var label = me.bolden_match_part(__(target), keywords);
				label += skip_list ? '' : (" " + (__(type)));

				return {
					type: type,
					label: label,
					value: __(target + " " + type),
					index: level + order,
					match: target,
					route: route,
				};
			};
			frappe.boot.user.can_read.forEach(function(item) {
				level = me.fuzzy_search(keywords, item);
				if (level) {
					target = item;
					if (in_list(frappe.boot.single_types, item)) {
						out.push(option("", ["Form", item, item], 0.05));

					} else if (frappe.boot.user.can_search.includes(item)) {
						// include 'making new' option
						if (in_list(frappe.boot.user.can_create, item)) {
							var match = item;
							out.push({
								type: "New",
								label: __("New {0}", [me.bolden_match_part(__(item), keywords)]),
								value: __("New {0}", [__(item)]),
								index: level + 0.015,
								match: item,
								onclick: function() {
									frappe.new_doc(match, true);
								}
							});
						}
						if (in_list(frappe.boot.treeviews, item)) {
							out.push(option("Tree", ["Tree", item], 0.05));

						} else {
							out.push(option("List", ["List", item], 0.05));
							if (frappe.model.can_get_report(item)) {
								out.push(option("Report", ["List", item, "Report"], 0.04));
							}
						}
					}
				}
			});
			return out;
		},

		get_reports: function(keywords) {
			var me = this;
			var out = [];
			var route;
			Object.keys(frappe.boot.user.all_reports).forEach(function(item) {
				var level = me.fuzzy_search(keywords, item);
				if(level > 0) {
					var report = frappe.boot.user.all_reports[item];
					if(report.report_type == "Report Builder")
						{ route = ["List", report.ref_doctype, "Report", item]; }
					else
						{ route = ["query-report",  item]; }
					out.push({
						type: "Report",
						label: __("Report {0}" , [me.bolden_match_part(__(item), keywords)]),
						value: __("Report {0}" , [__(item)]),
						index: level,
						route: route
					});
				}
			});
			return out;
		},

		get_pages: function(keywords) {
			var me = this;
			var out = [];
			this.pages = {};
			$.each(frappe.boot.page_info, function(name, p) {
				me.pages[p.title] = p;
				p.name = name;
			});
			Object.keys(this.pages).forEach(function(item) {
				if(item == "Hub" || item == "hub") { return; }
				var level = me.fuzzy_search(keywords, item);
				if(level) {
					var page = me.pages[item];
					out.push({
						type: "Page",
						label: __("Open {0}", [me.bolden_match_part(__(item), keywords)]),
						value: __("Open {0}", [__(item)]),
						match: item,
						index: level,
						route: [page.route || page.name]
					});
				}
			});
			var target = 'Calendar';
			if(__('calendar').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Calendar",
					value: __("Open {0}", [__(target)]),
					index: me.fuzzy_search(keywords, 'Calendar'),
					match: target,
					route: ['List', 'Event', target],
				});
			}
			target = 'Hub';
			if(__('hub').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Hub",
					value: __("Open {0}", [__(target)]),
					index: me.fuzzy_search(keywords, 'Hub'),
					match: target,
					route: [target, 'Item'],
				});
			}
			if(__('email inbox').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Inbox",
					value: __("Open {0}", [__('Email Inbox')]),
					index: me.fuzzy_search(keywords, 'email inbox'),
					match: target,
					route: ['List', 'Communication', 'Inbox'],
				});
			}
			return out;
		},

		get_workspaces: function(keywords) {
			var me = this;
			var out = [];
			frappe.boot.allowed_workspaces.forEach(function(item) {
				var level = me.fuzzy_search(keywords, item.name);
				if (level > 0) {
					var ret = {
						type: "Workspace",
						label: __("Open {0}", [me.bolden_match_part(__(item.name), keywords)]),
						value: __("Open {0}", [__(item.name)]),
						index: level,
						route: [frappe.router.slug(item.name)]
					};

					out.push(ret);
				}
			});
			return out;
		},

		get_dashboards: function(keywords) {
			var me = this;
			var out = [];
			frappe.boot.dashboards.forEach(function(item) {
				var level = me.fuzzy_search(keywords, item.name);
				if (level > 0) {
					var ret = {
						type: "Dashboard",
						label: __("{0} Dashboard", [me.bolden_match_part(__(item.name), keywords)]),
						value: __("{0} Dashboard", [__(item.name)]),
						index: level,
						route: ["dashboard-view", item.name]
					};

					out.push(ret);
				}
			});
			return out;
		},

		get_global_results: function(keywords, start, limit, doctype) {
			if ( doctype === void 0 ) doctype = "";

			var me = this;
			function get_results_sets(data) {
				var results_sets = [], result, set;
				function get_existing_set(doctype) {
					return results_sets.find(function(set) {
						return set.title === doctype;
					});
				}

				function make_description(content, doc_name) {
					var parts = content.split(" ||| ");
					var result_max_length = 300;
					var field_length = 120;
					var fields = [];
					var result_current_length = 0;
					var field_text = "";
					for(var i = 0; i < parts.length; i++) {
						var part = parts[i];
						if(part.toLowerCase().indexOf(keywords) !== -1) {
							// If the field contains the keyword
							if(part.indexOf(' &&& ') !== -1) {
								var colon_index = part.indexOf(' &&& ');
								var field_value = part.slice(colon_index + 5);
							} else {
								var colon_index = part.indexOf(' : ');
								var field_value = part.slice(colon_index + 3);
							}
							if(field_value.length > field_length) {
								// If field value exceeds field_length, find the keyword in it
								// and trim field value by half the field_length at both sides
								// ellipsify if necessary
								var field_data = "";
								var index = field_value.indexOf(keywords);
								field_data += index < field_length/2 ? field_value.slice(0, index)
									: '...' + field_value.slice(index - field_length/2, index);
								field_data += field_value.slice(index, index + field_length/2);
								field_data += index + field_length/2 < field_value.length ? "..." : "";
								field_value = field_data;
							}
							var field_name = part.slice(0, colon_index);

							// Find remaining result_length and add field length to result_current_length
							var remaining_length = result_max_length - result_current_length;
							result_current_length += field_name.length + field_value.length + 2;
							if(result_current_length < result_max_length) {
								// We have room, push the entire field
								field_text = '<span class="field-name text-muted">' +
									me.bolden_match_part(field_name, keywords) + ': </span> ' +
									me.bolden_match_part(field_value, keywords);
								if(fields.indexOf(field_text) === -1 && doc_name !== field_value) {
									fields.push(field_text);
								}
							} else {
								// Not enough room
								if(field_name.length < remaining_length){
									// Ellipsify (trim at word end) and push
									remaining_length -= field_name.length;
									field_text = '<span class="field-name text-muted">' +
										me.bolden_match_part(field_name, keywords) + ': </span> ';
									field_value = field_value.slice(0, remaining_length);
									field_value = field_value.slice(0, field_value.lastIndexOf(' ')) + ' ...';
									field_text += me.bolden_match_part(field_value, keywords);
									fields.push(field_text);
								} else {
									// No room for even the field name, skip
									fields.push('...');
								}
								break;
							}
						}
					}
					return fields.join(', ');
				}

				data.forEach(function(d) {
					// more properties
					result = {
						label: d.name,
						value: d.name,
						description: make_description(d.content, d.name),
						route: ['Form', d.doctype, d.name],
					};
					if(d.image || d.image === null){
						result.image = d.image;
					}
					set = get_existing_set(d.doctype);
					if(set) {
						set.results.push(result);
					} else {
						set = {
							title: d.doctype,
							results: [result],
							fetch_type: "Global"
						};
						results_sets.push(set);
					}

				});
				return results_sets;
			}
			return new Promise(function(resolve, reject) {
				frappe.call({
					method: "frappe.utils.global_search.search",
					args: {
						text: keywords,
						start: start,
						limit: limit,
						doctype: doctype
					},
					callback: function(r) {
						if(r.message) {
							resolve(get_results_sets(r.message));
						} else {
							resolve([]);
						}
					}
				});
			});
		},

		get_nav_results: function(keywords) {
			function sort_uniques(array) {
				var routes = [], out = [];
				array.forEach(function(d) {
					if(d.route) {
						if(d.route[0] === "List" && d.route[2]) {
							d.route.splice(2);
						}
						var str_route = d.route.join('/');
						if(routes.indexOf(str_route) === -1) {
							routes.push(str_route);
							out.push(d);
						} else {
							var old = routes.indexOf(str_route);
							if(out[old].index > d.index) {
								out[old] = d;
							}
						}
					} else {
						out.push(d);
					}
				});
				return out.sort(function(a, b) {
					return b.index - a.index;
				});
			}
			var lists = [], setup = [];
			var all_doctypes = sort_uniques(this.get_doctypes(keywords));
			all_doctypes.forEach(function(d) {
				if(d.type === "") {
					setup.push(d);
				} else {
					lists.push(d);
				}
			});
			var in_keyword = keywords.split(" in ")[0];
			return [{
				title: __("Recents"),
				fetch_type: "Nav",
				results: sort_uniques(this.get_recent_pages(keywords))
			},
			{
				title: __("Create a new ..."),
				fetch_type: "Nav",
				results: sort_uniques(this.get_creatables(keywords))
			},
			{
				title: __("Lists"),
				fetch_type: "Nav",
				results: lists
			},
			{
				title: __("Reports"),
				fetch_type: "Nav",
				results: sort_uniques(this.get_reports(keywords))
			},
			{
				title: __("Administration"),
				fetch_type: "Nav",
				results: sort_uniques(this.get_pages(keywords))
			},
			{
				title: __("Workspace"),
				fetch_type: "Nav",
				results: sort_uniques(this.get_workspaces(keywords))
			},
			{
				title: __("Dashboard"),
				fetch_type: "Nav",
				results: sort_uniques(this.get_dashboards(keywords))
			},
			{
				title: __("Setup"),
				fetch_type: "Nav",
				results: setup
			},
			{
				title: __("Find '{0}' in ...", [in_keyword]),
				fetch_type: "Nav",
				results: sort_uniques(this.get_search_in_list(keywords))
			}];
		},

		fuzzy_search: function(keywords, _item) {
			// Returns 10 for case-perfect contain, 0 for not found
			//  	9 for perfect contain,
			//  	0 - 6 for fuzzy contain

			// **Specific use-case step**
			keywords = keywords || '';
			var item = __(_item || '');
			var item_without_hyphen = item.replace(/-/g, " ");

			var item_length = item.length;
			var query_length = keywords.length;
			var length_ratio = query_length / item_length;
			var max_skips = 3, max_mismatch_len = 2;

			if (query_length > item_length) {
				return 0;
			}

			// check for perfect string matches or
			// matches that start with the keyword
			if ([item, item_without_hyphen].includes(keywords)
					|| [item, item_without_hyphen].some(function (txt) { return txt.toLowerCase().indexOf(keywords) === 0; })) {
				return 10 + length_ratio;
			}

			if (item.indexOf(keywords) !== -1 && keywords !== keywords.toLowerCase()) {
				return 9 + length_ratio;
			}

			item = item.toLowerCase();
			keywords = keywords.toLowerCase();

			if (item.indexOf(keywords) !== -1) {
				return 8 + length_ratio;
			}

			var skips = 0, mismatches = 0;
			outer: for (var i = 0, j = 0; i < query_length; i++) {
				if (mismatches !== 0) { skips++; }
				if (skips > max_skips) { return 0; }
				var k_ch = keywords.charCodeAt(i);
				mismatches = 0;
				while (j < item_length) {
					if (item.charCodeAt(j++) === k_ch) {
						continue outer;
					}
					if(++mismatches > max_mismatch_len)  { return 0 ; }
				}
				return 0;
			}

			// Since indexOf didn't pass, there will be atleast 1 skip
			// hence no divide by zero, but just to be safe
			if((skips + mismatches) > 0) {
				return (5 + length_ratio)/(skips + mismatches);
			} else {
				return 0;
			}
		},

		bolden_match_part: function(str, subseq) {
			var rendered = "";
			if(this.fuzzy_search(subseq, str) === 0) {
				return str;
			} else if(this.fuzzy_search(subseq, str) > 6) {
				var regEx = new RegExp("("+ subseq +")", "ig");
				return str.replace(regEx, '<mark>$1</mark>');
			} else {
				var str_orig = str;
				var str = str.toLowerCase();
				var str_len = str.length;
				var subseq = subseq.toLowerCase();

				outer: for(var i = 0, j = 0; i < subseq.length; i++) {
					var sub_ch = subseq.charCodeAt(i);
					while(j < str_len) {
						if(str.charCodeAt(j) === sub_ch) {
							var str_char = str_orig.charAt(j);
							if(str_char === str_char.toLowerCase()) {
								rendered += '<mark>' + subseq.charAt(i) + '</mark>';
							} else {
								rendered += '<mark>' + subseq.charAt(i).toUpperCase() + '</mark>';
							}
							j++;
							continue outer;
						}
						rendered += str_orig.charAt(j);
						j++;
					}
					return str_orig;
				}
				rendered += str_orig.slice(j);
				return rendered;
			}

		},

		get_executables: function get_executables(keywords) {
			var this$1 = this;

			var results = [];
			this.searchable_functions.forEach(function (item) {
				var target = item.label.toLowerCase();
				var txt = keywords.toLowerCase();
				if (txt === target || target.indexOf(txt) === 0) {
					results.push({
						type: "Executable",
						value:  this$1.bolden_match_part(__(item.label), txt),
						index: this$1.fuzzy_search(txt, target),
						match: item.label,
						onclick: function () { return item.action.apply(this$1, item.args); }
					});
				}
			});
			return results;
		},
		make_function_searchable: function make_function_searchable(_function, label, args) {
			if ( label === void 0 ) label=null;
			if ( args === void 0 ) args=null;

			if (typeof _function !== 'function') {
				throw new Error('First argument should be a function');
			}

			this.searchable_functions.push({
				'label': label || _function.name,
				'action': _function,
				'args': args,
			});
		},
		searchable_functions: [],
	};

	frappe.provide('frappe.ui.misc');
	frappe.ui.misc.about = function() {
		if(!frappe.ui.misc.about_dialog) {
			var d = new frappe.ui.Dialog({title: __('Frappe Framework')});

			$(d.body).html(repl("<div>\
		<p>"+__("Open Source Applications for the Web")+"</p>  \
		<p><i class='fa fa-globe fa-fw'></i>\
			Website: <a href='https://frappeframework.com' target='_blank'>https://frappeframework.com</a></p>\
		<p><i class='fa fa-github fa-fw'></i>\
			Source: <a href='https://github.com/frappe' target='_blank'>https://github.com/frappe</a></p>\
		<p><i class='fa fa-linkedin fa-fw'></i>\
			Linkedin: <a href='https://linkedin.com/company/frappe-tech' target='_blank'>https://linkedin.com/company/frappe-tech</a></p>\
		<p><i class='fa fa-facebook fa-fw'></i>\
			Facebook: <a href='https://facebook.com/erpnext' target='_blank'>https://facebook.com/erpnext</a></p>\
		<p><i class='fa fa-twitter fa-fw'></i>\
			Twitter: <a href='https://twitter.com/erpnext' target='_blank'>https://twitter.com/erpnext</a></p>\
		<hr>\
		<h4>Installed Apps</h4>\
		<div id='about-app-versions'>Loading versions...</div>\
		<hr>\
		<p class='text-muted'>&copy; Frappe Technologies Pvt. Ltd and contributors </p> \
		</div>", frappe.app));

			frappe.ui.misc.about_dialog = d;

			frappe.ui.misc.about_dialog.on_page_show = function() {
				if(!frappe.versions) {
					frappe.call({
						method: "frappe.utils.change_log.get_versions",
						callback: function(r) {
							show_versions(r.message);
						}
					});
				} else {
					show_versions(frappe.versions);
				}
			};

			var show_versions = function(versions) {
				var $wrap = $("#about-app-versions").empty();
				$.each(Object.keys(versions).sort(), function(i, key) {
					var v = versions[key];
					if(v.branch) {
						var text = $.format('<p><b>{0}:</b> v{1} ({2})<br></p>',
							[v.title, v.branch_version || v.version, v.branch]);
					} else {
						var text = $.format('<p><b>{0}:</b> v{1}<br></p>',
							[v.title, v.version]);
					}
					$(text).appendTo($wrap);
				});

				frappe.versions = versions;
			};

		}

		frappe.ui.misc.about_dialog.show();

	};

	frappe.templates['navbar'] = '<header class="navbar navbar-expand sticky-top" role="navigation">  <div class="container">   <a class="navbar-brand navbar-home" href="/app">    <img class="app-logo" style="width: {{ navbar_settings.logo_width || 24 }}px" src="{{ frappe.boot.app_logo_url }}">   </a>   <ul class="nav navbar-nav d-none d-sm-flex" id="navbar-breadcrumbs"></ul>   <div class="collapse navbar-collapse justify-content-end">    <form class="form-inline fill-width justify-content-end" role="search" onsubmit="return false;">     <div class="input-group search-bar text-muted hidden">      <input       id="navbar-search"       type="text"       class="form-control"       placeholder="{%= __("Search or type a command (Ctrl + G)") %}"       aria-haspopup="true"      >      <span class="search-icon">       <svg class="icon icon-sm"><use xlink:href="#icon-search"></use></svg>      </span>     </div>    </form>    <ul class="navbar-nav">     <li class="nav-item dropdown dropdown-notifications dropdown-mobile hidden">      <a       class="nav-link notifications-icon text-muted"       data-toggle="dropdown"       aria-haspopup="true"       aria-expanded="true"       href="#"       onclick="return false;">       <span class="notifications-seen">        <svg class="icon icon-md"><use href="#icon-notification"></use></svg>       </span>       <span class="notifications-unseen">        <svg class="icon icon-md"><use href="#icon-notification-with-indicator"></use></svg>       </span>      </a>      <div class="dropdown-menu notifications-list dropdown-menu-right" role="menu">       <div class="notification-list-header">        <div class="header-items"></div>        <div class="header-actions"></div>       </div>       <div class="notification-list-body">        <div class="panel-notifications"></div>        <div class="panel-events"></div>       </div>      </div>     </li>     <li class="nav-item dropdown dropdown-message dropdown-mobile hidden">      <a       class="nav-link notifications-icon text-muted"       data-toggle="dropdown"       aria-haspopup="true"       aria-expanded="true"       href="#"       onclick="return false;">       <span>        <svg class="icon icon-md"><use href="#icon-small-message"></use></svg>       </span>      </a>     </li>     <li class="vertical-bar d-none d-sm-block"></li>     <li class="nav-item dropdown dropdown-help dropdown-mobile d-none d-lg-block">      <a class="nav-link" data-toggle="dropdown" href="#" onclick="return false;">       {{ __("Help") }}       <span>        <svg class="icon icon-xs"><use href="#icon-small-down"></use></svg>       </span>      </a>      <div class="dropdown-menu dropdown-menu-right" id="toolbar-help" role="menu">       <div id="help-links"></div>       <div class="dropdown-divider documentation-links"></div>       {% for item in navbar_settings.help_dropdown %}        {% if (!item.hidden) { %}         {% if (item.route) { %}          <a class="dropdown-item" href="{{ item.route }}">           {%= __(item.item_label) %}          </a>         {% } else if (item.action) { %}          <a class="dropdown-item" onclick="return {{ item.action }}">           {%= __(item.item_label) %}          </a>         {% } else { %}          <div class="dropdown-divider"></div>         {% } %}        {% } %}       {% endfor %}      </div>     </li>     <li class="nav-item dropdown dropdown-navbar-user dropdown-mobile">      <a class="nav-link" data-toggle="dropdown" href="#" onclick="return false;">       {{ avatar }}      </a>      <div class="dropdown-menu dropdown-menu-right" id="toolbar-user" role="menu">       {% for item in navbar_settings.settings_dropdown %}        {% if (!item.hidden) { %}         {% if (item.route) { %}          <a class="dropdown-item" href="{{ item.route }}">           {%= __(item.item_label) %}          </a>         {% } else if (item.action) { %}          <a class="dropdown-item" onclick="return {{ item.action }}">           {%= __(item.item_label) %}          </a>         {% } else { %}          <div class="dropdown-divider"></div>         {% } %}        {% } %}       {% endfor %}      </div>     </li>    </ul>   </div>  </div> </header> ';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.ui.toolbar");
	frappe.provide('frappe.search');

	frappe.ui.toolbar.Toolbar = class {
		constructor () {
			$('header').replaceWith(frappe.render_template("navbar", {
				avatar: frappe.avatar(frappe.session.user, 'avatar-medium'),
				navbar_settings: frappe.boot.navbar_settings
			}));
			$('.dropdown-toggle').dropdown();

			this.setup_awesomebar();
			this.setup_notifications();
			this.setup_help();
			this.make();
		}

		make () {
			this.bind_events();
			$(document).trigger('toolbar_setup');
		}

		bind_events () {
			// clear all custom menus on page change
			$(document).on("page-change", function() {
				$("header .navbar .custom-menu").remove();
			});

			//focus search-modal on show in mobile view
			$('#search-modal').on('shown.bs.modal', function() {
				var search_modal = $(this);
				setTimeout(function() {
					search_modal.find('#modal-search').focus();
				}, 300);
			});
			$('.navbar-toggle-full-width').click(function () {
				frappe.ui.toolbar.toggle_full_width();
			});
		}


		setup_help () {
			if (!frappe.boot.desk_settings.notifications) {
				// hide the help section
				$('.navbar .vertical-bar').removeClass('d-sm-block');
				$('.dropdown-help').removeClass('d-lg-block');
				return;
			}
			frappe.provide('frappe.help');
			frappe.help.show_results = show_results;

			this.search = new frappe.search.SearchDialog();
			frappe.provide('frappe.searchdialog');
			frappe.searchdialog.search = this.search;

			$(".dropdown-help .dropdown-toggle").on("click", function() {
				$(".dropdown-help input").focus();
			});

			$(".dropdown-help .dropdown-menu").on("click", "input, button", function(e) {
				e.stopPropagation();
			});

			$("#input-help").on("keydown", function(e) {
				if(e.which == 13) {
					$(this).val("");
				}
			});

			$(document).on("page-change", function () {
				var $help_links = $(".dropdown-help #help-links");
				$help_links.html("");

				var route = frappe.get_route_str();
				var breadcrumbs = route.split("/");

				var links = [];
				for (var i = 0; i < breadcrumbs.length; i++) {
					var r = route.split("/", i + 1);
					var key = r.join("/");
					var help_links = frappe.help.help_links[key] || [];
					links = $.merge(links, help_links);
				}

				if(links.length === 0) {
					$help_links.next().hide();
				} else {
					$help_links.next().show();
				}

				for (var i = 0; i < links.length; i++) {
					var link = links[i];
					var url = link.url;
					$("<a>", {
						href: url,
						class: "dropdown-item",
						text: link.label,
						target: "_blank"
					}).appendTo($help_links);
				}

				$('.dropdown-help .dropdown-menu').on('click', 'a', show_results);
			});

			var $result_modal = frappe.get_modal("", "");
			$result_modal.addClass("help-modal");

			$(document).on("click", ".help-modal a", show_results);

			function show_results(e) {
				//edit links
				var href = e.target.href;
				if(href.indexOf('blob') > 0) {
					window.open(href, '_blank');
				}
				var path = $(e.target).attr("data-path");
				if(path) {
					e.preventDefault();
				}
			}
		}

		setup_awesomebar() {
			if (frappe.boot.desk_settings.search_bar) {
				var awesome_bar = new frappe.search.AwesomeBar();
				awesome_bar.setup("#navbar-search");

				// TODO: Remove this in v14
				frappe.search.utils.make_function_searchable(function() {
					frappe.set_route("List", "Client Script");
				}, __("Custom Script List"));

			}
		}

		setup_notifications () {
			if (frappe.boot.desk_settings.notifications && frappe.session.user !== 'Guest') {
				this.notifications = new frappe.ui.Notifications();
			}
		}

	};

	$.extend(frappe.ui.toolbar, {
		add_dropdown_button: function(parent, label, click, icon) {
			var menu = frappe.ui.toolbar.get_menu(parent);
			if(menu.find("li:not(.custom-menu)").length && !menu.find(".divider").length) {
				frappe.ui.toolbar.add_menu_divider(menu);
			}

			return $('<li class="custom-menu"><a><i class="fa-fw '
				+icon+'"></i> '+label+'</a></li>')
				.insertBefore(menu.find(".divider"))
				.find("a")
				.click(function() {
					click.apply(this);
				});
		},
		get_menu: function(label) {
			return $("#navbar-" + label.toLowerCase());
		},
		add_menu_divider: function(menu) {
			menu = typeof menu == "string" ?
				frappe.ui.toolbar.get_menu(menu) : menu;

			$('<li class="divider custom-menu"></li>').prependTo(menu);
		},
		add_icon_link: function add_icon_link(route, icon, index, class_name) {
			var parent_element = $(".navbar-right").get(0);
			var new_element = $(("<li class=\"" + class_name + "\">\n\t\t\t<a class=\"btn\" href=\"" + route + "\" title=\"" + (frappe.utils.to_title_case(class_name, true)) + "\" aria-haspopup=\"true\" aria-expanded=\"true\">\n\t\t\t\t<div>\n\t\t\t\t\t<i class=\"octicon " + icon + "\"></i>\n\t\t\t\t</div>\n\t\t\t</a>\n\t\t</li>")).get(0);

			parent_element.insertBefore(new_element, parent_element.children[index]);
		},
		toggle_full_width: function toggle_full_width() {
			var fullwidth = JSON.parse(localStorage.container_fullwidth || 'false');
			fullwidth = !fullwidth;
			localStorage.container_fullwidth = fullwidth;
			frappe.ui.toolbar.set_fullwidth_if_enabled();
			$(document.body).trigger('toggleFullWidth');
		},
		set_fullwidth_if_enabled: function set_fullwidth_if_enabled() {
			var fullwidth = JSON.parse(localStorage.container_fullwidth || 'false');
			$(document.body).toggleClass('full-width', fullwidth);
		},
		show_shortcuts: function show_shortcuts (e) {
			e.preventDefault();
			frappe.ui.keys.show_keyboard_shortcut_dialog();
			return false;
		},
	});

	frappe.ui.toolbar.clear_cache = frappe.utils.throttle(function() {
		frappe.assets.clear_local_storage();
		frappe.xcall('frappe.sessions.clear').then(function (message) {
			frappe.show_alert({
				message: message,
				indicator: 'info'
			});
			location.reload(true);
		});
	}, 10000);

	frappe.ui.toolbar.show_about = function() {
		try {
			frappe.ui.misc.about();
		} catch(e) {
			console.log(e);
		}
		return false;
	};

	frappe.ui.toolbar.route_to_user = function() {
		frappe.set_route('Form', 'User', frappe.session.user);
	};

	frappe.ui.toolbar.view_website = function() {
		var website_tab = window.open();
		website_tab.opener = null;
		website_tab.location = '/index';
	};

	frappe.ui.toolbar.setup_session_defaults = function() {
		var fields = [];
		frappe.call({
			method: 'frappe.core.doctype.session_default_settings.session_default_settings.get_session_default_values',
			callback: function (data) {
				fields = JSON.parse(data.message);
				var perms = frappe.perm.get_perm('Session Default Settings');
				//add settings button only if user is a System Manager or has permission on 'Session Default Settings'
				if ((in_list(frappe.user_roles, 'System Manager')) || (perms[0].read == 1))  {
					fields[fields.length] = {
						'fieldname': 'settings',
						'fieldtype': 'Button',
						'label': __('Settings'),
						'click': function () {
							frappe.set_route('Form', 'Session Default Settings', 'Session Default Settings');
						}
					};
				}
				frappe.prompt(fields, function(values) {
					//if default is not set for a particular field in prompt
					fields.forEach(function(d) {
						if (!values[d.fieldname]) {
							values[d.fieldname] = "";
						}
					});
					frappe.call({
						method: 'frappe.core.doctype.session_default_settings.session_default_settings.set_session_default_values',
						args: {
							default_values: values,
						},
						callback: function(data) {
							if (data.message == "success") {
								frappe.show_alert({
									'message': __('Session Defaults Saved'),
									'indicator': 'green'
								});
								frappe.ui.toolbar.clear_cache();
							}	else {
								frappe.show_alert({
									'message': __('An error occurred while setting Session Defaults'),
									'indicator': 'red'
								});
							}
						}
					});
				},
				__('Session Defaults'),
				__('Save')
				);
			}
		});
	};

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.last_edited_communication = {};
	var separator_element = '<div>---</div>';

	frappe.views.CommunicationComposer = class {
		constructor(opts) {
			$.extend(this, opts);
			if (!this.doc) {
				this.doc = this.frm && this.frm.doc || {};
			}

			this.make();
		}

		make() {
			var me = this;

			this.dialog = new frappe.ui.Dialog({
				title: (this.title || this.subject || __("New Email")),
				no_submit_on_enter: true,
				fields: this.get_fields(),
				primary_action_label: __("Send"),
				primary_action: function primary_action() {
					me.send_action();
				},
				secondary_action_label: __("Discard"),
				secondary_action: function secondary_action() {
					me.dialog.hide();
					me.clear_cache();
				},
				size: 'large',
				minimizable: true
			});

			this.dialog.sections[0].wrapper.addClass('to_section');

			this.prepare();
			this.dialog.show();

			if (this.frm) {
				$(document).trigger('form-typing', [this.frm]);
			}
		}

		get_fields() {
			var this$1 = this;

			var fields = [
				{
					label: __("To"),
					fieldtype: "MultiSelect",
					reqd: 0,
					fieldname: "recipients",
				},
				{
					fieldtype: "Button",
					label: frappe.utils.icon('down'),
					fieldname: 'option_toggle_button',
					click: function () {
						this$1.toggle_more_options();
					}
				},
				{
					fieldtype: "Section Break",
					hidden: 1,
					fieldname: "more_options"
				},
				{
					label: __("CC"),
					fieldtype: "MultiSelect",
					fieldname: "cc",
				},
				{
					label: __("BCC"),
					fieldtype: "MultiSelect",
					fieldname: "bcc",
				},
				{
					label: __("Email Template"),
					fieldtype: "Link",
					options: "Email Template",
					fieldname: "email_template"
				},
				{ fieldtype: "Section Break" },
				{
					label: __("Subject"),
					fieldtype: "Data",
					reqd: 1,
					fieldname: "subject",
					length: 524288
				},
				{
					label: __("Message"),
					fieldtype: "Text Editor",
					fieldname: "content",
					onchange: frappe.utils.debounce(
						this.save_as_draft.bind(this),
						300
					)
				},
				{ fieldtype: "Section Break" },
				{
					label: __("Send me a copy"),
					fieldtype: "Check",
					fieldname: "send_me_a_copy",
					default: frappe.boot.user.send_me_a_copy
				},
				{
					label: __("Send Read Receipt"),
					fieldtype: "Check",
					fieldname: "send_read_receipt"
				},
				{
					label: __("Attach Document Print"),
					fieldtype: "Check",
					fieldname: "attach_document_print"
				},
				{
					label: __("Select Print Format"),
					fieldtype: "Select",
					fieldname: "select_print_format"
				},
				{
					label: __("Select Languages"),
					fieldtype: "Select",
					fieldname: "language_sel"
				},
				{ fieldtype: "Column Break" },
				{
					label: __("Select Attachments"),
					fieldtype: "HTML",
					fieldname: "select_attachments"
				}
			];

			// add from if user has access to multiple email accounts
			var email_accounts = frappe.boot.email_accounts.filter(function (account) {
				return (
					!in_list(
						["All Accounts", "Sent", "Spam", "Trash"],
						account.email_account
					) && account.enable_outgoing
				);
			});

			if (email_accounts.length) {
				fields.unshift({
					label: __("From"),
					fieldtype: "Select",
					reqd: 1,
					fieldname: "sender",
					options: email_accounts.map(function(e) {
						return e.email_id;
					})
				});
			}

			return fields;
		}

		toggle_more_options(show_options) {
			show_options = show_options || this.dialog.fields_dict.more_options.df.hidden;
			this.dialog.set_df_property('more_options', 'hidden', !show_options);

			var label = frappe.utils.icon(show_options ? 'up-line': 'down');
			this.dialog.get_field('option_toggle_button').set_label(label);
		}

		prepare() {
			this.setup_multiselect_queries();
			this.setup_subject_and_recipients();
			this.setup_print_language();
			this.setup_print();
			this.setup_attach();
			this.setup_email();
			this.setup_email_template();
			this.setup_last_edited_communication();
			this.set_values();
		}

		setup_multiselect_queries() {
			var this$1 = this;

			['recipients', 'cc', 'bcc'].forEach(function (field) {
				this$1.dialog.fields_dict[field].get_data = function () {
					var data = this$1.dialog.fields_dict[field].get_value();
					var txt = data.match(/[^,\s*]*$/)[0] || '';

					frappe.call({
						method: "frappe.email.get_contact_list",
						args: {txt: txt},
						callback: function (r) {
							this$1.dialog.fields_dict[field].set_data(r.message);
						}
					});
				};
			});
		}

		setup_subject_and_recipients() {
			this.subject = this.subject || "";

			if (!this.forward && !this.recipients && this.last_email) {
				this.recipients = this.last_email.sender;
				this.cc = this.last_email.cc;
				this.bcc = this.last_email.bcc;
			}

			if (!this.forward && !this.recipients) {
				this.recipients = this.frm && this.frm.timeline.get_recipient();
			}

			if (!this.subject && this.frm) {
				// get subject from last communication
				var last = this.frm.timeline.get_last_email();

				if (last) {
					this.subject = last.subject;
					if (!this.recipients) {
						this.recipients = last.sender;
					}

					// prepend "Re:"
					if (strip(this.subject.toLowerCase().split(":")[0])!="re") {
						this.subject = __("Re: {0}", [this.subject]);
					}
				}

				if (!this.subject) {
					this.subject = this.frm.doc.name;
					if (this.frm.meta.subject_field && this.frm.doc[this.frm.meta.subject_field]) {
						this.subject = this.frm.doc[this.frm.meta.subject_field];
					} else if (this.frm.meta.title_field && this.frm.doc[this.frm.meta.title_field]) {
						this.subject = this.frm.doc[this.frm.meta.title_field];
					}
				}

				// always add an identifier to catch a reply
				// some email clients (outlook) may not send the message id to identify
				// the thread. So as a backup we use the name of the document as identifier
				var identifier = "#" + (this.frm.doc.name);
				if (!this.subject.includes(identifier)) {
					this.subject = (this.subject) + " (" + identifier + ")";
				}
			}

			if (this.frm && !this.recipients) {
				this.recipients = this.frm.doc[this.frm.email_field];
			}
		}

		setup_email_template() {
			var me = this;

			this.dialog.fields_dict["email_template"].df.onchange = function () {
				var email_template = me.dialog.fields_dict.email_template.get_value();
				if (!email_template) { return; }

				function prepend_reply(reply) {
					if (me.reply_added === email_template) { return; }

					var content_field = me.dialog.fields_dict.content;
					var subject_field = me.dialog.fields_dict.subject;

					var content = content_field.get_value() || "";
					content = content.split('<!-- salutation-ends -->')[1] || content;

					content_field.set_value(((reply.message) + "<br>" + content));
					subject_field.set_value(reply.subject);

					me.reply_added = email_template;
				}

				frappe.call({
					method: 'frappe.email.doctype.email_template.email_template.get_email_template',
					args: {
						template_name: email_template,
						doc: me.doc,
						_lang: me.dialog.get_value("language_sel")
					},
					callback: function callback(r) {
						prepend_reply(r.message);
					},
				});
			};
		}

		setup_last_edited_communication() {
			var this$1 = this;

			if (this.frm) {
				this.doctype = this.frm.doctype;
				this.key = this.frm.docname;
			} else {
				this.doctype = this.key = "Inbox";
			}

			if (this.last_email) {
				this.key = this.key + ":" + this.last_email.name;
			}

			if (this.subject) {
				this.key = this.key + ":" + this.subject;
			}

			this.dialog.on_hide = function () {
				$.extend(
					this$1.get_last_edited_communication(true),
					this$1.dialog.get_values(true)
				);

				if (this$1.frm) {
					$(document).trigger("form-stopped-typing", [this$1.frm]);
				}
			};
		}

		get_last_edited_communication(clear) {
			if (!frappe.last_edited_communication[this.doctype]) {
				frappe.last_edited_communication[this.doctype] = {};
			}

			if (clear || !frappe.last_edited_communication[this.doctype][this.key]) {
				frappe.last_edited_communication[this.doctype][this.key] = {};
			}

			return frappe.last_edited_communication[this.doctype][this.key];
		}

		async set_values() {
			for (var i = 0, list = ["recipients", "cc", "bcc", "sender"]; i < list.length; i += 1) {
				var fieldname = list[i];

				await this.dialog.set_value(fieldname, this[fieldname] || "");
			}

			var subject = frappe.utils.html2text(this.subject) || '';
			await this.dialog.set_value("subject", subject);

			await this.set_values_from_last_edited_communication();
			await this.set_content();

			// set default email template for the first email in a document
			if (this.frm && !this.is_a_reply && !this.content_set) {
				var email_template = this.frm.meta.default_email_template || '';
				await this.dialog.set_value("email_template", email_template);
			}

			for (var i$1 = 0, list$1 = ['email_template', 'cc', 'bcc']; i$1 < list$1.length; i$1 += 1) {
				var fieldname$1 = list$1[i$1];

				if (this.dialog.get_value(fieldname$1)) {
					this.toggle_more_options(true);
					break;
				}
			}
		}

		async set_values_from_last_edited_communication() {
			if (this.txt) { return; }

			var last_edited = this.get_last_edited_communication();
			if (!last_edited.content) { return; }

			// prevent re-triggering of email template
			if (last_edited.email_template) {
				var template_field = this.dialog.fields_dict.email_template;
				await template_field.set_model_value(last_edited.email_template);
				delete last_edited.email_template;
			}

			await this.dialog.set_values(last_edited);
			this.content_set = true;
		}

		selected_format() {
			return (
				this.dialog.fields_dict.select_print_format.input.value
				|| this.frm && this.frm.meta.default_print_format
				|| "Standard"
			);
		}

		get_print_format(format) {
			if (!format) {
				format = this.selected_format();
			}

			if (locals["Print Format"] && locals["Print Format"][format]) {
				return locals["Print Format"][format];
			} else {
				return {};
			}
		}

		setup_print_language() {
			var fields = this.dialog.fields_dict;

			//Load default print language from doctype
			this.lang_code = this.doc.language
				|| this.get_print_format().default_print_language
				|| frappe.boot.lang;

			//On selection of language retrieve language code
			var me = this;
			$(fields.language_sel.input).change(function(){
				me.lang_code = this.value;
			});

			// Load all languages in the select field language_sel
			$(fields.language_sel.input)
				.empty()
				.add_options(frappe.get_languages());

			if (this.lang_code) {
				$(fields.language_sel.input).val(this.lang_code);
			}
		}

		setup_print() {
			// print formats
			var fields = this.dialog.fields_dict;

			// toggle print format
			$(fields.attach_document_print.input).click(function() {
				$(fields.select_print_format.wrapper).toggle($(this).prop("checked"));
			});

			// select print format
			$(fields.select_print_format.wrapper).toggle(false);

			if (this.frm) {
				var print_formats = frappe.meta.get_print_formats(this.frm.meta.name);
				$(fields.select_print_format.input)
					.empty()
					.add_options(print_formats)
					.val(print_formats[0]);
			} else {
				$(fields.attach_document_print.wrapper).toggle(false);
			}

		}

		setup_attach() {
			var this$1 = this;

			var fields = this.dialog.fields_dict;
			var attach = $(fields.select_attachments.wrapper);

			if (!this.attachments) {
				this.attachments = [];
			}

			var args = {
				folder: 'Home/Attachments',
				on_success: function (attachment) {
					this$1.attachments.push(attachment);
					this$1.render_attachment_rows(attachment);
				}
			};

			if (this.frm) {
				args = {
					doctype: this.frm.doctype,
					docname: this.frm.docname,
					folder: 'Home/Attachments',
					on_success: function (attachment) {
						this$1.frm.attachments.attachment_uploaded(attachment);
						this$1.render_attachment_rows(attachment);
					}
				};
			}

			$(("\n\t\t\t<label class=\"control-label\">\n\t\t\t\t" + (__("Select Attachments")) + "\n\t\t\t</label>\n\t\t\t<div class='attach-list'></div>\n\t\t\t<p class='add-more-attachments'>\n\t\t\t\t<button class='btn btn-xs btn-default'>\n\t\t\t\t\t" + (frappe.utils.icon('small-add', 'xs')) + "&nbsp;\n\t\t\t\t\t" + (__("Add Attachment")) + "\n\t\t\t\t</button>\n\t\t\t</p>\n\t\t")).appendTo(attach.empty());

			attach
				.find(".add-more-attachments button")
				.on('click', function () { return new frappe.ui.FileUploader(args); });
			this.render_attachment_rows();
		}

		render_attachment_rows(attachment) {
			var this$1 = this;

			var select_attachments = this.dialog.fields_dict.select_attachments;
			var attachment_rows = $(select_attachments.wrapper).find(".attach-list");
			if (attachment) {
				attachment_rows.append(this.get_attachment_row(attachment, true));
			} else {
				var files = [];
				if (this.attachments && this.attachments.length) {
					files = files.concat(this.attachments);
				}
				if (this.frm) {
					files = files.concat(this.frm.get_files());
				}

				if (files.length) {
					$.each(files, function (i, f) {
						if (!f.file_name) { return; }
						if (!attachment_rows.find(("[data-file-name=\"" + (f.name) + "\"]")).length) {
							f.file_url = frappe.urllib.get_full_url(f.file_url);
							attachment_rows.append(this$1.get_attachment_row(f));
						}
					});
				}
			}
		}

		get_attachment_row(attachment, checked) {
			return $(("<p class=\"checkbox flex\">\n\t\t\t<label class=\"ellipsis\" title=\"" + (attachment.file_name) + "\">\n\t\t\t\t<input\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tdata-file-name=\"" + (attachment.name) + "\"\n\t\t\t\t\t" + (checked ? 'checked': '') + ">\n\t\t\t\t</input>\n\t\t\t\t<span class=\"ellipsis\">" + (attachment.file_name) + "</span>\n\t\t\t</label>\n\t\t\t&nbsp;\n\t\t\t<a href=\"" + (attachment.file_url) + "\" target=\"_blank\" class=\"btn-linkF\">\n\t\t\t\t" + (frappe.utils.icon('link-url')) + "\n\t\t\t</a>\n\t\t</p>"));
		}

		setup_email() {
			// email
			var fields = this.dialog.fields_dict;

			if (this.attach_document_print) {
				$(fields.attach_document_print.input).click();
				$(fields.select_print_format.wrapper).toggle(true);
			}

			$(fields.send_me_a_copy.input).on('click', function () {
				// update send me a copy (make it sticky)
				var val = fields.send_me_a_copy.get_value();
				frappe.db.set_value('User', frappe.session.user, 'send_me_a_copy', val);
				frappe.boot.user.send_me_a_copy = val;
			});

		}

		send_action() {
			var me = this;
			var btn = me.dialog.get_primary_btn();
			var form_values = this.get_values();
			if (!form_values) { return; }

			var selected_attachments =
				$.map($(me.dialog.wrapper).find("[data-file-name]:checked"), function (element) {
					return $(element).attr("data-file-name");
				});


			if (form_values.attach_document_print) {
				me.send_email(btn, form_values, selected_attachments, null, form_values.select_print_format || "");
			} else {
				me.send_email(btn, form_values, selected_attachments);
			}
		}

		get_values() {
			var form_values = this.dialog.get_values();

			// cc
			for (var i = 0, l = this.dialog.fields.length; i < l; i++) {
				var df = this.dialog.fields[i];

				if (df.is_cc_checkbox) {
					// concat in cc
					if (form_values[df.fieldname]) {
						form_values.cc = ( form_values.cc ? (form_values.cc + ", ") : "" ) + df.fieldname;
						form_values.bcc = ( form_values.bcc ? (form_values.bcc + ", ") : "" ) + df.fieldname;
					}

					delete form_values[df.fieldname];
				}
			}

			return form_values;
		}

		save_as_draft() {
			if (this.dialog && this.frm) {
				var message = this.dialog.get_value('content');
				message = message.split(separator_element)[0];
				localforage.setItem(this.frm.doctype + this.frm.docname, message).catch(function (e) {
					if (e) {
						// silently fail
						console.log(e); // eslint-disable-line
						console.warn('[Communication] IndexedDB is full. Cannot save message as draft'); // eslint-disable-line
					}
				});

			}
		}

		clear_cache() {
			this.delete_saved_draft();
			this.get_last_edited_communication(true);
		}

		delete_saved_draft() {
			if (this.dialog && this.frm) {
				localforage.removeItem(this.frm.doctype + this.frm.docname).catch(function (e) {
					if (e) {
						// silently fail
						console.log(e); // eslint-disable-line
						console.warn('[Communication] IndexedDB is full. Cannot save message as draft'); // eslint-disable-line
					}
				});
			}
		}

		send_email(btn, form_values, selected_attachments, print_html, print_format) {
			var me = this;
			this.dialog.hide();

			if (!form_values.recipients) {
				frappe.msgprint(__("Enter Email Recipient(s)"));
				return;
			}

			if (!form_values.attach_document_print) {
				print_html = null;
				print_format = null;
			}


			if (this.frm && !frappe.model.can_email(this.doc.doctype, this.frm)) {
				frappe.msgprint(__("You are not allowed to send emails related to this document"));
				return;
			}


			return frappe.call({
				method:"frappe.core.doctype.communication.email.make",
				args: {
					recipients: form_values.recipients,
					cc: form_values.cc,
					bcc: form_values.bcc,
					subject: form_values.subject,
					content: form_values.content,
					doctype: me.doc.doctype,
					name: me.doc.name,
					send_email: 1,
					print_html: print_html,
					send_me_a_copy: form_values.send_me_a_copy,
					print_format: print_format,
					sender: form_values.sender,
					sender_full_name: form_values.sender
						? frappe.user.full_name()
						: undefined,
					email_template: form_values.email_template,
					attachments: selected_attachments,
					_lang : me.lang_code,
					read_receipt:form_values.send_read_receipt,
					print_letterhead: me.is_print_letterhead_checked(),
				},
				btn: btn,
				callback: function callback(r) {
					if (!r.exc) {
						frappe.utils.play_sound("email");

						if (r.message["emails_not_sent_to"]) {
							frappe.msgprint(__("Email not sent to {0} (unsubscribed / disabled)",
								[ frappe.utils.escape_html(r.message["emails_not_sent_to"]) ]) );
						}

						me.clear_cache();

						if (me.frm) {
							me.frm.reload_doc();
						}

						// try the success callback if it exists
						if (me.success) {
							try {
								me.success(r);
							} catch (e) {
								console.log(e); // eslint-disable-line
							}
						}

					} else {
						frappe.msgprint(__("There were errors while sending email. Please try again."));

						// try the error callback if it exists
						if (me.error) {
							try {
								me.error(r);
							} catch (e) {
								console.log(e); // eslint-disable-line
							}
						}
					}
				}
			});
		}

		is_print_letterhead_checked() {
			if (this.frm && $(this.frm.wrapper).find('.form-print-wrapper').is(':visible')){
				return $(this.frm.wrapper).find('.print-letterhead').prop('checked') ? 1 : 0;
			} else {
				return (frappe.model.get_doc(":Print Settings", "Print Settings") ||
					{ with_letterhead: 1 }).with_letterhead ? 1 : 0;
			}
		}

		async set_content() {
			if (this.content_set) { return; }

			var message = this.txt || "";
			if (!message && this.frm) {
				var ref = this.frm;
				var doctype = ref.doctype;
				var docname = ref.docname;
				message = await localforage.getItem(doctype + docname) || "";
			}

			if (message) {
				this.content_set = true;
			}

			message += await this.get_signature();

			var SALUTATION_END_COMMENT = "<!-- salutation-ends -->";
			if (this.real_name && !message.includes(SALUTATION_END_COMMENT)) {
				this.message = "\n\t\t\t\t<p>" + (__('Dear {0},', [this.real_name], 'Salutation in new email')) + ",</p>\n\t\t\t\t" + SALUTATION_END_COMMENT + "<br>\n\t\t\t\t" + message + "\n\t\t\t";
			}

			if (this.is_a_reply) {
				message += this.get_earlier_reply();
			}

			await this.dialog.set_value("content", message);
		}

		async get_signature() {
			var signature = frappe.boot.user.email_signature;

			if (!signature) {
				var response = await frappe.db.get_value(
					'Email Account',
					{'default_outgoing': 1, 'add_signature': 1},
					'signature'
				);

				signature = response.message.signature;
			}

			if (!signature) { return ""; }

			if (!frappe.utils.is_html(signature)) {
				signature = signature.replace(/\n/g, "<br>");
			}

			return "<br><!-- signature-included -->" + signature;
		}

		get_earlier_reply() {
			var last_email = (
				this.last_email
				|| this.frm && this.frm.timeline.get_last_email(true)
			);

			if (!last_email) { return ""; }
			var last_email_content = last_email.original_comment || last_email.content;

			// convert the email context to text as we are enclosing
			// this inside <blockquote>
			last_email_content = this.html2text(last_email_content).replace(/\n/g, '<br>');

			// clip last email for a maximum of 20k characters
			// to prevent the email content from getting too large
			if (last_email_content.length > 20 * 1024) {
				last_email_content += '<div>' + __('Message clipped') + '</div>' + last_email_content;
				last_email_content = last_email_content.slice(0, 20 * 1024);
			}

			var communication_date = frappe.datetime.global_date_format(
				last_email.communication_date || last_email.creation
			);

			return ("\n\t\t\t<div><br></div>\n\t\t\t" + (separator_element) + "\n\t\t\t<p>\n\t\t\t" + (__("On {0}, {1} wrote:", [communication_date, last_email.sender])) + "\n\t\t\t</p>\n\t\t\t<blockquote>\n\t\t\t" + last_email_content + "\n\t\t\t</blockquote>\n\t\t");
		}

		html2text(html) {
			// convert HTML to text and try and preserve whitespace
			var d = document.createElement( 'div' );
			d.innerHTML = html.replace(/<\/div>/g, '<br></div>')  // replace end of blocks
				.replace(/<\/p>/g, '<br></p>') // replace end of paragraphs
				.replace(/<br>/g, '\n');

			// replace multiple empty lines with just one
			return d.textContent.replace(/\n{3,}/g, '\n\n');
		}
	};

	frappe.views.TranslationManager = class TranslationManager {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		make() {
			var this$1 = this;

			this.data = [];
			this.dialog = new frappe.ui.Dialog({
				fields: this.get_fields(),
				title: __('Translate {0}', [this.df.label]),
				no_submit_on_enter: true,
				primary_action_label: __('Update Translations'),
				primary_action:
					function (values) { return this$1.update_translations(values)
						.then(function () {
							this$1.dialog.hide();

							this$1.data = [];

							frappe.msgprint({
								title: __('Success'),
								message: __('Successfully updated translations'),
								indicator: 'green'
							});
						}); }
			});

			this.get_translations_data()
				.then(function (data) {
					var ref;

					(ref = this$1.data).push.apply(ref, (data || []));
					this$1.dialog.refresh();
					this$1.dialog.show();
				});
		}

		get_fields() {
			var this$1 = this;

			var fields = [
				{
					label: __('Source Text'),
					fieldname: 'source',
					fieldtype: 'Data',
					read_only: 1,
					bold: 1,
					default: this.source_text
				},
				{
					label: __('Translations'),
					fieldname: 'translation_data',
					fieldtype: 'Table',
					fields: [
						{
							label: 'Language',
							fieldname: 'language',
							fieldtype: 'Link',
							options: 'Language',
							in_list_view: 1,
							columns: 3
						},
						{
							label: 'Translation',
							fieldname: 'translation',
							fieldtype: 'Text',
							in_list_view: 1,
							columns: 7
						}
					],
					data: this.data,
					get_data: function () {
						return this$1.data;
					}
				}
			];
			return fields;
		}

		get_translations_data() {
			return frappe.db.get_list('Translation', {
				fields: ['name', 'language', 'translated_text as translation'],
				filters: {
					source_text: strip_html(this.source_text)
				}
			});
		}

		update_translations(ref) {
			var source = ref.source;
			var translation_data = ref.translation_data; if ( translation_data === void 0 ) translation_data = [];

			var translation_dict = {};
			translation_data.map(function (row) {
				translation_dict[row.language] = row.translation;
			});

			return frappe.call({
				method: 'frappe.translate.update_translations_for_source',
				btn: this.dialog.get_primary_btn(),
				args: {
					source: source,
					translation_dict: translation_dict
				}
			}).fail(function () {
				frappe.msgprint({
					title: __('Something went wrong'),
					message: __('Please try again'),
					indicator: 'red'
				});
			});
		}
	};

	frappe.standard_pages['Workspaces'] = function() {
		var wrapper = frappe.container.add_page('Workspaces');

		frappe.ui.make_app_page({
			parent: wrapper,
			name: 'Workspaces',
			title: __("Workspace"),
		});

		frappe.workspace = new frappe.views.Workspace(wrapper);
		$(wrapper).bind('show', function () {
			frappe.workspace.show();
		});
	};

	frappe.views.Workspace = class Workspace {
		constructor(wrapper) {
			this.wrapper = $(wrapper);
			this.page = wrapper.page;
			this.prepare_container();
			this.show_or_hide_sidebar();
			this.setup_dropdown();
			this.pages = {};
			this.sidebar_items = {};
			this.sidebar_categories = [
				"Modules",
				"Domains",
				"Places",
				"Administration"
			];

			this.setup_workspaces();
			this.make_sidebar();
		}

		setup_workspaces() {
			// workspaces grouped by categories
			this.workspaces = {};
			for (var i = 0, list = frappe.boot.allowed_workspaces; i < list.length; i += 1) {
				var page = list[i];

				if (!this.workspaces[page.category]) {
					this.workspaces[page.category] = [];
				}
				this.workspaces[page.category].push(page);
			}
		}

		show() {
			var page = this.get_page_to_show();
			this.page.set_title(("" + (__(page))));
			this.show_page(page);
		}

		prepare_container() {
			var list_sidebar = $("\n\t\t\t<div class=\"list-sidebar overlay-sidebar hidden-xs hidden-sm\">\n\t\t\t\t<div class=\"desk-sidebar list-unstyled sidebar-menu\"></div>\n\t\t\t</div>\n\t\t").appendTo(this.wrapper.find(".layout-side-section"));
			this.sidebar = list_sidebar.find(".desk-sidebar");

			this.body = this.wrapper.find(".layout-main-section");
		}

		get_page_to_show() {
			var default_page;

			if (localStorage.current_workspace) {
				default_page = localStorage.current_workspace;
			} else if (this.workspaces) {
				default_page = this.workspaces["Modules"][0].name;
			} else if (frappe.boot.allowed_workspaces) {
				default_page = frappe.boot.allowed_workspaces[0].name;
			} else {
				default_page = "Build";
			}

			var page = frappe.get_route()[1] || default_page;
			return page;
		}

		make_sidebar() {
			var this$1 = this;

			this.sidebar_categories.forEach(function (category) {
				if (this$1.workspaces[category]) {
					this$1.build_sidebar_section(category, this$1.workspaces[category]);
				}
			});
		}

		build_sidebar_section(title, items) {
			var this$1 = this;

			var sidebar_section = $("<div class=\"standard-sidebar-section\"></div>");

			// DO NOT REMOVE: Comment to load translation
			// __("Modules") __("Domains") __("Places") __("Administration")
			$(("<div class=\"standard-sidebar-label\">" + (__(title)) + "</div>"))
				.appendTo(sidebar_section);

			var get_sidebar_item = function (item) {
				return $(("\n\t\t\t\t<a\n\t\t\t\t\thref=\"/app/" + (frappe.router.slug(item.name)) + "\"\n\t\t\t\t\tclass=\"desk-sidebar-item standard-sidebar-item " + (item.selected ? "selected" : "") + "\"\n\t\t\t\t>\n\t\t\t\t\t<span>" + (frappe.utils.icon(item.icon || "folder-normal", "md")) + "</span>\n\t\t\t\t\t<span class=\"sidebar-item-label\">" + (item.label || item.name) + "<span>\n\t\t\t\t</a>\n\t\t\t"));
			};

			var make_sidebar_category_item = function (item) {
				if (item.name == this$1.get_page_to_show()) {
					item.selected = true;
					this$1.current_page_name = item.name;
				}

				var $item = get_sidebar_item(item);

				$item.appendTo(sidebar_section);
				this$1.sidebar_items[item.name] = $item;
			};

			items.forEach(function (item) { return make_sidebar_category_item(item); });

			sidebar_section.appendTo(this.sidebar);
		}

		show_page(page) {
			if (this.current_page_name && this.pages[this.current_page_name]) {
				this.pages[this.current_page_name].hide();
			}

			if (this.sidebar_items && this.sidebar_items[this.current_page_name]) {
				this.sidebar_items[this.current_page_name].removeClass("selected");
				this.sidebar_items[page].addClass("selected");
			}
			this.current_page_name = page;
			localStorage.current_workspace = page;

			this.pages[page] ? this.pages[page].show() : this.make_page(page);
			this.current_page = this.pages[page];
			this.setup_dropdown();
		}

		make_page(page) {
			var $page = new DesktopPage({
				container: this.body,
				page_name: page
			});

			this.pages[page] = $page;
			return $page;
		}

		customize() {
			var this$1 = this;

			if (this.current_page && this.current_page.allow_customization) {
				this.page.clear_menu();
				this.current_page.customize();

				this.page.set_primary_action(
					__("Save Customizations"),
					function () {
						this$1.current_page.save_customization();
						this$1.page.clear_primary_action();
						this$1.page.clear_secondary_action();
						this$1.setup_dropdown();
					},
					null,
					__("Saving")
				);

				this.page.set_secondary_action(
					__("Discard"),
					function () {
						this$1.current_page.reload();
						frappe.show_alert({ message: __("Customizations Discarded"), indicator: "info" });
						this$1.page.clear_primary_action();
						this$1.page.clear_secondary_action();
						this$1.setup_dropdown();
					}
				);
			}
		}

		setup_dropdown() {
			var this$1 = this;

			this.page.clear_menu();

			this.page.set_secondary_action(__('Customize'), function () {
				this$1.customize();
			});

			this.page.add_menu_item(__('Reset Customizations'), function () {
				this$1.current_page.reset_customization();
			}, 1);

			this.page.add_menu_item(__('Toggle Sidebar'), function () {
				this$1.toggle_side_bar();
			}, 1);
		}

		toggle_side_bar() {
			var show_workspace_sidebar = JSON.parse(localStorage.show_workspace_sidebar || "true");
			show_workspace_sidebar = !show_workspace_sidebar;
			localStorage.show_workspace_sidebar = show_workspace_sidebar;
			this.show_or_hide_sidebar();
			$(document.body).trigger("toggleDeskSidebar");
		}

		show_or_hide_sidebar() {
			var show_workspace_sidebar = JSON.parse(localStorage.show_workspace_sidebar || "true");
			$('#page-workspace .layout-side-section').toggleClass('hidden', !show_workspace_sidebar);
		}
	};

	class DesktopPage {
		constructor(ref) {
		var container = ref.container;
		var page_name = ref.page_name;

			frappe.desk_page = this;
			this.container = container;
			this.page_name = page_name;
			this.sections = {};
			this.allow_customization = false;
			this.reload();
		}

		show() {
			frappe.desk_page = this;
			this.page.show();
			if (this.sections.shortcuts) {
				this.sections.shortcuts.widgets_list.forEach(function (wid) {
					wid.set_actions();
				});
			}
		}

		hide() {
			this.page.hide();
		}

		reload() {
			this.in_customize_mode = false;
			this.page && this.page.remove();
			this.make();
		}

		make() {
			var this$1 = this;

			this.page = $(("<div class=\"desk-page\" data-page-name=" + (this.page_name) + "></div>"));
			this.page.append(frappe.render_template('workspace_loading_skeleton'));
			this.page.appendTo(this.container);

			this.get_data().then(function () {
				if (Object.keys(this$1.data).length == 0) {
					delete localStorage.current_workspace;
					frappe.set_route("workspace");
					return;
				}
				this$1.refresh();
			}).finally(this.page.find('.workspace_loading_skeleton').remove);
		}

		refresh() {
			this.page.empty();
			this.allow_customization = this.data.allow_customization || false;

			if (frappe.is_mobile()) {
				this.allow_customization = false;
			}

			this.data.onboarding && this.data.onboarding.items.length && this.make_onboarding();
			this.make_charts();
			this.make_shortcuts();
			this.make_cards();
		}

		get_data() {
			var this$1 = this;

			return frappe.xcall("frappe.desk.desktop.get_desktop_page", {
				page: this.page_name
			}).then(function (data) {
				this$1.data = data;
				if (Object.keys(this$1.data).length == 0) { return; }

				return frappe.dashboard_utils.get_dashboard_settings().then(function (settings) {
					var chart_config = settings.chart_config ? JSON.parse(settings.chart_config) : {};
					if (this$1.data.charts.items) {
						this$1.data.charts.items.map(function (chart) {
							chart.chart_settings = chart_config[chart.chart_name] || {};
						});
					}
				});
			});
		}

		customize() {
			var this$1 = this;

			if (this.in_customize_mode) {
				return;
			}

			// We need to remove this as the  chart group will be visible during customization
			$('.widget.onboarding-widget-box').hide();

			Object.keys(this.sections).forEach(function (section) {
				this$1.sections[section].customize();
			});
			this.in_customize_mode = true;

		}

		save_customization() {
			var this$1 = this;

			frappe.dom.freeze();
			var config = {};

			if (this.sections.charts) { config.charts = this.sections.charts.get_widget_config(); }
			if (this.sections.shortcuts) { config.shortcuts = this.sections.shortcuts.get_widget_config(); }
			if (this.sections.cards) { config.cards = this.sections.cards.get_widget_config(); }

			frappe.call('frappe.desk.desktop.save_customization', {
				page: this.page_name,
				config: config
			}).then(function (res) {
				frappe.dom.unfreeze();
				if (res.message) {
					frappe.show_alert({ message: __("Customizations Saved Successfully"), indicator: "green" });
					this$1.reload();
				} else {
					frappe.throw({ message: __("Something went wrong while saving customizations"), indicator: "red" });
					this$1.reload();
				}
			});
		}

		reset_customization() {
			var this$1 = this;

			frappe.call('frappe.desk.desktop.reset_customization', {
				page: this.page_name
			}).then(function () {
				frappe.show_alert({ message: __("Removed page customizations"), indicator: "green" });
				this$1.reload();
			});
		}

		make_onboarding() {
			this.onboarding_widget = frappe.widget.make_widget({
				label: this.data.onboarding.label || __("Let's Get Started"),
				subtitle: this.data.onboarding.subtitle,
				steps: this.data.onboarding.items,
				success: this.data.onboarding.success,
				docs_url: this.data.onboarding.docs_url,
				user_can_dismiss: this.data.onboarding.user_can_dismiss,
				widget_type: 'onboarding',
				container: this.page,
				options: {
					allow_sorting: false,
					allow_create: false,
					allow_delete: false,
					allow_hiding: false,
					allow_edit: false,
					max_widget_count: 2,
				}
			});
		}

		make_charts() {
			this.sections["charts"] = new frappe.widget.WidgetGroup({
				container: this.page,
				type: "chart",
				columns: 1,
				class_name: "widget-charts",
				hidden: Boolean(this.onboarding_widget),
				options: {
					allow_sorting: this.allow_customization,
					allow_create: this.allow_customization,
					allow_delete: this.allow_customization,
					allow_hiding: false,
					allow_edit: true,
					max_widget_count: 2,
				},
				widgets: this.data.charts.items
			});
		}

		make_shortcuts() {
			this.sections["shortcuts"] = new frappe.widget.WidgetGroup({
				title: this.data.shortcuts.label || __('Your Shortcuts'),
				container: this.page,
				type: "shortcut",
				columns: 3,
				options: {
					allow_sorting: this.allow_customization,
					allow_create: this.allow_customization,
					allow_delete: this.allow_customization,
					allow_hiding: false,
					allow_edit: true,
				},
				widgets: this.data.shortcuts.items
			});
		}

		make_cards() {
			var cards = new frappe.widget.WidgetGroup({
				title: this.data.cards.label || __("Reports & Masters"),
				container: this.page,
				type: "links",
				columns: 3,
				options: {
					allow_sorting: this.allow_customization,
					allow_create: false,
					allow_delete: false,
					allow_hiding: this.allow_customization,
					allow_edit: false,
				},
				widgets: this.data.cards.items
			});

			this.sections["cards"] = cards;
		}
	}

	class WidgetDialog {
		constructor(opts) {
			Object.assign(this, opts);
			this.editing = Boolean(this.values && Object.keys(this.values).length);
		}

		make() {
			this.make_dialog();
			this.setup_dialog_events();
			this.dialog.show();

			this.editing && this.set_default_values();
		}

		make_dialog() {
			var this$1 = this;

			this.dialog = new frappe.ui.Dialog({
				title: this.get_title(),
				fields: this.get_fields(),
				primary_action: function (data) {
					data = this$1.process_data(data);

					if (!this$1.editing && !data.name) {
						data.name = (this$1.type) + "-" + (this$1.label) + "-" + (frappe.utils.get_random(20));
					}

					this$1.dialog.hide();
					this$1.primary_action(data);
				},
				primary_action_label: this.primary_action_label || __("Add"),
			});
		}

		get_title() {
			// DO NOT REMOVE: Comment to load translation
			// __("New Chart") __("New Shortcut") __("Edit Chart") __("Edit Shortcut")

			var action = this.editing ? "Edit" : "Add";
			var label = action = action + " " + frappe.model.unscrub(this.type);
			return __(label);
		}

		get_fields() {
			//
		}

		set_default_values() {
			return this.dialog.set_values(this.values);
		}

		process_data(data) {
			return data;
		}

		setup_dialog_events() {
			//
		}

		hide_field(fieldname) {
			this.dialog.set_df_property(fieldname, "hidden", true);
		}

		show_field(fieldname) {
			this.dialog.set_df_property(fieldname, "hidden", false);
		}

		setup_filter(doctype) {
			var this$1 = this;

			if (this.filter_group) {
				this.filter_group.wrapper.empty();
				delete this.filter_group;
			}

			var $loading = this.dialog.get_field("filter_area_loading").$wrapper;
			$(("<span class=\"text-muted\">" + (__('Loading Filters...')) + "</span>")).appendTo($loading);

			this.filters = [];

			if (this.values && this.values.stats_filter) {
				var filters_json = new Function(("return " + (this.values.stats_filter)))();
				this.filters = Object.keys(filters_json).map(function (filter) {
					var val = filters_json[filter];
					return [this$1.values.link_to, filter, val[0], val[1], false];
				});
			}

			this.filter_group = new frappe.ui.FilterGroup({
				parent: this.dialog.get_field("filter_area").$wrapper,
				doctype: doctype,
				on_change: function () {},
			});

			frappe.model.with_doctype(doctype, function () {
				this$1.filter_group.add_filters_to_filter_group(this$1.filters);
				this$1.hide_field("filter_area_loading");
				this$1.show_field("filter_area");
			});
		}
	}

	class ChartDialog extends WidgetDialog {
		constructor(opts) {
			super(opts);
		}

		get_fields() {
			return [
				{
					fieldtype: "Link",
					fieldname: "chart_name",
					label: "Chart Name",
					options: "Dashboard Chart",
					reqd: 1,
				},
				{
					fieldtype: "Data",
					fieldname: "label",
					label: "Label",
				} ];
		}

		process_data(data) {
			data.label = data.label ? data.label : data.chart_name;
			return data;
		}
	}

	class ShortcutDialog extends WidgetDialog {
		constructor(opts) {
			super(opts);
		}

		hide_filters() {
			this.hide_field("count_section_break");
			this.hide_field("filters_section_break");
		}

		show_filters() {
			this.show_field("count_section_break");
			this.show_field("filters_section_break");
		}

		get_fields() {
			var this$1 = this;

			return [
				{
					fieldtype: "Select",
					fieldname: "type",
					label: "Type",
					reqd: 1,
					options: "DocType\nReport\nPage\nDashboard",
					onchange: function () {
						if (this$1.dialog.get_value("type") == "DocType") {
							this$1.dialog.fields_dict.link_to.get_query = function () {
								return {
									query: "frappe.core.report.permitted_documents_for_user.permitted_documents_for_user.query_doctypes",
									filters: {
										user: frappe.session.user
									}
								};
							};
						} else {
							this$1.dialog.fields_dict.link_to.get_query = null;
						}
					},
				},
				{
					fieldtype: "Data",
					fieldname: "label",
					label: "Label",
				},
				{
					fieldtype: "Column Break",
					fieldname: "column_break_4",
				},
				{
					fieldtype: "Dynamic Link",
					fieldname: "link_to",
					label: "Link To",
					reqd: 1,
					options: "type",
					onchange: function () {
						if (this$1.dialog.get_value("type") == "DocType") {
							var doctype = this$1.dialog.get_value("link_to");
							if (doctype && frappe.boot.single_types.includes(doctype)) {
								this$1.hide_filters();
							} else if (doctype) {
								this$1.setup_filter(doctype);
								this$1.show_filters();
							}

							var views = ["List", "Report Builder", "Dashboard", "New"];
							if (frappe.boot.treeviews.includes(doctype)) { views.push("Tree"); }
							if (frappe.boot.calendars.includes(doctype)) { views.push("Calendar"); }

							this$1.dialog.set_df_property("doc_view", "options", views.join("\n"));

						} else {
							this$1.hide_filters();
						}
					}
				},
				{
					fieldtype: "Select",
					fieldname: "doc_view",
					label: "DocType View",
					options: "List\nReport Builder\nDashboard\nTree\nNew\nCalendar",
					description: __("Which view of the associated DocType should this shortcut take you to?"),
					default: "List",
					depends_on: function (state) {
						if (this$1.dialog) {
							var doctype = this$1.dialog.get_value("link_to");
							var is_single = frappe.boot.single_types.includes(doctype);
							return state.type == "DocType" && !is_single;
						}

						return false;
					}
				},
				{
					fieldtype: "Section Break",
					fieldname: "filters_section_break",
					label: __("Count Filter"),
					hidden: 1,
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area_loading",
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area",
					hidden: 1,
				},
				{
					fieldtype: "Section Break",
					fieldname: "count_section_break",
					label: __("Count Customizations"),
					hidden: 1,
				},
				{
					fieldtype: "Select",
					fieldname: "color",
					label: __("Color"),
					options: ["Grey", "Green", "Red", "Orange", "Pink", "Yellow", "Blue", "Cyan"],
					default: "Grey",
					onchange: function () {
						var color = this$1.dialog.fields_dict.color.value.toLowerCase();
						var $select = this$1.dialog.fields_dict.color.$input;
						if (!$select.parent().find('.color-box').get(0)) {
							$("<div class=\"color-box\"></div>").insertBefore($select.get(0));
						}
						$select.parent().find('.color-box').get(0).style.backgroundColor = "var(--text-on-" + color + ")";
					}
				},
				{
					fieldtype: "Column Break",
					fieldname: "column_break_3",
				},
				{
					fieldtype: "Data",
					fieldname: "format",
					label: __("Format"),
					description: __("For Example: {} Open"),
				} ];
		}

		set_default_values() {
			var this$1 = this;

			super.set_default_values().then(function () {
				this$1.dialog.fields_dict.link_to.df.onchange();
			});
		}

		process_data(data) {

			if (this.dialog.get_value("type") == "DocType" && this.filter_group) {
				var filters = this.filter_group.get_filters();
				var stats_filter = null;

				if (filters.length) {
					stats_filter = {};
					filters.forEach(function (arr) {
						stats_filter[arr[1]] = [arr[2], arr[3]];
					});
					stats_filter = JSON.stringify(stats_filter);
				}
				data.stats_filter = stats_filter;
			}

			data.label = data.label
				? data.label
				: frappe.model.unscrub(data.link_to);

			return data;
		}
	}

	class NumberCardDialog extends WidgetDialog {
		constructor(opts) {
			super(opts);
		}

		get_fields() {
			var this$1 = this;

			var fields;
			fields = [
				{
					fieldtype: 'Select',
					label: __('Choose Existing Card or create New Card'),
					fieldname: 'new_or_existing',
					options: ['New Card', 'Existing Card']
				},
				{
					fieldtype: 'Link',
					fieldname: 'card',
					label: __('Number Cards'),
					options: 'Number Card',
					get_query: function () {
						return {
							'query': 'frappe.desk.doctype.number_card.number_card.get_cards_for_user',
							filters: {
								document_type: this$1.document_type,
							}
						};
					},
					depends_on: 'eval: doc.new_or_existing == "Existing Card"'
				},
				{
					fieldtype: 'Section Break',
					fieldname: 'sb_1',
					depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					label: __('Label'),
					fieldname: 'label',
					fieldtype: 'Data',
					mandatory_depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					label: __('Doctype'),
					fieldname: 'document_type',
					fieldtype: 'Link',
					options: 'DocType',
					onchange: function () {
						this$1.document_type = this$1.dialog.get_value("document_type");
						this$1.set_aggregate_function_fields(this$1.dialog.get_values());
						this$1.setup_filter(this$1.document_type);
					},
					hidden: 1
				},
				{
					label: __('Color'),
					fieldname: 'color',
					fieldtype: 'Color'
				},
				{
					fieldtype: "Column Break",
					fieldname: "cb_1",
				},
				{
					label: __('Function'),
					fieldname: 'function',
					fieldtype: 'Select',
					options: ['Count', 'Sum', 'Average', 'Minimum', 'Maximum'],
					mandatory_depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					label: __('Function Based On'),
					fieldname: 'aggregate_function_based_on',
					fieldtype: 'Select',
					depends_on: "eval: doc.function !== 'Count'",
					mandatory_depends_on: 'eval: doc.function !== "Count" && doc.new_or_existing == "New Card"'
				},
				{
					fieldtype: "Section Break",
					fieldname: "sb_1",
					label: __('Add Filters'),
					depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area_loading",
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area",
					hidden: 1,
				},
				{
					fieldtype: "Section Break",
					fieldname: "sb_1",
				} ];

			return fields;
		}

		setup_dialog_events() {
			if (!this.document_type) {
				if (this.default_values['doctype']) {
					this.document_type = this.default_values['doctype'];
					this.setup_filter(this.default_values['doctype']);
					this.set_aggregate_function_fields();
				} else {
					this.show_field('document_type');
				}
			}
		}

		set_aggregate_function_fields() {
			var aggregate_function_fields = [];
			if (this.document_type) {
				frappe.get_meta(this.document_type).fields.map(function (df) {
					if (frappe.model.numeric_fieldtypes.includes(df.fieldtype)) {
						if (df.fieldtype == 'Currency') {
							if (!df.options || df.options !== 'Company:company:default_currency') {
								return;
							}
						}
						aggregate_function_fields.push({label: df.label, value: df.fieldname});
					}
				});
			}
			this.dialog.set_df_property('aggregate_function_based_on', 'options', aggregate_function_fields);
		}

		process_data(data) {
			if (data.new_or_existing == 'Existing Card') {
				data.name = data.card;
			}
			data.stats_filter = JSON.stringify(this.filter_group.get_filters());
			data.document_type = this.document_type;

			return data;
		}
	}

	function get_dialog_constructor(type) {
		var widget_map = {
			chart: ChartDialog,
			shortcut: ShortcutDialog,
			number_card: NumberCardDialog,
		};

		return widget_map[type] || WidgetDialog;
	}

	class Widget {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		refresh() {
			this.set_title();
			this.set_actions();
			this.set_body();
			this.setup_events();
		}

		get_config() {
			return {
				name: this.name,
				label: this.label
			};
		}

		customize(options) {
			var this$1 = this;

			this.in_customize_mode = true;
			this.action_area.empty();

			options.allow_sorting &&
				this.add_custom_button(
					frappe.utils.icon('drag', 'xs'),
					null,
					"drag-handle"
				);

			options.allow_delete &&
				this.add_custom_button(
					frappe.utils.icon('delete', 'xs'),
					function () { return this$1.delete(); },
					"",
					("" + (__('Delete')))
				);

			if (options.allow_hiding) {
				if (this.hidden) {
					this.widget.removeClass("hidden");
					this.body.css("opacity", 0.5);
					this.title_field.css("opacity", 0.5);
					this.footer.css("opacity", 0.5);
				}
				var classname = this.hidden ? 'fa fa-eye' : 'fa fa-eye-slash';
				var title = this.hidden ? ("" + (__('Show'))) : ("" + (__('Hide')));
				this.add_custom_button(
					("<i class=\"" + classname + "\" aria-hidden=\"true\"></i>"),
					function () { return this$1.hide_or_show(); },
					"show-or-hide-button",
					title
				);

				this.show_or_hide_button = this.action_area.find(
					".show-or-hide-button"
				);
			}

			options.allow_edit &&
				this.add_custom_button(
					frappe.utils.icon("edit", "xs"),
					function () { return this$1.edit(); }
				);

			if (options.allow_resize) {
				var title$1 = this.width == 'Full'? ("" + (__('Collapse'))) : ("" + (__('Expand')));
				this.add_custom_button(
					'<i class="fa fa-expand" aria-hidden="true"></i>',
					function () { return this$1.toggle_width(); },
					"resize-button",
					title$1
				);

				this.resize_button = this.action_area.find(
					".resize-button"
				);
			}
		}

		make() {
			this.make_widget();
			this.widget.appendTo(this.container);
		}

		make_widget() {
			this.widget = $(("<div class=\"widget\n\t\t\t" + (this.hidden ? "hidden" : " ") + "\n\t\t\t" + (this.shadow ? "widget-shadow" : " ") + "\n\t\t\" data-widget-name=\"" + (this.name ? this.name : '') + "\">\n\t\t\t<div class=\"widget-head\">\n\t\t\t\t<div>\n\t\t\t\t\t<div class=\"widget-title ellipsis\"></div>\n\t\t\t\t\t<div class=\"widget-subtitle\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"widget-control\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"widget-body\">\n\t\t    </div>\n\t\t    <div class=\"widget-footer\">\n\t\t    </div>\n\t\t</div>"));

			this.title_field = this.widget.find(".widget-title");
			this.subtitle_field = this.widget.find(".widget-subtitle");
			this.body = this.widget.find(".widget-body");
			this.action_area = this.widget.find(".widget-control");
			this.head = this.widget.find(".widget-head");
			this.footer = this.widget.find(".widget-footer");
			this.refresh();
		}

		set_title(max_chars) {
			var base = this.label || this.name;
			var title = max_chars ? frappe.ellipsis(base, max_chars) : base;

			if (this.icon) {
				var icon = frappe.utils.icon(this.icon);
				this.title_field[0].innerHTML = icon + " <span>" + title + "</span>";
			} else {
				this.title_field[0].innerHTML = title;
				if (max_chars) {
					this.title_field[0].setAttribute('title', this.label);
				}
			}
			this.subtitle && this.subtitle_field.html(this.subtitle);
		}

		add_custom_button(html, action, class_name, title, btn_type) {
			if ( class_name === void 0 ) class_name = "";
			if ( title === void 0 ) title="";

			if (!btn_type) { btn_type = 'btn-secondary'; }
			var button = $(
				("<button class=\"btn " + btn_type + " btn-xs " + class_name + "\" title=\"" + title + "\">" + html + "</button>")
			);
			button.click(function (event) {
				event.stopPropagation();
				action && action();
			});
			button.appendTo(this.action_area);
		}

		delete(animate) {
			var this$1 = this;
			if ( animate === void 0 ) animate=true;

			var remove_widget = function (setup_new) {
				this$1.widget.remove();
				this$1.options.on_delete && this$1.options.on_delete(this$1.name, setup_new);
			};

			if (animate) {
				this.widget.addClass("zoom-out");
				// wait for animation
				setTimeout(function () {
					remove_widget(true);
				}, 300);
			} else {
				remove_widget(false);
			}
		}

		edit() {
			var this$1 = this;

			var dialog_class = get_dialog_constructor(this.widget_type);

			this.edit_dialog = new dialog_class({
				label: this.label,
				type: this.widget_type,
				values: this.get_config(),
				primary_action: function (data) {
					Object.assign(this$1, data);
					data.name = this$1.name;

					this$1.refresh();
				},
				primary_action_label: __("Save")
			});

			this.edit_dialog.make();
		}

		toggle_width() {
			if (this.width == 'Full') {
				this.widget.removeClass("full-width");
				this.width = null;
				this.refresh();
			} else {
				this.widget.addClass("full-width");
				this.width = 'Full';
				this.refresh();
			}

			var title = this.width == 'Full' ? ("" + (__('Collapse'))) : ("" + (__('Expand')));
			this.resize_button.attr('title', title);
		}

		hide_or_show() {
			if (!this.hidden) {
				this.body.css("opacity", 0.5);
				this.title_field.css("opacity", 0.5);
				this.footer.css("opacity", 0.5);
				this.hidden = true;
			} else {
				this.body.css("opacity", 1);
				this.title_field.css("opacity", 1);
				this.footer.css("opacity", 1);
				this.hidden = false;
			}
			this.show_or_hide_button.empty();

			var classname = this.hidden ? 'fa fa-eye' : 'fa fa-eye-slash';
			var title = this.hidden ? ("" + (__('Show'))) : ("" + (__('Hide')));

			$(("<i class=\"" + classname + "\" aria-hidden=\"true\" title=\"" + title + "\"></i>")).appendTo(
				this.show_or_hide_button
			);
		}

		setup_events() {
			//
		}

		set_actions() {
			//
		}

		set_body() {
			//
		}
	}

	frappe.provide('frappe.widget.utils');
	frappe.provide("frappe.dashboards");
	frappe.provide("frappe.dashboards.chart_sources");

	class ChartWidget extends Widget {
		constructor(opts) {
			opts.shadow = true;
			super(opts);
			this.height = this.height || 240;
		}

		get_config() {
			return {
				name: this.name,
				chart_name: this.chart_name,
				label: this.label,
				hidden: this.hidden,
				width: this.width,
			};
		}

		refresh() {
			delete this.dashboard_chart;
			this.set_body();
			this.make_chart();
		}

		set_chart_title() {
			var max_chars = this.widget.width() < 600 ? 20 : 60;
			this.set_title(max_chars);
		}

		set_body() {
			this.widget.addClass("dashboard-widget-box");
			if (this.width == "Full") {
				this.widget.addClass("full-width");
			}
		}

		setup_container() {
			this.body.empty();

			if (this.chart_doc.type == 'Heatmap') {
				this.setup_heatmap_container();
			}

			this.loading = $(
				("<div class=\"chart-loading-state text-muted\" style=\"height: " + (this.height) + "px;\">" + (__(
					"Loading..."
				)) + "</div>")
			);
			this.loading.appendTo(this.body);

			this.empty = $(
				("<div class=\"chart-loading-state text-muted\" style=\"height: " + (this.height) + "px;\">" + (__(
					"No Data..."
				)) + "</div>")
			);
			this.empty.hide().appendTo(this.body);

			this.chart_wrapper = $("<div></div>");
			this.chart_wrapper.appendTo(this.body);

			this.$heatmap_legend = null;
			this.set_chart_title();
		}

		setup_heatmap_container() {
			this.widget.addClass('heatmap-chart');
			this.widget.removeClass('full-width').addClass('full-width');
			this.width = 'Full';
		}

		set_summary() {
			var this$1 = this;

			if (!this.$summary) {
				this.$summary = $("<div class=\"report-summary\"></div>").hide();
				this.head.after(this.$summary);
			} else {
				this.$summary.empty();
			}

			this.summary.forEach(function (summary) {
				frappe.utils.build_summary_item(summary).appendTo(this$1.$summary);
			});
			this.summary.length && this.$summary.show();
		}

		make_chart() {
			var this$1 = this;

			this.get_settings().then(function () {
				if (!this$1.settings) {
					this$1.deleted = true;
					this$1.widget.remove();
					return;
				}

				if (!this$1.chart_settings) {
					this$1.chart_settings = {};
				}
				this$1.setup_container();
				if (!this$1.in_customize_mode) {
					this$1.action_area.empty();
					this$1.prepare_chart_actions();

					if (
						this$1.chart_doc.timeseries &&
						this$1.chart_doc.chart_type !== "Custom"
					) {
						this$1.render_time_series_filters();
					}
				}
				frappe.run_serially([
					function () { return this$1.prepare_chart_object(); },
					function () { return this$1.setup_filter_button(); },
					function () { return this$1.fetch_and_update_chart(); } ]);
			});
		}

		render_time_series_filters() {
			var filters = this.get_time_series_filters();
			frappe.dashboard_utils.render_chart_filters(
				filters,
				"chart-actions",
				this.action_area,
				0
			);
		}

		get_time_series_filters() {
			var this$1 = this;

			var filters;
			if (this.chart_doc.type == 'Heatmap') {
				filters = [{
					label: this.chart_settings.heatmap_year || this.chart_doc.heatmap_year,
					options: frappe.dashboard_utils.get_years_since_creation(frappe.boot.user.creation),
					action: function (selected_item) {
						this$1.selected_heatmap_year = selected_item;
						this$1.save_chart_config_for_user({'heatmap_year': this$1.selected_heatmap_year});
						this$1.fetch_and_update_chart();
					}
				}];
			} else {
				filters = [
					{
						label: this.chart_settings.time_interval || this.chart_doc.time_interval,
						options: ["Yearly", "Quarterly", "Monthly", "Weekly", "Daily"],
						icon: 'calendar',
						class: 'time-interval-filter',
						action: function (selected_item) {
							this$1.selected_time_interval = selected_item;
							this$1.save_chart_config_for_user({'time_interval': this$1.selected_time_interval});
							this$1.fetch_and_update_chart();
						}
					},
					{
						label: this.chart_settings.timespan || this.chart_doc.timespan,
						options: [
							"Select Date Range",
							"Last Year",
							"Last Quarter",
							"Last Month",
							"Last Week"
						],
						class: 'timespan-filter',
						action: function (selected_item) {
							this$1.selected_timespan = selected_item;

							if (this$1.selected_timespan === "Select Date Range") {
								this$1.render_date_range_field();
							} else {
								this$1.selected_from_date = null;
								this$1.selected_to_date = null;
								if (this$1.date_field_wrapper) {
									this$1.date_field_wrapper.hide();

									// Title maybe hidden becuase of date range fields
									// in half width chart
									this$1.title_field.show();
									this$1.subtitle_field.show();
									this$1.head.css('flex-direction', "row");
								}

								this$1.save_chart_config_for_user({
									'timespan': this$1.selected_timespan,
									'from_date': null,
									'to_date': null

								});
								this$1.fetch_and_update_chart();
							}
						}
					} ];
			}
			return filters;
		}

		fetch_and_update_chart() {
			var this$1 = this;

			this.args = {
				timespan: this.selected_timespan || this.chart_settings.timespan,
				time_interval: this.selected_time_interval || this.chart_settings.time_interval,
				from_date: this.selected_from_date || this.chart_settings.from_date,
				to_date: this.selected_to_date || this.chart_settings.to_date,
				heatmap_year: this.selected_heatmap_year || this.chart_settings.heatmap_year,
			};

			this.fetch(this.filters, true, this.args).then(function (data) {
				if (this$1.chart_doc.chart_type == "Report") {
					this$1.report_result = data;
					this$1.summary = data.report_summary;
					data = this$1.get_report_chart_data(data);
				}

				this$1.update_chart_object();
				this$1.data = data;
				this$1.render();
			});
		}

		render_date_range_field() {
			var this$1 = this;

			if (
				!this.date_field_wrapper ||
				!this.date_field_wrapper.is(':visible')
			) {
				this.date_field_wrapper = $(
					"<div class=\"dashboard-date-field pull-right\"></div>"
				).insertAfter(this.action_area.find('.timespan-filter'));

				if (this.width !== 'Full' && this.widget.width() < 700) {
					this.title_field.hide();
					this.subtitle_field.hide();
					this.head.css('flex-direction', 'row-reverse');
				}

				this.date_range_field = frappe.ui.form.make_control({
					df: {
						fieldtype: 'DateRange',
						fieldname: 'from_date',
						placeholder: 'Date Range',
						input_class: 'input-xs',
						default: [this.chart_settings.from_date, this.chart_settings.to_date],
						value: [this.chart_settings.from_date, this.chart_settings.to_date],
						reqd: 1,
						change: function () {
							var selected_date_range = this$1.date_range_field.get_value();
							this$1.selected_from_date = selected_date_range[0];
							this$1.selected_to_date = selected_date_range[1];

							if (selected_date_range && selected_date_range.length == 2) {
								this$1.save_chart_config_for_user({
									'timespan': this$1.selected_timespan,
									'from_date': this$1.selected_from_date,
									'to_date': this$1.selected_to_date,
								});
								this$1.fetch_and_update_chart();
							}
						}
					},
					parent: this.date_field_wrapper,
					render_input: 1
				});

				this.date_range_field.$input.focus();
			}
		}

		get_report_chart_data(result) {
			if (result.chart && this.chart_doc.use_report_chart) {
				return result.chart.data;
			} else {
				var y_fields = [];
				this.chart_doc.y_axis.map(function (field) {
					y_fields.push(field.y_field);
				});

				var chart_fields = {
					y_fields: y_fields,
					x_field: this.chart_doc.x_field,
					chart_type: this.chart_doc.type,
					color: this.chart_doc.color
				};
				var columns = result.columns.map(function (col) {
					return frappe.report_utils.prepare_field_from_column(col);
				});

				var data = frappe.report_utils.make_chart_options(
					columns,
					result,
					chart_fields
				).data;
				return data;
			}
		}

		prepare_chart_actions() {
			var this$1 = this;

			var actions = [
				{
					label: __("Refresh"),
					action: "action-refresh",
					handler: function () {
						delete this$1.dashboard_chart;
						this$1.make_chart();
					}
				},
				{
					label: __("Edit"),
					action: "action-edit",
					handler: function () {
						frappe.set_route(
							"Form",
							"Dashboard Chart",
							this$1.chart_doc.name
						);
					}
				},
				{
					label: __("Reset Chart"),
					action: "action-reset",
					handler: function () {
						this$1.reset_chart();
						delete this$1.dashboard_chart;
						this$1.make_chart();
					}
				}
			];

			if (this.chart_doc.document_type) {
				actions.push({
					label: __("{0} List", [this.chart_doc.document_type]),
					action: "action-list",
					handler: function () {
						frappe.set_route("List", this$1.chart_doc.document_type);
					}
				});
			} else if (this.chart_doc.chart_type === "Report") {
				actions.push({
					label: __("{0} Report", [this.chart_doc.report_name]),
					action: "action-list",
					handler: function () {
						frappe.set_route(
							"query-report",
							this$1.chart_doc.report_name
						);
					}
				});
			}
			this.set_chart_actions(actions);
		}

		setup_filter_button() {
			var this$1 = this;

			this.is_document_type =
				this.chart_doc.chart_type !== "Report" &&
				this.chart_doc.chart_type !== "Custom";

			this.filter_button = $(
				("<div class=\"filter-chart btn btn-xs pull-right\">\n\t\t\t\t" + (frappe.utils.icon('filter', 'sm')) + "\n\t\t\t</div>")
			);

			this.filter_button.appendTo(this.action_area);

			if (this.is_document_type) {
				if (this.filter_group) {
					this.filters = this.filter_group.get_filters();
				}
				this.create_filter_group_and_add_filters();
			} else {
				this.filter_button.on("click", function () {
					var fields;

					frappe.dashboard_utils
						.get_filters_for_chart_type(this$1.chart_doc)
						.then(function (filters) {
							if (!this$1.is_document_type) {
								if (!filters) {
									fields = [
										{
											fieldtype: "HTML",
											options: __("No Filters Set")
										}
									];
								} else {
									fields = filters
										.filter(function (df) { return df.fieldname; })
										.map(function (df) {
											Object.assign(df, df.dashboard_config || {});
											return df;
										});
								}
							} else {
								fields = [
									{
										fieldtype: "HTML",
										fieldname: "filter_area"
									}
								];
							}

							this$1.setup_filter_dialog(fields);
						});
				});
			}
		}

		setup_filter_dialog(fields) {
			var me = this;
			var dialog = new frappe.ui.Dialog({
				title: __("Set Filters for {0}", [this.chart_doc.chart_name]),
				fields: fields,
				primary_action: function() {
					var values = this.get_values();
					if (values) {
						this.hide();
						me.filters = values;
						me.save_chart_config_for_user({'filters': me.filters});
						me.fetch_and_update_chart();
					}
				},
				primary_action_label: "Set"
			});

			dialog.show();

			if (this.chart_doc.chart_type == 'Report') {
				//Set query report object so that it can be used while fetching filter values in the report
				frappe.query_report = new frappe.views.QueryReport({'filters': dialog.fields_list});
				frappe.query_reports[this.chart_doc.report_name].onload
						&& frappe.query_reports[this.chart_doc.report_name].onload(frappe.query_report);
			}
			dialog.set_values(this.filters);
		}

		reset_chart() {
			this.save_chart_config_for_user(null, 1);
			this.chart_settings = {};
			this.filters = null;
			this.selected_time_interval = null;
			this.selected_timespan = null;
			this.selected_heatmap_year = null;
		}

		save_chart_config_for_user(config, reset) {
			if ( reset === void 0 ) reset=0;

			Object.assign(this.chart_settings, config);
			frappe.xcall('frappe.desk.doctype.dashboard_settings.dashboard_settings.save_chart_config', {
				'reset': reset,
				'config': this.chart_settings,
				'chart_name': this.chart_doc.chart_name
			});
		}

		create_filter_group_and_add_filters() {
			var this$1 = this;

			this.filter_group = new frappe.ui.FilterGroup({
				doctype: this.chart_doc.document_type,
				filter_button: this.filter_button,
				on_change: function () {
					this$1.filters = this$1.filter_group.get_filters();
					this$1.save_chart_config_for_user({
						'filters': this$1.filters
					});
					this$1.fetch_and_update_chart();
				}
			});

			this.filters &&
				frappe.model.with_doctype(this.chart_doc.document_type, function () {
					this$1.filter_group.add_filters_to_filter_group(this$1.filters);
				});
		}

		set_chart_actions(actions) {
			/* eslint-disable indent */
			this.chart_actions = $(("<div class=\"chart-actions dropdown pull-right\">\n\t\t\t<button data-toggle=\"dropdown\"\n\t\t\t\taria-haspopup=\"true\"aria-expanded=\"false\"\n\t\t\t\tclass=\"btn btn-xs btn-secondary chart-menu\"\n\t\t\t>\n\t\t\t\t<svg class=\"icon icon-sm\">\n\t\t\t\t\t<use xlink:href=\"#icon-dot-horizontal\">\n\t\t\t\t\t</use>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t\t<ul class=\"dropdown-menu dropdown-menu-right\">\n\t\t\t\t" + (actions
						.map(
							function (action) { return ("<li><a class=\"dropdown-item\" data-action=\"" + (action.action) + "\">" + (action.label) + "</a></li>"); }
						)
						.join("")) + "\n\t\t\t</ul>\n\t\t</div>\n\t\t"));
			/* eslint-enable indent */

			this.chart_actions.find("a[data-action]").each(function (i, o) {
				var action = o.dataset.action;
				$(o).click(actions.find(function (a) { return a.action === action; }));
			});
			this.chart_actions.appendTo(this.action_area);
		}

		fetch(filters, refresh, args) {
			if ( refresh === void 0 ) refresh = false;

			var method = this.settings.method;

			if (this.chart_doc.chart_type == "Report") {
				args = {
					report_name: this.chart_doc.report_name,
					filters: filters,
					ignore_prepared_report: 1
				};
			} else {
				args = {
					chart_name: this.chart_doc.name,
					filters: filters,
					refresh: refresh ? 1 : 0,
					time_interval: args && args.time_interval ? args.time_interval : null,
					timespan: args && args.timespan ? args.timespan : null,
					from_date: args && args.from_date ? args.from_date : null,
					to_date: args && args.to_date ? args.to_date : null,
					heatmap_year: args && args.heatmap_year ?  args.heatmap_year : null,
				};
			}
			return frappe.xcall(method, args);
		}

		render() {
			if (!this.data || !this.data.labels || !Object.keys(this.data).length) {
				this.chart_wrapper.hide();
				this.loading.hide();
				this.$summary && this.$summary.hide();
				this.empty.show();
			} else {
				this.loading.hide();
				this.empty.hide();
				this.chart_wrapper.show();

				var chart_args = this.get_chart_args();

				if (!this.dashboard_chart) {
					this.dashboard_chart = frappe.utils.make_chart(this.chart_wrapper[0], chart_args);
				} else {
					this.dashboard_chart.update(this.data);
				}

				this.width == "Full" && this.summary && this.set_summary();
				this.chart_doc.type == 'Heatmap' && this.render_heatmap_legend();
			}
		}

		get_chart_args() {
			var this$1 = this;

			var colors = this.get_chart_colors();

			var chart_type_map = {
				Line: "line",
				Bar: "bar",
				Percentage: "percentage",
				Pie: "pie",
				Donut: "donut",
				Heatmap: "heatmap"
			};

			var chart_args = {
				data: this.data,
				type: chart_type_map[this.chart_doc.type],
				colors: colors,
				height: this.height,
				maxSlices: ['Pie', 'Donut'].includes(this.chart_doc.type) ? 6 : 9,
				axisOptions: {
					xIsSeries: this.chart_doc.timeseries,
					shortenYAxisNumbers: 1
				},
			};

			if (this.report_result && this.report_result.chart) {
				chart_args.tooltipOptions = {
					formatTooltipY: function (value) { return frappe.format(value, {
							fieldtype: this$1.report_result.chart.fieldtype,
							options: this$1.report_result.chart.options
						}, { always_show_decimals: true, inline: true }); }
				};
			}

			if (this.chart_doc.type == "Heatmap") {
				var heatmap_year = parseInt(this.selected_heatmap_year || this.chart_settings.heatmap_year || this.chart_doc.heatmap_year);
				chart_args.data.start = new Date((heatmap_year + "-01-01"));
				chart_args.data.end = new Date(((heatmap_year+1) + "-01-01"));
			}

			var set_options = function (options) {
				var custom_options = JSON.parse(options);
				for (var key in custom_options) {
					if (typeof chart_args[key] === 'object' && typeof custom_options[key] === 'object') {
						chart_args[key] = Object.assign(chart_args[key], custom_options[key]);
					} else {
						chart_args[key] = custom_options[key];
					}
				}
			};

			if (this.custom_options) {
				set_options(this.custom_options);
			}

			if (this.chart_doc.custom_options) {
				set_options(this.chart_doc.custom_options);
			}

			return chart_args;
		}

		get_chart_colors() {
			var colors = [];
			if (this.chart_doc.y_axis.length) {
				this.chart_doc.y_axis.map(function (field) {
					colors.push(field.color);
				});
			} else if (["Line", "Bar"].includes(this.chart_doc.type)) {
				colors = [this.chart_doc.color || []];
			}  else if (this.chart_doc.type == "Heatmap") {
				colors = [];
			}

			return colors;
		}

		render_heatmap_legend() {
			if (!this.$heatmap_legend && this.widget.width() > 991) {
				this.$heatmap_legend =
					$(("\n\t\t\t\t<div class=\"heatmap-legend\">\n\t\t\t\t\t<ul class=\"legend-colors\">\n\t\t\t\t\t\t<li style=\"background-color: #ebedf0\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #c6e48b\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #7bc96f\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #239a3b\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #196127\"></li>\n\t\t\t\t\t</ul>\n\t\t\t\t\t<div class=\"legend-label\">\n\t\t\t\t\t\t<div style=\"margin-bottom: 45px\">" + (__("Less")) + "</div>\n\t\t\t\t\t\t<div>" + (__("More")) + "</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t"));
				this.body.append(this.$heatmap_legend);
			}
		}

		update_last_synced() {
			if (!this.chart_doc.last_synced_on) {
				return;
			}
			var last_synced_text = __("Last synced {0}", [comment_when(this.chart_doc.last_synced_on)]);
			this.subtitle_field.html(last_synced_text);
		}

		update_chart_object() {
			var this$1 = this;

			frappe.db.get_doc("Dashboard Chart", this.chart_doc.name).then(function (doc) {
				this$1.chart_doc = doc;
				this$1.update_last_synced();
			});
		}

		prepare_chart_object() {
			if (this.chart_doc.type == 'Heatmap' && !this.chart_doc.heatmap_year) {
				this.chart_doc.heatmap_year = frappe.dashboard_utils.get_year(frappe.datetime.now_date());
			}

			return this.set_chart_filters();
		}

		set_chart_filters() {
			var this$1 = this;

			var user_saved_filters = this.chart_settings.filters || null;
			var chart_saved_filters = frappe.dashboard_utils.get_all_filters(this.chart_doc);

			if (this.chart_doc.chart_type == 'Report') {
				return frappe.dashboard_utils
					.get_filters_for_chart_type(this.chart_doc).then(function (filters) {
						chart_saved_filters = this$1.update_default_date_filters(filters, chart_saved_filters);
						this$1.filters =
							user_saved_filters || this$1.filters || chart_saved_filters;
					});
			} else {
				this.filters =
					user_saved_filters || this.filters || chart_saved_filters;
				return Promise.resolve();
			}
		}

		update_default_date_filters(report_filters, chart_filters) {
			if (report_filters) {
				report_filters.map(function (f) {
					if (['Date', 'DateRange'].includes(f.fieldtype) && f.default) {
						if (f.reqd || chart_filters[f.fieldname]) {
							chart_filters[f.fieldname] = f.default;
						}
					}
				});
			}
			return chart_filters;
		}

		get_settings() {
			var this$1 = this;

			return frappe.model
				.with_doc("Dashboard Chart", this.chart_name)
				.then(function (chart_doc) {
					if (chart_doc) {
						this$1.chart_doc = chart_doc;
						if (this$1.chart_doc.chart_type == "Custom") {
							// custom source
							if (
								frappe.dashboards.chart_sources[this$1.chart_doc.source]
							) {
								this$1.settings =
									frappe.dashboards.chart_sources[
										this$1.chart_doc.source
									];
								return Promise.resolve();
							} else {
								var method =
									"frappe.desk.doctype.dashboard_chart_source.dashboard_chart_source.get_config";
								return frappe
									.xcall(method, { name: this$1.chart_doc.source })
									.then(function (config) {
										frappe.dom.eval(config);
										this$1.settings =
											frappe.dashboards.chart_sources[
												this$1.chart_doc.source
											];
									});
							}
						} else if (this$1.chart_doc.chart_type == "Report") {
							this$1.settings = {
								method: "frappe.desk.query_report.run"
							};
							return Promise.resolve();
						} else {
							this$1.settings = {
								method: "frappe.desk.doctype.dashboard_chart.dashboard_chart.get"
							};
							return Promise.resolve();
						}
					}
				});
		}
	}

	frappe.provide("frappe.utils");

	class ShortcutWidget extends Widget {
		constructor(opts) {
			opts.shadow = true;
			super(opts);
		}

		get_config() {
			return {
				name: this.name,
				icon: this.icon,
				label: this.label,
				format: this.format,
				link_to: this.link_to,
				doc_view: this.doc_view,
				color: this.color,
				restrict_to_domain: this.restrict_to_domain,
				stats_filter: this.stats_filter,
				type: this.type,
			};
		}

		setup_events() {
			var this$1 = this;

			this.widget.click(function () {
				if (this$1.in_customize_mode) { return; }

				var route = frappe.utils.generate_route({
					route: this$1.route,
					name: this$1.link_to,
					type: this$1.type,
					is_query_report: this$1.is_query_report,
					doctype: this$1.ref_doctype,
					doc_view: this$1.doc_view
				});

				var filters = this$1.get_doctype_filter();
				if (this$1.type == "DocType" && filters) {
					frappe.route_options = filters;
				}
				frappe.set_route(route);
			});
		}

		set_actions() {
			var this$1 = this;

			if (this.in_customize_mode) { return; }

			this.widget.addClass("shortcut-widget-box");

			var filters = this.get_doctype_filter();
			if (this.type == "DocType" && filters) {
				frappe.db
					.count(this.link_to, {
						filters: filters,
					})
					.then(function (count) { return this$1.set_count(count); });
			}
		}

		get_doctype_filter() {
			var count_filter = new Function(("return " + (this.stats_filter)))();
			if (count_filter) {
				return count_filter;
			}

			return null;
		}

		set_count(count) {
			var this$1 = this;

			var get_label = function () {
				if (this$1.format) {
					return __(this$1.format).replace(/{}/g, count);
				}
				return count;
			};

			this.action_area.empty();
			var label = get_label();
			var color = this.color && count ? this.color.toLowerCase() : 'gray';
			$(("<div class=\"indicator-pill ellipsis " + color + "\">" + label + "</div>")).appendTo(this.action_area);
		}
	}

	frappe.provide("frappe.utils");

	class LinksWidget extends Widget {
		constructor(opts) {
			opts.icon = opts.icon || 'file';
			super(opts);
		}

		get_config() {
			return {
				name: this.name,
				links: JSON.stringify(this.links),
				label: this.label,
				hidden: this.hidden,
			};
		}

		set_body() {
			var this$1 = this;

			this.options = {};
			this.options.links = this.links;
			this.widget.addClass("links-widget-box");
			var is_link_disabled = function (item) {
				return item.dependencies && item.incomplete_dependencies;
			};
			var disabled_dependent = function (item) {
				return is_link_disabled(item) ? "disabled-link" : "";
			};

			var get_indicator_color = function (item) {
				if (item.open_count) {
					return "red";
				}
				if (item.onboard) {
					return item.count ? "blue" : "yellow";
				}
				return "gray";
			};

			var get_link_for_item = function (item) {
				if (is_link_disabled(item)) {
					return ("<span class=\"link-content ellipsis disabled-link\">" + (item.label ? item.label : item.name) + "</span>\n\t\t\t\t\t<div class=\"module-link-popover popover fade top in\" role=\"tooltip\" style=\"display: none;\">\n\t\t\t\t\t\t<div class=\"arrow\"></div>\n\t\t\t\t\t\t<h3 class=\"popover-title\" style=\"display: none;\"></h3>\n\t\t\t\t\t\t<div class=\"popover-content\" style=\"padding: 12px;\">\n\t\t\t\t\t\t\t<div class=\"small text-muted\">" + (__("You need to create these first: ")) + "</div>\n\t\t\t\t\t\t\t<div class=\"small\">" + (item.incomplete_dependencies.join(", ")) + "</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>");
				}

				if (item.youtube_id)
					{ return ("<span class=\"link-content help-video-link ellipsis\" data-youtubeid=\"" + (item.youtube_id) + "\">\n\t\t\t\t\t\t" + (item.label ? item.label : item.name) + "</span>"); }

				return ("<span class=\"link-content ellipsis\">" + (item.label ? item.label : item.name) + "</span>");
			};

			this.link_list = this.links.map(function (item) {
				var opts = {
					name: item.link_to,
					type: item.link_type,
					doctype: item.doctype,
					is_query_report: item.is_query_report
				};

				if (item.link_type.toLowerCase() == "report" && !item.is_query_report) {
					opts.doctype = item.dependencies;
				}

				var route = frappe.utils.generate_route(opts);

				return $(("<a href=\"" + route + "\" class=\"link-item ellipsis " + (item.onboard ? "onboard-spotlight" : "") + " " + (disabled_dependent(item)) + "\" type=\"" + (item.type) + "\">\n\t\t\t\t\t<span class=\"indicator-pill no-margin " + (get_indicator_color(item)) + "\"></span>\n\t\t\t\t\t" + (get_link_for_item(item)) + "\n\t\t\t</a>"));
			});

			this.link_list.forEach(function (link) { return link.appendTo(this$1.body); });
		}

		setup_events() {
			var this$1 = this;

			this.link_list.forEach(function (link) {
				// Bind Popver Event
				var link_label = link.find(".link-content");

				if (link.hasClass("disabled-link")) {
					var popover = link.find(".module-link-popover");

					link_label.mouseover(function () {
						if (this$1.in_customize_mode) { return; }
						popover.show();
					});
					link_label.mouseout(function () { return popover.hide(); });
				} else {
					link_label.click(function (event) {
						if (this$1.in_customize_mode) { return; }

						if (link_label.hasClass("help-video-link")) {
							var yt_id = event.currentTarget.dataset.youtubeid;
							frappe.help.show_video(yt_id);
						}
					});
				}
			});
		}
	}

	frappe.provide("frappe.utils");

	class OnboardingWidget extends Widget {
		make_body() {
			var this$1 = this;

			this.steps_wrapper = $("<div class=\"onboarding-steps-wrapper\"></div>").appendTo(this.body);
			this.step_preview = $("<div class=\"onboarding-step-preview\">\n\t\t\t<div class=\"onboarding-step-body\"></div>\n\t\t\t<div class=\"onboarding-step-footer\"></div>\n\t\t</div>").appendTo(this.body);

			this.step_body = this.step_preview.find(".onboarding-step-body");
			this.step_footer = this.step_preview.find(".onboarding-step-footer");

			this.steps.forEach(function (step, index) {
				this$1.add_step(step, index);
			});

			this.show_step(this.steps[0]);
		}

		add_step(step, index) {
			var this$1 = this;

			var status = 'pending';

			if (step.is_skipped) { status = "skipped"; }
			if (step.is_complete) { status = "complete"; }

			var $step = $(("<a class=\"onboarding-step " + status + "\">\n\t\t\t\t<div class=\"step-title\">\n\t\t\t\t\t<div class=\"step-index step-pending\">" + (__(index + 1)) + "</div>\n\t\t\t\t\t<div class=\"step-index step-skipped\">" + (frappe.utils.icon('tick', 'xs')) + "</div>\n\t\t\t\t\t<div class=\"step-index step-complete\">" + (frappe.utils.icon('tick', 'xs')) + "</div>\n\t\t\t\t\t<div>" + (__(step.title)) + "</div>\n\t\t\t\t</div>\n\t\t\t</a>"));

			step.$step = $step;

			// Add skip button
			if (!step.is_complete && !step.is_skipped) {
				var skip_html = $(
					("<div class=\"step-skip\">" + (__('Skip')) + "</div>")
				);

				skip_html.appendTo($step);
				skip_html.on("click", function () {
					this$1.skip_step(step);
					event.stopPropagation();
				});
			}
			$step.on("click", function () { return this$1.show_step(step); });
			$step.appendTo(this.steps_wrapper);

			return $step;
		}

		show_step(step) {
			var this$1 = this;

			this.active_step && this.active_step.$step.removeClass("active");

			step.$step.addClass("active");
			this.active_step = step;

			var actions = {
				"Watch Video": function (step) { return this$1.show_video(step); },
				"Create Entry": function (step) {
					if (step.is_complete) {
						frappe.set_route(("/app/List/" + (step.reference_document)));
					} else {
						if (step.show_full_form) {
							this$1.create_entry(step);
						} else {
							this$1.show_quick_entry(step);
						}
					}
				},
				"Show Form Tour": function (step) { return this$1.show_form_tour(step); },
				"Update Settings": function (step) { return this$1.update_settings(step); },
				"View Report": function (step) { return this$1.open_report(step); },
				"Go to Page": function (step) { return this$1.go_to_page(step); },
			};

			var toggle_content = function () {
				this$1.step_body.empty();
				this$1.step_footer.empty();

				this$1.step_body.html(
					step.description ?
						frappe.markdown(step.description)
						: ("<h1>" + (step.title) + "</h1>")
				);

				if (step.intro_video_url) {
					$(("<button class=\"btn btn-primary btn-sm\">" + (__('Watch Tutorial')) + "</button>"))
						.appendTo(this$1.step_footer)
						.on('click', toggle_video);
				} else {
					$(("<button class=\"btn btn-primary btn-sm\">" + (__(step.action_label || step.action)) + "</button>"))
						.appendTo(this$1.step_footer)
						.on('click', function () { return actions[step.action](step); });
				}
			};

			var toggle_video = function () {
				this$1.step_body.empty();
				this$1.step_footer.empty();

				var video = $(("<div class=\"video-player\" data-plyr-provider=\"youtube\" data-plyr-embed-id=\"" + (step.intro_video_url) + "\"></div>"));
				video.appendTo(this$1.step_body);
				var plyr = new frappe.Plyr(video[0], {
					hideControls: true,
					resetOnEnd: true,
				});

				$(("<button class=\"btn btn-primary btn-sm\">" + (__(step.action_label || step.action)) + "</button>"))
					.appendTo(this$1.step_footer)
					.on('click', function () {
						plyr.pause();
						actions[step.action](step);
					});

				// Fire only once, on hashchange
				$(window).one('hashchange', function () {
					plyr.pause();
				});

				$(("<button class=\"btn btn-secondary ml-2 btn-sm\">" + (__('Back')) + "</button>"))
					.appendTo(this$1.step_footer)
					.on('click', toggle_content);
			};

			toggle_content();
			// toggle_video();
		}

		go_to_page(step) {
			this.mark_complete(step);
			frappe.set_route(step.path).then(function () {
				var message = step.callback_message || __("You can continue with the onboarding after exploring this page");
				var title = step.callback_title || __("Awesome Work");

				var msg_dialog = frappe.msgprint({
					message: message,
					title: title,
					primary_action: {
						action: function () {
							msg_dialog.hide();
						},
						label: function () { return __("Continue"); },
					},
					wide: true,
				});
			});
		}

		open_report(step) {
			var this$1 = this;

			var route = frappe.utils.generate_route({
				name: step.reference_report,
				type: "report",
				is_query_report: step.report_type !== "Report Builder",
				doctype: step.report_reference_doctype,
			});

			var current_route = frappe.get_route();

			frappe.set_route(route).then(function () {
				var msg_dialog = frappe.msgprint({
					message: __(step.report_description),
					title: __(step.reference_report),
					primary_action: {
						action: function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
							msg_dialog.hide();
						},
						label: function () { return __("Continue"); },
					},
					secondary_action: {
						action: function () {
							msg_dialog.hide();
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						},
						label: __("Go Back"),
					},
				});

				frappe.msg_dialog.custom_onhide = function () { return this$1.mark_complete(step); };
			});
		}

		show_form_tour(step) {
			var this$1 = this;

			var route;
			if (step.is_single) {
				route = frappe.router.slug(step.reference_document);
			} else {
				route = (frappe.router.slug(step.reference_document)) + "/new";
			}

			var current_route = frappe.get_route();

			frappe.route_hooks = {};
			frappe.route_hooks.after_load = function (frm) {
				frm.show_tour(function () {
					var msg_dialog = frappe.msgprint({
						message: __("Let's take you back to onboarding"),
						title: __("Great Job"),
						primary_action: {
							action: function () {
								frappe.set_route(current_route).then(function () {
									this$1.mark_complete(step);
								});
								msg_dialog.hide();
							},
							label: function () { return __("Continue"); },
						},
					});
				});
			};

			frappe.set_route(route);
		}

		update_settings(step) {
			var this$1 = this;

			var current_route = frappe.get_route();

			frappe.route_hooks = {};
			frappe.route_hooks.after_load = function (frm) {
				frm.scroll_to_field(step.field);
				frm.doc.__unsaved = true;
			};

			frappe.route_hooks.after_save = function (frm) {
				var success = false;
				var args = {};

				var value = frm.doc[step.field];
				var custom_onhide = null;

				if (value && step.value_to_validate == "%") { success = true; }
				if (value == step.value_to_validate) { success = true; }
				if (cstr(value) == cstr(step.value_to_validate)) { success = true; }

				if (success) {
					args.message = __("Let's take you back to onboarding");
					args.title = __("Looks Great");
					args.primary_action = {
						action: function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						},
						label: __("Continue"),
					};

					custom_onhide = function () { return args.primary_action.action(); };
				} else {
					args.message = __("Looks like you didn't change the value");
					args.title = __("Oops");
					args.secondary_action = {
						action: function () { return frappe.set_route(current_route); },
						label: __("Go Back"),
					};

					args.primary_action = {
						action: function () {
							frappe.set_route(current_route).then(function () {
								setTimeout(function () {
									this$1.skip_step(step);
								}, 300);
							});
						},
						label: __("Skip Step"),
					};

					custom_onhide = function () { return args.secondary_action.action(); };
				}

				frappe.msgprint(args);
				frappe.msg_dialog.custom_onhide = function () { return custom_onhide(); };
			};

			frappe.set_route("Form", step.reference_document);
		}

		create_entry(step) {
			var this$1 = this;

			var current_route = frappe.get_route();

			frappe.route_hooks = {};
			frappe.route_hooks.after_load = function (frm) {
				frm.show_tour(function () {
					frappe.msgprint({
						message: __("Awesome, now try making an entry yourself"),
						title: __("Great"),
					});
				});
			};

			var callback = function () {
				frappe.msgprint({
					message: __("You're doing great, let's take you back to the onboarding page."),
					title: __("Good Work 🎉"),
					primary_action: {
						action: function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						},
						label: __("Continue"),
					},
				});

				frappe.msg_dialog.custom_onhide = function () {
					this$1.mark_complete(step);
				};
			};

			if (step.is_submittable) {
				frappe.route_hooks.after_save = function () {
					frappe.msgprint({
						message: __("Submit this document to complete this step."),
						title: __("Great")
					});
				};
				frappe.route_hooks.after_submit = callback;
			} else {
				frappe.route_hooks.after_save = callback;
			}

			frappe.set_route('Form', step.reference_document, 'new');
		}

		show_quick_entry(step) {
			var this$1 = this;

			var current_route = frappe.get_route_str();
			frappe.ui.form.make_quick_entry(
				step.reference_document,
				function () {
					if (frappe.get_route_str() != current_route) {
						var success_dialog = frappe.msgprint({
							message: __("Let's take you back to onboarding"),
							title: __("Looks Great"),
							primary_action: {
								action: function () {
									success_dialog.hide();
									frappe.set_route(current_route).then(function () {
										this$1.mark_complete(step);
									});
								},
								label: __("Continue"),
							},
						});

						frappe.msg_dialog.custom_onhide = function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						};
					} else {
						frappe.msgprint({
							message: __("Let us continue with the onboarding"),
							title: __("Looks Great")
						});
						this$1.mark_complete(step);
					}
				},
				null,
				null,
				true
			);
		}

		show_video(step) {
			frappe.help.show_video(step.video_url, step.title);
			this.mark_complete(step);
		}

		mark_complete(step) {
			var $step = step.$step;

			var callback = function () {
				step.is_complete = true;
				$step.removeClass("skipped");
				$step.addClass("complete");
			};

			this.update_step_status(step, "is_complete", 1, callback);
		}

		skip_step(step) {
			var $step = step.$step;

			var callback = function () {
				step.is_skipped = true;
				$step.removeClass("complete");
				$step.removeClass("pending");
				$step.addClass("skipped");
			};

			this.update_step_status(step, "is_skipped", 1, callback);
		}

		update_step_status(step, status, value, callback) {
			var this$1 = this;

			var icon_class = {
				is_complete: "complete",
				is_skipped: "skipped",
			};
			//  Clear any hooks
			frappe.route_hooks = {};

			frappe
				.call("frappe.desk.desktop.update_onboarding_step", {
					name: step.name,
					field: status,
					value: value,
				})
				.then(function () {
					callback();

					step.$step
						.removeClass("pending")
						.removeClass("complete")
						.removeClass("skipped")
						.addClass(icon_class[status]);

					var pending = this$1.steps.filter(function (step) {
						return !(step.is_complete || step.is_skipped);
					});

					if (pending.length == 0) {
						this$1.show_success();
					}
				});
		}

		show_success() {
			var this$1 = this;

			var success_message = this.success || __("You seem good to go!");
			var success_state_image =
				this.success_state_image ||
				"/assets/frappe/images/ui-states/success-color.png";
			var documentation = "";
			if (this.docs_url) {
				documentation = __(
					'Congratulations on completing the module setup. If you want to learn more you can refer to the documentation <a target="_blank" href="{0}">here</a>.',
					[this.docs_url]
				);
			}

			var success = $(("<div class=\"text-center onboarding-success\">\n\t\t\t\t\t<img src=\"" + success_state_image + "\" alt=\"Success State\" class=\"zoom-in success-state\">\n\t\t\t\t\t<h3>" + success_message + "</h3>\n\t\t\t\t\t<div class=\"text-muted\">" + documentation + "</div>\n\t\t\t\t\t<button class=\"btn btn-primary btn-sm\">" + (__('Continue')) + "</button>\n\t\t\t</div>\n\t\t"));

			success.find('.btn').on('click', function () { return this$1.delete(); });

			this.step_preview.empty();
			success.appendTo(this.step_preview);
		}

		set_body() {
			this.widget.addClass("onboarding-widget-box");
			if (this.is_dismissed()) {
				this.widget.hide();
			} else {
				this.make_body();
			}
		}

		is_dismissed() {
			var dismissed = JSON.parse(
				localStorage.getItem("dismissed-onboarding") || "{}"
			);
			if (Object.keys(dismissed).includes(this.label)) {
				var last_hidden = new Date(dismissed[this.label]);
				var today = new Date();
				var diff = frappe.datetime.get_hour_diff(today, last_hidden);
				return diff < 24;
			}
			return false;
		}

		set_actions() {
			var this$1 = this;

			this.action_area.empty();
			var dismiss = $(
				("<div class=\"small\" style=\"cursor:pointer;\">" + (__('Dismiss', null, 'Stop showing the onboarding widget.')) + "</div>")
			);
			dismiss.on("click", function () {
				var dismissed = JSON.parse(
					localStorage.getItem("dismissed-onboarding") || "{}"
				);
				dismissed[this$1.label] = frappe.datetime.now_datetime();

				localStorage.setItem(
					"dismissed-onboarding",
					JSON.stringify(dismissed)
				);
				this$1.delete();
			});
			dismiss.appendTo(this.action_area);
		}
	}

	class NewWidget {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		customize() {
			return;
		}

		make() {
			this.make_widget();
			this.widget.appendTo(this.container);
			this.setup_events();
		}

		get_title() {
			// DO NOT REMOVE: Comment to load translation
			// __("New Chart") __("New Shortcut") __("New Number Card")
			var title = "New " + (frappe.model.unscrub(this.type));
			return __(title);
		}

		make_widget() {
			var new_widget_class = "new-" + (frappe.scrub(frappe.model.unscrub(this.type), '-')) + "-widget";
			this.widget = $(("<div class=\"widget new-widget " + new_widget_class + "\">\n\t\t\t\t+ " + (this.get_title()) + "\n\t\t\t</div>"));
			this.body = this.widget;
		}

		setup_events() {
			var this$1 = this;

			this.widget.on("click", function () {
				if (!this$1.custom_dialog) {
					this$1.open_dialog();
				} else {
					this$1.custom_dialog();
				}
			});
		}

		open_dialog() {
			var dialog_class = get_dialog_constructor(this.type);

			this.dialog = new dialog_class({
				label: this.label,
				type: this.type,
				values: false,
				default_values: this.default_values,
				primary_action: this.on_create,
			});

			this.dialog.make();
		}

		delete() {
			this.widget.remove();
		}
	}

	frappe.provide("frappe.utils");

	class NumberCardWidget extends Widget {
		constructor(opts) {
			opts.shadow = true;
			super(opts);
		}

		get_config() {
			return {
				name: this.name,
				label: this.label,
				color: this.color,
				hidden: this.hidden,
			};
		}

		refresh() {
			this.set_body();
		}

		set_body() {
			this.widget.addClass("number-widget-box");
			this.make_card();
		}

		set_title() {
			$(this.title_field).html(("<div class=\"number-label\">" + (this.card_doc.label) + "</div>"));
		}

		make_card() {
			var this$1 = this;

			frappe.model.with_doc('Number Card', this.name).then(function (card) {
				if (!card) {
					if (this$1.document_type) {
						frappe.run_serially([
							function () { return this$1.create_number_card(); },
							function () { return this$1.render_card(); } ]);
					} else {
						// widget doesn't exist so delete
						this$1.delete(false);
						return;
					}
				} else {
					this$1.card_doc = card;
					this$1.render_card();
				}

				this$1.set_events();
			});
		}

		create_number_card() {
			var this$1 = this;

			this.set_doc_args();
			return frappe.xcall(
				'frappe.desk.doctype.number_card.number_card.create_number_card',
				{
					'args': this.card_doc
				}
			).then(function (doc) {
				this$1.name = doc.name;
				this$1.card_doc = doc;
				this$1.widget.attr('data-widget-name', this$1.name);
			});
		}

		set_events() {
			var this$1 = this;

			$(this.body).click(function () {
				if (this$1.in_customize_mode || this$1.card_doc.type == 'Custom') { return; }
				this$1.set_route();
			});
		}

		set_route() {
			var is_document_type = this.card_doc.type !== 'Report';
			var name = is_document_type ? this.card_doc.document_type : this.card_doc.report_name;
			var route = frappe.utils.generate_route({
				name: name,
				type: is_document_type ? 'doctype' : 'report',
				is_query_report: !is_document_type,
			});

			if (is_document_type) {
				var filters = JSON.parse(this.card_doc.filters_json);
				frappe.route_options = filters.reduce(function (acc, filter) {
					var obj;

					return Object.assign(acc, ( obj = {}, obj[((filter[0]) + "." + (filter[1]))] = [filter[2], filter[3]], obj ));
				}, {});
			}

			frappe.set_route(route);
		}

		set_doc_args() {
			this.card_doc = Object.assign({}, {
				document_type: this.document_type,
				label: this.label,
				function: this.function,
				aggregate_function_based_on: this.aggregate_function_based_on,
				color: this.color,
				filters_json: this.stats_filter
			});
		}

		get_settings(type) {
			var this$1 = this;

			this.filters = this.get_filters();
			var settings_map = {
				'Custom': {
					method: this.card_doc.method,
					args: {
						filters: this.filters
					},
					get_number: function (res) { return this$1.get_number_for_custom_card(res); },
				},
				'Report': {
					method: 'frappe.desk.query_report.run',
					args: {
						report_name: this.card_doc.report_name,
						filters: this.filters,
						ignore_prepared_report: 1
					},
					get_number: function (res) { return this$1.get_number_for_report_card(res); },
				},
				'Document Type': {
					method: 'frappe.desk.doctype.number_card.number_card.get_result',
					args: {
						doc: this.card_doc,
						filters: this.filters,
					},
					get_number: function (res) { return this$1.get_number_for_doctype_card(res); },
				}
			};
			return settings_map[type];
		}

		get_filters() {
			var filters = frappe.dashboard_utils.get_all_filters(this.card_doc);
			return filters;
		}

		render_card() {
			var this$1 = this;

			this.prepare_actions();
			this.set_title();
			this.set_loading_state();

			if (!this.card_doc.type) {
				this.card_doc.type = 'Document Type';
			}

			this.settings = this.get_settings(this.card_doc.type);

			frappe.run_serially([
				function () { return this$1.render_number(); },
				function () { return this$1.render_stats(); } ]);
		}

		set_loading_state() {
			$(this.body).html(("<div class=\"number-card-loading text-muted\">\n\t\t\t" + (__('Loading...')) + "\n\t\t</div>"));
		}

		get_number() {
			var this$1 = this;

			return frappe.xcall(this.settings.method, this.settings.args).then(function (res) {
				return this$1.settings.get_number(res);
			});
		}

		get_number_for_custom_card(res) {
			if (typeof res === 'object') {
				this.number = res.value;
				this.set_formatted_number(res);
			} else {
				this.formatted_number = res;
			}
		}

		get_number_for_doctype_card(res) {
			var this$1 = this;

			this.number = res;
			if (this.card_doc.function !== 'Count') {
				return frappe.model.with_doctype(this.card_doc.document_type, function () {
					var based_on_df =
						frappe.meta.get_docfield(this$1.card_doc.document_type, this$1.card_doc.aggregate_function_based_on);
					this$1.set_formatted_number(based_on_df);
				});
			} else {
				this.formatted_number = res;
			}
		}

		get_number_for_report_card(res) {
			var field = this.card_doc.report_field;
			var vals = res.result.reduce(function (acc, col) {
				col[field] && acc.push(col[field]);
				return acc;
			}, []);
			var col = res.columns.find(function (col) { return col.fieldname == field; });
			this.number = frappe.report_utils.get_result_of_fn(this.card_doc.report_function, vals);
			this.set_formatted_number(col);
		}

		set_formatted_number(df) {
			var default_country = frappe.sys_defaults.country;
			var shortened_number = frappe.utils.shorten_number(this.number, default_country, 5);
			var number_parts = shortened_number.split(' ');

			var symbol = number_parts[1] || '';
			var formatted_number = $(frappe.format(number_parts[0], df)).text();

			this.formatted_number = formatted_number + ' ' + symbol;
		}

		render_number() {
			var this$1 = this;

			return this.get_number().then(function () {
				$(this$1.body).html(("<div class=\"widget-content\">\n\t\t\t\t<div class=\"number\" style=\"color:" + (this$1.card_doc.color) + "\">" + (this$1.formatted_number) + "</div>\n\t\t\t\t</div>"));
			});
		}

		render_stats() {
			var this$1 = this;

			if (this.card_doc.type !== 'Document Type') {
				return;
			}

			var caret_html = '';
			var color_class = '';

			return this.get_percentage_stats().then(function () {
				if (this$1.percentage_stat == 0 || this$1.percentage_stat == undefined) {
					color_class = 'grey-stat';
				} else if (this$1.percentage_stat > 0) {
					caret_html =
						"<span class=\"indicator-pill-round green\">\n\t\t\t\t\t\t" + (frappe.utils.icon('arrow-up-right', 'xs')) + "\n\t\t\t\t\t</span>";
					color_class = 'green-stat';
				} else {
					caret_html =
						"<span class=\"indicator-pill-round red\">\n\t\t\t\t\t\t" + (frappe.utils.icon('arrow-down-left', 'xs')) + "\n\t\t\t\t\t</span>";
					color_class = 'red-stat';
				}

				var stats_qualifier_map = {
					'Daily': __('since yesterday'),
					'Weekly': __('since last week'),
					'Monthly': __('since last month'),
					'Yearly': __('since last year')
				};
				var stats_qualifier = stats_qualifier_map[this$1.card_doc.stats_time_interval];

				var get_stat = function () {
					if (this$1.percentage_stat == undefined) { return NaN; }
					var parts = this$1.percentage_stat.split(' ');
					var symbol = parts[1] || '';
					return Math.abs(parts[0]) + ' ' + symbol;
				};

				$(this$1.body).find('.widget-content').append(("<div class=\"card-stats " + color_class + "\">\n\t\t\t\t<span class=\"percentage-stat-area\">\n\t\t\t\t\t" + caret_html + "\n\t\t\t\t\t<span class=\"percentage-stat\">\n\t\t\t\t\t\t" + (get_stat()) + " %\n\t\t\t\t\t</span>\n\t\t\t\t</span>\n\t\t\t\t<span class=\"stat-period text-muted\">\n\t\t\t\t\t" + stats_qualifier + "\n\t\t\t\t</span>\n\t\t\t</div>"));
			});
		}

		get_percentage_stats() {
			var this$1 = this;

			return frappe.xcall('frappe.desk.doctype.number_card.number_card.get_percentage_difference', {
				doc: this.card_doc,
				filters: this.filters,
				result: this.number
			}).then(function (res) {
				if (res !== undefined) {
					this$1.percentage_stat = frappe.utils.shorten_number(res);
				}
			});
		}

		prepare_actions() {
			var this$1 = this;

			var actions = [
				{
					label: __('Refresh'),
					action: 'action-refresh',
					handler: function () {
						this$1.render_card();
					}
				},
				{
					label: __('Edit'),
					action: 'action-edit',
					handler: function () {
						frappe.set_route(
							'Form',
							'Number Card',
							this$1.name
						);
					}
				} ];

			this.set_card_actions(actions);
		}

		set_card_actions(actions) {
			/* eslint-disable indent */
			this.card_actions =
				$(("<div class=\"card-actions dropdown pull-right\">\n\t\t\t\t<a data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t...\n\t\t\t\t</a>\n\t\t\t\t<ul class=\"dropdown-menu\" style=\"max-height: 300px; overflow-y: auto;\">\n\t\t\t\t\t" + (actions
							.map(
								function (action) { return ("<li class=\"dropdown-item\">\n\t\t\t\t\t\t\t\t\t<a data-action=\"" + (action.action) + "\">" + (action.label) + "</a>\n\t\t\t\t\t\t\t\t</li>"); }
							).join('')) + "\n\t\t\t\t</ul>\n\t\t\t</div>"));
			/* eslint-disable indent */

			this.card_actions.find("a[data-action]").each(function (i, o) {
				var action = o.dataset.action;
				$(o).click(actions.find(function (a) { return a.action === action; }));
			});

			this.action_area.html(this.card_actions);
		}
	}

	frappe.provide("frappe.widget");

	frappe.widget.widget_factory = {
		chart: ChartWidget,
		base: Widget,
		shortcut: ShortcutWidget,
		links: LinksWidget,
		onboarding: OnboardingWidget,
		number_card: NumberCardWidget,
	};

	frappe.widget.make_widget = function (opts) {
		var widget_class = frappe.widget.widget_factory[opts.widget_type];
		if (widget_class) {
			return new widget_class(opts);
		} else {
			// eslint-disable-next-line
			console.warn("Invalid Widget Name: " + opts.widget_type);
		}
	};

	class WidgetGroup {
		constructor(opts) {
			Object.assign(this, opts);
			this.widgets_list = [];
			this.widgets_dict = {};
			this.widget_order = [];
			this.make();
		}

		make() {
			this.make_container();
			if (this.title) {
				this.set_title();
			} else {
				this.title_area.remove();
			}
			this.widgets && this.make_widgets();
		}

		make_container() {
			var widget_area = $(("<div class=\"widget-group " + (this.class_name || '') + "\">\n\t\t\t\t<div class=\"widget-group-head\">\n\t\t\t\t\t<div class=\"widget-group-title\"></div>\n\t\t\t\t\t<div class=\"widget-group-control\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"widget-group-body grid-col-" + (this.columns) + "\">\n\t\t\t\t</div>\n\t\t\t</div>"));
			this.widget_area = widget_area;
			if (this.hidden) { this.widget_area.hide(); }
			this.title_area = widget_area.find(".widget-group-title");
			this.control_area = widget_area.find(".widget-group-control");
			this.body = widget_area.find(".widget-group-body");
			!this.widgets.length && this.widget_area.hide();
			widget_area.appendTo(this.container);
		}

		set_title() {
			this.title_area[0].innerText = this.title;
		}

		make_widgets() {
			var this$1 = this;

			this.body.empty();
			this.widgets.forEach(function (widget) {
				this$1.add_widget(widget);
			});
		}

		add_widget(widget) {
			var this$1 = this;

			var widget_object = frappe.widget.make_widget(Object.assign({}, widget,
				{widget_type: this.type,
				container: this.body,
				height: this.height || null,
				options: Object.assign({}, this.options,
					{on_delete: function (name) { return this$1.on_delete(name); }})}));

			this.widgets_list.push(widget_object);
			this.widgets_dict[widget.name] = widget_object;

			return widget_object;
		}

		remove_widget(widget_obj) {
			widget_obj.widget.remove();
			this.widgets_list.filter(function (widget) {
				if (widget.name == widget_obj.name) { return false; }
			});
			delete this.widgets_dict[widget_obj.name];
		}

		customize() {
			var this$1 = this;

			if (!this.hidden) { this.widget_area.show(); }
			this.widgets_list.forEach(function (wid) {
				wid.customize(this$1.options);
			});

			this.options.allow_create && this.setup_new_widget();
			this.options.allow_sorting && this.setup_sortable();
		}

		setup_new_widget() {
			var this$1 = this;

			var max = this.options
				? this.options.max_widget_count || Number.POSITIVE_INFINITY
				: Number.POSITIVE_INFINITY;

			if (this.widgets_list.length < max) {
				this.new_widget = new NewWidget({
					container: this.body,
					type: this.type,
					custom_dialog: this.custom_dialog,
					default_values: this.default_values,
					on_create: function (config) {
						// Remove new widget
						this$1.new_widget.delete();
						delete this$1.new_widget;

						config.in_customize_mode = 1;

						// Add new widget and customize it
						var wid = this$1.add_widget(config);
						wid.customize(this$1.options);

						// Put back the new widget if required
						if (this$1.widgets_list.length < max) {
							this$1.setup_new_widget();
						}
					},
				});
			}
		}

		on_delete(name, setup_new) {
			this.widgets_list = this.widgets_list.filter(function (wid) { return name != wid.name; });
			delete this.widgets_dict[name];
			this.update_widget_order();

			if (!this.new_widget && setup_new) { this.setup_new_widget(); }
		}

		update_widget_order() {
			var this$1 = this;

			this.widget_order = [];
			this.body.children().each(function (index, element) {
				var name = element.dataset.widgetName;
				if (name) {
					this$1.widget_order.push(name);
				}
			});
		}

		setup_sortable() {
			var this$1 = this;

			var container = this.body[0];
			this.sortable = new Sortable(container, {
				animation: 150,
				handle: ".drag-handle",
				onEnd: function () { return this$1.update_widget_order(); },
			});
		}

		get_widget_config() {
			this.update_widget_order();
			var prepared_dict = {};

			this.widgets_list.forEach(function (wid) {
				var config = wid.get_config();
				var name = config.docname ? config.docname : config.name;
				prepared_dict[name] = config;
			});

			return {
				order: this.widget_order,
				widgets: prepared_dict,
			};
		}
	}

	frappe.widget.WidgetGroup = WidgetGroup;

	frappe.templates['sort_selector'] = '<div class="sort-selector">  <div class="btn-group">   <button class="btn btn-default btn-sm btn-order"    data-value="{{ sort_order }}"    title="{{ sort_order==="desc" ? "descending" : "ascending" }}">    <span class="sort-order">     <svg class="icon icon-sm">      <use xlink:href="#icon-{{ sort_order==="desc" ? "sort-descending" : "sort-ascending" }}"></use>     </svg>    </span>   </button>   <button type="button" class="btn btn-default btn-sm sort-selector-button" data-toggle="dropdown">    <span class="dropdown-text">{{ __(sort_by_label) }}</span>    <ul class="dropdown-menu dropdown-menu-right">     {% for value in options %}     <li>      <a class="dropdown-item option" data-value="{{ value.fieldname }}">       {{ __(value.label) }}      </a>     </li>     {% endfor %}    </ul>   </button>  </div> </div> ';

	frappe.ui.SortSelector = Class.extend({
		// parent:
		// change:
		// args:
		//		options: {fieldname:, label:}
		//		sort_by:
		//		sort_by_label:
		//		sort_order:
		//		doctype: (optional)
		init: function(opts) {
			$.extend(this, opts);
			this.labels = {};
			this.make();
		},
		make: function() {
			this.prepare_args();
			this.parent.find('.sort-selector').remove();
			this.wrapper = $(frappe.render_template('sort_selector', this.args)).appendTo(this.parent);
			this.bind_events();
		},
		bind_events: function() {
			var me = this;

			// order
			this.wrapper.find('.btn-order').on('click', function() {
				var btn = $(this);
				var order = $(this).attr('data-value') === 'desc' ? 'asc' : 'desc';
				var title = $(this).attr('data-value' )=== 'desc' ? 'ascending' : 'descending';

				btn.attr('data-value', order);
				btn.attr('title', title);
				me.sort_order = order;
				var icon_name = order === 'asc'? 'sort-ascending' : 'sort-descending';
				btn.find('.sort-order').html(frappe.utils.icon(icon_name, 'sm'));
				(me.onchange || me.change)(me.sort_by, me.sort_order);
			});

			// select field
			this.wrapper.find('.dropdown-menu a.option').on('click', function() {
				me.sort_by = $(this).attr('data-value');
				me.wrapper.find('.dropdown-text').html($(this).html());
				(me.onchange || me.change)(me.sort_by, me.sort_order);
			});

		},
		prepare_args: function() {
			var me = this;
			if(!this.args) {
				this.args = {};
			}

			// args as string
			if(this.args && typeof this.args === 'string') {
				var order_by = this.args;
				this.args = {};

				if (order_by.includes('`.`')) {
					// scrub table name (separated by dot), like `tabTime Log`.`modified` desc`
					order_by = order_by.split('.')[1];
				}

				var parts = order_by.split(' ');
				if (parts.length === 2) {
					var fieldname = strip(parts[0], '`');

					this.args.sort_by = fieldname;
					this.args.sort_order = parts[1];
				}
			}

			if(this.args.options) {
				this.args.options.forEach(function(o) {
					me.labels[o.fieldname] = o.label;
				});
			}

			this.setup_from_doctype();

			// if label is missing, add from options
			if(this.args.sort_by && !this.args.sort_by_label) {
				this.args.options.every(function(o) {
					if(o.fieldname===me.args.sort_by) {
						me.args.sort_by_label = o.label;
						return false;
					}
					return true;
				});
			}

		},
		setup_from_doctype: function() {
			var me = this;
			var meta = frappe.get_meta(this.doctype);
			if (!meta) { return; }

			var ref = this.get_meta_sort_field();
			var meta_sort_field = ref.meta_sort_field;
			var meta_sort_order = ref.meta_sort_order;

			if(!this.args.sort_by) {
				if(meta_sort_field) {
					this.args.sort_by = meta_sort_field;
					this.args.sort_order = meta_sort_order;
				} else {
					// default
					this.args.sort_by = 'modified';
					this.args.sort_order = 'desc';
				}
			}

			if(!this.args.sort_by_label) {
				this.args.sort_by_label = this.get_label(this.args.sort_by);
			}

			if(!this.args.options) {
				// default options
				var _options = [
					{'fieldname': 'modified'}
				];

				// title field
				if(meta.title_field) {
					_options.push({'fieldname': meta.title_field});
				}

				// bold or mandatory
				meta.fields.forEach(function(df) {
					if(df.mandatory || df.bold) {
						_options.push({fieldname: df.fieldname, label: df.label});
					}
				});

				// meta sort field
				if(meta_sort_field) { _options.push({ 'fieldname': meta_sort_field }); }

				// more default options
				_options.push(
					{'fieldname': 'name'},
					{'fieldname': 'creation'},
					{'fieldname': 'idx'}
				);

				// de-duplicate
				this.args.options = _options.uniqBy(function(obj) {
					return obj.fieldname;
				});

				// add missing labels
				this.args.options.forEach(function(o) {
					if(!o.label) {
						o.label = me.get_label(o.fieldname);
					}
				});
			}

			// set default
			this.sort_by = this.args.sort_by;
			this.sort_order = this.args.sort_order;
		},
		get_meta_sort_field: function() {
			var meta = frappe.get_meta(this.doctype);

			if (!meta) {
				return {
					meta_sort_field: null,
					meta_sort_order: null
				}
			}

			if(meta.sort_field && meta.sort_field.includes(',')) {
				var parts = meta.sort_field.split(',')[0].split(' ');
				return {
					meta_sort_field: parts[0],
					meta_sort_order: parts[1]
				}
			} else {
				return {
					meta_sort_field: meta.sort_field || 'modified',
					meta_sort_order: meta.sort_order ? meta.sort_order.toLowerCase() : ''
				}
			}
		},
		get_label: function(fieldname) {
			if(fieldname==='idx') {
				return __("Most Used");
			} else {
				return this.labels[fieldname]
					|| frappe.meta.get_label(this.doctype, fieldname);
			}
		},
		get_sql_string: function() {
			// build string like `tabTask`.`subject` desc
			return '`tab' + this.doctype + '`.`' + this.sort_by + '` ' +  this.sort_order;
		}
	});

	frappe.templates['change_log'] = '{% for (var i=0, l=change_log.length; i < l; i++) {     var app_info = change_log[i]; %}  {% if (i > 0) { %} <hr> {% } %}  <div class="text-left app-change-log">   <h2 style="margin-top: 10px;">             {{ app_info.title }}    <small>{{ __("updated to {0}", [app_info.version]) }}</small>   </h2>   <div class="app-change-log-body">   {% for (var x=0, y=app_info.change_log.length; x < y; x++) {             var version_info = app_info.change_log[x];             if(version_info) { %}        <p>{{ frappe.markdown(version_info[1]) }}</p>       {% }         } %}      </div>  </div> {% } %} ';

	frappe.templates['workspace_loading_skeleton'] = '<div class="workspace-skeleton">  <div class="widget-group">   <div class="widget-group-head skeleton-header">    <div class="widget-group-title skeleton-card"></div>   </div>   <div class="widget-group-body grid-col-3">    <div class="widget shortcut-widget-box skeleton-card"></div>    <div class="widget shortcut-widget-box skeleton-card"></div>    <div class="widget shortcut-widget-box skeleton-card"></div>   </div>  </div>  <div class="widget-group skeleton-body">   <div class="widget-group-head skeleton-header">    <div class="widget-group-title skeleton-card"></div>   </div>   <div class="widget-group-body grid-col-3">    <div class="widget links-widget-box skeleton-card"></div>    <div class="widget links-widget-box skeleton-card"></div>    <div class="widget links-widget-box skeleton-card"></div>    <div class="widget links-widget-box skeleton-card"></div>    <div class="widget links-widget-box skeleton-card"></div>   </div>  </div> </div> ';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt
	/* eslint-disable no-console */

	// __('Modules') __('Domains') __('Places') __('Administration') # for translation, don't remove

	frappe.start_app = function() {
		if (!frappe.Application)
			{ return; }
		frappe.assets.check();
		frappe.provide('frappe.app');
		frappe.provide('frappe.desk');
		frappe.app = new frappe.Application();
	};

	$(document).ready(function() {
		if (!frappe.utils.supportsES6) {
			frappe.msgprint({
				indicator: 'red',
				title: __('Browser not supported'),
				message: __('Some of the features might not work in your browser. Please update your browser to the latest version.')
			});
		}
		frappe.start_app();
	});

	frappe.Application = Class.extend({
		init: function() {
			this.startup();
		},

		startup: function() {
			var this$1 = this;

			frappe.socketio.init();
			frappe.model.init();

			if(frappe.boot.status==='failed') {
				frappe.msgprint({
					message: frappe.boot.error,
					title: __('Session Start Failed'),
					indicator: 'red',
				});
				throw 'boot failed';
			}

			this.setup_frappe_vue();
			this.load_bootinfo();
			this.load_user_permissions();
			this.make_nav_bar();
			this.set_favicon();
			this.setup_analytics();
			this.set_fullwidth_if_enabled();
			this.add_browser_class();
			this.setup_energy_point_listeners();
			this.setup_copy_doc_listener();

			frappe.ui.keys.setup();

			frappe.ui.keys.add_shortcut({
				shortcut: 'shift+ctrl+g',
				description: __('Switch Theme'),
				action: function () {
					frappe.theme_switcher = new frappe.ui.ThemeSwitcher();
					frappe.theme_switcher.show();
				}
			});

			// page container
			this.make_page_container();
			this.set_route();

			// trigger app startup
			$(document).trigger('startup');

			$(document).trigger('app_ready');

			if (frappe.boot.messages) {
				frappe.msgprint(frappe.boot.messages);
			}

			if (frappe.user_roles.includes('System Manager')) {
				// delayed following requests to make boot faster
				setTimeout(function () {
					this$1.show_change_log();
					this$1.show_update_available();
				}, 1000);
			}

			if (!frappe.boot.developer_mode) {
				var console_security_message = __("Using this console may allow attackers to impersonate you and steal your information. Do not enter or paste code that you do not understand.");
				console.log(
					("%c" + console_security_message),
					"font-size: large"
				);
			}

			this.show_notes();

			if (frappe.ui.startup_setup_dialog && !frappe.boot.setup_complete) {
				frappe.ui.startup_setup_dialog.pre_show();
				frappe.ui.startup_setup_dialog.show();
			}

			frappe.realtime.on("version-update", function() {
				var dialog = frappe.msgprint({
					message:__("The application has been updated to a new version, please refresh this page"),
					indicator: 'green',
					title: __('Version Updated')
				});
				dialog.set_primary_action(__("Refresh"), function() {
					location.reload(true);
				});
				dialog.get_close_btn().toggle(false);
			});

			// listen to build errors
			this.setup_build_error_listener();

			if (frappe.sys_defaults.email_user_password) {
				var email_list =  frappe.sys_defaults.email_user_password.split(',');
				for (var u in email_list) {
					if (email_list[u]===frappe.user.name) {
						this.set_password(email_list[u]);
					}
				}
			}

			// REDESIGN-TODO: Fix preview popovers
			this.link_preview = new frappe.ui.LinkPreview();

			if (!frappe.boot.developer_mode) {
				setInterval(function() {
					frappe.call({
						method: 'frappe.core.page.background_jobs.background_jobs.get_scheduler_status',
						callback: function(r) {
							if (r.message[0] == __("Inactive")) {
								frappe.call('frappe.utils.scheduler.activate_scheduler');
							}
						}
					});
				}, 300000); // check every 5 minutes

				if (frappe.user.has_role("System Manager")) {
					setInterval(function() {
						frappe.call({
							method: 'frappe.core.doctype.log_settings.log_settings.has_unseen_error_log',
							args: {
								user: frappe.session.user
							},
							callback: function(r) {
								if (r.message.show_alert) {
									frappe.show_alert({
										indicator: 'red',
										message: r.message.message
									});
								}
							}
						});
					}, 600000); // check every 10 minutes
				}
			}
		},

		set_route: function set_route() {
			frappe.flags.setting_original_route = true;
			if (frappe.boot && localStorage.getItem("session_last_route")) {
				frappe.set_route(localStorage.getItem("session_last_route"));
				localStorage.removeItem("session_last_route");
			} else {
				// route to home page
				frappe.router.route();
			}
			frappe.after_ajax(function () { return frappe.flags.setting_original_route = false; });
			frappe.router.on('change', function () {
				$(".tooltip").hide();
			});
		},

		setup_frappe_vue: function setup_frappe_vue() {
			Vue.prototype.__ = window.__;
			Vue.prototype.frappe = window.frappe;
		},

		set_password: function(user) {
			var me=this;
			frappe.call({
				method: 'frappe.core.doctype.user.user.get_email_awaiting',
				args: {
					"user": user
				},
				callback: function(email_account) {
					email_account = email_account["message"];
					if (email_account) {
						var i = 0;
						if (i < email_account.length) {
							me.email_password_prompt( email_account, user, i);
						}
					}
				}
			});
		},

		email_password_prompt: function(email_account,user,i) {
			var me = this;
			var d = new frappe.ui.Dialog({
				title: __('Password missing in Email Account'),
				fields: [
					{
						'fieldname': 'password',
						'fieldtype': 'Password',
						'label': __('Please enter the password for: <b>{0}</b>', [email_account[i]["email_id"]]),
						'reqd': 1
					},
					{
						"fieldname": "submit",
						"fieldtype": "Button",
						"label": __("Submit")
					}
				]
			});
			d.get_input("submit").on("click", function() {
				//setup spinner
				d.hide();
				var s = new frappe.ui.Dialog({
					title: __("Checking one moment"),
					fields: [{
						"fieldtype": "HTML",
						"fieldname": "checking"
					}]
				});
				s.fields_dict.checking.$wrapper.html('<i class="fa fa-spinner fa-spin fa-4x"></i>');
				s.show();
				frappe.call({
					method: 'frappe.email.doctype.email_account.email_account.set_email_password',
					args: {
						"email_account": email_account[i]["email_account"],
						"user": user,
						"password": d.get_value("password")
					},
					callback: function(passed) {
						s.hide();
						d.hide();//hide waiting indication
						if (!passed["message"]) {
							frappe.show_alert({message: __("Login Failed please try again"), indicator: 'error'}, 5);
							me.email_password_prompt(email_account, user, i);
						} else {
							if (i + 1 < email_account.length) {
								i = i + 1;
								me.email_password_prompt(email_account, user, i);
							}
						}

					}
				});
			});
			d.show();
		},
		load_bootinfo: function() {
			if(frappe.boot) {
				this.setup_workspaces();
				frappe.model.sync(frappe.boot.docs);
				$.extend(frappe._messages, frappe.boot.__messages);
				this.check_metadata_cache_status();
				this.set_globals();
				this.sync_pages();
				frappe.router.setup();
				moment.locale("en");
				moment.user_utc_offset = moment().utcOffset();
				if(frappe.boot.timezone_info) {
					moment.tz.add(frappe.boot.timezone_info);
				}
				if(frappe.boot.print_css) {
					frappe.dom.set_style(frappe.boot.print_css, "print-style");
				}
				frappe.user.name = frappe.boot.user.name;
				frappe.router.setup();
			} else {
				this.set_as_guest();
			}
		},

		setup_workspaces: function setup_workspaces() {
			frappe.modules = {};
			frappe.workspaces = {};
			for (var i = 0, list = frappe.boot.allowed_workspaces || []; i < list.length; i += 1) {
				var page = list[i];

				frappe.modules[page.module]=page;
				frappe.workspaces[frappe.router.slug(page.name)] = page;
			}
			if (!frappe.workspaces['home']) {
				// default workspace is settings for Frappe
				frappe.workspaces['home'] = frappe.workspaces[Object.keys(frappe.workspaces)[0]];
			}
		},

		load_user_permissions: function() {
			frappe.defaults.update_user_permissions();

			frappe.realtime.on('update_user_permissions', frappe.utils.debounce(function () {
				frappe.defaults.update_user_permissions();
			}, 500));
		},

		check_metadata_cache_status: function() {
			if(frappe.boot.metadata_version != localStorage.metadata_version) {
				frappe.assets.clear_local_storage();
				frappe.assets.init_local_storage();
			}
		},

		set_globals: function() {
			frappe.session.user = frappe.boot.user.name;
			frappe.session.logged_in_user = frappe.boot.user.name;
			frappe.session.user_email = frappe.boot.user.email;
			frappe.session.user_fullname = frappe.user_info().fullname;

			frappe.user_defaults = frappe.boot.user.defaults;
			frappe.user_roles = frappe.boot.user.roles;
			frappe.sys_defaults = frappe.boot.sysdefaults;

			frappe.ui.py_date_format = frappe.boot.sysdefaults.date_format.replace('dd', '%d').replace('mm', '%m').replace('yyyy', '%Y');
			frappe.boot.user.last_selected_values = {};

			// Proxy for user globals
			Object.defineProperties(window, {
				'user': {
					get: function() {
						console.warn('Please use `frappe.session.user` instead of `user`. It will be deprecated soon.');
						return frappe.session.user;
					}
				},
				'user_fullname': {
					get: function() {
						console.warn('Please use `frappe.session.user_fullname` instead of `user_fullname`. It will be deprecated soon.');
						return frappe.session.user;
					}
				},
				'user_email': {
					get: function() {
						console.warn('Please use `frappe.session.user_email` instead of `user_email`. It will be deprecated soon.');
						return frappe.session.user_email;
					}
				},
				'user_defaults': {
					get: function() {
						console.warn('Please use `frappe.user_defaults` instead of `user_defaults`. It will be deprecated soon.');
						return frappe.user_defaults;
					}
				},
				'roles': {
					get: function() {
						console.warn('Please use `frappe.user_roles` instead of `roles`. It will be deprecated soon.');
						return frappe.user_roles;
					}
				},
				'sys_defaults': {
					get: function() {
						console.warn('Please use `frappe.sys_defaults` instead of `sys_defaults`. It will be deprecated soon.');
						return frappe.user_roles;
					}
				}
			});
		},
		sync_pages: function() {
			// clear cached pages if timestamp is not found
			if(localStorage["page_info"]) {
				frappe.boot.allowed_pages = [];
				var page_info = JSON.parse(localStorage["page_info"]);
				$.each(frappe.boot.page_info, function(name, p) {
					if(!page_info[name] || (page_info[name].modified != p.modified)) {
						delete localStorage["_page:" + name];
					}
					frappe.boot.allowed_pages.push(name);
				});
			} else {
				frappe.boot.allowed_pages = Object.keys(frappe.boot.page_info);
			}
			localStorage["page_info"] = JSON.stringify(frappe.boot.page_info);
		},
		set_as_guest: function() {
			frappe.session.user = 'Guest';
			frappe.session.user_email = '';
			frappe.session.user_fullname = 'Guest';

			frappe.user_defaults = {};
			frappe.user_roles = ['Guest'];
			frappe.sys_defaults = {};
		},
		make_page_container: function() {
			if ($("#body").length) {
				$(".splash").remove();
				frappe.temp_container = $("<div id='temp-container' style='display: none;'>")
					.appendTo("body");
				frappe.container = new frappe.views.Container();
			}
		},
		make_nav_bar: function() {
			// toolbar
			if(frappe.boot && frappe.boot.home_page!=='setup-wizard') {
				frappe.frappe_toolbar = new frappe.ui.toolbar.Toolbar();
			}

		},
		logout: function() {
			var me = this;
			me.logged_out = true;
			return frappe.call({
				method:'logout',
				callback: function(r) {
					if(r.exc) {
						return;
					}
					me.redirect_to_login();
				}
			});
		},
		handle_session_expired: function() {
			if(!frappe.app.session_expired_dialog) {
				var dialog = new frappe.ui.Dialog({
					title: __('Session Expired'),
					keep_open: true,
					fields: [
						{ fieldtype:'Password', fieldname:'password',
							label: __('Please Enter Your Password to Continue') } ],
					onhide: function () {
						if (!dialog.logged_in) {
							frappe.app.redirect_to_login();
						}
					}
				});
				dialog.set_primary_action(__('Login'), function () {
					dialog.set_message(__('Authenticating...'));
					frappe.call({
						method: 'login',
						args: {
							usr: frappe.session.user,
							pwd: dialog.get_values().password
						},
						callback: function (r) {
							if (r.message==='Logged In') {
								dialog.logged_in = true;

								// revert backdrop
								$('.modal-backdrop').css({
									'opacity': '',
									'background-color': '#334143'
								});
							}
							dialog.hide();
						},
						statusCode: function () {
							dialog.hide();
						}
					});
				});
				frappe.app.session_expired_dialog = dialog;
			}
			if(!frappe.app.session_expired_dialog.display) {
				frappe.app.session_expired_dialog.show();
				// add backdrop
				$('.modal-backdrop').css({
					'opacity': 1,
					'background-color': '#4B4C9D'
				});
			}
		},
		redirect_to_login: function() {
			window.location.href = '/';
		},
		set_favicon: function() {
			var link = $('link[type="image/x-icon"]').remove().attr("href");
			$('<link rel="shortcut icon" href="' + link + '" type="image/x-icon">').appendTo("head");
			$('<link rel="icon" href="' + link + '" type="image/x-icon">').appendTo("head");
		},
		trigger_primary_action: function() {
			// to trigger change event on active input before triggering primary action
			$(document.activeElement).blur();
			// wait for possible JS validations triggered after blur (it might change primary button)
			setTimeout(function () {
				if (window.cur_dialog && cur_dialog.display) {
					// trigger primary
					cur_dialog.get_primary_btn().trigger("click");
				} else if (cur_frm && cur_frm.page.btn_primary.is(':visible')) {
					cur_frm.page.btn_primary.trigger('click');
				} else if (frappe.container.page.save_action) {
					frappe.container.page.save_action();
				}
			}, 100);
		},

		show_change_log: function() {
			var me = this;
			var change_log = frappe.boot.change_log;

			// frappe.boot.change_log = [{
			// 	"change_log": [
			// 		[<version>, <change_log in markdown>],
			// 		[<version>, <change_log in markdown>],
			// 	],
			// 	"description": "ERP made simple",
			// 	"title": "ERPNext",
			// 	"version": "12.2.0"
			// }];

			if (!Array.isArray(change_log) || !change_log.length || window.Cypress) {
				return;
			}

			// Iterate over changelog
			var change_log_dialog = frappe.msgprint({
				message: frappe.render_template("change_log", {"change_log": change_log}),
				title: __("Updated To A New Version 🎉"),
				wide: true,
			});
			change_log_dialog.keep_open = true;
			change_log_dialog.custom_onhide = function() {
				frappe.call({
					"method": "frappe.utils.change_log.update_last_known_versions"
				});
				me.show_notes();
			};
		},

		show_update_available: function () {
			frappe.call({
				"method": "frappe.utils.change_log.show_update_popup"
			});
		},

		setup_analytics: function() {
			if(window.mixpanel) {
				window.mixpanel.identify(frappe.session.user);
				window.mixpanel.people.set({
					"$first_name": frappe.boot.user.first_name,
					"$last_name": frappe.boot.user.last_name,
					"$created": frappe.boot.user.creation,
					"$email": frappe.session.user
				});
			}
		},

		add_browser_class: function add_browser_class() {
			$('html').addClass(frappe.utils.get_browser().name.toLowerCase());
		},

		set_fullwidth_if_enabled: function set_fullwidth_if_enabled() {
			frappe.ui.toolbar.set_fullwidth_if_enabled();
		},

		show_notes: function() {
			var me = this;
			if(frappe.boot.notes.length) {
				frappe.boot.notes.forEach(function(note) {
					if(!note.seen || note.notify_on_every_login) {
						var d = frappe.msgprint({message:note.content, title:note.title});
						d.keep_open = true;
						d.custom_onhide = function() {
							note.seen = true;

							// Mark note as read if the Notify On Every Login flag is not set
							if (!note.notify_on_every_login) {
								frappe.call({
									method: "frappe.desk.doctype.note.note.mark_as_seen",
									args: {
										note: note.name
									}
								});
							}

							// next note
							me.show_notes();

						};
					}
				});
			}
		},

		setup_build_error_listener: function setup_build_error_listener() {
			if (frappe.boot.developer_mode) {
				frappe.realtime.on('build_error', function (data) {
					console.log(data);
				});
			}
		},

		setup_energy_point_listeners: function setup_energy_point_listeners() {
			frappe.realtime.on('energy_point_alert', function (message) {
				frappe.show_alert(message);
			});
		},

		setup_copy_doc_listener: function setup_copy_doc_listener() {
			$('body').on('paste', function (e) {
				try {
					var pasted_data = frappe.utils.get_clipboard_data(e);
					var doc = JSON.parse(pasted_data);
					if (doc.doctype) {
						e.preventDefault();
						var sleep = function (time) {
							return new Promise(function (resolve) { return setTimeout(resolve, time); });
						};

						frappe.dom.freeze(__('Creating {0}', [doc.doctype]) + '...');
						// to avoid abrupt UX
						// wait for activity feedback
						sleep(500).then(function () {
							var res = frappe.model.with_doctype(doc.doctype, function () {
								var newdoc = frappe.model.copy_doc(doc);
								newdoc.__newname = doc.name;
								delete doc.name;
								newdoc.idx = null;
								newdoc.__run_link_triggers = false;
								frappe.set_route('Form', newdoc.doctype, newdoc.name);
								frappe.dom.unfreeze();
							});
							res && res.fail(frappe.dom.unfreeze);
						});
					}
				} catch (e) {
					//
				}
			});
		}
	});

	frappe.get_module = function(m, default_module) {
		var module = frappe.modules[m] || default_module;
		if (!module) {
			return;
		}

		if(module._setup) {
			return module;
		}

		if(!module.label) {
			module.label = m;
		}

		if(!module._label) {
			module._label = __(module.label);
		}

		module._setup = true;

		return module;
	};

	frappe.provide('frappe.utils');

	function get_url_arg(name) {
		return get_query_params()[name] || "";
	}

	function get_query_string(url) {
		if(url.includes("?")) {
			return url.slice(url.indexOf("?")+1);
		}else {
			return "";
		}
	}

	function get_query_params(query_string) {
		var query_params = {};
		if (!query_string) {
			query_string = location.search.substring(1);
		}

		var query_list = query_string.split("&");
		for (var i=0, l=query_list.length; i < l; i++ ){
			var pair = query_list[i].split(/=(.+)/);
			var key = pair[0];
			if (!key) {
				continue;
			}

			var value = pair[1];
			if (typeof value === "string") {
				value = value.replace(/\+/g, "%20");
				try {
					value = decodeURIComponent(value);
				} catch(e) {
					// if value contains %, it fails
				}
			}

			if (key in query_params) {
				if (typeof query_params[key] === "undefined") {
					query_params[key] = [];
				} else if (typeof query_params[key] === "string") {
					query_params[key] = [query_params[key]];
				}
				query_params[key].push(value);
			} else {
				query_params[key] = value;
			}
		}
		return query_params;
	}

	function make_query_string(obj, encode) {
		if ( encode === void 0 ) encode=true;

		var query_params = [];
		for (var key in obj) {
			var value = obj[key];
			if (value === undefined || value === '' || value === null) {
				continue;
			}
			if (typeof value === 'object') {
				value = JSON.stringify(value);
			}

			if (encode) {
				key = encodeURIComponent(key);
				value = encodeURIComponent(value);
			}

			query_params.push((key + "=" + value));
		}
		return '?' + query_params.join('&');
	}

	Object.assign(frappe.utils, {
		get_url_arg: get_url_arg,
		get_query_string: get_query_string,
		get_query_params: get_query_params,
		make_query_string: make_query_string
	});

	var fuse = createCommonjsModule(function (module, exports) {
	/*!
	 * Fuse.js v3.4.6 - Lightweight fuzzy-search (http://fusejs.io)
	 * 
	 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
	 * All Rights Reserved. Apache Software License 2.0
	 * 
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */
	!function(e,t){module.exports=t();}(commonjsGlobal,function(){return function(e){var t={};function n(r){if(t[r]){ return t[r].exports; }var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r});},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},n.t=function(e,t){if(1&t&&(e=n(e)),8&t){ return e; }if(4&t&&"object"==typeof e&&e&&e.__esModule){ return e; }var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e){ for(var o in e){ n.d(r,o,function(t){return e[t]}.bind(null,o)); } }return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)};},function(e,t,n){function r(e){return (r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t)){ throw new TypeError("Cannot call a class as a function") }}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t);}var t,n;return t=e,(n=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&"number"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize){ for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1){ t.push(new i(n[r],this.options)); } }return {tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if("string"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1){ this._analyze({key:"",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t}); }return {weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1){ for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if("string"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1){ throw new Error("Key weight has to be > 0 and <= 1"); }d=d.name;}else { s[d]={weight:1}; }this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});} }return {weights:s,results:o}}},{key:"_analyze",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if("string"==typeof i){this._log("\nKey: ".concat(""===n?"-":n));var S=f.search(i);if(this._log('Full text: "'.concat(i,'", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\nPattern: "'.concat(_.pattern,'"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: "'.concat(A,'", score: ').concat(I[A]));}L&&(k+=1);}m=b[0];for(var O=b.length,j=1;j<O;j+=1){ m+=b[j]; }m/=O,this._log("Token score average:",m);}var P=S.score;m>-1&&(P=(P+m)/2),this._log("Score average:",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log("\nCheck Matches: ".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]));}}else if(s(i)){ for(var z=0,E=i.length;z<E;z+=1){ this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f}); } }}}},{key:"_computeScore",value:function(e,t){this._log("\n\nComputing score:\n");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l);}t[n].score=1===s?a:s,this._log(t[n]);}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn);}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===r(t)&&null!==t){if(-1!==n.indexOf(t)){ return; }n.push(t);}return t})),n=null;}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a);}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score;});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1){ o[h](s,c); }t.push(c);}else { t.push(s.item); }}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments);}}])&&o(t.prototype,n),e}();e.exports=c;},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t)){ throw new TypeError("Cannot call a class as a function") }}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern));}var t,n;return t=e,(n=[{key:"search",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e){ return {isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]}; }var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n){ return o(e,this.pattern,r); }var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),e}();e.exports=s;},function(e,t){var n=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,"\\$&").replace(r,"|")),i=e.match(o),a=!!i,s=[];if(a){ for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1]);} }return {score:a?.5:1,isMatch:a,matchedIndices:s}};},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1){ x[b]=0; }if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m);}}k=-1;for(var L=[],w=1,A=S+y,C=1<<(S<=31?S-1:30),I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O);}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g){ break; }P=Math.max(1,2*g-k);}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m){ break; }L=T;}return {isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}};},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l};},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1);}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n};},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1){ t[e.charAt(r)]=0; }for(var o=0;o<n;o+=1){ t[e.charAt(o)]|=1<<n-o-1; }return t};},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf("."),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c){ if(s||"string"!=typeof c&&"number"!=typeof c){ if(r(c)){ for(var h=0,l=c.length;h<l;h+=1){ e(c[h],s,o); } }else { s&&e(c,s,o); } }else { o.push(c.toString()); } }}else { o.push(t); }return o}(e,t,[])};}])});
	});

	var Fuse = unwrapExports(fuse);
	var fuse_1 = fuse.Fuse;

	var hyper_min = createCommonjsModule(function (module) {
	!function(){function e(){}function t(t,n){
	var arguments$1 = arguments;
	var o,r,i,l,a=W;for(l=arguments.length;l-- >2;){ S.push(arguments$1[l]); }n&&null!=n.children&&(S.length||S.push(n.children),delete n.children);while(S.length){ if((r=S.pop())&&void 0!==r.pop){ for(l=r.length;l--;){ S.push(r[l]); } }else{ "boolean"==typeof r&&(r=null),(i="function"!=typeof t)&&(null==r?r="":"number"==typeof r?r+="":"string"!=typeof r&&(i=!1)),i&&o?a[a.length-1]+=r:a===W?a=[r]:a.push(r),o=i; } }var _=new e;return _.nodeName=t,_.children=a,_.attributes=null==n?void 0:n,_.key=null==n?void 0:n.key,_}function n(e,t){for(var n in t){ e[n]=t[n]; }return e}function o(e){!e.__d&&(e.__d=!0)&&1==A.push(e)&&(V)(r);}function r(){var e,t=A;A=[];while(e=t.pop()){ e.__d&&N(e); }}function i(e,t,n){return "string"==typeof t||"number"==typeof t?void 0!==e.splitText:"string"==typeof t.nodeName?!e._componentConstructor&&l(e,t.nodeName):n||e._componentConstructor===t.nodeName}function l(e,t){return e.__n===t||e.nodeName.toLowerCase()===t.toLowerCase()}function a(e){var t=n({},e.attributes);t.children=e.children;var o=e.nodeName.defaultProps;if(void 0!==o){ for(var r in o){ void 0===t[r]&&(t[r]=o[r]); } }return t}function _(e,t){var n=t?document.createElementNS("http://www.w3.org/2000/svg",e):document.createElement(e);return n.__n=e,n}function u(e){var t=e.parentNode;t&&t.removeChild(e);}function p(e,t,n,o,r){if("className"===t&&(t="class"),"key"===t);else if("ref"===t){ n&&n(null),o&&o(e); }else if("class"!==t||r){ if("style"===t){if(o&&"string"!=typeof o&&"string"!=typeof n||(e.style.cssText=o||""),o&&"object"==typeof o){if("string"!=typeof n){ for(var i in n){ i in o||(e.style[i]=""); } }for(var i in o){ e.style[i]="number"==typeof o[i]&&!1===P.test(i)?o[i]+"px":o[i]; }}}else if("html"===t){ o&&(e.innerHTML=o); }else if("o"==t[0]&&"n"==t[1]){var l=t!==(t=t.replace(/Capture$/,""));t=t.toLowerCase().substring(2),o?n||e.addEventListener(t,s,l):e.removeEventListener(t,s,l),(e.__l||(e.__l={}))[t]=o;}else if("list"!==t&&"type"!==t&&!r&&t in e){ c(e,t,null==o?"":o),null!=o&&!1!==o||e.removeAttribute(t); }else{var a=r&&t!==(t=t.replace(/^xlink\:?/,""));null==o||!1===o?a?e.removeAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase()):e.removeAttribute(t):"function"!=typeof o&&(a?e.setAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase(),o):e.setAttribute(t,o));} }else { e.className=o||""; }}function c(e,t,n){try{e[t]=n;}catch(e){}}function s(e){return this.__l[e.type](e)}function f(){var e;while(e=E.pop()){ e.on_mounted&&e.on_mounted(); }}function d(e,t,n,o,r,i){D++||(H=null!=r&&void 0!==r.ownerSVGElement,R=null!=e&&!("__hyperattr_"in e));var l=h(e,t,n,o,i);return r&&l.parentNode!==r&&r.appendChild(l),--D||(R=!1,i||f()),l}function h(e,t,n,o,r){var i=e,a=H;if(null!=t&&"boolean"!=typeof t||(t=""),"string"==typeof t||"number"==typeof t){ return e&&void 0!==e.splitText&&e.parentNode&&(!e._component||r)?e.nodeValue!=t&&(e.nodeValue=t):(i=document.createTextNode(t),e&&(e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0))),i.__hyperattr_=!0,i; }var u=t.nodeName;if("function"==typeof u){ return k(e,t,n,o); }if(H="svg"===u||"foreignObject"!==u&&H,u+="",(!e||!l(e,u))&&(i=_(u,H),e)){while(e.firstChild){ i.appendChild(e.firstChild); }e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0);}var p=i.firstChild,c=i.__hyperattr_,s=t.children;if(null==c){c=i.__hyperattr_={};for(var f=i.attributes,d=f.length;d--;){ c[f[d].name]=f[d].value; }}return !R&&s&&1===s.length&&"string"==typeof s[0]&&null!=p&&void 0!==p.splitText&&null==p.nextSibling?p.nodeValue!=s[0]&&(p.nodeValue=s[0]):(s&&s.length||null!=p)&&v(i,s,n,o,R||null!=c.html),y(i,t.attributes,c),H=a,i}function v(e,t,n,o,r){var l,a,_,p,c,s=e.childNodes,f=[],d={},v=0,b=0,y=s.length,g=0,w=t?t.length:0;if(0!==y){ for(var C=0;C<y;C++){var x=s[C],N=x.__hyperattr_,k=w&&N?x._component?x._component.__k:N.key:null;null!=k?(v++,d[k]=x):(N||(void 0!==x.splitText?!r||x.nodeValue.trim():r))&&(f[g++]=x);} }if(0!==w){ for(var C=0;C<w;C++){p=t[C],c=null;var k=p.key;if(null!=k){ v&&void 0!==d[k]&&(c=d[k],d[k]=void 0,v--); }else if(!c&&b<g){ for(l=b;l<g;l++){ if(void 0!==f[l]&&i(a=f[l],p,r)){c=a,f[l]=void 0,l===g-1&&g--,l===b&&b++;break} } }c=h(c,p,n,o),_=s[C],c&&c!==e&&c!==_&&(null==_?e.appendChild(c):c===_.nextSibling?u(_):e.insertBefore(c,_));} }if(v){ for(var C in d){ void 0!==d[C]&&m(d[C],!1); } }while(b<=g){ void 0!==(c=f[g--])&&m(c,!1); }}function m(e,t){var n=e._component;n?U(n):(null!=e.__hyperattr_&&e.__hyperattr_.ref&&e.__hyperattr_.ref(null),!1!==t&&null!=e.__hyperattr_||u(e),b(e));}function b(e){e=e.lastChild;while(e){var t=e.previousSibling;m(e,!0),e=t;}}function y(e,t,n){var o;for(o in n){ t&&null!=t[o]||null==n[o]||p(e,o,n[o],n[o]=void 0,H); }for(o in t){ "children"===o||"innerHTML"===o||o in n&&t[o]===("value"===o||"checked"===o?e[o]:n[o])||p(e,o,n[o],n[o]=t[o],H); }}function g(e){var t=e.constructor.name;(j[t]||(j[t]=[])).push(e);}function w(e,t,n){var o,r=j[e.name];if(e.prototype&&e.prototype.render?(o=new e(t,n),L.call(o,t,n)):(o=new L(t,n),o.constructor=e,o.render=C),r){ for(var i=r.length;i--;){ if(r[i].constructor===e){o.__b=r[i].__b,r.splice(i,1);break} } }return o}function C(e,t,n){return this.constructor(e,n)}function x(e,t,n,r,i){e.__x||(e.__x=!0,(e.__r=t.ref)&&delete t.ref,(e.__k=t.key)&&delete t.key,!e.base||i?e.on_mount&&e.on_mount():e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r),r&&r!==e.context&&(e.__c||(e.__c=e.context),e.context=r),e.__p||(e.__p=e.props),e.props=t,e.__x=!1,0!==n&&(1!==n&&!1===M.syncComponentUpdates&&e.base?o(e):N(e,1,i)),e.__r&&e.__r(e));}function N(e,t,o,r){if(!e.__x){var i,l,_,u=e.props,p=e.state,c=e.context,s=e.__p||u,h=e.__s||p,v=e.__c||c,b=e.base,y=e.__b,g=b||y,C=e._component,k=!1;if(b&&(e.props=s,e.state=h,e.context=v,2!==t&&e.shouldComponentUpdate&&!1===e.shouldComponentUpdate(u,p,c)?k=!0:e.componentWillUpdate&&e.componentWillUpdate(u,p,c),e.props=u,e.state=p,e.context=c),e.__p=e.__s=e.__c=e.__b=null,e.__d=!1,!k){i=e.render(u,p,c),e.getChildContext&&(c=n(n({},c),e.getChildContext()));var L,T,S=i&&i.nodeName;if("function"==typeof S){var W=a(i);l=C,l&&l.constructor===S&&W.key==l.__k?x(l,W,1,c,!1):(L=l,e._component=l=w(S,W,c),l.__b=l.__b||y,l.__u=e,x(l,W,0,c,!1),N(l,1,o,!0)),T=l.base;}else { _=g,L=C,L&&(_=e._component=null),(g||1===t)&&(_&&(_._component=null),T=d(_,i,c,o||!b,g&&g.parentNode,!0)); }if(g&&T!==g&&l!==C){var P=g.parentNode;P&&T!==P&&(P.replaceChild(T,g),L||(g._component=null,m(g,!1)));}if(L&&U(L),e.base=T,T&&!r){var V=e,A=e;while(A=A.__u){ (V=A).base=T; }T._component=V,T._componentConstructor=V.constructor;}}if(!b||o?E.unshift(e):k||(e.on_updated&&e.on_updated(s,h,v),M.afterUpdate&&M.afterUpdate(e)),null!=e.__h){ while(e.__h.length){ e.__h.pop().call(e); } }D||r||f();}}function k(e,t,n,o){var r=e&&e._component,i=r,l=e,_=r&&e._componentConstructor===t.nodeName,u=_,p=a(t);while(r&&!u&&(r=r.__u)){ u=r.constructor===t.nodeName; }return r&&u&&(!o||r._component)?(x(r,p,3,n,o),e=r.base):(i&&!_&&(U(i),e=l=null),r=w(t.nodeName,p,n),e&&!r.__b&&(r.__b=e,l=null),x(r,p,1,n,o),e=r.base,l&&e!==l&&(l._component=null,m(l,!1))),e}function U(e){var t=e.base;e.__x=!0,e.componentWillUnmount&&e.componentWillUnmount(),e.base=null;var n=e._component;n?U(n):t&&(t.__hyperattr_&&t.__hyperattr_.ref&&t.__hyperattr_.ref(null),e.__b=t,u(t),g(e),b(t)),e.__r&&e.__r(null);}function L(e,t){this.__d=!0,this.context=t,this.props=e,this.state=this.state||{};}function T(e,t,n){return d(n,e,{},!1,t,!1)}var M={},S=[],W=[],P=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,V="function"==typeof Promise?Promise.resolve().then.bind(Promise.resolve()):setTimeout,A=[],E=[],D=0,H=!1,R=!1,j={};n(L.prototype,{set_state:function(e,t){var r=this.state;this.__s||(this.__s=n({},r)),n(r,"function"==typeof e?e(r,this.props):e),t&&(this.__h=this.__h||[]).push(t),o(this);},forceUpdate:function(e){e&&(this.__h=this.__h||[]).push(e),N(this,2);},render:function(){}});var I={h:t,Component:L,render:T};module.exports=I;}();
	});

	// Frappe Chat

	/* eslint semi: "never" */
	// Fuck semicolons - https://mislav.net/2010/05/semicolons

	// frappe extensions

	/**
	 * @description The base class for all Frappe Errors.
	 *
	 * @example
	 * try
	 *      throw new frappe.Error("foobar")
	 * catch (e)
	 *      console.log(e.name)
	 * // returns "FrappeError"
	 *
	 * @see  https://stackoverflow.com/a/32749533
	 * @todo Requires "transform-builtin-extend" for Babel 6
	 */
	frappe.Error = Error;
	// class extends Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = 'FrappeError'

	// 		if ( typeof Error.captureStackTrace === 'function' )
	// 			Error.captureStackTrace(this, this.constructor)
	// 		else
	// 			this.stack = (new Error(message)).stack
	// 	}
	// }

	/**
	 * @description TypeError
	 */
	frappe.TypeError  = TypeError;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = this.constructor.name
	// 	}
	// }

	/**
	 * @description ValueError
	 */
	frappe.ValueError = Error;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = this.constructor.name
	// 	}
	// }

	/**
	 * @description ImportError
	 */
	frappe.ImportError = Error;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name  = this.constructor.name
	// 	}
	// }

	// frappe.datetime
	frappe.provide('frappe.datetime');

	/**
	 * @description Frappe's datetime object. (Inspired by Python's datetime object).
	 *
	 * @example
	 * const datetime = new frappe.datetime.datetime()
	 */
	frappe.datetime.datetime = class {
		/**
		 * @description Frappe's datetime Class's constructor.
		 */
		constructor (instance, format) {
		if ( format === void 0 ) format = null;

			if ( typeof moment === 'undefined' )
				{ throw new frappe.ImportError("Moment.js not installed.") }

			this.moment = instance ? moment(instance, format) : moment();
		}

		/**
		 * @description Returns a formatted string of the datetime object.
		 */
		format (format) {
			if ( format === void 0 ) format = null;

			var  formatted = this.moment.format(format);
			return formatted
		}
	};

	/**
	 * @description Frappe's daterange object.
	 *
	 * @example
	 * const range = new frappe.datetime.range(frappe.datetime.now(), frappe.datetime.now())
	 * range.contains(frappe.datetime.now())
	 */
	frappe.datetime.range   = class {
		constructor (start, end) {
			if ( typeof moment === undefined )
				{ throw new frappe.ImportError("Moment.js not installed.") }

			this.start = start;
			this.end   = end;
		}

		contains (datetime) {
			var  contains = datetime.moment.isBetween(this.start.moment, this.end.moment);
			return contains
		}
	};

	/**
	 * @description Returns the current datetime.
	 *
	 * @example
	 * const datetime = new frappe.datetime.now()
	 */
	frappe.datetime.now   = function () { return new frappe.datetime.datetime(); };

	frappe.datetime.equal = function (a, b, type) {
		a = a.moment;
		b = b.moment;

		var equal = a.isSame(b, type);

		return equal
	};

	/**
	 * @description Compares two frappe.datetime.datetime objects.
	 *
	 * @param   {frappe.datetime.datetime} a - A frappe.datetime.datetime/moment object.
	 * @param   {frappe.datetime.datetime} b - A frappe.datetime.datetime/moment object.
	 *
	 * @returns {number} 0 (if a and b are equal), 1 (if a is before b), -1 (if a is after b).
	 *
	 * @example
	 * frappe.datetime.compare(frappe.datetime.now(), frappe.datetime.now())
	 * // returns 0
	 * const then = frappe.datetime.now()
	 *
	 * frappe.datetime.compare(then, frappe.datetime.now())
	 * // returns 1
	 */
	frappe.datetime.compare = function (a, b) {
		a = a.moment;
		b = b.moment;

		if ( a.isBefore(b) )
			{ return  1 }
		else
		if ( b.isBefore(a) )
			{ return -1 }
		else
			{ return  0 }
	};

	// frappe.quick_edit
	frappe.quick_edit      = function (doctype, docname, fn) {
		return new Promise(function (resolve) {
			frappe.model.with_doctype(doctype, function () {
				frappe.db.get_doc(doctype, docname).then(function (doc)  {
					var meta     = frappe.get_meta(doctype);
					var fields   = meta.fields;
					var required = fields.filter(function (f) { return f.reqd || f.bold && !f.read_only; });

					required.map(function (f) {
						if(f.fieldname == 'content' && doc.type == 'File') {
							f['read_only'] = 1;
						}
					});

					var dialog   = new frappe.ui.Dialog({
						title: __('Edit') + doctype + " (" + docname + ")",
						fields: required,
						action: {
							primary: {
								   label: __("Save"),
								onsubmit: function (values) {
									frappe.call('frappe.client.save',
										{ doc: Object.assign({}, {doctype: doctype, docname: docname}, doc, values) })
										  .then(function (r) {
											if ( fn )
												{ fn(r.message); }

											resolve(r.message);
										  });

									dialog.hide();
								}
							},
							secondary: {
								label: __("Discard")
							}
						}
					});
					dialog.set_values(doc);

					var $element = $(dialog.body);
					$element.append(("\n\t\t\t\t\t<div class=\"qe-fp\" style=\"padding-top: '15px'; padding-bottom: '15px'; padding-left: '7px'\">\n\t\t\t\t\t\t<button class=\"btn btn-default btn-sm\">\n\t\t\t\t\t\t\t" + (__("Edit in Full Page")) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t"));
					$element.find('.qe-fp').click(function () {
						dialog.hide();
						frappe.set_route('Form', doctype, docname);
					});

					dialog.show();
				});
			});
		})
	};

	// frappe._
	// frappe's utility namespace.
	frappe.provide('frappe._');

	// String Utilities

	/**
	 * @description Python-inspired format extension for string objects.
	 *
	 * @param  {string} string - A string with placeholders.
	 * @param  {object} object - An object with placeholder, value pairs.
	 *
	 * @return {string}        - The formatted string.
	 *
	 * @example
	 * frappe._.format('{foo} {bar}', { bar: 'foo', foo: 'bar' })
	 * // returns "bar foo"
	 */
	frappe._.format = function (string, object) {
		for (var key in object)
			{ string  = string.replace(("{" + key + "}"), object[key]); }

		return string
	};

	/**
	 * @description Fuzzy Search a given query within a dataset.
	 *
	 * @param  {string} query   - A query string.
	 * @param  {array}  dataset - A dataset to search within, can contain singletons or objects.
	 * @param  {object} options - Options as per fuze.js
	 *
	 * @return {array}          - The fuzzy matched index/object within the dataset.
	 *
	 * @example
	 * frappe._.fuzzy_search("foobar", ["foobar", "bartender"])
	 * // returns [0, 1]
	 *
	 * @see http://fusejs.io
	 */
	frappe._.fuzzy_search = function (query, dataset, options) {
		var DEFAULT     = {
					shouldSort: true,
					 threshold: 0.6,
					  location: 0,
					  distance: 100,
			minMatchCharLength: 1,
			  maxPatternLength: 32
		};
		options       = Object.assign({}, DEFAULT, options);

		var fuse    = new Fuse(dataset, options);
		var result  = fuse.search(query);

		return result
	};

	/**
	 * @description Pluralizes a given word.
	 *
	 * @param  {string} word  - The word to be pluralized.
	 * @param  {number} count - The count.
	 *
	 * @return {string}       - The pluralized string.
	 *
	 * @example
	 * frappe._.pluralize('member',  1)
	 * // returns "member"
	 * frappe._.pluralize('members', 0)
	 * // returns "members"
	 *
	 * @todo Handle more edge cases.
	 */
	frappe._.pluralize = function (word, count, suffix) {
		if ( count === void 0 ) count = 0;
		if ( suffix === void 0 ) suffix = 's';

		return ("" + word + (count === 1 ? '' : suffix));
	};

	/**
	 * @description Captializes a given string.
	 *
	 * @param   {word}  - The word to be capitalized.
	 *
	 * @return {string} - The capitalized word.
	 *
	 * @example
	 * frappe._.capitalize('foobar')
	 * // returns "Foobar"
	 */
	frappe._.capitalize = function (word) { return ("" + (word.charAt(0).toUpperCase()) + (word.slice(1))); };

	// Array Utilities

	/**
	 * @description Returns the first element of an array.
	 *
	 * @param   {array} array - The array.
	 *
	 * @returns - The first element of an array, undefined elsewise.
	 *
	 * @example
	 * frappe._.head([1, 2, 3])
	 * // returns 1
	 * frappe._.head([])
	 * // returns undefined
	 */
	frappe._.head = function (arr) { return frappe._.is_empty(arr) ? undefined : arr[0]; };

	/**
	 * @description Returns a copy of the given array (shallow).
	 *
	 * @param   {array} array - The array to be copied.
	 *
	 * @returns {array}       - The copied array.
	 *
	 * @example
	 * frappe._.copy_array(["foobar", "barfoo"])
	 * // returns ["foobar", "barfoo"]
	 *
	 * @todo Add optional deep copy.
	 */
	frappe._.copy_array = function (array) {
		if ( Array.isArray(array) )
			{ return array.slice() }
		else
			{ throw frappe.TypeError(("Expected Array, recieved " + (typeof array) + " instead.")) }
	};

	/**
	 * @description Check whether an array|string|object|jQuery is empty.
	 *
	 * @param   {any}     value - The value to be checked on.
	 *
	 * @returns {boolean}       - Returns if the object is empty.
	 *
	 * @example
	 * frappe._.is_empty([])      // returns true
	 * frappe._.is_empty(["foo"]) // returns false
	 *
	 * frappe._.is_empty("")      // returns true
	 * frappe._.is_empty("foo")   // returns false
	 *
	 * frappe._.is_empty({ })            // returns true
	 * frappe._.is_empty({ foo: "bar" }) // returns false
	 *
	 * frappe._.is_empty($('.papito'))   // returns false
	 *
	 * @todo Handle other cases.
	 */
	frappe._.is_empty = function (value) {
		var empty = false;

		if ( value === undefined || value === null )
			{ empty = true; }
		else
		if ( Array.isArray(value) || typeof value === 'string' || value instanceof $ )
			{ empty = value.length === 0; }
		else
		if ( typeof value === 'object' )
			{ empty = Object.keys(value).length === 0; }

		return empty
	};

	/**
	 * @description Converts a singleton to an array, if required.
	 *
	 * @param {object} item - An object
	 *
	 * @example
	 * frappe._.as_array("foo")
	 * // returns ["foo"]
	 *
	 * frappe._.as_array(["foo"])
	 * // returns ["foo"]
	 *
	 * @see https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-
	 */
	frappe._.as_array = function (item) { return Array.isArray(item) ? item : [item]; };

	/**
	 * @description Return a singleton if array contains a single element.
	 *
	 * @param   {array}        list - An array to squash.
	 *
	 * @returns {array|object}      - Returns an array if there's more than 1 object else the first object itself.
	 *
	 * @example
	 * frappe._.squash(["foo"])
	 * // returns "foo"
	 *
	 * frappe._.squash(["foo", "bar"])
	 * // returns ["foo", "bar"]
	 */
	frappe._.squash = function (list) { return Array.isArray(list) && list.length === 1 ? list[0] : list; };

	/**
	 * @description Returns true, if the current device is a mobile device.
	 *
	 * @example
	 * frappe._.is_mobile()
	 * // returns true|false
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
	 */
	frappe._.is_mobile = function () {
		var regex    = new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini", "i");
		var agent    = navigator.userAgent;
		var mobile   = regex.test(agent);

		return mobile
	};

	/**
	 * @description Removes falsey values from an array.
	 *
	 * @example
	 * frappe._.compact([1, 2, false, NaN, ''])
	 * // returns [1, 2]
	 */
	frappe._.compact   = function (array) { return array.filter(Boolean); };

	// extend utils to base.
	frappe.utils       = Object.assign({}, frappe.utils, frappe._);

	// frappe extensions

	// frappe.user extensions
	/**
	 * @description Returns the first name of a User.
	 *
	 * @param {string} user - User
	 *
	 * @returns The first name of the user.
	 *
	 * @example
	 * frappe.user.first_name("Rahul Malhotra")
	 * // returns "Rahul"
	 */
	frappe.provide('frappe.user');
	frappe.user.first_name = function (user) { return frappe._.head(frappe.user.full_name(user).split(" ")); };

	frappe.provide('frappe.ui.keycode');
	frappe.ui.keycode = { RETURN: 13 };

	/**
	 * @description Frappe's Store Class
	 */
	 // frappe.stores  - A registry for frappe stores.
	frappe.provide('frappe.stores');
	frappe.stores = [ ];
	frappe.Store  = class
	{
		/**
		 * @description Frappe's Store Class's constructor.
		 *
		 * @param {string} name - Name of the logger.
		 */
		constructor (name) {
			if ( typeof name !== 'string' )
				{ throw new frappe.TypeError(("Expected string for name, got " + (typeof name) + " instead.")) }
			this.name = name;
		}

		/**
		 * @description Get instance of frappe.Store (return registered one if declared).
		 *
		 * @param {string} name - Name of the store.
		 */
		static get (name) {
			if ( !(name in frappe.stores) )
				{ frappe.stores[name] = new frappe.Store(name); }
			return frappe.stores[name]
		}

		set (key, value) { localStorage.setItem(((this.name) + ":" + key), value); }
		get (key, value) { return localStorage.getItem(((this.name) + ":" + key)) }
	};

	// frappe.loggers - A registry for frappe loggers.
	frappe.provide('frappe.loggers');
	/**
	 * @description Frappe's Logger Class
	 *
	 * @example
	 * frappe.log       = frappe.Logger.get('foobar')
	 * frappe.log.level = frappe.Logger.DEBUG
	 *
	 * frappe.log.info('foobar')
	 * // prints '[timestamp] foobar: foobar'
	 */
	frappe.Logger = class {
		/**
		 * @description Frappe's Logger Class's constructor.
		 *
		 * @param {string} name - Name of the logger.
		 */
		constructor (name, level) {
			if ( typeof name !== 'string' )
				{ throw new frappe.TypeError(("Expected string for name, got " + (typeof name) + " instead.")) }

			this.name   = name;
			this.level  = level;

			if ( !this.level ) {
				if ( frappe.boot.developer_mode )
					{ this.level = frappe.Logger.ERROR; }
				else
					{ this.level = frappe.Logger.NOTSET; }
			}
			this.format = frappe.Logger.FORMAT;
		}

		/**
		 * @description Get instance of frappe.Logger (return registered one if declared).
		 *
		 * @param {string} name - Name of the logger.
		 */
		static get (name, level) {
			if ( !(name in frappe.loggers) )
				{ frappe.loggers[name] = new frappe.Logger(name, level); }
			return frappe.loggers[name]
		}

		debug (message) { this.log(message, frappe.Logger.DEBUG); }
		info  (message) { this.log(message, frappe.Logger.INFO);  }
		warn  (message) { this.log(message, frappe.Logger.WARN);  }
		error (message) { this.log(message, frappe.Logger.ERROR); }

		log (message, level) {
			var timestamp   = frappe.datetime.now();

			if ( level.value <= this.level.value ) {
				var format  = frappe._.format(this.format, {
					time: timestamp.format('HH:mm:ss'),
					name: this.name
				});
				console.log(("%c " + format + ":"), ("color: " + (level.color)), message);
			}
		}
	};

	frappe.Logger.DEBUG  = { value: 10, color: '#616161', name: 'DEBUG'  };
	frappe.Logger.INFO   = { value: 20, color: '#2196F3', name: 'INFO'   };
	frappe.Logger.WARN   = { value: 30, color: '#FFC107', name: 'WARN'   };
	frappe.Logger.ERROR  = { value: 40, color: '#F44336', name: 'ERROR'  };
	frappe.Logger.NOTSET = { value:  0,                   name: 'NOTSET' };

	frappe.Logger.FORMAT = '{time} {name}';

	// frappe.chat
	frappe.provide('frappe.chat');

	frappe.log = frappe.Logger.get('frappe.chat', frappe.Logger.NOTSET);

	// frappe.chat.profile
	frappe.provide('frappe.chat.profile');

	/**
	 * @description Create a Chat Profile.
	 *
	 * @param   {string|array} fields - (Optional) fields to be retrieved after creating a Chat Profile.
	 * @param   {function}     fn     - (Optional) callback with the returned Chat Profile.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.profile.create(console.log)
	 *
	 * frappe.chat.profile.create("status").then(console.log) // { status: "Online" }
	 */
	frappe.chat.profile.create = function (fields, fn) {
		if ( typeof fields === "function" ) {
			fn     = fields;
			fields = null;
		} else
		if ( typeof fields === "string" )
			{ fields = frappe._.as_array(fields); }

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_profile.chat_profile.create",
				{ user: frappe.session.user, exists_ok: true, fields: fields },
					function (response) {
						if ( fn )
							{ fn(response.message); }

						resolve(response.message);
					});
		})
	};

	/**
	 * @description Updates a Chat Profile.
	 *
	 * @param   {string} user   - (Optional) Chat Profile User, defaults to session user.
	 * @param   {object} update - (Required) Updates to be dispatched.
	 *
	 * @example
	 * frappe.chat.profile.update(frappe.session.user, { "status": "Offline" })
	 */
	frappe.chat.profile.update = function (user, update, fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_profile.chat_profile.update",
				{ user: user || frappe.session.user, data: update },
					function (response) {
						if ( fn )
							{ fn(response.message); }

						resolve(response.message);
					});
		})
	};

	// frappe.chat.profile.on
	frappe.provide('frappe.chat.profile.on');

	/**
	 * @description Triggers on a Chat Profile update of a user (Only if there's a one-on-one conversation).
	 *
	 * @param   {function} fn - (Optional) callback with the User and the Chat Profile update.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.profile.on.update(function (user, update)
	 * {
	 *      // do stuff
	 * })
	 */
	frappe.chat.profile.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.profile:update", function (r) { return fn(r.user, r.data); });
	};
	frappe.chat.profile.STATUSES
	=
	[
		{
			name: "Online",
		   color: "green"
		},
		{
			 name: "Away",
			color: "yellow"
		},
		{
			 name: "Busy",
			color: "red"
		},
		{
			 name: "Offline",
			color: "gray"
		}
	];

	// frappe.chat.room
	frappe.provide('frappe.chat.room');

	/**
	 * @description Creates a Chat Room.
	 *
	 * @param   {string}       kind  - (Required) "Direct", "Group" or "Visitor".
	 * @param   {string}       owner - (Optional) Chat Room owner (defaults to current user).
	 * @param   {string|array} users - (Required for "Direct" and "Visitor", Optional for "Group") User(s) within Chat Room.
	 * @param   {string}       name  - Chat Room name.
	 * @param   {function}     fn    - callback with created Chat Room.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.room.create("Direct", frappe.session.user, "foo@bar.com", function (room) {
	 *      // do stuff
	 * })
	 * frappe.chat.room.create("Group",  frappe.session.user, ["santa@gmail.com", "banta@gmail.com"], "Santa and Banta", function (room) {
	 *      // do stuff
	 * })
	 */
	frappe.chat.room.create = function (kind, owner, users, name, fn) {
		if ( typeof name === "function" ) {
			fn   = name;
			name = null;
		}

		users    = frappe._.as_array(users);

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.create",
				{ kind: kind, token: owner || frappe.session.user, users: users, name: name },
				function (r) {
					var room = r.message;
					room     = Object.assign({}, room, {creation: new frappe.datetime.datetime(room.creation)});

					if ( fn )
						{ fn(room); }

					resolve(room);
				});
		})
	};

	/**
	 * @description Returns Chat Room(s).
	 *
	 * @param   {string|array} names   - (Optional) Chat Room(s) to retrieve.
	 * @param   {string|array} fields  - (Optional) fields to be retrieved for each Chat Room.
	 * @param   {function}     fn      - (Optional) callback with the returned Chat Room(s).
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.room.get(function (rooms) {
	 *      // do stuff
	 * })
	 * frappe.chat.room.get().then(function (rooms) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get(null, ["room_name", "avatar"], function (rooms) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get("CR00001", "room_name", function (room) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get(["CR00001", "CR00002"], ["room_name", "last_message"], function (rooms) {
	 *
	 * })
	 */
	frappe.chat.room.get = function (names, fields, fn) {
		if ( typeof names === "function" ) {
			fn     = names;
			names  = null;
			fields = null;
		}
		else
		if ( typeof names === "string" ) {
			names  = frappe._.as_array(names);

			if ( typeof fields === "function" ) {
				fn     = fields;
				fields = null;
			}
			else
			if ( typeof fields === "string" )
				{ fields = frappe._.as_array(fields); }
		}

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.get",
				{ user: frappe.session.user, rooms: names, fields: fields },
					function (response) {
						var rooms = response.message;
						if ( rooms ) { // frappe.api BOGZ! (emtpy arrays are falsified, not good design).
							rooms = frappe._.as_array(rooms);
							rooms = rooms.map(function (room) {
								return Object.assign({}, room, {creation: new frappe.datetime.datetime(room.creation),
									last_message: room.last_message ? Object.assign({}, room.last_message,
										{creation: new frappe.datetime.datetime(room.last_message.creation)}) : null})
							});
							rooms = frappe._.squash(rooms);
						}
						else
							{ rooms = [ ]; }

						if ( fn )
							{ fn(rooms); }

						resolve(rooms);
					});
		})
	};

	/**
	 * @description Subscribe current user to said Chat Room(s).
	 *
	 * @param {string|array} rooms - Chat Room(s).
	 *
	 * @example
	 * frappe.chat.room.subscribe("CR00001")
	 */
	frappe.chat.room.subscribe = function (rooms) {
		frappe.realtime.publish("frappe.chat.room:subscribe", rooms);
	};

	/**
	 * @description Get Chat Room history.
	 *
	 * @param   {string} name - Chat Room name
	 *
	 * @returns {Promise}     - Chat Message(s)
	 *
	 * @example
	 * frappe.chat.room.history(function (messages)
	 * {
	 *      // do stuff.
	 * })
	 */
	frappe.chat.room.history = function (name, fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.history",
				{ room: name, user: frappe.session.user },
					function (r) {
						var messages = r.message ? frappe._.as_array(r.message) : [ ]; // frappe.api BOGZ! (emtpy arrays are falsified, not good design).
						messages     = messages.map(function (m) {
							return Object.assign({}, m,
								{creation: new frappe.datetime.datetime(m.creation)})
						});

						if ( fn )
							{ fn(messages); }

						resolve(messages);
					});
		})
	};

	/**
	 * @description Searches Rooms based on a query.
	 *
	 * @param   {string} query - The query string.
	 * @param   {array}  rooms - A list of Chat Rooms.
	 *
	 * @returns {array}        - A fuzzy searched list of rooms.
	 */
	frappe.chat.room.search = function (query, rooms) {
		var dataset = rooms.map(function (r) {
			if ( r.room_name )
				{ return r.room_name }
			else
				if ( r.owner === frappe.session.user )
					{ return frappe.user.full_name(frappe._.squash(r.users)) }
				else
					{ return frappe.user.full_name(r.owner) }
		});
		var results = frappe._.fuzzy_search(query, dataset);
		rooms         = results.map(function (i) { return rooms[i]; });

		return rooms
	};

	/**
	 * @description Sort Chat Room(s) based on Last Message Timestamp or Creation Date.
	 *
	 * @param {array}   - A list of Chat Room(s)
	 * @param {compare} - (Optional) a comparision function.
	 */
	frappe.chat.room.sort = function (rooms, compare) {
		if ( compare === void 0 ) compare = null;

		compare = compare || function (a, b) {
			if ( a.last_message && b.last_message )
				{ return frappe.datetime.compare(a.last_message.creation, b.last_message.creation) }
			else
			if ( a.last_message )
				{ return frappe.datetime.compare(a.last_message.creation, b.creation) }
			else
			if ( b.last_message )
				{ return frappe.datetime.compare(a.creation, b.last_message.creation) }
			else
				{ return frappe.datetime.compare(a.creation, b.creation) }
		};
		rooms.sort(compare);

		return rooms
	};

	// frappe.chat.room.on
	frappe.provide('frappe.chat.room.on');

	/**
	 * @description Triggers on Chat Room updated.
	 *
	 * @param {function} fn - callback with the Chat Room and Update.
	 */
	frappe.chat.room.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.room:update", function (r) {
			if ( r.data.last_message )
				// creation to frappe.datetime.datetime (easier to manipulate).
				{ r.data = Object.assign({}, r.data, {last_message: Object.assign({}, r.data.last_message, {creation: new frappe.datetime.datetime(r.data.last_message.creation)})}); }

			fn(r.room, r.data);
		});
	};

	/**
	 * @description Triggers on Chat Room created.
	 *
	 * @param {function} fn - callback with the created Chat Room.
	 */
	frappe.chat.room.on.create = function (fn) {
		frappe.realtime.on("frappe.chat.room:create", function (r) { return fn(Object.assign({}, r, {creation: new frappe.datetime.datetime(r.creation)})); }
		);
	};

	/**
	 * @description Triggers when a User is typing in a Chat Room.
	 *
	 * @param {function} fn - callback with the typing User within the Chat Room.
	 */
	frappe.chat.room.on.typing = function (fn) {
		frappe.realtime.on("frappe.chat.room:typing", function (r) { return fn(r.room, r.user); });
	};

	// frappe.chat.message
	frappe.provide('frappe.chat.message');

	frappe.chat.message.typing = function (room, user) {
		frappe.realtime.publish("frappe.chat.message:typing", { user: user || frappe.session.user, room: room });
	};

	frappe.chat.message.send   = function (room, message, type) {
		if ( type === void 0 ) type = "Content";

		frappe.call("frappe.chat.doctype.chat_message.chat_message.send",
			{ user: frappe.session.user, room: room, content: message, type: type });
	};

	frappe.chat.message.update = function (message, update, fn) {
		return new Promise(function (resolve) {
			frappe.call('frappe.chat.doctype.chat_message.chat_message.update',
				{ user: frappe.session.user, message: message, update: update },
				function (r) {
					if ( fn )
						{ fn(response.message); }

					resolve(response.message);
				});
		})
	};

	frappe.chat.message.sort   = function (messages) {
		if ( !frappe._.is_empty(messages) )
			{ messages.sort(function (a, b) { return frappe.datetime.compare(b.creation, a.creation); }); }

		return messages
	};

	/**
	 * @description Add user to seen (defaults to session.user)
	 */
	frappe.chat.message.seen   = function (mess, user) {
		frappe.call('frappe.chat.doctype.chat_message.chat_message.seen',
			{ message: mess, user: user || frappe.session.user });
	};

	frappe.provide('frappe.chat.message.on');
	frappe.chat.message.on.create = function (fn) {
		frappe.realtime.on("frappe.chat.message:create", function (r) { return fn(Object.assign({}, r, {creation: new frappe.datetime.datetime(r.creation)})); }
		);
	};

	frappe.chat.message.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.message:update", function (r) { return fn(r.message, r.data); });
	};

	frappe.chat.pretty_datetime   = function (date) {
		var today    = moment();
		var instance = date.moment;

		if ( today.isSame(instance, "d") )
			{ return instance.format("hh:mm A") }
		else
		if ( today.isSame(instance, "week") )
			{ return instance.format("dddd") }
		else
			{ return instance.format("DD/MM/YYYY") }
	};

	// frappe.chat.sound
	frappe.provide('frappe.chat.sound');

	/**
	 * @description Plays a given registered sound.
	 *
	 * @param {value} - The name of the registered sound.
	 *
	 * @example
	 * frappe.chat.sound.play("message")
	 */
	frappe.chat.sound.play  = function (name, volume) {
		if ( volume === void 0 ) volume = 0.1;

		// frappe._.play_sound(`chat-${name}`)
		var $audio = $("<audio class=\"chat-audio\"/>");
		$audio.attr('volume', volume);

		if  ( frappe._.is_empty($audio) )
			{ $(document).append($audio); }

		if  ( !$audio.paused ) {
			frappe.log.info('Stopping sound playing.');
			$audio[0].pause();
			$audio.attr('currentTime', 0);
		}

		frappe.log.info('Playing sound.');
		$audio.attr('src', ((frappe.chat.sound.PATH) + "/chat-" + name + ".mp3"));
		$audio[0].play();
	};
	frappe.chat.sound.PATH  = '/assets/frappe/sounds';

	// frappe.chat.emoji
	frappe.chat.emojis = [ ];
	frappe.chat.emoji  = function (fn) {
		return new Promise(function (resolve) {
			if ( !frappe._.is_empty(frappe.chat.emojis) ) {
				if ( fn )
					{ fn(frappe.chat.emojis); }

				resolve(frappe.chat.emojis);
			}
			else
				{ $.get('https://cdn.rawgit.com/frappe/emoji/master/emoji', function (data) {
					frappe.chat.emojis = JSON.parse(data);

					if ( fn )
						{ fn(frappe.chat.emojis); }

					resolve(frappe.chat.emojis);
				}); }
		})
	};

	// Website Settings
	frappe.provide('frappe.chat.website.settings');
	frappe.chat.website.settings = function (fields, fn) {
		if ( typeof fields === "function" ) {
			fn     = fields;
			fields = null;
		} else
		if ( typeof fields === "string" )
			{ fields = frappe._.as_array(fields); }

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.website.settings",
				{ fields: fields })
				.then(function (response) {
					var message = response.message;

					if ( message.enable_from )
						{ message   = Object.assign({}, message, {enable_from: new frappe.datetime.datetime(message.enable_from, 'HH:mm:ss')}); }
					if ( message.enable_to )
						{ message   = Object.assign({}, message, {enable_to:   new frappe.datetime.datetime(message.enable_to,   'HH:mm:ss')}); }

					if ( fn )
						{ fn(message); }

					resolve(message);
				});
		})
	};

	frappe.chat.website.token    = function (fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.website.token")
				.then(function (response) {
					if ( fn )
						{ fn(response.message); }

					resolve(response.message);
				});
		})
	};

	var h = hyper_min.h;
	var Component = hyper_min.Component;

	// frappe.components
	// frappe's component namespace.
	frappe.provide('frappe.components');

	frappe.provide('frappe.chat.component');

	/**
	 * @description Button Component
	 *
	 * @prop {string}  type  - (Optional) "default", "primary", "info", "success", "warning", "danger" (defaults to "default")
	 * @prop {boolean} block - (Optional) Render a button block (defaults to false).
	 */
	frappe.components.Button
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var size      = frappe.components.Button.SIZE[props.size];

			return (
				h("button", Object.assign({}, props, {class: ("btn " + (size && size.class) + " btn-" + (props.type) + " " + (props.block ? "btn-block" : "") + " " + (props.class ? props.class : ""))}),
					props.children
				)
			)
		}
	};
	frappe.components.Button.SIZE
	=
	{
		small: {
			class: "btn-sm"
		},
		large: {
			class: "btn-lg"
		}
	};
	frappe.components.Button.defaultProps
	=
	{
		 type: "default",
		block: false
	};

	/**
	 * @description FAB Component
	 *
	 * @extends frappe.components.Button
	 */
	frappe.components.FAB
	=
	class extends frappe.components.Button {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var size      = frappe.components.FAB.SIZE[props.size];

			return (
				h(frappe.components.Button, Object.assign({}, props, {class: ((props.class) + " " + (size && size.class))}),
					h("i", { class: props.icon })
				)
			)
		}
	};
	frappe.components.FAB.defaultProps
	=
	{
		icon: "octicon octicon-plus"
	};
	frappe.components.FAB.SIZE
	=
	{
		small:
		{
			class: "frappe-fab-sm"
		},
		large:
		{
			class: "frappe-fab-lg"
		}
	};

	/**
	 * @description Octicon Component
	 *
	 * @prop color - (Required) color for the indicator
	 */
	frappe.components.Indicator
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.color ? h("span", Object.assign({}, props, {class: ("indicator " + (props.color))})) : null
		}
	};

	/**
	 * @description FontAwesome Component
	 */
	frappe.components.FontAwesome
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.type ? h("i", Object.assign({}, props, {class: ("fa " + (props.fixed ? "fa-fw" : "") + " fa-" + (props.type) + " " + (props.class))})) : null
		}
	};
	frappe.components.FontAwesome.defaultProps
	=
	{
		fixed: false
	};

	/**
	 * @description Octicon Component
	 *
	 * @extends frappe.Component
	 */
	frappe.components.Octicon
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.type ? h("i", Object.assign({}, props, {class: ("octicon octicon-" + (props.type))})) : null
		}
	};

	/**
	 * @description Avatar Component
	 *
	 * @prop {string} title - (Optional) title for the avatar.
	 * @prop {string} abbr  - (Optional) abbreviation for the avatar, defaults to the first letter of the title.
	 * @prop {string} size  - (Optional) size of the avatar to be displayed.
	 * @prop {image}  image - (Optional) image for the avatar, defaults to the first letter of the title.
	 */
	frappe.components.Avatar
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var abbr      = props.abbr || props.title.substr(0, 1);
			var size      = frappe.components.Avatar.SIZE[props.size] || frappe.components.Avatar.SIZE.medium;

			return (
				h("span", { class: ("avatar " + (size.class) + " " + (props.class ? props.class : "")) },
					props.image ?
						h("img", { class: "media-object", src: props.image })
						:
						h("div", { class: "standard-image" }, abbr)
				)
			)
		}
	};
	frappe.components.Avatar.SIZE
	=
	{
		small:
		{
			class: "avatar-small"
		},
		large:
		{
			class: "avatar-large"
		},
		medium:
		{
			class: "avatar-medium"
		}
	};

	/**
	 * @description Frappe Chat Object.
	 *
	 * @example
	 * const chat = new frappe.Chat(options) // appends to "body"
	 * chat.render()
	 * const chat = new frappe.Chat(".selector", options)
	 * chat.render()
	 *
	 * const chat = new frappe.Chat()
	 * chat.set_wrapper('.selector')
	 *     .set_options(options)
	 *     .render()
	 */
	frappe.Chat
	=
	class {
		/**
		 * @description Frappe Chat Object.
		 *
		 * @param {string} selector - A query selector, HTML Element or jQuery object.
		 * @param {object} options  - Optional configurations.
		 */
		constructor (selector, options) {
			if ( !(typeof selector === "string" || selector instanceof $ || selector instanceof HTMLElement) ) {
				options  = selector;
				selector = null;
			}

			this.options = frappe.Chat.OPTIONS;

			this.set_wrapper(selector ? selector : "body");
			this.set_options(options);

		}

		/**
		 * Set the container on which the chat widget is mounted on.
		 * @param   {string|HTMLElement} selector - A query selector, HTML Element or jQuery object.
		 *
		 * @returns {frappe.Chat}                 - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.set_wrapper(".selector")
		 */
		set_wrapper (selector) {
			this.$wrapper = $(selector);

			return this
		}

		/**
		 * Set the configurations for the chat interface.
		 * @param   {object}      options - Optional Configurations.
		 *
		 * @returns {frappe.Chat}         - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.set_options({ layout: frappe.Chat.Layout.PAGE })
		 */
		set_options (options) {
			this.options = Object.assign({}, this.options, options);

			return this
		}

		/**
		 * @description Destory the chat widget.
		 *
		 * @returns {frappe.Chat} - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.render()
		 *     .destroy()
		 */
		destroy ( ) {
			var $wrapper = this.$wrapper;
			$wrapper.remove(".frappe-chat");

			return this
		}

		/**
		 * @description Render the chat widget component onto destined wrapper.
		 *
		 * @returns {frappe.Chat} - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.render()
		 */
		render (props) {
			if ( props === void 0 ) props = { };

			this.destroy();

			var $wrapper   = this.$wrapper;
			var options    = this.options;

			var component  = h(frappe.Chat.Widget, Object.assign({}, {layout: options.layout,
				target: options.target},
				props));

			hyper_min.render(component, $wrapper[0]);

			return this
		}
	};
	frappe.Chat.Layout
	=
	{
		PAGE: "page", POPPER: "popper"
	};
	frappe.Chat.OPTIONS
	=
	{
		layout: frappe.Chat.Layout.POPPER
	};

	/**
	 * @description The base Component for Frappe Chat
	 */
	frappe.Chat.Widget
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.setup(props);
			this.make();
		}

		setup (props) {
			var this$1 = this;

			// room actions
			this.room           = { };
			this.room.add       = function (rooms) {
				rooms           = frappe._.as_array(rooms);
				var names     = rooms.map(function (r) { return r.name; });

				frappe.log.info(("Subscribing " + (frappe.session.user) + " to Chat Rooms " + (names.join(", ")) + "."));
				frappe.chat.room.subscribe(names);

				var state     = [ ];

				for (var i = 0, list = rooms; i < list.length; i += 1)
					  {
					var room = list[i];

					if ( ["Group", "Visitor"].includes(room.type) || room.owner === frappe.session.user || room.last_message || room.users.includes(frappe.session.user)) {
						frappe.log.info(("Adding " + (room.name) + " to component."));
						state.push(room);
					}
				}

				this$1.set_state({ rooms: this$1.state.rooms.concat( state ) });
			};
			this.room.update    = function (room, update) {
				var ref = this$1;
				var state = ref.state;
				var   exists    = false;
				var rooms     = state.rooms.map(function (r) {
					if ( r.name === room ) {
						exists  = true;
						if ( update.typing ) {
							if ( !frappe._.is_empty(r.typing) ) {
								var usr = update.typing;
								if ( !r.typing.includes(usr) ) {
									update.typing = frappe._.copy_array(r.typing);
									update.typing.push(usr);
								}
							}
							else
								{ update.typing = frappe._.as_array(update.typing); }
						}

						return Object.assign({}, r, update)
					}

					return r
				});

				if ( frappe.session.user !== 'Guest' ) {
					if ( !exists )
						{ frappe.chat.room.get(room, function (room) { return this$1.room.add(room); }); }
					else
						{ this$1.set_state({ rooms: rooms }); }
				}

				if ( state.room.name === room ) {
					if ( update.typing ) {
						if ( !frappe._.is_empty(state.room.typing) ) {
							var usr = update.typing;
							if ( !state.room.typing.includes(usr) ) {
								update.typing = frappe._.copy_array(state.room.typing);
								update.typing.push(usr);
							}
						} else
							{ update.typing = frappe._.as_array(update.typing); }
					}

					var room$1  = Object.assign({}, state.room, update);

					this$1.set_state({ room: room$1 });
				}
			};
			this.room.select    = function (name) {
				frappe.chat.room.history(name, function (messages) {
					var ref = this$1;
					var state = ref.state;
					var room       = state.rooms.find(function (r) { return r.name === name; });

					this$1.set_state({
						room: Object.assign({}, state.room, room, {messages: messages})
					});
				});
			};

			this.state = Object.assign({}, frappe.Chat.Widget.defaultState, props);
		}

		make ( ) {
			var this$1 = this;

			if ( frappe.session.user !== 'Guest' ) {
				frappe.chat.profile.create([
					"status", "message_preview", "notification_tones", "conversation_tones"
				]).then(function (profile) {
					this$1.set_state({ profile: profile });

					frappe.chat.room.get(function (rooms) {
						rooms = frappe._.as_array(rooms);
						frappe.log.info(("User " + (frappe.session.user) + " is subscribed to " + (rooms.length) + " " + (frappe._.pluralize('room', rooms.length)) + "."));

						if ( !frappe._.is_empty(rooms) )
							{ this$1.room.add(rooms); }
					});

					this$1.bind();
				});
			} else {
				this.bind();
			}
		}

		bind ( ) {
			var this$1 = this;

			frappe.chat.profile.on.update(function (user, update) {
				frappe.log.warn(("TRIGGER: Chat Profile update " + (JSON.stringify(update)) + " of User " + user + "."));

				if ( 'status' in update ) {
					if ( user === frappe.session.user ) {
						this$1.set_state({
							profile: Object.assign({}, this$1.state.profile, {status: update.status})
						});
					} else {
						var status = frappe.chat.profile.STATUSES.find(function (s) { return s.name === update.status; });
						var color  = status.color;

						var alert  = "<span class=\"indicator " + color + "\"/> " + (frappe.user.full_name(user)) + " is currently <b>" + (update.status) + "</b>";
						frappe.show_alert(alert, 3);
					}
				}
			});

			frappe.chat.room.on.create(function (room) {
				frappe.log.warn(("TRIGGER: Chat Room " + (room.name) + " created."));
				this$1.room.add(room);
			});

			frappe.chat.room.on.update(function (room, update) {
				frappe.log.warn(("TRIGGER: Chat Room " + room + " update " + (JSON.stringify(update)) + " recieved."));
				this$1.room.update(room, update);
			});

			frappe.chat.room.on.typing(function (room, user) {
				if ( user !== frappe.session.user ) {
					frappe.log.warn(("User " + user + " typing in Chat Room " + room + "."));
					this$1.room.update(room, { typing: user });

					setTimeout(function () { return this$1.room.update(room, { typing: null }); }, 5000);
				}
			});

			frappe.chat.message.on.create(function (r) {
				var ref = this$1;
				var state = ref.state;

				// play sound.
				if ( state.room.name )
					{ state.profile.conversation_tones && frappe.chat.sound.play('message'); }
				else
					{ state.profile.notification_tones && frappe.chat.sound.play('notification'); }

				if ( r.user !== frappe.session.user && state.profile.message_preview && !state.toggle ) {
					var $element = $('body').find('.frappe-chat-alert');
					$element.remove();

					var  alert   = // TODO: ellipses content
					"\n\t\t\t\t<span data-action=\"show-message\" class=\"cursor-pointer\">\n\t\t\t\t\t<span class=\"indicator yellow\"/>\n\t\t\t\t\t\t<span class=\"avatar avatar-small\">\n\t\t\t\t\t\t\t<span class=\"avatar-frame\" style=\"background-image: url(" + (frappe.user.image(r.user)) + ")\"></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<b>" + (frappe.user.first_name(r.user)) + "</b>: " + (r.content) + "\n\t\t\t\t</span>\n\t\t\t\t";
					frappe.show_alert(alert, 15, {
						"show-message": function (r) {
							this.room.select(r.room);
							this.base.firstChild._component.toggle();
						}.bind(this$1, r)
					});
					frappe.notify(("" + (frappe.user.first_name(r.user))), {
						body: r.content,
						icon: frappe.user.image(r.user),
						tag: r.user
					});
				}

				if ( r.room === state.room.name ) {
					var mess  = frappe._.copy_array(state.room.messages);
					mess.push(r);

					this$1.set_state({ room: Object.assign({}, state.room, {messages: mess}) });
				}
			});

			frappe.chat.message.on.update(function (message, update) {
				frappe.log.warn(("TRIGGER: Chat Message " + message + " update " + (JSON.stringify(update)) + " recieved."));
			});
		}

		render ( ) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var me               = this;

			var ActionBar        = h(frappe.Chat.Widget.ActionBar, {
				placeholder: __("Search or Create a New Chat"),
					  class: "level",
					 layout: props.layout,
					actions:
				frappe._.compact([
					{
						  label: __("New"),
						onclick: function ( ) {
							var dialog = new frappe.ui.Dialog({
								  title: __("New Chat"),
								 fields: [
									 {
											 label: __("Chat Type"),
										 fieldname: "type",
										 fieldtype: "Select",
										   options: ["Group", "Direct Chat"],
										   default: "Group",
										  onchange: function () {
												var type     = dialog.get_value("type");
												var is_group = type === "Group";

												dialog.set_df_property("group_name", "reqd",  is_group);
												dialog.set_df_property("user",       "reqd", !is_group);
										  }
									 },
									 {
											 label: __("Group Name"),
										 fieldname: "group_name",
										 fieldtype: "Data",
											  reqd: true,
										depends_on: "eval:doc.type == 'Group'"
									 },
									 {
											 label: __("Users"),
										 fieldname: "users",
										 fieldtype: "MultiSelect",
										   options: frappe.user.get_emails(),
										depends_on: "eval:doc.type == 'Group'"
									 },
									 {
											 label: __("User"),
										 fieldname: "user",
										 fieldtype: "Link",
										   options: "User",
										depends_on: "eval:doc.type == 'Direct Chat'"
									 }
								 ],
								action: {
									primary: {
										   label: __('Create'),
										onsubmit: function (values) {
											if ( values.type === "Group" ) {
												if ( !frappe._.is_empty(values.users) ) {
													var name  = values.group_name;
													var users = dialog.fields_dict.users.get_values();

													frappe.chat.room.create("Group",  null, users, name);
												}
											} else {
												var user      = values.user;

												frappe.chat.room.create("Direct", null, user);
											}
											dialog.hide();
										}
									}
								}
							});
							dialog.show();
						}
					},
					frappe._.is_mobile() && {
						   icon: "octicon octicon-x",
						   class: "frappe-chat-close",
						onclick: function () { return this$1.set_state({ toggle: false }); }
					}
				], Boolean),
				change: function (query) { me.set_state({ query: query }); },
				  span: function (span)  { me.set_state({ span: span  }); },
			});

			var   contacts   = [ ];
			if ( 'user_info' in frappe.boot ) {
				var emails = frappe.user.get_emails();
				for (var i$1 = 0, list$1 = emails; i$1 < list$1.length; i$1 += 1) {
					var email = list$1[i$1];

					var exists = false;

					for (var i = 0, list = state.rooms; i < list.length; i += 1) {
						var room = list[i];

						if ( room.type === 'Direct' ) {
							if ( room.owner === email || frappe._.squash(room.users) === email )
								{ exists = true; }
						}
					}

					if ( !exists )
						{ contacts.push({ owner: frappe.session.user, users: [email] }); }
				}
			}
			var rooms      = state.query ? frappe.chat.room.search(state.query, state.rooms.concat(contacts)) : frappe.chat.room.sort(state.rooms);

			var layout     = state.span  ? frappe.Chat.Layout.PAGE : frappe.Chat.Layout.POPPER;

			var RoomList   = frappe._.is_empty(rooms) && !state.query ?
				h("div", { class: "vcenter" },
					h("div", { class: "text-center text-extra-muted" },
						h("p","",__("You don't have any messages yet."))
					)
				)
				:
				h(frappe.Chat.Widget.RoomList, { rooms: rooms, click: function (room) {
					if ( room.name )
						{ this$1.room.select(room.name); }
					else
						{ frappe.chat.room.create("Direct", room.owner, frappe._.squash(room.users), function (ref) {
							var name = ref.name;

							return this$1.room.select(name);
					}); }
				}});
			var Room       = h(frappe.Chat.Widget.Room, Object.assign({}, state.room, {layout: layout, destroy: function () {
				this$1.set_state({
					room: { name: null, messages: [ ] }
				});
			}}));

			var component  = layout === frappe.Chat.Layout.POPPER ?
				h(frappe.Chat.Widget.Popper, { heading: ActionBar, page: state.room.name && Room, target: props.target,
					toggle: function (t) { return this$1.set_state({ toggle: t }); } },
					RoomList
				)
				:
				h("div", { class: "frappe-chat-popper" },
					h("div", { class: "frappe-chat-popper-collapse" },
						h("div", { class: "panel panel-default panel-span", style: { width: "25%" } },
							h("div", { class: "panel-heading" },
								ActionBar
							),
							RoomList
						),
						Room
					)
				);

			return (
				h("div", { class: "frappe-chat" },
					component
				)
			)
		}
	};
	frappe.Chat.Widget.defaultState =  {
		  query: "",
		profile: { },
		  rooms: [ ],
		   room: { name: null, messages: [ ], typing: [ ] },
		 toggle: false,
		   span: false
	};
	frappe.Chat.Widget.defaultProps = {
		layout: frappe.Chat.Layout.POPPER
	};

	/**
	 * @description Chat Widget Popper HOC.
	 */
	frappe.Chat.Widget.Popper
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.setup(props);
		}

		setup (props) {
			var this$1 = this;

			this.toggle = this.toggle.bind(this);

			this.state  = frappe.Chat.Widget.Popper.defaultState;

			if ( props.target )
				{ $(props.target).click(function () { return this$1.toggle(); }); }

			frappe.chat.widget = this;
		}

		toggle  (active) {
			var toggle;
			if ( arguments.length === 1 )
				{ toggle = active; }
			else
				{ toggle = this.state.active ? false : true; }

			this.set_state({ active: toggle });

			this.props.toggle(toggle);
		}

		on_mounted ( ) {
			var this$1 = this;

			$(document.body).on('click', '.page-container, .frappe-chat-close', function (ref) {
				var currentTarget = ref.currentTarget;

				this$1.toggle(false);
			});
		}

		render  ( )  {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			return !state.destroy ?
			(
				h("div", { class: "frappe-chat-popper", style: !props.target ? { "margin-bottom": "80px" } : null },
					!props.target ?
						h(frappe.components.FAB, {
							  class: "frappe-fab",
							   icon: state.active ? "fa fa-fw fa-times" : "font-heavy octicon octicon-comment",
							   size: frappe._.is_mobile() ? null : "large",
							   type: "primary",
							onclick: function () { return this$1.toggle(); },
						}) : null,
					state.active ?
						h("div", { class: "frappe-chat-popper-collapse" },
							props.page ? props.page : (
								h("div", { class: ("panel panel-default " + (frappe._.is_mobile() ? "panel-span" : "")) },
									h("div", { class: "panel-heading" },
										props.heading
									),
									props.children
								)
							)
					) : null
				)
			) : null
		}
	};
	frappe.Chat.Widget.Popper.defaultState
	=
	{
		 active: false,
		destroy: false
	};

	/**
	 * @description frappe.Chat.Widget ActionBar Component
	 */
	frappe.Chat.Widget.ActionBar
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.change = this.change.bind(this);
			this.submit = this.submit.bind(this);

			this.state  = frappe.Chat.Widget.ActionBar.defaultState;
		}

		change (e) {
			var obj;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			this.set_state(( obj = {}, obj[e.target.name] = e.target.value, obj ));

			props.change(state.query);
		}

		submit (e) {
			var ref = this;
			var props = ref.props;
			var state = ref.state;

			e.preventDefault();

			props.submit(state.query);
		}

		render ( ) {
			var me               = this;
			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var actions = props.actions;

			return (
				h("div", { class: ("frappe-chat-action-bar " + (props.class ? props.class : "")) },
					h("form", { oninput: this.change, onsubmit: this.submit },
						h("input", { autocomplete: "off", class: "form-control input-sm", name: "query", value: state.query, placeholder: props.placeholder || "Search" })
					),
					!frappe._.is_empty(actions) ?
						actions.map(function (action) { return h(frappe.Chat.Widget.ActionBar.Action, Object.assign({}, action)); }) : null,
					!frappe._.is_mobile() ?
						h(frappe.Chat.Widget.ActionBar.Action, {
							icon: ("octicon octicon-screen-" + (state.span ? "normal" : "full")),
							onclick: function () {
								var span = !state.span;
								me.set_state({ span: span });
								props.span(span);
							}
						})
						:
						null
				)
			)
		}
	};
	frappe.Chat.Widget.ActionBar.defaultState
	=
	{
		query: null,
		 span: false
	};

	/**
	 * @description frappe.Chat.Widget ActionBar's Action Component.
	 */
	frappe.Chat.Widget.ActionBar.Action
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h(frappe.components.Button, Object.assign({}, {size: "small", class: "btn-action"}, props),
					props.icon ? h("i", { class: props.icon }) : null,
					("" + (props.icon ? " " : "") + (props.label ? props.label : ""))
				)
			)
		}
	};

	/**
	 * @description frappe.Chat.Widget RoomList Component
	 */
	frappe.Chat.Widget.RoomList
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var rooms     = props.rooms;

			return !frappe._.is_empty(rooms) ? (
				h("ul", { class: "frappe-chat-room-list nav nav-pills nav-stacked" },
					rooms.map(function (room) { return h(frappe.Chat.Widget.RoomList.Item, Object.assign({}, room, {click: props.click})); })
				)
			) : null
		}
	};

	/**
	 * @description frappe.Chat.Widget RoomList's Item Component
	 */
	frappe.Chat.Widget.RoomList.Item
	=
	class extends Component {
		render ( ) {
			var ref    = this;
			var props = ref.props;
			var item         = { };

			if ( props.type === "Group" ) {
				item.title     = props.room_name;
				item.image     = props.avatar;

				if ( !frappe._.is_empty(props.typing) ) {
					props.typing  = frappe._.as_array(props.typing); // HACK: (BUG) why does typing return a string?
					var names   = props.typing.map(function (user) { return frappe.user.first_name(user); });
					item.subtitle = (names.join(", ")) + " typing...";
				} else
				if ( props.last_message ) {
					var message = props.last_message;
					var content = message.content;

					if ( message.type === "File" ) {
						item.subtitle = "📁 " + (content.name);
					} else {
						item.subtitle = props.last_message.content;
					}
				}
			} else {
				var user     = props.owner === frappe.session.user ? frappe._.squash(props.users) : props.owner;

				item.title     = frappe.user.full_name(user);
				item.image     = frappe.user.image(user);
				item.abbr      = frappe.user.abbr(user);

				if ( !frappe._.is_empty(props.typing) )
					{ item.subtitle = 'typing...'; }
				else
				if ( props.last_message ) {
					var message$1 = props.last_message;
					var content$1 = message$1.content;

					if ( message$1.type === "File" ) {
						item.subtitle = "📁 " + (content$1.name);
					} else {
						item.subtitle = props.last_message.content;
					}
				}
			}

			var is_unread = false;
			if ( props.last_message ) {
				item.timestamp = frappe.chat.pretty_datetime(props.last_message.creation);
				is_unread = !props.last_message.seen.includes(frappe.session.user);
			}

			return (
				h("li", null,
					h("a", { class: props.active ? "active": "", onclick: function () {
						if (props.last_message) {
							frappe.chat.message.seen(props.last_message.name);
						}
						props.click(props);
					} },
						h("div", { class: "row" },
							h("div", { class: "col-xs-9" },
								h(frappe.Chat.Widget.MediaProfile, Object.assign({}, item))
							),
							h("div", { class: "col-xs-3 text-right" },
								[
									h("div", { class: "text-muted", style: { "font-size": "9px" } }, item.timestamp),
									is_unread ? h("span", { class: "indicator red" }) : null
								]
							)
						)
					)
				)
			)
		}
	};

	/**
	 * @description frappe.Chat.Widget's MediProfile Component.
	 */
	frappe.Chat.Widget.MediaProfile
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var position  = frappe.Chat.Widget.MediaProfile.POSITION[props.position || "left"];
			var avatar    = (
				h("div", { class: ((position.class) + " media-middle") },
					h(frappe.components.Avatar, Object.assign({}, props,
						{title: props.title,
						image: props.image,
						 size: props.size,
						 abbr: props.abbr}))
				)
			);

			return (
				h("div", { class: "media", style: position.class === "media-right" ? { "text-align": "right" } : null },
					position.class === "media-left"  ? avatar : null,
					h("div", { class: "media-body" },
						h("div", { class: "media-heading ellipsis small", style: ("max-width: " + (props.width_title || "100%") + " display: inline-block") }, props.title),
						props.content  ? h("div","",h("small","",props.content))  : null,
						props.subtitle ? h("div",{ class: "media-subtitle small" },h("small", { class: "text-muted" }, props.subtitle)) : null
					),
					position.class === "media-right" ? avatar : null
				)
			)
		}
	};
	frappe.Chat.Widget.MediaProfile.POSITION
	=
	{
		left: { class: "media-left" }, right: { class: "media-right" }
	};

	/**
	 * @description frappe.Chat.Widget Room Component
	 */
	frappe.Chat.Widget.Room
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var hints            =
			[
				{
					 match: /@(\w*)$/,
					search: function (keyword, callback) {
						if ( props.type === 'Group' ) {
							var query = keyword.slice(1);
							var users = [].concat(frappe._.as_array(props.owner), props.users);
							var grep  = users.filter(function (user) { return user !== frappe.session.user && user.indexOf(query) === 0; });

							callback(grep);
						}
					},
					component: function (item) {
						return (
							h(frappe.Chat.Widget.MediaProfile, {
								title: frappe.user.full_name(item),
								image: frappe.user.image(item),
								 size: "small"
							})
						)
					}
				},
				{
					match: /:([a-z]*)$/,
				   search: function (keyword, callback) {
						frappe.chat.emoji(function (emojis) {
							var query = keyword.slice(1);
							var items = [ ];
							for (var i$1 = 0, list$1 = emojis; i$1 < list$1.length; i$1 += 1)
								{
								var emoji = list$1[i$1];

								for (var i = 0, list = emoji.aliases; i < list.length; i += 1)
									{
										var alias = list[i];

										if ( alias.indexOf(query) === 0 )
										{ items.push({ name: alias, value: emoji.emoji });
									}
							} }

							callback(items);
						});
				   },
					 content: function (item) { return item.value; },
				   component: function (item) {
						return (
							h(frappe.Chat.Widget.MediaProfile, {
								title: item.name,
								 abbr: item.value,
								 size: "small"
							})
						)
				   }
			   }
			];

			var actions = frappe._.compact([
				!frappe._.is_mobile() && {
					 icon: "camera",
					label: "Camera",
					onclick: function ( ) {
						var capture = new frappe.ui.Capture({
							animate: false,
							  error: true
						});
						capture.show();

						capture.submit(function (data_url) {
							// data_url
						});
					}
				},
				{
					 icon: "file",
					label: "File",
					onclick: function ( ) {
						new frappe.ui.FileUploader({
							doctype: "Chat Room",
							docname: props.name,
							on_success: function on_success(file_doc) {
								var file_url = file_doc.file_url;
								var filename = file_doc.filename;
								frappe.chat.message.send(props.name, { path: file_url, name: filename }, "File");
							}
						});
					}
				}
			]);

			if ( frappe.session.user !== 'Guest' ) {
				if (props.messages) {
					props.messages = frappe._.as_array(props.messages);
					for (var i = 0, list = props.messages; i < list.length; i += 1)
						{
						var message = list[i];

						if ( !message.seen.includes(frappe.session.user) )
							{ frappe.chat.message.seen(message.name); }
						else
							{ break
					} }
				}
			}

			return (
				h("div", { class: ("panel panel-default\n\t\t\t\t" + (props.name ? "panel-bg" : "") + "\n\t\t\t\t" + (props.layout === frappe.Chat.Layout.PAGE || frappe._.is_mobile() ? "panel-span" : "")),
					style: props.layout === frappe.Chat.Layout.PAGE && { width: "75%", left: "25%", "box-shadow": "none" } },
					props.name && h(frappe.Chat.Widget.Room.Header, Object.assign({}, props, {on_back: props.destroy})),
					props.name ?
						!frappe._.is_empty(props.messages) ?
							h(frappe.chat.component.ChatList, {
								messages: props.messages
							})
							:
							h("div", { class: "panel-body", style: { "height": "100%" } },
								h("div", { class: "vcenter" },
									h("div", { class: "text-center text-extra-muted" },
										h(frappe.components.Octicon, { type: "comment-discussion", style: "font-size: 48px" }),
										h("p","",__("Start a conversation."))
									)
								)
							)
						:
						h("div", { class: "panel-body", style: { "height": "100%" } },
							h("div", { class: "vcenter" },
								h("div", { class: "text-center text-extra-muted" },
									h(frappe.components.Octicon, { type: "comment-discussion", style: "font-size: 125px" }),
									h("p","",__("Select a chat to start messaging."))
								)
							)
						),
					props.name ?
						h("div", { class: "chat-room-footer" },
							h(frappe.chat.component.ChatForm, { actions: actions,
								onchange: function () {
									frappe.chat.message.typing(props.name);
								},
								onsubmit: function (message) {
									frappe.chat.message.send(props.name, message);
								},
								hint: hints
							})
						)
						:
						null
				)
			)
		}
	};

	frappe.Chat.Widget.Room.Header
	=
	class extends Component {
		render ( ) {
			var ref     = this;
			var props = ref.props;

			var item          = { };

			if ( ["Group", "Visitor"].includes(props.type) ) {
				item.route      = "chat-room/" + (props.name);

				item.title      = props.room_name;
				item.image      = props.avatar;

				if ( !frappe._.is_empty(props.typing) ) {
					props.typing  = frappe._.as_array(props.typing); // HACK: (BUG) why does typing return as a string?
					var users   = props.typing.map(function (user) { return frappe.user.first_name(user); });
					item.subtitle = (users.join(", ")) + " typing...";
				} else
					{ item.subtitle = props.type === "Group" ?
						((props.users.length) + " " + (frappe._.pluralize('member', props.users.length)))
						: ""; }
			}
			else {
				var user      = props.owner === frappe.session.user ? frappe._.squash(props.users) : props.owner;

				item.route      = "user/" + user;

				item.title      = frappe.user.full_name(user);
				item.image      = frappe.user.image(user);

				if ( !frappe._.is_empty(props.typing) )
					{ item.subtitle = 'typing...'; }
			}

			var popper        = props.layout === frappe.Chat.Layout.POPPER || frappe._.is_mobile();

			return (
				h("div", { class: "panel-heading", style: { "height": "50px" } }, // sorry. :(
					h("div", { class: "level" },
						popper && frappe.session.user !== "Guest" ?
							h(frappe.components.Button,{class:"btn-back",onclick:props.on_back},
								h(frappe.components.Octicon, { type: "chevron-left" })
							) : null,
						h("div","",
							h("div", { class: "panel-title" },
								h("div", { class: "cursor-pointer", onclick: function () {
									frappe.session.user !== "Guest" ?
										frappe.set_route(item.route) : null;
								}},
									h(frappe.Chat.Widget.MediaProfile, Object.assign({}, item))
								)
							)
						),
						h("div", { class: popper ? "col-xs-2"  : "col-xs-3" },
							h("div", { class: "text-right" },
								frappe._.is_mobile() && h(frappe.components.Button, { class: "frappe-chat-close", onclick: props.toggle },
									h(frappe.components.Octicon, { type: "x" })
								)
							)
						)
					)
				)
			)
		}
	};

	/**
	 * @description ChatList Component
	 *
	 * @prop {array} messages - ChatMessage(s)
	 */
	frappe.chat.component.ChatList
	=
	class extends Component {
		on_mounted ( ) {
			this.$element  = $('.frappe-chat').find('.chat-list');
			this.$element.scrollTop(this.$element[0].scrollHeight);
		}

		on_updated ( ) {
			this.$element.scrollTop(this.$element[0].scrollHeight);
		}

		render ( ) {
			var messages = [ ];
			for (var i   = 0 ; i < this.props.messages.length ; ++i) {
				var   message   = this.props.messages[i];
				var me        = message.user === frappe.session.user;

				if ( i === 0 || !frappe.datetime.equal(message.creation, this.props.messages[i - 1].creation, 'day') )
					{ messages.push({ type: "Notification", content: message.creation.format('MMMM DD') }); }

				messages.push(message);
			}

			return (
				h("div",{class:"chat-list list-group"},
					!frappe._.is_empty(messages) ?
						messages.map(function (m) { return h(frappe.chat.component.ChatList.Item, Object.assign({}, m)); }) : null
				)
			)
		}
	};

	/**
	 * @description ChatList.Item Component
	 *
	 * @prop {string} name       - ChatMessage name
	 * @prop {string} user       - ChatMessage user
	 * @prop {string} room       - ChatMessage room
	 * @prop {string} room_type  - ChatMessage room_type ("Direct", "Group" or "Visitor")
	 * @prop {string} content    - ChatMessage content
	 * @prop {frappe.datetime.datetime} creation - ChatMessage creation
	 *
	 * @prop {boolean} groupable - Whether the ChatMessage is groupable.
	 */
	frappe.chat.component.ChatList.Item
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			var me        = props.user === frappe.session.user;
			var content   = props.content;

			return (
				h("div",{class: "chat-list-item list-group-item"},
					props.type === "Notification" ?
						h("div",{class:"chat-list-notification"},
							h("div",{class:"chat-list-notification-content"},
								content
							)
						)
						:
						h("div",{class:("" + (me ? "text-right" : ""))},
							props.room_type === "Group" && !me ?
								h(frappe.components.Avatar, {
									title: frappe.user.full_name(props.user),
									image: frappe.user.image(props.user)
								}) : null,
							h(frappe.chat.component.ChatBubble, props)
						)
				)
			)
		}
	};

	/**
	 * @description ChatBubble Component
	 *
	 * @prop {string} name       - ChatMessage name
	 * @prop {string} user       - ChatMessage user
	 * @prop {string} room       - ChatMessage room
	 * @prop {string} room_type  - ChatMessage room_type ("Direct", "Group" or "Visitor")
	 * @prop {string} content    - ChatMessage content
	 * @prop {frappe.datetime.datetime} creation - ChatMessage creation
	 *
	 * @prop {boolean} groupable - Whether the ChatMessage is groupable.
	 */
	frappe.chat.component.ChatBubble
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.onclick = this.onclick.bind(this);
		}

		onclick ( ) {
			var ref = this;
			var props = ref.props;
			if ( props.user === frappe.session.user ) {
				frappe.quick_edit("Chat Message", props.name, function (values) {

				});
			}
		}

		render  ( ) {
			var ref = this;
			var props = ref.props;
			var creation 	= props.creation.format('hh:mm A');

			var me        = props.user === frappe.session.user;
			var read      = !frappe._.is_empty(props.seen) && !props.seen.includes(frappe.session.user);

			var content   = props.content;

			return (
				h("div",{class:("chat-bubble " + (props.groupable ? "chat-groupable" : "") + " chat-bubble-" + (me ? "r" : "l")),
					onclick: this.onclick},
					props.room_type === "Group" && !me ?
						h("div",{class:"chat-bubble-author"},
						h("a", { onclick: function () { frappe.set_route('Form', 'User', props.user); } },
							frappe.user.full_name(props.user)
						)
						) : null,
					h("div",{class:"chat-bubble-content"},
							h("small","",
								props.type === "File" ?
									h("a", { class: "no-decoration", href: content.path, target: "_blank" },
										h(frappe.components.FontAwesome, { type: "file", fixed: true }), (" " + (content.name))
									)
									:
									content
							)
					),
					h("div",{class:"chat-bubble-meta"},
						h("span",{class:"chat-bubble-creation"},creation),
						me && read ?
							h("span",{class:"chat-bubble-check"},
								h(frappe.components.Octicon,{type:"check"})
							) : null
					)
				)
			)
		}
	};

	/**
	 * @description ChatForm Component
	 */
	frappe.chat.component.ChatForm
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.onchange   = this.onchange.bind(this);
			this.onsubmit   = this.onsubmit.bind(this);

			this.hint        = this.hint.bind(this);

			this.state       = frappe.chat.component.ChatForm.defaultState;
		}

		onchange (e) {
			var obj;

			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var value            = e.target.value;

			this.set_state(( obj = {}, obj[e.target.name] = value, obj ));

			props.onchange(state);

			this.hint(value);
		}

		hint (value) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			if ( props.hint ) {
				var tokens =  value.split(" ");
				var sliced = tokens.slice(0, tokens.length - 1);

				var token  = tokens[tokens.length - 1];

				if ( token ) {
					props.hint   = frappe._.as_array(props.hint);
					var hint   = props.hint.find(function (hint) { return hint.match.test(token); });

					if ( hint ) {
						hint.search(token, function (items) {
							var hints = items.map(function (item) {
								// You should stop writing one-liners! >_>
								var replace = token.replace(hint.match, hint.content ? hint.content(item) : item);
								var content = ((sliced.join(" ")) + " " + replace).trim();
								item          = { component: hint.component(item), content: content };

								return item
							}).slice(0, hint.max || 5);

							this$1.set_state({ hints: hints });
						});
					}
					else
						{ this.set_state({ hints: [ ] }); }
				} else
					{ this.set_state({ hints: [ ] }); }
			}
		}

		onsubmit (e) {
			e.preventDefault();

			if ( this.state.content ) {
				this.props.onsubmit(this.state.content);

				this.set_state({ content: null });
			}
		}

		render ( ) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			return (
				h("div",{class:"chat-form"},
					state.hints.length ?
						h("ul", { class: "hint-list list-group" },
							state.hints.map(function (item) {
								return (
									h("li", { class: "hint-list-item list-group-item" },
										h("a", { href: "javascript:void(0)", onclick: function () {
											this$1.set_state({ content: item.content, hints: [ ] });
										}},
											item.component
										)
									)
								)
							})
						) : null,
					h("form", { oninput: this.onchange, onsubmit: this.onsubmit },
						h("div",{class:"input-group input-group-lg"},
							!frappe._.is_empty(props.actions) ?
								h("div",{class:"input-group-btn dropup"},
									h(frappe.components.Button,{ class: (frappe.session.user === "Guest" ? "disabled" : "dropdown-toggle"), "data-toggle": "dropdown"},
										h(frappe.components.FontAwesome, { class: "text-muted", type: "paperclip", fixed: true })
									),
									h("div",{ class:"dropdown-menu dropdown-menu-left", onclick: function (e) { return e.stopPropagation(); } },
										!frappe._.is_empty(props.actions) && props.actions.map(function (action) {
											return (
												h("li", null,
													h("a",{onclick:action.onclick},
														h(frappe.components.FontAwesome,{type:action.icon,fixed:true}), (" " + (action.label))
													)
												)
											)
										})
									)
								) : null,
							h("textarea", {
										class: "form-control",
										 name: "content",
										value: state.content,
								  placeholder: "Type a message",
									autofocus: true,
								   onkeypress: function (e) {
										if ( e.which === frappe.ui.keycode.RETURN && !e.shiftKey )
											{ this$1.onsubmit(e); }
								   }
							}),
							h("div",{class:"input-group-btn"},
								h(frappe.components.Button, { onclick: this.onsubmit },
									h(frappe.components.FontAwesome, { class: !frappe._.is_empty(state.content) ? "text-primary" : "text-muted", type: "send", fixed: true })
								)
							)
						)
					)
				)
			)
		}
	};
	frappe.chat.component.ChatForm.defaultState
	=
	{
		content: null,
		  hints: [ ],
	};

	/**
	 * @description EmojiPicker Component
	 *
	 * @todo Under Development
	 */
	frappe.chat.component.EmojiPicker
	=
	class extends Component  {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h("div", { class: ("frappe-chat-emoji dropup " + (props.class)) },
					h(frappe.components.Button, { type: "primary", class: "dropdown-toggle", "data-toggle": "dropdown" },
						h(frappe.components.FontAwesome, { type: "smile-o", fixed: true })
					),
					h("div", { class: "dropdown-menu dropdown-menu-right", onclick: function (e) { return e.stopPropagation(); } },
						h("div", { class: "panel panel-default" },
							h(frappe.chat.component.EmojiPicker.List)
						)
					)
				)
			)
		}
	};
	frappe.chat.component.EmojiPicker.List
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h("div", { class: "list-group" }

				)
			)
		}
	};

	/**
	 * @description Python equivalent to sys.platform
	 */
	frappe.provide('frappe._');
	frappe._.platform   = function () {
		var string    = navigator.appVersion;

		if ( string.includes("Win") ) 	{ return "Windows" }
		if ( string.includes("Mac") ) 	{ return "Darwin" }
		if ( string.includes("X11") ) 	{ return "UNIX" }
		if ( string.includes("Linux") ) { return "Linux" }

		return undefined
	};

	/**
	 * @description Frappe's Asset Helper
	 */
	frappe.provide('frappe.assets');
	frappe.assets.image = function (image, app) {
		if ( app === void 0 ) app = 'frappe';

		var  path     = "/assets/" + app + "/images/" + image;
		return path
	};

	/**
	 * @description Notify using Web Push Notifications
	 */
	frappe.provide('frappe.boot');
	frappe.provide('frappe.browser');
	frappe.browser.Notification = 'Notification' in window;

	frappe.notify     = function (string, options) {
		frappe.log    = frappe.Logger.get('frappe.notify');

		var OPTIONS = {
			icon: frappe.assets.image('favicon.png', 'frappe'),
			lang: frappe.boot.lang || "en"
		};
		options       = Object.assign({ }, OPTIONS, options);

		if ( !frappe.browser.Notification )
			{ frappe.log.error('ERROR: This browser does not support desktop notifications.'); }

		Notification.requestPermission(function (status) {
			if ( status === "granted" ) {
				var notification = new Notification(string, options);
			}
		});
	};

	frappe.chat.render = function (render, force) {
		if ( render === void 0 ) render = true;
		if ( force === void 0 ) force = false;

		frappe.log.info(((render ? "Enable" : "Disable") + " Chat for User."));

		var desk = 'desk' in frappe;
		if ( desk ) {
			// With the assumption, that there's only one navbar.
			var $placeholder = $('.navbar .frappe-chat-dropdown');

			if ( render ) {
				$placeholder.removeClass('hidden');
			} else {
				$placeholder.addClass('hidden');
			}
		}

		// Avoid re-renders. Once is enough.
		if ( !frappe.chatter || force ) {
			frappe.chatter = new frappe.Chat({
				target: desk ? '.frappe-chat-toggle' : null
			});

			if ( render ) {
				if ( frappe.session.user === 'Guest' && !desk ) {
					frappe.store = frappe.Store.get('frappe.chat');
					var token	 = frappe.store.get('guest_token');

					frappe.log.info(("Local Guest Token - " + token));

					var setup_room = function (token) {
						return new Promise(function (resolve) {
							frappe.chat.room.create("Visitor", token).then(function (room) {
								frappe.log.info(("Visitor Room Created: " + (room.name)));
								frappe.chat.room.subscribe(room.name);

								var reference = room;

								frappe.chat.room.history(room.name).then(function (messages) {
									var  room = Object.assign({}, reference, {messages: messages});
									return room
								}).then(function (room) {
									resolve(room);
								});
							});
						})
					};

					if ( !token ) {
						frappe.chat.website.token().then(function (token) {
							frappe.log.info(("Generated Guest Token - " + token));
							frappe.store.set('guest_token', token);

							setup_room(token).then(function (room) {
								frappe.chatter.render({ room: room });
							});
						});
					} else {
						setup_room(token).then(function (room) {
							frappe.chatter.render({ room: room });
						});
					}
				} else {
					frappe.chatter.render();
				}
			}
		}
	};

	frappe.chat.setup  = function () {
		frappe.log     = frappe.Logger.get('frappe.chat');

		frappe.log.info('Setting up frappe.chat');
		frappe.log.warn('TODO: frappe.chat.<object> requires a storage.');

		if ( frappe.session.user !== 'Guest' ) {
			// Create/Get Chat Profile for session User, retrieve enable_chat
			frappe.log.info('Creating a Chat Profile.');

			frappe.chat.profile.create('enable_chat').then(function (ref) {
				var enable_chat = ref.enable_chat;

				frappe.log.info(("Chat Profile created for User " + (frappe.session.user) + "."));

				if ( 'desk' in frappe && frappe.sys_defaults ) { // same as desk?
					var should_render = Boolean(parseInt(frappe.sys_defaults.enable_chat)) && enable_chat;
					frappe.chat.render(should_render);
				}
			});

			// Triggered when a User updates his/her Chat Profile.
			// Don't worry, enable_chat is broadcasted to this user only. No overhead. :)
			frappe.chat.profile.on.update(function (user, profile) {
				if ( user === frappe.session.user && 'enable_chat' in profile ) {
					frappe.log.warn(("Chat Profile update (Enable Chat - " + (Boolean(profile.enable_chat)) + ")"));
					var should_render = Boolean(parseInt(frappe.sys_defaults.enable_chat)) && profile.enable_chat;
					frappe.chat.render(should_render);
				}
			});
		} else {
			// Website Settings
			frappe.log.info('Retrieving Chat Website Settings.');
			frappe.chat.website.settings(["socketio", "enable", "enable_from", "enable_to"])
				.then(function (settings) {
					frappe.log.info(("Chat Website Setting - " + (JSON.stringify(settings))));
					frappe.log.info(("Chat Website Setting - " + (settings.enable ? "Enable" : "Disable")));

					var should_render = settings.enable;
					if ( settings.enable_from && settings.enable_to ) {
						frappe.log.info(("Enabling Chat Schedule - " + (settings.enable_from.format()) + " : " + (settings.enable_to.format())));

						var range   = new frappe.datetime.range(settings.enable_from, settings.enable_to);
						should_render = range.contains(frappe.datetime.now());
					}

					if ( should_render ) {
						frappe.log.info("Initializing Socket.IO");
						frappe.socketio.init(settings.socketio.port);
					}

					frappe.chat.render(should_render);
			});
		}
	};

	// TODO: Re-enable after re-designing chat
	// $(document).on('ready toolbar_setup', () =>
	// {
	// 	frappe.chat.setup()
	// })

	// Copyright (c) 2019, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.energy_points');

	Object.assign(frappe.energy_points, {
		get_points: function get_points(points) {
			return ("<span class=\"bold\" style=\"color: " + (points >= 0 ? '#45A163' : '#e42121') + "\">\n\t\t\t" + (points > 0 ? '+' : '') + points + "\n\t\t</span>");
		},
		format_form_log: function format_form_log(log) {
			var separator = "<span>&nbsp;-&nbsp;</span>";
			var formatted_log = "<span>\n\t\t\t<!--" + (this.get_points(log.points)) + "&nbsp;-->\n\t\t\t<a href=\"/app/energy-point-log/" + (log.name) + "\">" + (this.get_form_log_message(log)) + "</a>\n\t\t\t" + (log.reason ? separator + log.reason : '') + "\n\t\t</span>";
			return formatted_log;
		},
		format_history_log: function format_history_log(log) {
			// redundant code to honor readability and to avoid confusion
			var separator = "<span>&nbsp;-&nbsp;</span>";
			var route = frappe.utils.get_form_link(log.reference_doctype, log.reference_name);
			var formatted_log = "<div class=\"flex\">\n\t\t\t<span class=\"" + (log.points >= 0 ? 'green' : 'red') + " mr-2\">\n\t\t\t\t" + (this.get_points(log.points)) + "\n\t\t\t</span>\n\t\t\t<a href=\"" + route + "\" class=\"text-muted\">" + (this.get_history_log_message(log)) + "</a>\n\t\t\t" + (log.reason ? separator + log.reason : '') + "\n\t\t\t" + (separator + frappe.datetime.comment_when(log.creation)) + "\n\t\t</div>";
			return formatted_log;
		},
		get_history_log_message: function get_history_log_message(log) {
			var owner_name = frappe.user.full_name(log.owner).bold();
			var ref_doc = log.reference_name;

			if (log.type === 'Appreciation') {
				return __('{0} appreciated on {1}', [owner_name, ref_doc]);
			}
			if (log.type === 'Criticism') {
				return __('{0} criticized on {1}', [owner_name, ref_doc]);
			}
			if (log.type === 'Revert') {
				return __('{0} reverted {1}', [owner_name, log.revert_of]);
			}
			return __('via automatic rule {0} on {1}', [log.rule.bold(), ref_doc]);
		},
		get_form_log_message: function get_form_log_message(log) {
			// redundant code to honor readability and to avoid confusion
			var owner_name = frappe.user.full_name(log.owner).bold();
			var user = frappe.user.full_name(log.user).bold();
			if (log.type === 'Appreciation') {
				return __('{0} appreciated {1}', [owner_name, user]);
			}
			if (log.type === 'Criticism') {
				return __('{0} criticized {1}', [owner_name, user]);
			}
			if (log.type === 'Revert') {
				return __('{0} reverted {1}', [owner_name, log.revert_of]);
			}
			return __('gained by {0} via automatic rule {1}', [user, log.rule.bold()]);
		},
	});

	frappe.dashboard_utils = {
		render_chart_filters: function(filters, button_class, container, append) {
			filters.forEach(function (filter) {
				var icon_html = '', filter_class = '';

				if (filter.icon) {
					icon_html = frappe.utils.icon(filter.icon);
				}

				if (filter.class) {
					filter_class = filter.class;
				}

				var chart_filter_html =
					"<div class=\"" + button_class + " " + filter_class + " btn-group dropdown pull-right\">\n\t\t\t\t\t<a data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t\t\t<button class=\"btn btn-secondary btn-xs\">\n\t\t\t \t\t\t\t" + icon_html + "\n\t\t\t\t\t\t\t<span class=\"filter-label\">" + (filter.label) + "</span>\n\t\t\t\t\t\t\t" + (frappe.utils.icon('select', 'xs')) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t</a>";
				var options_html;

				if (filter.fieldnames) {
					options_html = filter.options.map(function (option, i) { return ("<li>\n\t\t\t\t\t\t<a class=\"dropdown-item\" data-fieldname=\"" + (filter.fieldnames[i]) + "\">" + option + "</a>\n\t\t\t\t\t</li>"); }).join('');
				} else {
					options_html = filter.options.map( function (option) { return ("<li><a class=\"dropdown-item\">" + option + "</a></li>"); }).join('');
				}

				var dropdown_html = chart_filter_html + "<ul class=\"dropdown-menu\">" + options_html + "</ul></div>";
				var $chart_filter = $(dropdown_html);

				if (append) {
					$chart_filter.prependTo(container);
				} else { $chart_filter.appendTo(container); }

				$chart_filter.find('.dropdown-menu').on('click', 'li a', function (e) {
					var $el = $(e.currentTarget);
					var fieldname;
					if ($el.attr('data-fieldname')) {
						fieldname = $el.attr('data-fieldname');
					}

					var selected_item = $el.text();
					$el.parents(("." + button_class)).find('.filter-label').text(selected_item);
					filter.action(selected_item, fieldname);
				});
			});

		},

		get_filters_for_chart_type: function(chart) {
			if (chart.chart_type === 'Custom' && chart.source) {
				var method = 'frappe.desk.doctype.dashboard_chart_source.dashboard_chart_source.get_config';
				return frappe.xcall(method, {name: chart.source}).then(function (config) {
					frappe.dom.eval(config);
					return frappe.dashboards.chart_sources[chart.source].filters;
				});
			} else if (chart.chart_type === 'Report' && chart.report_name) {
				return frappe.report_utils.get_report_filters(chart.report_name).then(function (filters) {
					return filters;
				});
			} else {
				return Promise.resolve();
			}
		},

		get_dashboard_settings: function get_dashboard_settings() {
			var this$1 = this;

			return frappe.db.get_list('Dashboard Settings', {
				filters: {
					name: frappe.session.user
				},
				fields: ['*']
			}).then(function (settings) {
				if (!settings.length) {
					return this$1.create_dashboard_settings().then(function (settings) {
						return settings;
					});
				} else {
					return settings[0];
				}
			});
		},

		create_dashboard_settings: function create_dashboard_settings() {
			return frappe.xcall(
				'frappe.desk.doctype.dashboard_settings.dashboard_settings.create_dashboard_settings',
				{
					user: frappe.session.user
				}
			).then(function (settings) {
				return settings;
			});
		},

		get_years_since_creation: function get_years_since_creation(creation) {
			//Get years since user account created
			var creation_year = this.get_year(creation);
			var current_year = this.get_year(frappe.datetime.now_date());
			var years_list = [];
			for (var year = current_year; year >= creation_year; year--) {
				years_list.push(year);
			}
			return years_list;
		},

		get_year: function get_year(date_str) {
			return date_str.substring(0, date_str.indexOf('-'));
		},

		remove_common_static_filter_values: function remove_common_static_filter_values(static_filters, dynamic_filters) {
			if (dynamic_filters) {
				if ($.isArray(static_filters)) {
					static_filters = static_filters.filter(function (static_filter) {
						for (var i = 0, list = dynamic_filters; i < list.length; i += 1) {
							var dynamic_filter = list[i];

							if (static_filter[0] == dynamic_filter[0]
								&& static_filter[1] == dynamic_filter[1]) {
								return false;
							}
						}
						return true;
					});
				} else {
					for (var i = 0, list = Object.keys(dynamic_filters); i < list.length; i += 1) {
						var key = list[i];

						delete static_filters[key];
					}
				}
			}

			return static_filters;
		},

		get_fields_for_dynamic_filter_dialog: function get_fields_for_dynamic_filter_dialog(is_document_type, filters, dynamic_filters) {
			var fields = [
				{
					fieldtype: 'HTML',
					fieldname: 'description',
					options:
						"<div>\n\t\t\t\t\t\t<p>Set dynamic filter values in JavaScript for the required fields here.\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p>Ex:\n\t\t\t\t\t\t\t<code>frappe.defaults.get_user_default(\"Company\")</code>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>"
				}
			];

			if (is_document_type) {
				if (dynamic_filters) {
					filters = filters.concat( dynamic_filters);
				}
				filters.forEach(function (f) {
					for (var i = 0, list = fields; i < list.length; i += 1) {
						var field = list[i];

						if (field.fieldname == f[0] + ':' + f[1]) {
							return;
						}
					}
					if (f[2] == '=') {
						fields.push({
							label: ((f[1]) + " (" + (f[0]) + ")"),
							fieldname: f[0] + ':' + f[1],
							fieldtype: 'Data',
						});
					}
				});
			} else {
				filters = Object.assign({}, dynamic_filters, filters);
				for (var i = 0, list = Object.keys(filters); i < list.length; i += 1) {
					var key = list[i];

					fields.push({
						label: key,
						fieldname: key,
						fieldtype: 'Data',
					});
				}
			}

			return fields;
		},

		get_all_filters: function get_all_filters(doc) {
			var filters = JSON.parse(doc.filters_json || "null");
			var dynamic_filters = JSON.parse(doc.dynamic_filters_json || "null");

			if (!dynamic_filters) {
				return filters;
			}

			if ($.isArray(dynamic_filters)) {
				dynamic_filters.forEach(function (f) {
					try {
						f[3] = eval(f[3]);
					} catch (e) {
						frappe.throw(__("Invalid expression set in filter {0} ({1})", [f[1], f[0]]));
					}
				});
				filters = filters.concat( dynamic_filters);
			} else {
				for (var i = 0, list = Object.keys(dynamic_filters); i < list.length; i += 1) {
					var key = list[i];

					try {
						var val = eval(dynamic_filters[key]);
						dynamic_filters[key] = val;
					} catch (e) {
						frappe.throw(__("Invalid expression set in filter {0}", [key]));
					}
				}
				Object.assign(filters, dynamic_filters);
			}

			return filters;
		},

		get_dashboard_link_field: function get_dashboard_link_field() {
			var field = {
				label: __('Select Dashboard'),
				fieldtype: 'Link',
				fieldname: 'dashboard',
				options: 'Dashboard',
			};

			if (!frappe.boot.developer_mode) {
				field.get_query = function () {
					return {
						filters: {
							is_standard: 0
						}
					};
				};
			}

			return field;
		},

		get_add_to_dashboard_dialog: function get_add_to_dashboard_dialog(docname, doctype, method) {
			var field = this.get_dashboard_link_field();

			var dialog = new frappe.ui.Dialog({
				title: __('Add to Dashboard'),
				fields: [field],
				primary_action: function (values) {
					values.name = docname;
					values.set_standard = frappe.boot.developer_mode;
					frappe.xcall(
						method,
						{args: values}
					).then(function (){
						var dashboard_route_html =
							"<a href = \"#dashboard/" + (values.dashboard) + "\">" + (values.dashboard) + "</a>";
						var message =
							__("{0} {1} added to Dashboard {2}", [doctype, values.name, dashboard_route_html]);

						frappe.msgprint(message);
					});

					dialog.hide();
				}
			});

			return dialog;
		}

	};

	function t(e){return (t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}function e(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function n(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}function i(t,e,i){return e&&n(t.prototype,e),i&&n(t,i),t}function a(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function"); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&r(t,e);}function s(t){return (s=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function r(t,e){return (r=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function o(t,e){return !e||"object"!=typeof e&&"function"!=typeof e?function(t){if(void 0===t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return t}(t):e}function l(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct){ return !1; }if(Reflect.construct.sham){ return !1; }if("function"==typeof Proxy){ return !0; }try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return !1}}();return function(){var n,i=s(t);if(e){var a=s(this).constructor;n=Reflect.construct(i,arguments,a);}else { n=i.apply(this,arguments); }return o(this,n)}}function c(t,e,n){return (c="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var i=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=s(t));){ }return t}(t,e);if(i){var a=Object.getOwnPropertyDescriptor(i,e);return a.get?a.get.call(n):a.value}})(t,e,n||t)}function u(t,e){return function(t){if(Array.isArray(t)){ return t }}(t)||function(t,e){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(t))){ return; }var n=[],i=!0,a=!1,s=void 0;try{for(var r,o=t[Symbol.iterator]();!(i=(r=o.next()).done)&&(n.push(r.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,s=t;}finally{try{i||null==o.return||o.return();}finally{if(a){ throw s }}}return n}(t,e)||d(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function h$1(t){return function(t){if(Array.isArray(t)){ return p(t) }}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t)){ return Array.from(t) }}(t)||d(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function d(t,e){if(t){if("string"==typeof t){ return p(t,e); }var n=Object.prototype.toString.call(t).slice(8,-1);return "Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?p(t,e):void 0}}function p(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++){ i[n]=t[n]; }return i}function f(t,e){return "string"==typeof t?(e||document).querySelector(t):t||null}function v(t){var e=t.getBoundingClientRect();return {top:e.top+(document.documentElement.scrollTop||document.body.scrollTop),left:e.left+(document.documentElement.scrollLeft||document.body.scrollLeft)}}function g(t){return null===t.offsetParent}function m(t){var e=t.getBoundingClientRect();return e.top>=0&&e.left>=0&&e.bottom<=(window.innerHeight||document.documentElement.clientHeight)&&e.right<=(window.innerWidth||document.documentElement.clientWidth)}!function(t,e){void 0===e&&(e={});var n=e.insertAt;if(t&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===n&&i.firstChild?i.insertBefore(a,i.firstChild):i.appendChild(a),a.styleSheet?a.styleSheet.cssText=t:a.appendChild(document.createTextNode(t));}}(':root {\n  --charts-label-color: #313b44;\n  --charts-axis-line-color: #f4f5f6;\n  --charts-tooltip-title: var(--charts-label-color);\n  --charts-tooltip-label: var(--charts-label-color);\n  --charts-tooltip-value: #192734;\n  --charts-tooltip-bg: #ffffff;\n  --charts-stroke-width: 2px;\n  --charts-dataset-circle-stroke: #ffffff;\n  --charts-dataset-circle-stroke-width: var(--charts-stroke-width);\n  --charts-legend-label: var(--charts-label-color);\n  --charts-legend-value: var(--charts-label-color); }\n\n.chart-container {\n  position: relative;\n  /* for absolutely positioned tooltip */\n  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif; }\n  .chart-container .axis,\n  .chart-container .chart-label {\n    fill: var(--charts-label-color); }\n    .chart-container .axis line,\n    .chart-container .chart-label line {\n      stroke: var(--charts-axis-line-color); }\n  .chart-container .dataset-units circle {\n    stroke: var(--charts-dataset-circle-stroke);\n    stroke-width: var(--charts-dataset-circle-stroke-width); }\n  .chart-container .dataset-units path {\n    fill: none;\n    stroke-opacity: 1;\n    stroke-width: var(--charts-stroke-width); }\n  .chart-container .dataset-path {\n    stroke-width: var(--charts-stroke-width); }\n  .chart-container .path-group path {\n    fill: none;\n    stroke-opacity: 1;\n    stroke-width: var(--charts-stroke-width); }\n  .chart-container line.dashed {\n    stroke-dasharray: 5, 3; }\n  .chart-container .axis-line .specific-value {\n    text-anchor: start; }\n  .chart-container .axis-line .y-line {\n    text-anchor: end; }\n  .chart-container .axis-line .x-line {\n    text-anchor: middle; }\n  .chart-container .legend-dataset-label {\n    fill: var(--charts-legend-label);\n    font-weight: 600; }\n  .chart-container .legend-dataset-value {\n    fill: var(--charts-legend-value); }\n\n.graph-svg-tip {\n  position: absolute;\n  z-index: 99999;\n  padding: 10px;\n  font-size: 12px;\n  text-align: center;\n  background: var(--charts-tooltip-bg);\n  box-shadow: 0px 1px 4px rgba(17, 43, 66, 0.1), 0px 2px 6px rgba(17, 43, 66, 0.08), 0px 40px 30px -30px rgba(17, 43, 66, 0.1);\n  border-radius: 6px; }\n  .graph-svg-tip ul {\n    padding-left: 0;\n    display: flex; }\n  .graph-svg-tip ol {\n    padding-left: 0;\n    display: flex; }\n  .graph-svg-tip ul.data-point-list li {\n    min-width: 90px;\n    font-weight: 600; }\n  .graph-svg-tip .svg-pointer {\n    position: absolute;\n    height: 12px;\n    width: 12px;\n    border-radius: 2px;\n    background: var(--charts-tooltip-bg);\n    transform: rotate(45deg);\n    margin-top: -7px;\n    margin-left: -6px; }\n  .graph-svg-tip.comparison {\n    text-align: left;\n    padding: 0px;\n    pointer-events: none; }\n    .graph-svg-tip.comparison .title {\n      display: block;\n      padding: 16px;\n      margin: 0;\n      color: var(--charts-tooltip-title);\n      font-weight: 600;\n      line-height: 1;\n      pointer-events: none;\n      text-transform: uppercase; }\n      .graph-svg-tip.comparison .title strong {\n        color: var(--charts-tooltip-value); }\n    .graph-svg-tip.comparison ul {\n      margin: 0;\n      white-space: nowrap;\n      list-style: none; }\n      .graph-svg-tip.comparison ul.tooltip-grid {\n        display: grid;\n        grid-template-columns: repeat(4, minmax(0, 1fr));\n        gap: 5px; }\n    .graph-svg-tip.comparison li {\n      display: inline-block;\n      display: flex;\n      flex-direction: row;\n      font-weight: 600;\n      line-height: 1;\n      padding: 5px 15px 15px 15px; }\n      .graph-svg-tip.comparison li .tooltip-legend {\n        height: 12px;\n        width: 12px;\n        margin-right: 8px;\n        border-radius: 2px; }\n      .graph-svg-tip.comparison li .tooltip-label {\n        margin-top: 4px;\n        font-size: 11px;\n        line-height: 1.25;\n        max-width: 150px;\n        white-space: normal;\n        color: var(--charts-tooltip-label); }\n      .graph-svg-tip.comparison li .tooltip-value {\n        color: var(--charts-tooltip-value); }\n'),f.create=function(e,n){var i=document.createElement(e);for(var a in n){var s=n[a];if("inside"===a){ f(s).appendChild(i); }else if("around"===a){var r=f(s);r.parentNode.insertBefore(i,r),i.appendChild(r);}else{ "styles"===a?"object"===t(s)&&Object.keys(s).map((function(t){i.style[t]=s[t];})):a in i?i[a]=s:i.setAttribute(a,s); }}return i};var y={margins:{top:10,bottom:10,left:20,right:20},paddings:{top:20,bottom:40,left:30,right:10},baseHeight:240,titleHeight:20,legendHeight:30,titleFontSize:12};function b(t){return t.titleHeight+t.margins.top+t.paddings.top}function x(t){return t.margins.left+t.paddings.left}function k(t){return t.margins.top+t.margins.bottom+t.paddings.top+t.paddings.bottom+t.titleHeight+t.legendHeight}function w(t){return t.margins.left+t.margins.right+t.paddings.left+t.paddings.right}var A=["pink","blue","green","grey","red","yellow","purple","teal","cyan","orange"],D={bar:A,line:A,pie:A,percentage:A,heatmap:["#ebedf0","#c6e48b","#7bc96f","#239a3b","#196127"],donut:A},L=Math.PI/180,M=function(){function t(n){var i=n.parent,a=void 0===i?null:i,s=n.colors,r=void 0===s?[]:s;e(this,t),this.parent=a,this.colors=r,this.titleName="",this.titleValue="",this.listValues=[],this.titleValueFirst=0,this.x=0,this.y=0,this.top=0,this.left=0,this.setup();}return i(t,[{key:"setup",value:function(){this.makeTooltip();}},{key:"refresh",value:function(){this.fill(),this.calcPosition();}},{key:"makeTooltip",value:function(){var t=this;this.container=f.create("div",{inside:this.parent,className:"graph-svg-tip comparison",innerHTML:'<span class="title"></span>\n\t\t\t\t<ul class="data-point-list"></ul>\n\t\t\t\t<div class="svg-pointer"></div>'}),this.hideTip(),this.title=this.container.querySelector(".title"),this.list=this.container.querySelector(".data-point-list"),this.dataPointList=this.container.querySelector(".data-point-list"),this.parent.addEventListener("mouseleave",(function(){t.hideTip();}));}},{key:"fill",value:function(){var t,e=this;this.index&&this.container.setAttribute("data-point-index",this.index),t=this.titleValueFirst?"<strong>".concat(this.titleValue,"</strong>").concat(this.titleName):"".concat(this.titleName,"<strong>").concat(this.titleValue,"</strong>"),this.listValues.length>4?this.list.classList.add("tooltip-grid"):this.list.classList.remove("tooltip-grid"),this.title.innerHTML=t,this.dataPointList.innerHTML="",this.listValues.map((function(t,n){var i=e.colors[n]||"black",a=0===t.formatted||t.formatted?t.formatted:t.value,s=f.create("li",{innerHTML:'<div class="tooltip-legend" style="background: '.concat(i,';"></div>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<div class="tooltip-value">').concat(0===a||a?a:"",'</div>\n\t\t\t\t\t\t<div class="tooltip-label">').concat(t.title?t.title:"","</div>\n\t\t\t\t\t</div>")});e.dataPointList.appendChild(s);}));}},{key:"calcPosition",value:function(){var t=this.container.offsetWidth;this.top=this.y-this.container.offsetHeight-7.48,this.left=this.x-t/2;var e=this.parent.offsetWidth-t,n=this.container.querySelector(".svg-pointer");if(this.left<0){ n.style.left="calc(50% - ".concat(-1*this.left,"px)"),this.left=0; }else if(this.left>e){var i=this.left-e,a="calc(50% + ".concat(i,"px)");n.style.left=a,this.left=e;}else { n.style.left="50%"; }}},{key:"setValues",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1;this.titleName=n.name,this.titleValue=n.value,this.listValues=i,this.x=t,this.y=e,this.titleValueFirst=n.valueFirst||0,this.index=a,this.refresh();}},{key:"hideTip",value:function(){this.container.style.top="0px",this.container.style.left="0px",this.container.style.opacity="0";}},{key:"showTip",value:function(){this.container.style.top=this.top+"px",this.container.style.left=this.left+"px",this.container.style.opacity="1";}}]),t}();function T(t){return parseFloat(t.toFixed(2))}function C(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];n||(n=i?t[0]:t[t.length-1]);var a=new Array(Math.abs(e)).fill(n);return t=i?a.concat(t):t.concat(a)}function P(t,e){return (t+"").length*e}function N(t,e){return {x:Math.sin(t*L)*e,y:Math.cos(t*L)*e}}function E(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return !Number.isNaN(t)&&(void 0!==t&&(!!Number.isFinite(t)&&!(e&&t<0)))}function O(t){return Number(Math.round(t+"e4")+"e-4")}function S(e){var n,i,a;if(e instanceof Date){ return new Date(e.getTime()); }if("object"!==t(e)||null===e){ return e; }for(a in n=Array.isArray(e)?[]:{},e){ i=e[a],n[a]=S(i); }return n}function F(t,e){var n,i;return t<=e?(n=e-t,i=t):(n=t-e,i=e),[n,i]}function z(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.length-t.length;return n>0?t=C(t,n):e=C(e,n),[t,e]}function H(t,e){if(t){ return t.length>e?t.slice(0,e-3)+"...":t }}function R(t){var e;if("number"==typeof t){ e=t; }else if("string"==typeof t&&(e=Number(t),Number.isNaN(e))){ return t; }var n=Math.floor(Math.log10(Math.abs(e)));if(n<=2){ return e; }var i=Math.floor(n/3),a=Math.pow(10,n-3*i)*+(e/Math.pow(10,n)).toFixed(1);return Math.round(100*a)/100+" "+["","K","M","B","T"][i]}function W(t,e){for(var n=[],i=0;i<t.length;i++){ n.push([t[i],e[i]]); }var a=function(t,e,n,i){var a,s,r,o,l=(a=e||t,r=(s=n||t)[0]-a[0],o=s[1]-a[1],{length:Math.sqrt(Math.pow(r,2)+Math.pow(o,2)),angle:Math.atan2(o,r)}),c=l.angle+(i?Math.PI:0),u=.2*l.length;return [t[0]+Math.cos(c)*u,t[1]+Math.sin(c)*u]};return function(t,e){return t.reduce((function(t,n,i,a){return 0===i?"".concat(n[0],",").concat(n[1]):"".concat(t," ").concat(e(n,i,a))}),"")}(n,(function(t,e,n){var i=a(n[e-1],n[e-2],t),s=a(t,n[e-1],n[e+1],!0);return "C ".concat(i[0],",").concat(i[1]," ").concat(s[0],",").concat(s[1]," ").concat(t[0],",").concat(t[1])}))}function j(t,e){return "string"==typeof t?(e||document).querySelector(t):t||null}function I(e,n){var i=document.createElementNS("http://www.w3.org/2000/svg",e);for(var a in n){var s=n[a];if("inside"===a){ j(s).appendChild(i); }else if("around"===a){var r=j(s);r.parentNode.insertBefore(i,r),i.appendChild(r);}else{ "styles"===a?"object"===t(s)&&Object.keys(s).map((function(t){i.style[t]=s[t];})):("className"===a&&(a="class"),"innerHTML"===a?i.textContent=s:i.setAttribute(a,s)); }}return i}function B(t,e){return I("linearGradient",{inside:t,id:e,x1:0,x2:0,y1:0,y2:1})}function Y(t,e,n,i){return I("stop",{inside:t,style:"stop-color: ".concat(n),offset:e,"stop-opacity":i})}function V(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,i={className:t,transform:e};return n&&(i.inside=n),I("g",i)}function U(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"none",i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2;return I("path",{className:e,d:t,styles:{stroke:n,fill:i,"stroke-width":a}})}function q(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=n.x+t.x,o=n.y+t.y,l=n.x+e.x,c=n.y+e.y;return "M".concat(n.x," ").concat(n.y,"\n\t\tL").concat(r," ").concat(o,"\n\t\tA ").concat(i," ").concat(i," 0 ").concat(s," ").concat(a?1:0,"\n\t\t").concat(l," ").concat(c," z")}function G(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=n.x+t.x,o=n.y+t.y,l=n.x+e.x,c=2*n.y,u=n.y+e.y;return "M".concat(n.x," ").concat(n.y,"\n\t\tL").concat(r," ").concat(o,"\n\t\tA ").concat(i," ").concat(i," 0 ").concat(s," ").concat(a?1:0,"\n\t\t").concat(l," ").concat(c," z\n\t\tL").concat(r," ").concat(c,"\n\t\tA ").concat(i," ").concat(i," 0 ").concat(s," ").concat(a?1:0,"\n\t\t").concat(l," ").concat(u," z")}function _(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=n.x+t.x,o=n.y+t.y,l=n.x+e.x,c=n.y+e.y;return "M".concat(r," ").concat(o,"\n\t\tA ").concat(i," ").concat(i," 0 ").concat(s," ").concat(a?1:0,"\n\t\t").concat(l," ").concat(c)}function X(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=n.x+t.x,o=n.y+t.y,l=n.x+e.x,c=2*i+o,u=n.y+t.y;return "M".concat(r," ").concat(o,"\n\t\tA ").concat(i," ").concat(i," 0 ").concat(s," ").concat(a?1:0,"\n\t\t").concat(l," ").concat(c,"\n\t\tM").concat(r," ").concat(c,"\n\t\tA ").concat(i," ").concat(i," 0 ").concat(s," ").concat(a?1:0,"\n\t\t").concat(l," ").concat(u)}function J(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i="path-fill-gradient-"+e+"-"+(n?"lighter":"default"),a=B(t,i),s=[1,.6,.2];return n&&(s=[.4,.05,0]),Y(a,"0%",e,s[0]),Y(a,"50%",e,s[1]),Y(a,"100%",e,s[2]),i}function K(t,e,n){var i=n/2,a=e-i;return "M".concat(t,",0 h").concat(a," q").concat(i,",0 ").concat(i,",").concat(i," q0,").concat(i," -").concat(i,",").concat(i," h-").concat(a," v").concat(n,"z")}function $$1(t,e,n){var i=n/2,a=e-i;return "M".concat(t+i,",0 h").concat(a," v").concat(n," h-").concat(a," q-").concat(i,", 0 -").concat(i,",-").concat(i," q0,-").concat(i," ").concat(i,",-").concat(i,"z")}function Q(t,e,n,i,a){var s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none",r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:{},o={className:t,x:e,y:n,width:i,height:i,rx:a,fill:s};return Object.keys(r).map((function(t){o[t]=r[t];})),I("rect",o)}function Z(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"none",s=arguments.length>5?arguments[5]:void 0,r=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];o||(o=10);var c={className:"legend-dot",x:0,y:4-n,height:n,width:n,rx:i,fill:a},u=I("text",{className:"legend-dataset-label",x:n,y:0,dx:o+"px",dy:o/3+"px","font-size":1.6*o+"px","text-anchor":"start",innerHTML:s=l?H(s,18):s}),h=null;r&&(h=I("text",{className:"legend-dataset-value",x:n,y:20,dx:"10px",dy:10/3+"px","font-size":"12px","text-anchor":"start",innerHTML:r}));var d=I("g",{transform:"translate(".concat(t,", ").concat(e,")")});return d.appendChild(I("rect",c)),d.appendChild(u),r&&h&&d.appendChild(h),d}function tt(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},s=a.fontSize||10,r=void 0!==a.dy?a.dy:s/2,o=a.fill||"var(--charts-label-color)",l=a.textAnchor||"start";return I("text",{className:t,x:e,y:n,dy:r+"px","font-size":s+"px",fill:o,"text-anchor":l,innerHTML:i})}function et(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},s=I("line",{className:"line-vertical "+a.className,x1:0,x2:0,y1:n,y2:i,styles:{stroke:a.stroke}}),r=I("text",{x:0,y:n>i?n+4:n-4-10,dy:"10px","font-size":"10px","text-anchor":"middle",innerHTML:e+""}),o=I("g",{transform:"translate(".concat(t,", 0)")});return o.appendChild(s),o.appendChild(r),o}function nt(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};a.lineType||(a.lineType=""),a.shortenNumbers&&(e=R(e));var s="line-horizontal "+a.className+("dashed"===a.lineType?"dashed":""),r=I("line",{className:s,x1:n,x2:i,y1:0,y2:0,styles:{stroke:a.stroke}}),o=I("text",{x:n<i?n-4:n+4,y:0,dy:"3px","font-size":"10px","text-anchor":n<i?"end":"start",innerHTML:e+""}),l=I("g",{transform:"translate(0, ".concat(t,")"),"stroke-opacity":1});return 0!==o&&"0"!==o||(l.style.stroke="rgba(27, 31, 35, 0.6)"),l.appendChild(r),l.appendChild(o),l}var it={bar:function(t){var e;"rect"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode();return n.style.fill="#000000",n.style.opacity="0.4",e&&n.setAttribute("transform",e),n},dot:function(t){var e;"circle"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode(),i=t.getAttribute("r"),a=t.getAttribute("fill");return n.setAttribute("r",parseInt(i)+4),n.setAttribute("fill",a),n.style.opacity="0.6",e&&n.setAttribute("transform",e),n},heat_square:function(t){var e;"circle"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode(),i=t.getAttribute("r"),a=t.getAttribute("fill");return n.setAttribute("r",parseInt(i)+4),n.setAttribute("fill",a),n.style.opacity="0.6",e&&n.setAttribute("transform",e),n}},at={bar:function(t,e){var n;"rect"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["x","y","width","height"];Object.values(t.attributes).filter((function(t){return i.includes(t.name)&&t.specified})).map((function(t){e.setAttribute(t.name,t.nodeValue);})),n&&e.setAttribute("transform",n);},dot:function(t,e){var n;"circle"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["cx","cy"];Object.values(t.attributes).filter((function(t){return i.includes(t.name)&&t.specified})).map((function(t){e.setAttribute(t.name,t.nodeValue);})),n&&e.setAttribute("transform",n);},heat_square:function(t,e){var n;"circle"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["cx","cy"];Object.values(t.attributes).filter((function(t){return i.includes(t.name)&&t.specified})).map((function(t){e.setAttribute(t.name,t.nodeValue);})),n&&e.setAttribute("transform",n);}},st={pink:"#F683AE",blue:"#318AD8",green:"#48BB74",grey:"#A6B1B9",red:"#F56B6B",yellow:"#FACF7A",purple:"#44427B",teal:"#5FD8C4",cyan:"#15CCEF",orange:"#F8814F","light-pink":"#FED7E5","light-blue":"#BFDDF7","light-green":"#48BB74","light-grey":"#F4F5F6","light-red":"#F6DFDF","light-yellow":"#FEE9BF","light-purple":"#E8E8F7","light-teal":"#D3FDF6","light-cyan":"#DDF8FD","light-orange":"#FECDB8"};function rt(t,e,n,i){var a="string"==typeof e?e:e.join(", ");return [t,{transform:n.join(", ")},i,"easein","translate",{transform:a}]}function ot(t,e,n){return rt(t,[0,n],[0,e],350)}function lt(t,e){return [t,{d:e},350,"easein"]}var ct={ease:"0.25 0.1 0.25 1",linear:"0 0 1 1",easein:"0.1 0.8 0.2 1",easeout:"0 0 0.58 1",easeinout:"0.42 0 0.58 1"};function ut(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"linear",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},r=t.cloneNode(!0),o=t.cloneNode(!0);for(var l in e){var c=void 0;c="transform"===l?document.createElementNS("http://www.w3.org/2000/svg","animateTransform"):document.createElementNS("http://www.w3.org/2000/svg","animate");var u=s[l]||t.getAttribute(l),h=e[l],d={attributeName:l,from:u,to:h,begin:"0s",dur:n/1e3+"s",values:u+";"+h,keySplines:ct[i],keyTimes:"0;1",calcMode:"spline",fill:"freeze"};for(var p in a&&(d.type=a),d){ c.setAttribute(p,d[p]); }r.appendChild(c),a?o.setAttribute(l,"translate(".concat(h,")")):o.setAttribute(l,h);}return [r,o]}function ht(t,e){t.style.transform=e,t.style.webkitTransform=e,t.style.msTransform=e,t.style.mozTransform=e,t.style.oTransform=e;}function dt(t,e){var n=[],i=[];e.map((function(t){var e,a,s=t[0],r=s.parentNode;t[0]=s;var o=u(ut.apply(void 0,h$1(t)),2);e=o[0],a=o[1],n.push(a),i.push([e,r]),r.replaceChild(e,s);}));var a=t.cloneNode(!0);return i.map((function(t,i){t[1].replaceChild(n[i],t[0]),e[i][0]=n[i];})),a}function pt(t,e,n){if(0!==n.length){var i=dt(e,n);e.parentNode==t&&(t.removeChild(e),t.appendChild(i)),setTimeout((function(){i.parentNode==t&&(t.removeChild(i),t.appendChild(e));}),250);}}var ft=function(){function t(n,i){if(e(this,t),i=S(i),this.parent="string"==typeof n?document.querySelector(n):n,!(this.parent instanceof HTMLElement)){ throw new Error("No `parent` element to render on was provided."); }this.rawChartArgs=i,this.title=i.title||"",this.type=i.type||"",this.realData=this.prepareData(i.data),this.data=this.prepareFirstData(this.realData),this.colors=this.validateColors(i.colors,this.type),this.config={showTooltip:1,showLegend:void 0!==i.showLegend?i.showLegend:1,isNavigable:i.isNavigable||0,animate:void 0!==i.animate?i.animate:1,truncateLegends:i.truncateLegends||1},this.measures=JSON.parse(JSON.stringify(y));var a=this.measures;this.setMeasures(i),this.title.length||(a.titleHeight=0),this.config.showLegend||(a.legendHeight=0),this.argHeight=i.height||a.baseHeight,this.state={},this.options={},this.initTimeout=700,this.config.isNavigable&&(this.overlays=[]),this.configure(i);}return i(t,[{key:"prepareData",value:function(t){return t}},{key:"prepareFirstData",value:function(t){return t}},{key:"validateColors",value:function(t,e){var n=[];return (t=(t||[]).concat(D[e])).forEach((function(t){var e=function(t){return /rgb[a]{0,1}\([\d, ]+\)/gim.test(t)?/\D+(\d*)\D+(\d*)\D+(\d*)/gim.exec(t).map((function(t,e){return 0!==e?Number(t).toString(16):"#"})).reduce((function(t,e){return "".concat(t).concat(e)})):st[t]||t}(t);!function(t){return /(^\s*)(#)((?:[A-Fa-f0-9]{3}){1,2})$/i.test(t)||/(^\s*)(rgb|hsl)(a?)[(]\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*(?:,\s*([\d.]+)\s*)?[)]$/i.test(t)}(e)?console.warn('"'+t+'" is not a valid color.'):n.push(e);})),n}},{key:"setMeasures",value:function(){}},{key:"configure",value:function(){var t=this,e=this.argHeight;this.baseHeight=e,this.height=e-k(this.measures),this.boundDrawFn=function(){return t.draw(!0)},ResizeObserver&&(this.resizeObserver=new ResizeObserver(this.boundDrawFn),this.resizeObserver.observe(this.parent)),window.addEventListener("resize",this.boundDrawFn),window.addEventListener("orientationchange",this.boundDrawFn);}},{key:"destroy",value:function(){this.resizeObserver&&this.resizeObserver.disconnect(),window.removeEventListener("resize",this.boundDrawFn),window.removeEventListener("orientationchange",this.boundDrawFn);}},{key:"setup",value:function(){this.makeContainer(),this.updateWidth(),this.makeTooltip(),this.draw(!1,!0);}},{key:"makeContainer",value:function(){this.parent.innerHTML="";var t={inside:this.parent,className:"chart-container"};this.independentWidth&&(t.styles={width:this.independentWidth+"px"}),this.container=f.create("div",t);}},{key:"makeTooltip",value:function(){this.tip=new M({parent:this.container,colors:this.colors}),this.bindTooltip();}},{key:"bindTooltip",value:function(){}},{key:"draw",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];e&&g(this.parent)||(this.updateWidth(),this.calc(e),this.makeChartArea(),this.setupComponents(),this.components.forEach((function(e){return e.setup(t.drawArea)})),this.render(this.components,!1),n&&(this.data=this.realData,setTimeout((function(){t.update(t.data,!0);}),this.initTimeout)),this.config.showLegend&&this.renderLegend(),this.setupNavigation(n));}},{key:"calc",value:function(){}},{key:"updateWidth",value:function(){var t,e,n;this.baseWidth=(t=this.parent,e=window.getComputedStyle(t),n=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight),t.clientWidth-n),this.width=this.baseWidth-w(this.measures);}},{key:"makeChartArea",value:function(){this.svg&&this.container.removeChild(this.svg);var t,e,n,i,a=this.measures;this.svg=(t=this.container,e="frappe-chart chart",n=this.baseWidth,i=this.baseHeight,I("svg",{className:e,inside:t,width:n,height:i})),this.svgDefs=I("defs",{inside:this.svg}),this.title.length&&(this.titleEL=tt("title",a.margins.left,a.margins.top,this.title,{fontSize:a.titleFontSize,fill:"#666666",dy:a.titleFontSize}));var s=b(a);this.drawArea=V(this.type+"-chart chart-draw-area","translate(".concat(x(a),", ").concat(s,")")),this.config.showLegend&&(s+=this.height+a.paddings.bottom,this.legendArea=V("chart-legend","translate(".concat(x(a),", ").concat(s,")"))),this.title.length&&this.svg.appendChild(this.titleEL),this.svg.appendChild(this.drawArea),this.config.showLegend&&this.svg.appendChild(this.legendArea),this.updateTipOffset(x(a),b(a));}},{key:"updateTipOffset",value:function(t,e){this.tip.offset={x:t,y:e};}},{key:"setupComponents",value:function(){this.components=new Map;}},{key:"update",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t||console.error("No data to update."),e||(t=S(t)),this.data=this.prepareData(t),this.calc(),this.render(this.components,this.config.animate);}},{key:"render",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.components,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.config.isNavigable&&this.overlays.map((function(t){return t.parentNode.removeChild(t)}));var i=[];e.forEach((function(t){i=i.concat(t.update(n));})),i.length>0?(pt(this.container,this.svg,i),setTimeout((function(){e.forEach((function(t){return t.make()})),t.updateNav();}),400)):(e.forEach((function(t){return t.make()})),this.updateNav());}},{key:"updateNav",value:function(){this.config.isNavigable&&(this.makeOverlay(),this.bindUnits());}},{key:"renderLegend",value:function(t){var e=this;this.legendArea.textContent="";var n=0,i=0;t.map((function(t,a){var s=Math.floor(e.width/150);n>s&&(n=0,i+=e.config.legendRowHeight);var r=150*n,o=e.makeLegend(t,a,r,i);e.legendArea.appendChild(o),n++;}));}},{key:"makeLegend",value:function(){}},{key:"setupNavigation",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.config.isNavigable&&e&&(this.bindOverlay(),this.keyActions={13:this.onEnterKey.bind(this),37:this.onLeftArrow.bind(this),38:this.onUpArrow.bind(this),39:this.onRightArrow.bind(this),40:this.onDownArrow.bind(this)},document.addEventListener("keydown",(function(e){m(t.container)&&(e=e||window.event,t.keyActions[e.keyCode]&&t.keyActions[e.keyCode]());})));}},{key:"makeOverlay",value:function(){}},{key:"updateOverlay",value:function(){}},{key:"bindOverlay",value:function(){}},{key:"bindUnits",value:function(){}},{key:"onLeftArrow",value:function(){}},{key:"onRightArrow",value:function(){}},{key:"onUpArrow",value:function(){}},{key:"onDownArrow",value:function(){}},{key:"onEnterKey",value:function(){}},{key:"addDataPoint",value:function(){}},{key:"removeDataPoint",value:function(){}},{key:"getDataPoint",value:function(){}},{key:"setCurrentDataPoint",value:function(){}},{key:"updateDataset",value:function(){}},{key:"export",value:function(){var t=function(t){var e=t.cloneNode(!0);e.classList.add("chart-container"),e.setAttribute("xmlns","http://www.w3.org/2000/svg"),e.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");var n=f.create("style",{innerHTML:".chart-container{position:relative;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif}.chart-container .axis,.chart-container .chart-label{fill:#555b51}.chart-container .axis line,.chart-container .chart-label line{stroke:#dadada}.chart-container .dataset-units circle{stroke:#fff;stroke-width:2}.chart-container .dataset-units path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container .dataset-path{stroke-width:2px}.chart-container .path-group path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container line.dashed{stroke-dasharray:5,3}.chart-container .axis-line .specific-value{text-anchor:start}.chart-container .axis-line .y-line{text-anchor:end}.chart-container .axis-line .x-line{text-anchor:middle}.chart-container .legend-dataset-text{fill:#6c7680;font-weight:600}.graph-svg-tip{position:absolute;z-index:99999;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.8);border-radius:3px}.graph-svg-tip ul{padding-left:0;display:flex}.graph-svg-tip ol{padding-left:0;display:flex}.graph-svg-tip ul.data-point-list li{min-width:90px;flex:1;font-weight:600}.graph-svg-tip strong{color:#dfe2e5;font-weight:600}.graph-svg-tip .svg-pointer{position:absolute;height:5px;margin:0 0 0 -5px;content:' ';border:5px solid transparent;}.graph-svg-tip.comparison{padding:0;text-align:left;pointer-events:none}.graph-svg-tip.comparison .title{display:block;padding:10px;margin:0;font-weight:600;line-height:1;pointer-events:none}.graph-svg-tip.comparison ul{margin:0;white-space:nowrap;list-style:none}.graph-svg-tip.comparison li{display:inline-block;padding:5px 10px}"});e.insertBefore(n,e.firstChild);var i=f.create("div");return i.appendChild(e),i.innerHTML}(this.svg);!function(t,e){var n=document.createElement("a");n.style="display: none";var i=new Blob(e,{type:"image/svg+xml; charset=utf-8"}),a=window.URL.createObjectURL(i);n.href=a,n.download=t,document.body.appendChild(n),n.click(),setTimeout((function(){document.body.removeChild(n),window.URL.revokeObjectURL(a);}),300);}(this.title||"Chart",[t]);}}]),t}(),vt=function(t){a(r,ft);var n=l(r);function r(t,i){return e(this,r),n.call(this,t,i)}return i(r,[{key:"configure",value:function(t){c(s(r.prototype),"configure",this).call(this,t),this.config.formatTooltipY=(t.tooltipOptions||{}).formatTooltipY,this.config.maxSlices=t.maxSlices||20,this.config.maxLegendPoints=t.maxLegendPoints||20,this.config.legendRowHeight=60;}},{key:"calc",value:function(){var t=this,e=this.state,n=this.config.maxSlices;e.sliceTotals=[];var i=this.data.labels.map((function(e,n){var i=0;return t.data.datasets.map((function(t){i+=t.values[n];})),[i,e]})).filter((function(t){return t[0]>=0})),a=i;if(i.length>n){i.sort((function(t,e){return e[0]-t[0]})),a=i.slice(0,n-1);var s=i.slice(n-1),r=0;s.map((function(t){r+=t[0];})),a.push([r,"Rest"]),this.colors[n-1]="grey";}e.labels=[],a.map((function(t){e.sliceTotals.push(O(t[0])),e.labels.push(t[1]);})),e.grandTotal=e.sliceTotals.reduce((function(t,e){return t+e}),0),this.center={x:this.width/2,y:this.height/2};}},{key:"renderLegend",value:function(){var t=this.state;this.legendArea.textContent="",this.legendTotals=t.sliceTotals.slice(0,this.config.maxLegendPoints),c(s(r.prototype),"renderLegend",this).call(this,this.legendTotals);}},{key:"makeLegend",value:function(t,e,n,i){var a=this.config.formatTooltipY?this.config.formatTooltipY(t):t;return Z(n,i,12,3,this.colors[e],this.state.labels[e],a,null,this.config.truncateLegends)}}]),r}(),gt=["January","February","March","April","May","June","July","August","September","October","November","December"],mt=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];function yt(t){var e=new Date(t);return e.setMinutes(e.getMinutes()-e.getTimezoneOffset()),e}function bt(t){var e=t.getDate(),n=t.getMonth()+1;return [t.getFullYear(),(n>9?"":"0")+n,(e>9?"":"0")+e].join("-")}function xt(t){return new Date(t.getTime())}function kt(t,e){var n=Lt(t);return Math.ceil(function(t,e){return (yt(e)-yt(t))/864e5}(n,e)/7)}function wt(t,e){return t.getMonth()===e.getMonth()&&t.getFullYear()===e.getFullYear()}function At(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=gt[t];return e?n.slice(0,3):n}function Dt(t,e){return new Date(e,t+1,0)}function Lt(t){var e=xt(t),n=e.getDay();return 0!==n&&Mt(e,-1*n),e}function Mt(t,e){t.setDate(t.getDate()+e);}var Tt=function(){function t(n){var i=n.layerClass,a=void 0===i?"":i,s=n.layerTransform,r=void 0===s?"":s,o=n.constants,l=n.getData,c=n.makeElements,u=n.animateElements;e(this,t),this.layerTransform=r,this.constants=o,this.makeElements=c,this.getData=l,this.animateElements=u,this.store=[],this.labels=[],this.layerClass=a,this.layerClass="function"==typeof this.layerClass?this.layerClass():this.layerClass,this.refresh();}return i(t,[{key:"refresh",value:function(t){this.data=t||this.getData();}},{key:"setup",value:function(t){this.layer=V(this.layerClass,this.layerTransform,t);}},{key:"make",value:function(){this.render(this.data),this.oldData=this.data;}},{key:"render",value:function(t){var e=this;this.store=this.makeElements(t),this.layer.textContent="",this.store.forEach((function(t){e.layer.appendChild(t);})),this.labels.forEach((function(t){e.layer.appendChild(t);}));}},{key:"update",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.refresh();var e=[];return t&&(e=this.animateElements(this.data)||[]),e}}]),t}(),Ct={donutSlices:{layerClass:"donut-slices",makeElements:function(t){return t.sliceStrings.map((function(e,n){var i=U(e,"donut-path",t.colors[n],"none",t.strokeWidth);return i.style.transition="transform .3s;",i}))},animateElements:function(t){return this.store.map((function(e,n){return lt(e,t.sliceStrings[n])}))}},pieSlices:{layerClass:"pie-slices",makeElements:function(t){return t.sliceStrings.map((function(e,n){var i=U(e,"pie-path","none",t.colors[n]);return i.style.transition="transform .3s;",i}))},animateElements:function(t){return this.store.map((function(e,n){return lt(e,t.sliceStrings[n])}))}},percentageBars:{layerClass:"percentage-bars",makeElements:function(t){var e=this,n=t.xPositions.length;return t.xPositions.map((function(i,a){var s=a==n-1,r=0==a;return function(t,e,n,i,a,s){var r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"none";if(s){var o=K(t,n,i);return U(o,"percentage-bar",null,r)}if(a){var l=$$1(t,n,i);return U(l,"percentage-bar",null,r)}var c={className:"percentage-bar",x:t,y:e,width:n,height:i,fill:r};return I("rect",c)}(i,0,t.widths[a],e.constants.barHeight,r,s,t.colors[a])}))},animateElements:function(t){if(t){ return [] }}},yAxis:{layerClass:"y axis",makeElements:function(t){var e=this;return t.positions.map((function(n,i){return function(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};E(t)||(t=0),i.pos||(i.pos="left"),i.offset||(i.offset=0),i.mode||(i.mode="span"),i.stroke||(i.stroke="#E2E6E9"),i.className||(i.className="");var a=-6,s="span"===i.mode?n+6:0;return "tick"===i.mode&&"right"===i.pos&&(a=n+6,s=n),a+=i.offset,s+=i.offset,"number"==typeof e&&(e=O(e)),nt(t,e,a,s,{className:i.className,lineType:i.lineType,shortenNumbers:i.shortenNumbers})}(n,t.labels[i],e.constants.width,{mode:e.constants.mode,pos:e.constants.pos,shortenNumbers:e.constants.shortenNumbers})}))},animateElements:function(t){var e=t.positions,n=t.labels,i=this.oldData.positions,a=this.oldData.labels,s=u(z(i,e),2);i=s[0],e=s[1];var r=u(z(a,n),2);return a=r[0],n=r[1],this.render({positions:i,labels:n}),this.store.map((function(t,n){return ot(t,e[n],i[n])}))}},xAxis:{layerClass:"x axis",makeElements:function(t){var e=this;return t.positions.map((function(n,i){return function(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};E(t)||(t=0),i.pos||(i.pos="bottom"),i.offset||(i.offset=0),i.mode||(i.mode="span"),i.className||(i.className="");var a=n+6,s="span"===i.mode?-6:n;return "tick"===i.mode&&"top"===i.pos&&(a=-6,s=0),et(t,e,a,s,{className:i.className,lineType:i.lineType})}(n,t.calcLabels[i],e.constants.height,{mode:e.constants.mode,pos:e.constants.pos})}))},animateElements:function(t){var e=t.positions,n=t.calcLabels,i=this.oldData.positions,a=this.oldData.calcLabels,s=u(z(i,e),2);i=s[0],e=s[1];var r=u(z(a,n),2);return a=r[0],n=r[1],this.render({positions:i,calcLabels:n}),this.store.map((function(t,n){return function(t,e,n){return rt(t,[n,0],[e,0],350)}(t,e[n],i[n])}))}},yMarkers:{layerClass:"y-markers",makeElements:function(t){var e=this;return t.map((function(t){return function(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};E(t)||(t=0),i.labelPos||(i.labelPos="right"),i.lineType||(i.lineType="dashed");var a="left"===i.labelPos?4:n-P(e,5)-4,s=I("text",{className:"chart-label",x:a,y:0,dy:"-5px","font-size":"10px","text-anchor":"start",innerHTML:e+""}),r=nt(t,"",0,n,{stroke:i.stroke||"#E2E6E9",className:i.className||"",lineType:i.lineType});return r.appendChild(s),r}(t.position,t.label,e.constants.width,{labelPos:t.options.labelPos,stroke:t.options.stroke,mode:"span",lineType:t.options.lineType})}))},animateElements:function(t){var e=u(z(this.oldData,t),2);this.oldData=e[0];var n=(t=e[1]).map((function(t){return t.position})),i=t.map((function(t){return t.label})),a=t.map((function(t){return t.options})),s=this.oldData.map((function(t){return t.position}));return this.render(s.map((function(t,e){return {position:s[e],label:i[e],options:a[e]}}))),this.store.map((function(t,e){return ot(t,n[e],s[e])}))}},yRegions:{layerClass:"y-regions",makeElements:function(t){var e=this;return t.map((function(t){return function(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},s=t-e,r=I("rect",{className:"bar mini",styles:{fill:a.fill||"rgba(228, 234, 239, 0.49)",stroke:a.stroke||"#E2E6E9","stroke-dasharray":"".concat(n,", ").concat(s)},x:0,y:0,width:n,height:s});a.labelPos||(a.labelPos="right");var o="left"===a.labelPos?4:n-P(i+"",4.5)-4,l=I("text",{className:"chart-label",x:o,y:0,dy:"-5px","font-size":"10px","text-anchor":"start",innerHTML:i+""}),c=I("g",{transform:"translate(0, ".concat(e,")")});return c.appendChild(r),c.appendChild(l),c}(t.startPos,t.endPos,e.constants.width,t.label,{labelPos:t.options.labelPos,stroke:t.options.stroke,fill:t.options.fill})}))},animateElements:function(t){var e=u(z(this.oldData,t),2);this.oldData=e[0];var n=(t=e[1]).map((function(t){return t.endPos})),i=t.map((function(t){return t.label})),a=t.map((function(t){return t.startPos})),s=t.map((function(t){return t.options})),r=this.oldData.map((function(t){return t.endPos})),o=this.oldData.map((function(t){return t.startPos}));this.render(r.map((function(t,e){return {startPos:o[e],endPos:r[e],label:i[e],options:s[e]}})));var l=[];return this.store.map((function(t,e){l=l.concat(function(t,e,n,i){var a=e-n,s=t.childNodes[0],r=s.getAttribute("width");return [[s,{height:a,"stroke-dasharray":"".concat(r,", ").concat(a)},350,"easein"],rt(t,[0,i],[0,n],350)]}(t,a[e],n[e],r[e]));})),l}},heatDomain:{layerClass:function(){return "heat-domain domain-"+this.constants.index},makeElements:function(t){var e=this,n=this.constants,i=n.index,a=n.colWidth,s=n.rowHeight,r=n.squareSize,o=n.radius,l=n.xTranslate,c=l,u=0;return this.serializedSubDomains=[],t.cols.map((function(t,n){1===n&&e.labels.push(tt("domain-name",c,-12,At(i,!0).toUpperCase(),{fontSize:9})),t.map((function(t,n){if(t.fill){var i={"data-date":t.yyyyMmDd,"data-value":t.dataValue,"data-day":n},a=Q("day",c,u,r,o,t.fill,i);e.serializedSubDomains.push(a);}u+=s;})),u=0,c+=a;})),this.serializedSubDomains},animateElements:function(t){if(t){ return [] }}},barGraph:{layerClass:function(){return "dataset-units dataset-bars dataset-"+this.constants.index},makeElements:function(t){var e=this.constants;return this.unitType="bar",this.units=t.yPositions.map((function(n,i){return function(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:{},l=F(e,o.zeroLine),c=u(l,2),h=c[0],d=c[1];d-=r,0===h&&(h=o.minHeight,d-=o.minHeight),E(t)||(t=0),E(d)||(d=0),E(h,!0)||(h=0),E(n,!0)||(n=0);var p=I("rect",{className:"bar mini",style:"fill: ".concat(i),"data-point-index":s,x:t,y:d,width:n,height:h});if((a+="")||a.length){p.setAttribute("y",0),p.setAttribute("x",0);var f=I("text",{className:"data-point-value",x:n/2,y:0,dy:"-5px","font-size":"10px","text-anchor":"middle",innerHTML:a}),v=I("g",{"data-point-index":s,transform:"translate(".concat(t,", ").concat(d,")")});return v.appendChild(p),v.appendChild(f),v}return p}(t.xPositions[i],n,t.barWidth,e.color,t.labels[i],i,t.offsets[i],{zeroLine:t.zeroLine,barsWidth:t.barsWidth,minHeight:e.minHeight})})),this.units},animateElements:function(t){var e=t.xPositions,n=t.yPositions,i=t.offsets,a=t.labels,s=this.oldData.xPositions,r=this.oldData.yPositions,o=this.oldData.offsets,l=this.oldData.labels,c=u(z(s,e),2);s=c[0],e=c[1];var h=u(z(r,n),2);r=h[0],n=h[1];var d=u(z(o,i),2);o=d[0],i=d[1];var p=u(z(l,a),2);l=p[0],a=p[1],this.render({xPositions:s,yPositions:r,offsets:o,labels:a,zeroLine:this.oldData.zeroLine,barsWidth:this.oldData.barsWidth,barWidth:this.oldData.barWidth});var f=[];return this.store.map((function(a,s){f=f.concat(function(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},r=F(n,s.zeroLine),o=u(r,2),l=o[0],c=o[1];if(c-=a,"rect"!==t.nodeName){var h=t.childNodes[0],d=[h,{width:i,height:l},350,"easein"],p=t.getAttribute("transform").split("(")[1].slice(0,-1),f=rt(t,p,[e,c],350);return [d,f]}return [[t,{width:i,height:l,x:e,y:c},350,"easein"]]}(a,e[s],n[s],t.barWidth,i[s],{zeroLine:t.zeroLine}));})),f}},lineGraph:{layerClass:function(){return "dataset-units dataset-line dataset-"+this.constants.index},makeElements:function(t){var e=this.constants;return this.unitType="dot",this.paths={},e.hideLine||(this.paths=function(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},s=e.map((function(e,n){return t[n]+","+e})),r=s.join("L");i.spline&&(r=W(t,e));var o=U("M"+r,"line-graph-path",n);if(i.heatline){var l=J(a.svgDefs,n);o.style.stroke="url(#".concat(l,")");}var c={path:o};if(i.regionFill){var u=J(a.svgDefs,n,!0),h="M"+"".concat(t[0],",").concat(a.zeroLine,"L")+r+"L".concat(t.slice(-1)[0],",").concat(a.zeroLine);c.region=U(h,"region-fill","none","url(#".concat(u,")"));}return c}(t.xPositions,t.yPositions,e.color,{heatline:e.heatline,regionFill:e.regionFill,spline:e.spline},{svgDefs:e.svgDefs,zeroLine:t.zeroLine})),this.units=[],e.showDots&&(this.units=t.yPositions.map((function(n,i){return function(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=I("circle",{style:"fill: ".concat(i),"data-point-index":s,cx:t,cy:e,r:n});if((a+="")||a.length){r.setAttribute("cy",0),r.setAttribute("cx",0);var o=I("text",{className:"data-point-value",x:0,y:0,dy:-5-n+"px","font-size":"10px","text-anchor":"middle",innerHTML:a}),l=I("g",{"data-point-index":s,transform:"translate(".concat(t,", ").concat(e,")")});return l.appendChild(r),l.appendChild(o),l}return r}(t.xPositions[i],n,t.radius,e.color,e.valuesOverPoints?t.values[i]:"",i)}))),Object.values(this.paths).concat(this.units)},animateElements:function(t){var e=t.xPositions,n=t.yPositions,i=t.values,a=this.oldData.xPositions,s=this.oldData.yPositions,r=this.oldData.values,o=u(z(a,e),2);a=o[0],e=o[1];var l=u(z(s,n),2);s=l[0],n=l[1];var c=u(z(r,i),2);r=c[0],i=c[1],this.render({xPositions:a,yPositions:s,values:i,zeroLine:this.oldData.zeroLine,radius:this.oldData.radius});var h=[];return Object.keys(this.paths).length&&(h=h.concat(function(t,e,n,i,a){var s=[],r=n.map((function(t,n){return e[n]+","+t})).join("L");a&&(r=W(e,n));var o=[t.path,{d:"M"+r},350,"easein"];if(s.push(o),t.region){var l="".concat(e[0],",").concat(i,"L"),c="L".concat(e.slice(-1)[0],", ").concat(i),u=[t.region,{d:"M"+l+r+c},350,"easein"];s.push(u);}return s}(this.paths,e,n,t.zeroLine,this.constants.spline))),this.units.length&&this.units.map((function(t,i){h=h.concat(function(t,e,n){if("circle"!==t.nodeName){var i=t.getAttribute("transform").split("(")[1].slice(0,-1);return [rt(t,i,[e,n],350)]}return [[t,{cx:e,cy:n},350,"easein"]]}(t,e[i],n[i]));})),h}}};function Pt(t,e,n){var i=Object.keys(Ct).filter((function(e){return t.includes(e)})),a=Ct[i[0]];return Object.assign(a,{constants:e,getData:n}),new Tt(a)}var Nt=function(t){a(r,vt);var n=l(r);function r(t,i){var a;return e(this,r),(a=n.call(this,t,i)).type="percentage",a.setup(),a}return i(r,[{key:"setMeasures",value:function(t){var e=this.measures;this.barOptions=t.barOptions||{};var n=this.barOptions;n.height=n.height||16,e.paddings.right=30,e.paddings.top=60,e.paddings.bottom=0,e.legendHeight=80,e.baseHeight=8*n.height+k(e);}},{key:"setupComponents",value:function(){var t=this.state,e=[["percentageBars",{barHeight:this.barOptions.height},function(){return {xPositions:t.xPositions,widths:t.widths,colors:this.colors}}.bind(this)]];this.components=new Map(e.map((function(t){var e=Pt.apply(void 0,h$1(t));return [t[0],e]})));}},{key:"calc",value:function(){var t=this;c(s(r.prototype),"calc",this).call(this);var e=this.state;e.xPositions=[],e.widths=[];var n=0;e.sliceTotals.map((function(i){var a=t.width*i/e.grandTotal;e.widths.push(a),e.xPositions.push(n),n+=a;}));}},{key:"makeDataByIndex",value:function(){}},{key:"bindTooltip",value:function(){var t=this,e=this.state;this.container.addEventListener("mousemove",(function(n){var i=t.components.get("percentageBars").store,a=n.target;if(i.includes(a)){var s=i.indexOf(a),r=v(t.container),o=v(a),l=a.getAttribute("width")||a.getBoundingClientRect().width,c=o.left-r.left+parseInt(l)/2,u=o.top-r.top,h=(t.formattedLabels&&t.formattedLabels.length>0?t.formattedLabels[s]:t.state.labels[s])+": ",d=e.sliceTotals[s]/e.grandTotal;t.tip.setValues(c,u,{name:h,value:(100*d).toFixed(1)+"%"}),t.tip.showTip();}}));}}]),r}(),Et=function(t){a(r,vt);var n=l(r);function r(t,i){var a;return e(this,r),(a=n.call(this,t,i)).initTimeout=0,a.init=1,a.setup(),a}return i(r,[{key:"configure",value:function(t){c(s(r.prototype),"configure",this).call(this,t),this.mouseMove=this.mouseMove.bind(this),this.mouseLeave=this.mouseLeave.bind(this),this.hoverRadio=t.hoverRadio||.1,this.config.startAngle=t.startAngle||0,this.type="pie",this.sliceName="pieSlices",this.arcFunc=q,this.shapeFunc=G,this.clockWise=t.clockWise||!1;}},{key:"getRadius",value:function(){return this.height>this.width?this.center.x:this.center.y}},{key:"calc",value:function(){var t=this;c(s(r.prototype),"calc",this).call(this);var e=this.state;this.radius=this.getRadius();var n=this.radius,i=this.clockWise,a=e.slicesProperties||[];e.sliceStrings=[],e.slicesProperties=[];var o=180-this.config.startAngle;e.sliceTotals.map((function(s,r){var l,c,u=o,h=s/e.grandTotal*360,d=h>180?1:0,p=i?-h:h,f=o+=p,v=N(u,n),g=N(f,n),m=t.init&&a[r];t.init?(l=m?m.startPosition:v,c=m?m.endPosition:v):(l=v,c=g);var y=360===h?t.shapeFunc(l,c,t.center,t.radius,i,d):t.arcFunc(l,c,t.center,t.radius,i,d);e.sliceStrings.push(y),e.slicesProperties.push({startPosition:v,endPosition:g,value:s,total:e.grandTotal,startAngle:u,endAngle:f,angle:p});})),this.init=0;}},{key:"setupComponents",value:function(){var t=this.state,e=[["pieSlices",{},function(){return {sliceStrings:t.sliceStrings,colors:this.colors}}.bind(this)]];this.components=new Map(e.map((function(t){var e=Pt.apply(void 0,h$1(t));return [t[0],e]})));}},{key:"calTranslateByAngle",value:function(t){var e=this.radius,n=this.hoverRadio,i=N(t.startAngle+t.angle/2,e);return "translate3d(".concat(i.x*n,"px,").concat(i.y*n,"px,0)")}},{key:"hoverSlice",value:function(t,e,n,i){if(t){var a=this.colors[e];if(n){ht(t,this.calTranslateByAngle(this.state.slicesProperties[e]));var s=v(this.svg),r=i.pageX-s.left+10,o=i.pageY-s.top-10,l=(this.formatted_labels&&this.formatted_labels.length>0?this.formatted_labels[e]:this.state.labels[e])+": ",c=(100*this.state.sliceTotals[e]/this.state.grandTotal).toFixed(1);this.tip.setValues(r,o,{name:l,value:c+"%"}),this.tip.showTip();}else { this.resetHover(t,a); }}}},{key:"resetHover",value:function(t,e){ht(t,"translate3d(0,0,0)"),this.tip.hideTip(),t.style.fill=e;}},{key:"bindTooltip",value:function(){this.container.addEventListener("mousemove",this.mouseMove),this.container.addEventListener("mouseleave",this.mouseLeave);}},{key:"mouseMove",value:function(t){var e=t.target,n=this.components.get(this.sliceName).store,i=this.curActiveSliceIndex,a=this.curActiveSlice;if(n.includes(e)){var s=n.indexOf(e);this.hoverSlice(a,i,!1),this.curActiveSlice=e,this.curActiveSliceIndex=s,this.hoverSlice(e,s,!0,t);}else { this.mouseLeave(); }}},{key:"mouseLeave",value:function(){this.hoverSlice(this.curActiveSlice,this.curActiveSliceIndex,!1);}}]),r}();function Ot(t){if(0===t){ return [0,0]; }if(isNaN(t)){ return {mantissa:-6755399441055744,exponent:972}; }var e=t>0?1:-1;if(!isFinite(t)){ return {mantissa:4503599627370496*e,exponent:972}; }t=Math.abs(t);var n=Math.floor(Math.log10(t));return [e*(t/Math.pow(10,n)),n]}function St(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Math.ceil(t),i=Math.floor(e),a=n-i,s=a,r=1;a>5&&(a%2!=0&&(a=++n-i),s=a/2,r=2),a<=2&&(r=a/(s=4)),0===a&&(s=5,r=1);for(var o=[],l=0;l<=s;l++){ o.push(i+r*l); }return o}function Ft(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Ot(t),i=u(n,2),a=i[0],s=i[1],r=e?e/Math.pow(10,s):0,o=St(a=a.toFixed(6),r);return o=o.map((function(t){return t*Math.pow(10,s)}))}function zt(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Math.max.apply(Math,h$1(t)),i=Math.min.apply(Math,h$1(t)),a=[];function s(t,e){for(var n=Ft(t),i=n[1]-n[0],a=0,s=1;a<e;s++){ a+=i,n.unshift(-1*a); }return n}if(n>=0&&i>=0){ Ot(n)[1],a=e?Ft(n,i):Ft(n); }else if(n>0&&i<0){var r=Math.abs(i);if(n>=r){ Ot(n)[1],a=s(n,r); }else{Ot(r)[1];var o=s(r,n);a=o.reverse().map((function(t){return -1*t}));}}else if(n<=0&&i<=0){var l=Math.abs(i),c=Math.abs(n);Ot(l)[1],a=(a=e?Ft(l,c):Ft(l)).reverse().map((function(t){return -1*t}));}return a}function Ht(t){var e,n=Rt(t);if(t.indexOf(0)>=0){ e=t.indexOf(0); }else if(t[0]>0){e=-1*t[0]/n;}else{e=-1*t[t.length-1]/n+(t.length-1);}return e}function Rt(t){return t[1]-t[0]}function Wt(t){return t[t.length-1]-t[0]}function jt(t,e){return T(e.zeroLine-t*e.scaleMultiplier)}var It=function(t){a(s,ft);var n=l(s);function s(t,i){var a;e(this,s),(a=n.call(this,t,i)).type="heatmap",a.countLabel=i.countLabel||"";var r=["Sunday","Monday"],o=r.includes(i.startSubDomain)?i.startSubDomain:"Sunday";return a.startSubDomainIndex=r.indexOf(o),a.setup(),a}return i(s,[{key:"setMeasures",value:function(t){var e=this.measures;this.discreteDomains=0===t.discreteDomains?0:1,e.paddings.top=36,e.paddings.bottom=0,e.legendHeight=24,e.baseHeight=84+k(e);var n=this.data,i=this.discreteDomains?12:0;this.independentWidth=12*(kt(n.start,n.end)+i)+w(e);}},{key:"updateWidth",value:function(){var t=this.discreteDomains?12:0,e=this.state.noOfWeeks?this.state.noOfWeeks:52;this.baseWidth=12*(e+t)+w(this.measures);}},{key:"prepareData",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data;if(t.start&&t.end&&t.start>t.end){ throw new Error("Start date cannot be greater than end date."); }if(t.start||(t.start=new Date,t.start.setFullYear(t.start.getFullYear()-1)),t.end||(t.end=new Date),t.dataPoints=t.dataPoints||{},parseInt(Object.keys(t.dataPoints)[0])>1e5){var e={};Object.keys(t.dataPoints).forEach((function(n){var i=new Date(1e3*n);e[bt(i)]=t.dataPoints[n];})),t.dataPoints=e;}return t}},{key:"calc",value:function(){var t=this.state;t.start=xt(this.data.start),t.end=xt(this.data.end),t.firstWeekStart=xt(t.start),t.noOfWeeks=kt(t.start,t.end),t.distribution=function(t,e){for(var n=Math.max.apply(Math,h$1(t)),i=1/(e-1),a=[],s=0;s<e;s++){var r=n*(i*s);a.push(r);}return a}(Object.values(this.data.dataPoints),5),t.domainConfigs=this.getDomains();}},{key:"setupComponents",value:function(){var t=this,e=this.state,n=this.discreteDomains?0:1,i=e.domainConfigs.map((function(i,a){return ["heatDomain",{index:i.index,colWidth:12,rowHeight:12,squareSize:10,radius:t.rawChartArgs.radius||0,xTranslate:12*e.domainConfigs.filter((function(t,e){return e<a})).map((function(t){return t.cols.length-n})).reduce((function(t,e){return t+e}),0)},function(){return e.domainConfigs[a]}.bind(t)]}));this.components=new Map(i.map((function(t,e){var n=Pt.apply(void 0,h$1(t));return [t[0]+"-"+e,n]})));var a=0;mt.forEach((function(e,n){if([1,3,5].includes(n)){var i=tt("subdomain-name",-6,a,e,{fontSize:10,dy:8,textAnchor:"end"});t.drawArea.appendChild(i);}a+=12;}));}},{key:"update",value:function(t){t||console.error("No data to update."),this.data=this.prepareData(t),this.draw(),this.bindTooltip();}},{key:"bindTooltip",value:function(){var t=this;this.container.addEventListener("mousemove",(function(e){t.components.forEach((function(n){var i=n.store,a=e.target;if(i.includes(a)){var s=a.getAttribute("data-value"),r=a.getAttribute("data-date").split("-"),o=At(parseInt(r[1])-1,!0),l=t.container.getBoundingClientRect(),c=a.getBoundingClientRect(),u=parseInt(e.target.getAttribute("width")),h=c.left-l.left+u/2,d=c.top-l.top,p=s+" "+t.countLabel,f=" on "+o+" "+r[0]+", "+r[2];t.tip.setValues(h,d,{name:f,value:p,valueFirst:1},[]),t.tip.showTip();}}));}));}},{key:"renderLegend",value:function(){var t=this;this.legendArea.textContent="";var e=0,n=this.rawChartArgs.radius||0,i=tt("subdomain-name",e,12,"Less",{fontSize:11,dy:9});e=30,this.legendArea.appendChild(i),this.colors.slice(0,5).map((function(i,a){var s=Q("heatmap-legend-unit",e+15*a,12,10,n,i);t.legendArea.appendChild(s);}));var a=tt("subdomain-name",e+75+3,12,"More",{fontSize:11,dy:9});this.legendArea.appendChild(a);}},{key:"getDomains",value:function(){for(var t=this.state,e=[t.start.getMonth(),t.start.getFullYear()],n=e[0],i=e[1],a=[t.end.getMonth(),t.end.getFullYear()],s=a[0]-n+1+12*(a[1]-i),r=[],o=xt(t.start),l=0;l<s;l++){var c=t.end;if(!wt(o,t.end)){var u=[o.getMonth(),o.getFullYear()];c=Dt(u[0],u[1]);}r.push(this.getDomainConfig(o,c)),Mt(c,1),o=c;}return r}},{key:"getDomainConfig",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=[t.getMonth(),t.getFullYear()],i=n[0],a=n[1],s=Lt(t),r={index:i,cols:[]};Mt(e=xt(e)||Dt(i,a),1);for(var o,l=kt(s,e),c=[],u=0;u<l;u++){ o=this.getCol(s,i),c.push(o),Mt(s=new Date(o[6].yyyyMmDd),1); }return void 0!==o[6].dataValue&&(Mt(s,1),c.push(this.getCol(s,i,!0))),r.cols=c,r}},{key:"getCol",value:function(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=this.state,a=xt(t),s=[],r=0;r<7;r++,Mt(a,1)){var o={},l=a>=i.start&&a<=i.end;n||a.getMonth()!==e||!l?o.yyyyMmDd=bt(a):o=this.getSubDomainConfig(a),s.push(o);}return s}},{key:"getSubDomainConfig",value:function(t){var e,n,i=bt(t),a=this.data.dataPoints[i];return {yyyyMmDd:i,dataValue:a||0,fill:this.colors[(e=a,n=this.state.distribution,n.filter((function(t){return t<e})).length)]}}}]),s}();function Bt(t,e){t.labels=t.labels||[];var n=t.labels.length,i=t.datasets,a=new Array(n).fill(0);return i||(i=[{values:a}]),i.map((function(t){if(t.values){var i=t.values;i=(i=i.map((function(t){return isNaN(t)?0:t}))).length>n?i.slice(0,n):C(i,n-i.length,0);}else { t.values=a; }t.chartType||(t.chartType=e);})),t.yRegions&&t.yRegions.map((function(t){if(t.end<t.start){var e=[t.end,t.start];t.start=e[0],t.end=e[1];}})),t}function Yt(t){var e=t.labels.length,n=new Array(e).fill(0),i={labels:t.labels.slice(0,-1),datasets:t.datasets.map((function(t){return {name:"",values:n.slice(0,-1),chartType:t.chartType}}))};return t.yMarkers&&(i.yMarkers=[{value:0,label:""}]),t.yRegions&&(i.yRegions=[{start:0,end:0,label:""}]),i}var Vt=function(t){a(r,ft);var n=l(r);function r(t,i){var a;return e(this,r),(a=n.call(this,t,i)).barOptions=i.barOptions||{},a.lineOptions=i.lineOptions||{},a.type=i.type||"line",a.init=1,a.setup(),a}return i(r,[{key:"setMeasures",value:function(){this.data.datasets.length<=1&&(this.config.showLegend=0,this.measures.paddings.bottom=30);}},{key:"configure",value:function(t){c(s(r.prototype),"configure",this).call(this,t),t.axisOptions=t.axisOptions||{},t.tooltipOptions=t.tooltipOptions||{},this.config.xAxisMode=t.axisOptions.xAxisMode||"span",this.config.yAxisMode=t.axisOptions.yAxisMode||"span",this.config.xIsSeries=t.axisOptions.xIsSeries||0,this.config.shortenYAxisNumbers=t.axisOptions.shortenYAxisNumbers||0,this.config.formatTooltipX=t.tooltipOptions.formatTooltipX,this.config.formatTooltipY=t.tooltipOptions.formatTooltipY,this.config.valuesOverPoints=t.valuesOverPoints,this.config.legendRowHeight=30;}},{key:"prepareData",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data;return Bt(t,this.type)}},{key:"prepareFirstData",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data;return Yt(t)}},{key:"calc",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.calcXPositions(),t||this.calcYAxisParameters(this.getAllYValues(),"line"===this.type),this.makeDataByIndex();}},{key:"calcXPositions",value:function(){var t=this.state,e=this.data.labels;t.datasetLength=e.length,t.unitWidth=this.width/t.datasetLength,t.xOffset=t.unitWidth/2,t.xAxis={labels:e,positions:e.map((function(e,n){return T(t.xOffset+n*t.unitWidth)}))};}},{key:"calcYAxisParameters",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"false",n=zt(t,e),i=this.height/Wt(n),a=Rt(n)*i,s=this.height-Ht(n)*a;this.state.yAxis={labels:n,positions:n.map((function(t){return s-t*i})),scaleMultiplier:i,zeroLine:s},this.calcDatasetPoints(),this.calcYExtremes(),this.calcYRegions();}},{key:"calcDatasetPoints",value:function(){var t=this.state,e=function(e){return e.map((function(e){return jt(e,t.yAxis)}))};t.datasets=this.data.datasets.map((function(t,n){var i=t.values,a=t.cumulativeYs||[];return {name:t.name&&t.name.replace(/<|>|&/g,(function(t){return "&"==t?"&amp;":"<"==t?"&lt;":"&gt;"})),index:n,chartType:t.chartType,values:i,yPositions:e(i),cumulativeYs:a,cumulativeYPos:e(a)}}));}},{key:"calcYExtremes",value:function(){var t=this.state;this.barOptions.stacked?t.yExtremes=t.datasets[t.datasets.length-1].cumulativeYPos:(t.yExtremes=new Array(t.datasetLength).fill(9999),t.datasets.map((function(e){e.yPositions.map((function(e,n){e<t.yExtremes[n]&&(t.yExtremes[n]=e);}));})));}},{key:"calcYRegions",value:function(){var t=this.state;this.data.yMarkers&&(this.state.yMarkers=this.data.yMarkers.map((function(e){return e.position=jt(e.value,t.yAxis),e.options||(e.options={}),e}))),this.data.yRegions&&(this.state.yRegions=this.data.yRegions.map((function(e){return e.startPos=jt(e.start,t.yAxis),e.endPos=jt(e.end,t.yAxis),e.options||(e.options={}),e})));}},{key:"getAllYValues",value:function(){var t,e=this,n="values";if(this.barOptions.stacked){n="cumulativeYs";var i=new Array(this.state.datasetLength).fill(0);this.data.datasets.map((function(t,a){var s=e.data.datasets[a].values;t[n]=i=i.map((function(t,e){return t+s[e]}));}));}var a=this.data.datasets.map((function(t){return t[n]}));return this.data.yMarkers&&a.push(this.data.yMarkers.map((function(t){return t.value}))),this.data.yRegions&&this.data.yRegions.map((function(t){a.push([t.end,t.start]);})),(t=[]).concat.apply(t,h$1(a))}},{key:"setupComponents",value:function(){var t=this,e=[["yAxis",{mode:this.config.yAxisMode,width:this.width,shortenNumbers:this.config.shortenYAxisNumbers},function(){return this.state.yAxis}.bind(this)],["xAxis",{mode:this.config.xAxisMode,height:this.height},function(){var t=this.state;return t.xAxis.calcLabels=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=t/e.length*.6;i<=0&&(i=1);var a,s=i/7;if(n){var r=Math.max.apply(Math,h$1(e.map((function(t){return t.length}))));a=Math.ceil(r/s);}var o=e.map((function(t,i){return (t+="").length>s&&(n?i%a!=0&&i!==e.length-1&&(t=""):t=s-3>0?t.slice(0,s-3)+" ...":t.slice(0,s)+".."),t}));return o}(this.width,t.xAxis.labels,this.config.xIsSeries),t.xAxis}.bind(this)],["yRegions",{width:this.width,pos:"right"},function(){return this.state.yRegions}.bind(this)]],n=this.state.datasets.filter((function(t){return "bar"===t.chartType})),i=this.state.datasets.filter((function(t){return "line"===t.chartType})),a=n.map((function(e){var i=e.index;return ["barGraph-"+e.index,{index:i,color:t.colors[i],stacked:t.barOptions.stacked,valuesOverPoints:t.config.valuesOverPoints,minHeight:0*t.height},function(){var t=this.state,e=t.datasets[i],a=this.barOptions.stacked,s=this.barOptions.spaceRatio||.5,r=t.unitWidth*(1-s),o=r/(a?1:n.length),l=t.xAxis.positions.map((function(t){return t-r/2}));a||(l=l.map((function(t){return t+o*i})));var c=new Array(t.datasetLength).fill("");this.config.valuesOverPoints&&(c=a&&e.index===t.datasets.length-1?e.cumulativeYs:e.values);var u=new Array(t.datasetLength).fill(0);return a&&(u=e.yPositions.map((function(t,n){return t-e.cumulativeYPos[n]}))),{xPositions:l,yPositions:e.yPositions,offsets:u,labels:c,zeroLine:t.yAxis.zeroLine,barsWidth:r,barWidth:o}}.bind(t)]})),s=i.map((function(e){var n=e.index;return ["lineGraph-"+e.index,{index:n,color:t.colors[n],svgDefs:t.svgDefs,heatline:t.lineOptions.heatline,regionFill:t.lineOptions.regionFill,spline:t.lineOptions.spline,showDots:t.lineOptions.showDots,hideLine:t.lineOptions.hideLine,valuesOverPoints:t.config.valuesOverPoints},function(){var t=this.state,e=t.datasets[n],i=t.yAxis.positions[0]<t.yAxis.zeroLine?t.yAxis.positions[0]:t.yAxis.zeroLine;return {xPositions:t.xAxis.positions,yPositions:e.yPositions,values:e.values,zeroLine:i,radius:this.lineOptions.dotSize||4}}.bind(t)]})),r=[["yMarkers",{width:this.width,pos:"right"},function(){return this.state.yMarkers}.bind(this)]];e=e.concat(a,s,r);var o=["yMarkers","yRegions"];this.dataUnitComponents=[],this.components=new Map(e.filter((function(e){return !o.includes(e[0])||t.state[e[0]]})).map((function(e){var n=Pt.apply(void 0,h$1(e));return (e[0].includes("lineGraph")||e[0].includes("barGraph"))&&t.dataUnitComponents.push(n),[e[0],n]})));}},{key:"makeDataByIndex",value:function(){var t=this;this.dataByIndex={};var e=this.state,n=this.config.formatTooltipX,i=this.config.formatTooltipY;e.xAxis.labels.map((function(a,s){var r=t.state.datasets.map((function(e,n){var a=e.values[s];return {title:e.name,value:a,yPos:e.yPositions[s],color:t.colors[n],formatted:i?i(a):a}}));t.dataByIndex[s]={label:a,formattedLabel:n?n(a):a,xPos:e.xAxis.positions[s],values:r,yExtreme:e.yExtremes[s]};}));}},{key:"bindTooltip",value:function(){var t=this;this.container.addEventListener("mousemove",(function(e){var n=t.measures,i=v(t.container),a=e.pageX-i.left-x(n),s=e.pageY-i.top;s<t.height+b(n)&&s>b(n)?t.mapTooltipXPosition(a):t.tip.hideTip();}));}},{key:"mapTooltipXPosition",value:function(t){var e=this.state;if(e.yExtremes){var n=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=e.reduce((function(e,n){return Math.abs(n-t)<Math.abs(e-t)?n:e}),[]);return n?e.indexOf(i):i}(t,e.xAxis.positions,!0);if(n>=0){var i=this.dataByIndex[n];this.tip.setValues(i.xPos+this.tip.offset.x,i.yExtreme+this.tip.offset.y,{name:i.formattedLabel,value:""},i.values,n),this.tip.showTip();}}}},{key:"renderLegend",value:function(){var t=this.data;t.datasets.length>1&&c(s(r.prototype),"renderLegend",this).call(this,t.datasets);}},{key:"makeLegend",value:function(t,e,n,i){return Z(n,i+5,12,3,this.colors[e],t.name,null,8.75,this.config.truncateLegends)}},{key:"makeOverlay",value:function(){var t=this;this.init?this.init=0:(this.overlayGuides&&this.overlayGuides.forEach((function(t){var e=t.overlay;e.parentNode.removeChild(e);})),this.overlayGuides=this.dataUnitComponents.map((function(t){return {type:t.unitType,overlay:void 0,units:t.units}})),void 0===this.state.currentIndex&&(this.state.currentIndex=this.state.datasetLength-1),this.overlayGuides.map((function(e){var n=e.units[t.state.currentIndex];e.overlay=it[e.type](n),t.drawArea.appendChild(e.overlay);})));}},{key:"updateOverlayGuides",value:function(){this.overlayGuides&&this.overlayGuides.forEach((function(t){var e=t.overlay;e.parentNode.removeChild(e);}));}},{key:"bindOverlay",value:function(){var t=this;this.parent.addEventListener("data-select",(function(){t.updateOverlay();}));}},{key:"bindUnits",value:function(){var t=this;this.dataUnitComponents.map((function(e){e.units.map((function(e){e.addEventListener("click",(function(){var n=e.getAttribute("data-point-index");t.setCurrentDataPoint(n);}));}));})),this.tip.container.addEventListener("click",(function(){var e=t.tip.container.getAttribute("data-point-index");t.setCurrentDataPoint(e);}));}},{key:"updateOverlay",value:function(){var t=this;this.overlayGuides.map((function(e){var n=e.units[t.state.currentIndex];at[e.type](n,e.overlay);}));}},{key:"onLeftArrow",value:function(){this.setCurrentDataPoint(this.state.currentIndex-1);}},{key:"onRightArrow",value:function(){this.setCurrentDataPoint(this.state.currentIndex+1);}},{key:"getDataPoint",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.state.currentIndex,e=this.state,n={index:t,label:e.xAxis.labels[t],values:e.datasets.map((function(e){return e.values[t]}))};return n}},{key:"setCurrentDataPoint",value:function(t){var e=this.state;(t=parseInt(t))<0&&(t=0),t>=e.xAxis.labels.length&&(t=e.xAxis.labels.length-1),t!==e.currentIndex&&(e.currentIndex=t,function(t,e,n){var i=document.createEvent("HTMLEvents");for(var a in i.initEvent(e,!0,!0),n){ i[a]=n[a]; }t.dispatchEvent(i);}(this.parent,"data-select",this.getDataPoint()));}},{key:"addDataPoint",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.state.datasetLength;c(s(r.prototype),"addDataPoint",this).call(this,t,e,n),this.data.labels.splice(n,0,t),this.data.datasets.map((function(t,i){t.values.splice(n,0,e[i]);})),this.update(this.data);}},{key:"removeDataPoint",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.state.datasetLength-1;this.data.labels.length<=1||(c(s(r.prototype),"removeDataPoint",this).call(this,t),this.data.labels.splice(t,1),this.data.datasets.map((function(e){e.values.splice(t,1);})),this.update(this.data));}},{key:"updateDataset",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.data.datasets[e].values=t,this.update(this.data);}},{key:"updateDatasets",value:function(t){this.data.datasets.map((function(e,n){t[n]&&(e.values=t[n]);})),this.update(this.data);}}]),r}(),Ut={bar:Vt,line:Vt,percentage:Nt,heatmap:It,pie:Et,donut:function(t){a(r,Et);var n=l(r);function r(t,i){return e(this,r),n.call(this,t,i)}return i(r,[{key:"configure",value:function(t){c(s(r.prototype),"configure",this).call(this,t),this.type="donut",this.sliceName="donutSlices",this.arcFunc=_,this.shapeFunc=X,this.strokeWidth=t.strokeWidth||30;}},{key:"getRadius",value:function(){return this.height>this.width?this.center.x-this.strokeWidth/2:this.center.y-this.strokeWidth/2}},{key:"resetHover",value:function(t,e){transform(t,"translate3d(0,0,0)"),this.tip.hideTip(),t.style.stroke=e;}},{key:"setupComponents",value:function(){var t=this.state,e=[[this.sliceName,{},function(){return {sliceStrings:t.sliceStrings,colors:this.colors,strokeWidth:this.strokeWidth}}.bind(this)]];this.components=new Map(e.map((function(t){var e=Pt.apply(void 0,h$1(t));return [t[0],e]})));}}]),r}()};var qt=function t(n,i){return e(this,t),function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"line",e=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return "axis-mixed"===t?(n.type="line",new Vt(e,n)):Ut[t]?new Ut[t](e,n):void console.error("Undefined chart type: "+t)}(i.type,n,i)};

	frappe.Chart = qt;

	var Sortable$1 = createCommonjsModule(function (module) {
	/**!
	 * Sortable
	 * @author	RubaXa   <trash@rubaxa.org>
	 * @author	owenm    <owen23355@gmail.com>
	 * @license MIT
	 */

	(function sortableModule(factory) {

		{
			module.exports = factory();
		}
	})(function sortableFactory() {

		if (typeof window === "undefined" || !window.document) {
			return function sortableError() {
				throw new Error("Sortable.js requires a window with a document");
			};
		}

		var dragEl,
			parentEl,
			ghostEl,
			cloneEl,
			rootEl,
			nextEl,
			lastDownEl,

			scrollEl,
			scrollParentEl,
			scrollCustomFn,

			oldIndex,
			newIndex,

			activeGroup,
			putSortable,

			autoScrolls = [],
			scrolling = false,

			awaitingDragStarted = false,
			ignoreNextClick = false,
			sortables = [],

			pointerElemChangedInterval,
			lastPointerElemX,
			lastPointerElemY,

			tapEvt,
			touchEvt,

			moved,


			lastTarget,
			lastDirection,
			pastFirstInvertThresh = false,
			isCircumstantialInvert = false,
			lastMode, // 'swap' or 'insert'

			targetMoveDistance,


			forRepaintDummy,
			realDragElRect, // dragEl rect after current animation

			/** @const */
			R_SPACE = /\s+/g,

			expando = 'Sortable' + (new Date).getTime(),

			win = window,
			document = win.document,
			parseInt = win.parseInt,
			setTimeout = win.setTimeout,

			$ = win.jQuery || win.Zepto,
			Polymer = win.Polymer,

			captureMode = {
				capture: false,
				passive: false
			},

			IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
			Edge = !!navigator.userAgent.match(/Edge/i),
			// FireFox = !!navigator.userAgent.match(/firefox/i),

			CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',

			// This will not pass for IE9, because IE9 DnD only works on anchors
			supportDraggable = ('draggable' in document.createElement('div')),

			supportCssPointerEvents = (function() {
				// false when <= IE11
				if (IE11OrLess) {
					return false;
				}
				var el = document.createElement('x');
				el.style.cssText = 'pointer-events:auto';
				return el.style.pointerEvents === 'auto';
			})(),

			_silent = false,
			_alignedSilent = false,

			abs = Math.abs,
			min = Math.min,

			savedInputChecked = [],

			_detectDirection = function(el, options) {
				var elCSS = _css(el),
					elWidth = parseInt(elCSS.width),
					child1 = _getChild(el, 0, options),
					child2 = _getChild(el, 1, options),
					firstChildCSS = child1 && _css(child1),
					secondChildCSS = child2 && _css(child2),
					firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + _getRect(child1).width,
					secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + _getRect(child2).width;
				if (elCSS.display === 'flex') {
					return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse'
					? 'vertical' : 'horizontal';
				}
				if (child1 && firstChildCSS.float !== 'none') {
					var touchingSideChild2 = firstChildCSS.float === 'left' ? 'left' : 'right';

					return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ?
						'vertical' : 'horizontal';
				}
				return (child1 &&
					(
						firstChildCSS.display === 'block' ||
						firstChildCSS.display === 'flex' ||
						firstChildCSS.display === 'table' ||
						firstChildCSS.display === 'grid' ||
						firstChildWidth >= elWidth &&
						elCSS[CSSFloatProperty] === 'none' ||
						child2 &&
						elCSS[CSSFloatProperty] === 'none' &&
						firstChildWidth + secondChildWidth > elWidth
					) ?
					'vertical' : 'horizontal'
				);
			},

			/**
			 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
			 * @param  {Number} x      X position
			 * @param  {Number} y      Y position
			 * @return {HTMLElement}   Element of the first found nearest Sortable
			 */
			_detectNearestEmptySortable = function(x, y) {
				for (var i = 0; i < sortables.length; i++) {
					if (sortables[i].children.length) { continue; }

					var rect = _getRect(sortables[i]),
						threshold = sortables[i][expando].options.emptyInsertThreshold,
						insideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),
						insideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);

					if (insideHorizontally && insideVertically) {
						return sortables[i];
					}
				}
			},

			_isClientInRowColumn = function(x, y, el, axis, options) {
				var targetRect = _getRect(el),
					targetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,
					targetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,
					mouseOnOppAxis = axis === 'vertical' ? x : y;

				return targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;
			},

			_isElInRowColumn = function(el1, el2, axis) {
				var el1Rect = el1 === dragEl && realDragElRect || _getRect(el1),
					el2Rect = el2 === dragEl && realDragElRect || _getRect(el2),
					el1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,
					el1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,
					el1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,
					el2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,
					el2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,
					el2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;

				return (
					el1S1Opp === el2S1Opp ||
					el1S2Opp === el2S2Opp ||
					(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)
				);
			},

			_getParentAutoScrollElement = function(el, includeSelf) {
				// skip to window
				if (!el || !el.getBoundingClientRect) { return win; }

				var elem = el;
				var gotSelf = false;
				do {
					// we don't need to get elem css if it isn't even overflowing in the first place (performance)
					if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
						var elemCSS = _css(elem);
						if (
							elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||
							elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')
						) {
							if (!elem || !elem.getBoundingClientRect || elem === document.body) { return win; }

							if (gotSelf || includeSelf) { return elem; }
							gotSelf = true;
						}
					}
				/* jshint boss:true */
				} while (elem = elem.parentNode);

				return win;
			},

			_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl, /**Boolean*/isFallback) {
				// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
				if (options.scroll) {
					var _this = rootEl ? rootEl[expando] : window,
						sens = options.scrollSensitivity,
						speed = options.scrollSpeed,

						x = evt.clientX,
						y = evt.clientY,

						winWidth = window.innerWidth,
						winHeight = window.innerHeight,

						scrollThisInstance = false;

					// Detect scrollEl
					if (scrollParentEl !== rootEl) {
						_clearAutoScrolls();

						scrollEl = options.scroll;
						scrollCustomFn = options.scrollFn;

						if (scrollEl === true) {
							scrollEl = _getParentAutoScrollElement(rootEl, true);
							scrollParentEl = scrollEl;
						}
					}


					var layersOut = 0;
					var currentParent = scrollEl;
					do {
						var	el = currentParent,
							rect = _getRect(el),

							top = rect.top,
							bottom = rect.bottom,
							left = rect.left,
							right = rect.right,

							width = rect.width,
							height = rect.height,

							scrollWidth,
							scrollHeight,

							css,

							vx,
							vy,

							canScrollX,
							canScrollY,

							scrollPosX,
							scrollPosY;


						if (el !== win) {
							scrollWidth = el.scrollWidth;
							scrollHeight = el.scrollHeight;

							css = _css(el);

							canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll');
							canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll');

							scrollPosX = el.scrollLeft;
							scrollPosY = el.scrollTop;
						} else {
							scrollWidth = document.documentElement.scrollWidth;
							scrollHeight = document.documentElement.scrollHeight;

							css = _css(document.documentElement);

							canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll' || css.overflowX === 'visible');
							canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll' || css.overflowY === 'visible');

							scrollPosX = document.documentElement.scrollLeft;
							scrollPosY = document.documentElement.scrollTop;
						}

						vx = canScrollX && (abs(right - x) <= sens && (scrollPosX + width) < scrollWidth) - (abs(left - x) <= sens && !!scrollPosX);

						vy = canScrollY && (abs(bottom - y) <= sens && (scrollPosY + height) < scrollHeight) - (abs(top - y) <= sens && !!scrollPosY);


						if (!autoScrolls[layersOut]) {
							for (var i = 0; i <= layersOut; i++) {
								if (!autoScrolls[i]) {
									autoScrolls[i] = {};
								}
							}
						}

						if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
							autoScrolls[layersOut].el = el;
							autoScrolls[layersOut].vx = vx;
							autoScrolls[layersOut].vy = vy;

							clearInterval(autoScrolls[layersOut].pid);

							if (el && (vx != 0 || vy != 0)) {
								scrollThisInstance = true;
								/* jshint loopfunc:true */
								autoScrolls[layersOut].pid = setInterval((function () {
									// emulate drag over during autoscroll (fallback), emulating native DnD behaviour
									if (isFallback && this.layer === 0) {
										Sortable.active._emulateDragOver(true);
									}
									var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
									var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

									if ('function' === typeof(scrollCustomFn)) {
										if (scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt, touchEvt, autoScrolls[this.layer].el) !== 'continue') {
											return;
										}
									}
									if (autoScrolls[this.layer].el === win) {
										win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
									} else {
										autoScrolls[this.layer].el.scrollTop += scrollOffsetY;
										autoScrolls[this.layer].el.scrollLeft += scrollOffsetX;
									}
								}).bind({layer: layersOut}), 24);
							}
						}
						layersOut++;
					} while (options.bubbleScroll && currentParent !== win && (currentParent = _getParentAutoScrollElement(currentParent, false)));
					scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
				}
			}, 30),

			_clearAutoScrolls = function () {
				autoScrolls.forEach(function(autoScroll) {
					clearInterval(autoScroll.pid);
				});
				autoScrolls = [];
			},

			_prepareGroup = function (options) {
				function toFn(value, pull) {
					return function(to, from, dragEl, evt) {
						var sameGroup = to.options.group.name &&
										from.options.group.name &&
										to.options.group.name === from.options.group.name;

						if (value == null && (pull || sameGroup)) {
							// Default pull value
							// Default pull and put value if same group
							return true;
						} else if (value == null || value === false) {
							return false;
						} else if (pull && value === 'clone') {
							return value;
						} else if (typeof value === 'function') {
							return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
						} else {
							var otherGroup = (pull ? to : from).options.group.name;

							return (value === true ||
							(typeof value === 'string' && value === otherGroup) ||
							(value.join && value.indexOf(otherGroup) > -1));
						}
					};
				}

				var group = {};
				var originalGroup = options.group;

				if (!originalGroup || typeof originalGroup != 'object') {
					originalGroup = {name: originalGroup};
				}

				group.name = originalGroup.name;
				group.checkPull = toFn(originalGroup.pull, true);
				group.checkPut = toFn(originalGroup.put);
				group.revertClone = originalGroup.revertClone;

				options.group = group;
			},

			_checkAlignment = function(evt) {
				if (!dragEl || !dragEl.parentNode) { return; }
				dragEl.parentNode[expando] && dragEl.parentNode[expando]._computeIsAligned(evt);
			},

			_isTrueParentSortable = function(el, target) {
				var trueParent = target;
				while (!trueParent[expando]) {
					trueParent = trueParent.parentNode;
				}

				return el === trueParent;
			},

			_artificalBubble = function(sortable, originalEvt, method) {
				// Artificial IE bubbling
				var nextParent = sortable.parentNode;
				while (nextParent && !nextParent[expando]) {
					nextParent = nextParent.parentNode;
				}

				if (nextParent) {
					nextParent[expando][method](_extend(originalEvt, {
						artificialBubble: true
					}));
				}
			},

			_hideGhostForTarget = function() {
				if (!supportCssPointerEvents && ghostEl) {
					_css(ghostEl, 'display', 'none');
				}
			},

			_unhideGhostForTarget = function() {
				if (!supportCssPointerEvents && ghostEl) {
					_css(ghostEl, 'display', '');
				}
			};


		// #1184 fix - Prevent click event on fallback if dragged but item not changed position
		document.addEventListener('click', function(evt) {
			if (ignoreNextClick) {
				evt.preventDefault();
				evt.stopPropagation && evt.stopPropagation();
				evt.stopImmediatePropagation && evt.stopImmediatePropagation();
				ignoreNextClick = false;
				return false;
			}
		}, true);

		var nearestEmptyInsertDetectEvent = function(evt) {
			evt = evt.touches ? evt.touches[0] : evt;
			if (dragEl) {
				var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

				if (nearest) {
					nearest[expando]._onDragOver({
						clientX: evt.clientX,
						clientY: evt.clientY,
						target: nearest,
						rootEl: nearest
					});
				}
			}
		};
		// We do not want this to be triggered if completed (bubbling canceled), so only define it here
		_on(document, 'dragover', nearestEmptyInsertDetectEvent);
		_on(document, 'mousemove', nearestEmptyInsertDetectEvent);
		_on(document, 'touchmove', nearestEmptyInsertDetectEvent);

		/**
		 * @class  Sortable
		 * @param  {HTMLElement}  el
		 * @param  {Object}       [options]
		 */
		function Sortable(el, options) {
			if (!(el && el.nodeType && el.nodeType === 1)) {
				throw 'Sortable: `el` must be HTMLElement, not ' + {}.toString.call(el);
			}

			this.el = el; // root element
			this.options = options = _extend({}, options);


			// Export instance
			el[expando] = this;

			// Default options
			var defaults = {
				group: null,
				sort: true,
				disabled: false,
				store: null,
				handle: null,
				scroll: true,
				scrollSensitivity: 30,
				scrollSpeed: 10,
				bubbleScroll: true,
				draggable: /[uo]l/i.test(el.nodeName) ? '>li' : '>*',
				swapThreshold: 1, // percentage; 0 <= x <= 1
				invertSwap: false, // invert always
				invertedSwapThreshold: null, // will be set to same as swapThreshold if default
				removeCloneOnHide: true,
				direction: function() {
					return _detectDirection(el, this.options);
				},
				ghostClass: 'sortable-ghost',
				chosenClass: 'sortable-chosen',
				dragClass: 'sortable-drag',
				ignore: 'a, img',
				filter: null,
				preventOnFilter: true,
				animation: 0,
				easing: null,
				setData: function (dataTransfer, dragEl) {
					dataTransfer.setData('Text', dragEl.textContent);
				},
				dropBubble: false,
				dragoverBubble: false,
				dataIdAttr: 'data-id',
				delay: 0,
				touchStartThreshold: parseInt(window.devicePixelRatio, 10) || 1,
				forceFallback: false,
				fallbackClass: 'sortable-fallback',
				fallbackOnBody: false,
				fallbackTolerance: 0,
				fallbackOffset: {x: 0, y: 0},
				supportPointer: Sortable.supportPointer !== false && (
					('PointerEvent' in window) ||
					window.navigator && ('msPointerEnabled' in window.navigator) // microsoft
				),
				emptyInsertThreshold: 5
			};


			// Set default options
			for (var name in defaults) {
				!(name in options) && (options[name] = defaults[name]);
			}

			_prepareGroup(options);

			// Bind all private methods
			for (var fn in this) {
				if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
					this[fn] = this[fn].bind(this);
				}
			}

			// Setup drag mode
			this.nativeDraggable = options.forceFallback ? false : supportDraggable;

			// Bind events
			if (options.supportPointer) {
				_on(el, 'pointerdown', this._onTapStart);
			} else {
				_on(el, 'mousedown', this._onTapStart);
				_on(el, 'touchstart', this._onTapStart);
			}

			if (this.nativeDraggable) {
				_on(el, 'dragover', this);
				_on(el, 'dragenter', this);
			}

			sortables.push(this.el);

			// Restore sorting
			options.store && options.store.get && this.sort(options.store.get(this) || []);
		}

		Sortable.prototype = /** @lends Sortable.prototype */ {
			constructor: Sortable,

			_computeIsAligned: function(evt) {
				var target;

				if (ghostEl && !supportCssPointerEvents) {
					_hideGhostForTarget();
					target = document.elementFromPoint(evt.clientX, evt.clientY);
					_unhideGhostForTarget();
				} else {
					target = evt.target;
				}

				target = _closest(target, this.options.draggable, this.el, false);
				if (_alignedSilent) { return; }
				if (!dragEl || dragEl.parentNode !== this.el) { return; }

				var children = this.el.children;
				for (var i = 0; i < children.length; i++) {
					// Don't change for target in case it is changed to aligned before onDragOver is fired
					if (_closest(children[i], this.options.draggable, this.el, false) && children[i] !== target) {
						children[i].sortableMouseAligned = _isClientInRowColumn(evt.clientX, evt.clientY, children[i], this._getDirection(evt, null), this.options);
					}
				}
				// Used for nulling last target when not in element, nothing to do with checking if aligned
				if (!_closest(target, this.options.draggable, this.el, true)) {
					lastTarget = null;
				}

				_alignedSilent = true;
				setTimeout(function() {
					_alignedSilent = false;
				}, 30);

			},

			_getDirection: function(evt, target) {
				return (typeof this.options.direction === 'function') ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
			},

			_onTapStart: function (/** Event|TouchEvent */evt) {
				if (!evt.cancelable) { return; }
				var _this = this,
					el = this.el,
					options = this.options,
					preventOnFilter = options.preventOnFilter,
					type = evt.type,
					touch = evt.touches && evt.touches[0],
					target = (touch || evt).target,
					originalTarget = evt.target.shadowRoot && ((evt.path && evt.path[0]) || (evt.composedPath && evt.composedPath()[0])) || target,
					filter = options.filter,
					startIndex;

				_saveInputCheckedState(el);


				// IE: Calls events in capture mode if event element is nested. This ensures only correct element's _onTapStart goes through.
				// This process is also done in _onDragOver
				if (IE11OrLess && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
					return;
				}

				// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
				if (dragEl) {
					return;
				}

				if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
					return; // only left button and enabled
				}

				// cancel dnd if original target is content editable
				if (originalTarget.isContentEditable) {
					return;
				}

				target = _closest(target, options.draggable, el, false);

				if (!target) {
					if (IE11OrLess) {
						_artificalBubble(el, evt, '_onTapStart');
					}
					return;
				}

				if (lastDownEl === target) {
					// Ignoring duplicate `down`
					return;
				}

				// Get the index of the dragged element within its parent
				startIndex = _index(target, options.draggable);

				// Check filter
				if (typeof filter === 'function') {
					if (filter.call(this, evt, target, this)) {
						_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
						preventOnFilter && evt.cancelable && evt.preventDefault();
						return; // cancel dnd
					}
				}
				else if (filter) {
					filter = filter.split(',').some(function (criteria) {
						criteria = _closest(originalTarget, criteria.trim(), el, false);

						if (criteria) {
							_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
							return true;
						}
					});

					if (filter) {
						preventOnFilter && evt.cancelable && evt.preventDefault();
						return; // cancel dnd
					}
				}

				if (options.handle && !_closest(originalTarget, options.handle, el, false)) {
					return;
				}

				// Prepare `dragstart`
				this._prepareDragStart(evt, touch, target, startIndex);
			},


			_handleAutoScroll: function(evt, fallback) {
				if (!dragEl || !this.options.scroll) { return; }
				var x = evt.clientX,
					y = evt.clientY,

					elem = document.elementFromPoint(x, y),
					_this = this;

				// IE does not seem to have native autoscroll,
				// Edge's autoscroll seems too conditional,
				// Firefox and Chrome are good
				if (fallback || Edge || IE11OrLess) {
					_autoScroll(evt, _this.options, elem, fallback);

					// Listener for pointer element change
					var ogElemScroller = _getParentAutoScrollElement(elem, true);
					if (
						scrolling &&
						(
							!pointerElemChangedInterval ||
							x !== lastPointerElemX ||
							y !== lastPointerElemY
						)
					) {

						pointerElemChangedInterval && clearInterval(pointerElemChangedInterval);
						// Detect for pointer elem change, emulating native DnD behaviour
						pointerElemChangedInterval = setInterval(function() {
							if (!dragEl) { return; }
							// could also check if scroll direction on newElem changes due to parent autoscrolling
							var newElem = _getParentAutoScrollElement(document.elementFromPoint(x, y), true);
							if (newElem !== ogElemScroller) {
								ogElemScroller = newElem;
								_clearAutoScrolls();
								_autoScroll(evt, _this.options, ogElemScroller, fallback);
							}
						}, 10);
						lastPointerElemX = x;
						lastPointerElemY = y;
					}

				} else {
					// if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
					if (!_this.options.bubbleScroll || _getParentAutoScrollElement(elem, true) === window) {
						_clearAutoScrolls();
						return;
					}
					_autoScroll(evt, _this.options, _getParentAutoScrollElement(elem, false), false);
				}
			},

			_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
				var _this = this,
					el = _this.el,
					options = _this.options,
					ownerDocument = el.ownerDocument,
					dragStartFn;

				if (target && !dragEl && (target.parentNode === el)) {
					rootEl = el;
					dragEl = target;
					parentEl = dragEl.parentNode;
					nextEl = dragEl.nextSibling;
					lastDownEl = target;
					activeGroup = options.group;
					oldIndex = startIndex;

					tapEvt = {
						target: dragEl,
						clientX: (touch || evt).clientX,
						clientY: (touch || evt).clientY
					};

					this._lastX = (touch || evt).clientX;
					this._lastY = (touch || evt).clientY;

					dragEl.style['will-change'] = 'all';
					// undo animation if needed
					dragEl.style.transition = '';
					dragEl.style.transform = '';

					dragStartFn = function () {
						// Delayed drag has been triggered
						// we can re-enable the events: touchmove/mousemove
						_this._disableDelayedDrag();

						// Make the element draggable
						dragEl.draggable = _this.nativeDraggable;

						// Bind the events: dragstart/dragend
						_this._triggerDragStart(evt, touch);

						// Drag start event
						_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);

						// Chosen item
						_toggleClass(dragEl, options.chosenClass, true);
					};

					// Disable "draggable"
					options.ignore.split(',').forEach(function (criteria) {
						_find(dragEl, criteria.trim(), _disableDraggable);
					});

					if (options.supportPointer) {
						_on(ownerDocument, 'pointerup', _this._onDrop);
					} else {
						_on(ownerDocument, 'mouseup', _this._onDrop);
						_on(ownerDocument, 'touchend', _this._onDrop);
						_on(ownerDocument, 'touchcancel', _this._onDrop);
					}

					if (options.delay) {
						// If the user moves the pointer or let go the click or touch
						// before the delay has been reached:
						// disable the delayed drag
						_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
						_on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
						_on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
						options.supportPointer && _on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);

						_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
					} else {
						dragStartFn();
					}
				}
			},

			_delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/e) {
				var touch = e.touches ? e.touches[0] : e;
				if (min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY))
						>= this.options.touchStartThreshold
				) {
					this._disableDelayedDrag();
				}
			},

			_disableDelayedDrag: function () {
				var ownerDocument = this.el.ownerDocument;

				clearTimeout(this._dragStartTimer);
				_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
				_off(ownerDocument, 'touchend', this._disableDelayedDrag);
				_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
				_off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
				_off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
				_off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
			},

			_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
				touch = touch || (evt.pointerType == 'touch' ? evt : null);

				if (!this.nativeDraggable || touch) {
					if (this.options.supportPointer) {
						_on(document, 'pointermove', this._onTouchMove);
					} else if (touch) {
						_on(document, 'touchmove', this._onTouchMove);
					} else {
						_on(document, 'mousemove', this._onTouchMove);
					}
				} else {
					_on(dragEl, 'dragend', this);
					_on(rootEl, 'dragstart', this._onDragStart);
				}

				try {
					if (document.selection) {
						// Timeout neccessary for IE9
						_nextTick(function () {
							document.selection.empty();
						});
					} else {
						window.getSelection().removeAllRanges();
					}
				} catch (err) {
				}
			},

			_dragStarted: function (fallback) {
				awaitingDragStarted = false;
				if (rootEl && dragEl) {
					if (this.nativeDraggable) {
						_on(document, 'dragover', this._handleAutoScroll);
						_on(document, 'dragover', _checkAlignment);
					}
					var options = this.options;

					// Apply effect
					!fallback && _toggleClass(dragEl, options.dragClass, false);
					_toggleClass(dragEl, options.ghostClass, true);

					// In case dragging an animated element
					_css(dragEl, 'transform', '');

					Sortable.active = this;

					fallback && this._appendGhost();

					// Drag start event
					_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);
				} else {
					this._nulling();
				}
			},

			_emulateDragOver: function (bypassLastTouchCheck) {
				if (touchEvt) {
					if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !bypassLastTouchCheck) {
						return;
					}
					this._lastX = touchEvt.clientX;
					this._lastY = touchEvt.clientY;

					_hideGhostForTarget();

					var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
					var parent = target;

					while (target && target.shadowRoot) {
						target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
						parent = target;
					}

					if (parent) {
						do {
							if (parent[expando]) {
								var inserted;

								inserted = parent[expando]._onDragOver({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});

								if (inserted && !this.options.dragoverBubble) {
									break;
								}
							}

							target = parent; // store last element
						}
						/* jshint boss:true */
						while (parent = parent.parentNode);
					}
					dragEl.parentNode[expando]._computeIsAligned(touchEvt);

					_unhideGhostForTarget();
				}
			},


			_onTouchMove: function (/**TouchEvent*/evt) {
				if (tapEvt) {
					var	options = this.options,
						fallbackTolerance = options.fallbackTolerance,
						fallbackOffset = options.fallbackOffset,
						touch = evt.touches ? evt.touches[0] : evt,
						matrix = ghostEl && _matrix(ghostEl),
						scaleX = ghostEl && matrix && matrix.a,
						scaleY = ghostEl && matrix && matrix.d,
						dx = ((touch.clientX - tapEvt.clientX) + fallbackOffset.x) / (scaleX ? scaleX : 1),
						dy = ((touch.clientY - tapEvt.clientY) + fallbackOffset.y) / (scaleY ? scaleY : 1),
						translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';


					// only set the status to dragging, when we are actually dragging
					if (!Sortable.active && !awaitingDragStarted) {
						if (fallbackTolerance &&
							min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
						) {
							return;
						}
						this._onDragStart(evt, true);
					}

					this._handleAutoScroll(touch, true);


					moved = true;
					touchEvt = touch;


					_css(ghostEl, 'webkitTransform', translate3d);
					_css(ghostEl, 'mozTransform', translate3d);
					_css(ghostEl, 'msTransform', translate3d);
					_css(ghostEl, 'transform', translate3d);

					evt.cancelable && evt.preventDefault();
				}
			},

			_appendGhost: function () {
				if (!ghostEl) {
					var rect = _getRect(dragEl, this.options.fallbackOnBody ? document.body : rootEl, true),
						css = _css(dragEl),
						options = this.options;

					ghostEl = dragEl.cloneNode(true);

					_toggleClass(ghostEl, options.ghostClass, false);
					_toggleClass(ghostEl, options.fallbackClass, true);
					_toggleClass(ghostEl, options.dragClass, true);

					_css(ghostEl, 'box-sizing', 'border-box');
					_css(ghostEl, 'margin', 0);
					_css(ghostEl, 'top', rect.top);
					_css(ghostEl, 'left', rect.left);
					_css(ghostEl, 'width', rect.width);
					_css(ghostEl, 'height', rect.height);
					_css(ghostEl, 'opacity', '0.8');
					_css(ghostEl, 'position', 'fixed');
					_css(ghostEl, 'zIndex', '100000');
					_css(ghostEl, 'pointerEvents', 'none');

					options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
				}
			},

			_onDragStart: function (/**Event*/evt, /**boolean*/fallback) {
				var _this = this;
				var dataTransfer = evt.dataTransfer;
				var options = _this.options;

				// Setup clone
				cloneEl = _clone(dragEl);

				cloneEl.draggable = false;
				cloneEl.style['will-change'] = '';

				this._hideClone();

				_toggleClass(cloneEl, _this.options.chosenClass, false);


				// #1143: IFrame support workaround
				_this._cloneId = _nextTick(function () {
					if (!_this.options.removeCloneOnHide) {
						rootEl.insertBefore(cloneEl, dragEl);
					}
					_dispatchEvent(_this, rootEl, 'clone', dragEl);
				});


				!fallback && _toggleClass(dragEl, options.dragClass, true);

				// Set proper drop events
				if (fallback) {
					ignoreNextClick = true;
					_this._loopId = setInterval(_this._emulateDragOver, 50);
				} else {
					// Undo what was set in _prepareDragStart before drag started
					_off(document, 'mouseup', _this._onDrop);
					_off(document, 'touchend', _this._onDrop);
					_off(document, 'touchcancel', _this._onDrop);

					if (dataTransfer) {
						dataTransfer.effectAllowed = 'move';
						options.setData && options.setData.call(_this, dataTransfer, dragEl);
					}

					_on(document, 'drop', _this);

					// #1276 fix:
					_css(dragEl, 'transform', 'translateZ(0)');
				}

				awaitingDragStarted = true;

				_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback));
				_on(document, 'selectstart', _this);
			},

			// Returns true - if no further action is needed (either inserted or another condition)
			_onDragOver: function (/**Event*/evt) {
				var el = this.el,
					target = evt.target,
					dragRect,
					targetRect,
					revert,
					options = this.options,
					group = options.group,
					activeSortable = Sortable.active,
					isOwner = (activeGroup === group),
					canSort = options.sort,
					_this = this;

				if (_silent) { return; }

				// IE event order fix
				if (IE11OrLess && !evt.rootEl && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
					return;
				}

				// Return invocation when no further action is needed in another sortable
				function completed() {
					if (activeSortable) {
						// Set ghost class to new sortable's ghost class
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
						_toggleClass(dragEl, options.ghostClass, true);
					}

					if (putSortable !== _this && _this !== Sortable.active) {
						putSortable = _this;
					} else if (_this === Sortable.active) {
						putSortable = null;
					}


					// Null lastTarget if it is not inside a previously swapped element
					if ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {
						lastTarget = null;
					}
					// no bubbling and not fallback
					if (!options.dragoverBubble && !evt.rootEl && target !== document) {
						_this._handleAutoScroll(evt);
						dragEl.parentNode[expando]._computeIsAligned(evt);
					}

					!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();

					return true;
				}

				// Call when dragEl has been inserted
				function changed() {
					_dispatchEvent(_this, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl, options.draggable), evt);
				}


				if (evt.preventDefault !== void 0) {
					evt.cancelable && evt.preventDefault();
				}


				moved = true;

				target = _closest(target, options.draggable, el, true);

				// target is dragEl or target is animated
				if (!!_closest(evt.target, null, dragEl, true) || target.animated) {
					return completed();
				}

				if (target !== dragEl) {
					ignoreNextClick = false;
				}

				if (activeSortable && !options.disabled &&
					(isOwner
						? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
						: (
							putSortable === this ||
							(
								(this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
								group.checkPut(this, activeSortable, dragEl, evt)
							)
						)
					)
				) {
					var axis = this._getDirection(evt, target);

					dragRect = _getRect(dragEl);

					if (revert) {
						this._hideClone();
						parentEl = rootEl; // actualization

						if (nextEl) {
							rootEl.insertBefore(dragEl, nextEl);
						} else {
							rootEl.appendChild(dragEl);
						}

						return completed();
					}

					if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
						_ghostIsLast(evt, axis, el) && !dragEl.animated
					) {
						//assign target only if condition is true
						if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
							target = _lastChild(el);
						}

						if (target) {
							targetRect = _getRect(target);
						}

						if (isOwner) {
							activeSortable._hideClone();
						} else {
							activeSortable._showClone(this);
						}

						if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
							realDragElRect = null;

							changed();
							this._animate(dragRect, dragEl);
							target && this._animate(targetRect, target);
							return completed();
						}
					}
					else if (target && target !== dragEl && target.parentNode === el) {
						var direction = 0,
							targetBeforeFirstSwap,
							aligned = target.sortableMouseAligned,
							differentLevel = dragEl.parentNode !== el,
							scrolledPastTop = _isScrolledPast(target, axis === 'vertical' ? 'top' : 'left');

						if (lastTarget !== target) {
							lastMode = null;
							targetBeforeFirstSwap = _getRect(target)[axis === 'vertical' ? 'top' : 'left'];
							pastFirstInvertThresh = false;
						}

						// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0
						if (
							_isElInRowColumn(dragEl, target, axis) && aligned ||
							differentLevel ||
							scrolledPastTop ||
							options.invertSwap ||
							lastMode === 'insert' ||
							// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside
							// and lastMode will change to 'insert', but we must swap
							lastMode === 'swap'
						) {
							// New target that we will be inside
							if (lastMode !== 'swap') {
								isCircumstantialInvert = options.invertSwap || differentLevel || scrolling || scrolledPastTop;
							}

							direction = _getSwapDirection(evt, target, axis,
								options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,
								isCircumstantialInvert,
								lastTarget === target);
							lastMode = 'swap';
						} else {
							// Insert at position
							direction = _getInsertDirection(target, options);
							lastMode = 'insert';
						}
						if (direction === 0) { return completed(); }

						realDragElRect = null;
						lastTarget = target;

						lastDirection = direction;

						targetRect = _getRect(target);

						var nextSibling = target.nextElementSibling,
							after = false;

						after = direction === 1;

						var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

						if (moveVector !== false) {
							if (moveVector === 1 || moveVector === -1) {
								after = (moveVector === 1);
							}

							_silent = true;
							setTimeout(_unsilent, 30);

							if (isOwner) {
								activeSortable._hideClone();
							} else {
								activeSortable._showClone(this);
							}

							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
							}

							parentEl = dragEl.parentNode; // actualization

							// must be done before animation
							if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
								targetMoveDistance = abs(targetBeforeFirstSwap - _getRect(target)[axis === 'vertical' ? 'top' : 'left']);
							}
							changed();
							!differentLevel && this._animate(targetRect, target);
							this._animate(dragRect, dragEl);

							return completed();
						}
					}

					if (el.contains(dragEl)) {
						return completed();
					}
				}

				if (IE11OrLess && !evt.rootEl) {
					_artificalBubble(el, evt, '_onDragOver');
				}

				return false;
			},

			_animate: function (prevRect, target) {
				var ms = this.options.animation;

				if (ms) {
					var currentRect = _getRect(target);

					if (target === dragEl) {
						realDragElRect = currentRect;
					}

					if (prevRect.nodeType === 1) {
						prevRect = _getRect(prevRect);
					}

					// Check if actually moving position
					if ((prevRect.left + prevRect.width / 2) !== (currentRect.left + currentRect.width / 2)
						|| (prevRect.top + prevRect.height / 2) !== (currentRect.top + currentRect.height / 2)
					) {
						var matrix = _matrix(this.el),
							scaleX = matrix && matrix.a,
							scaleY = matrix && matrix.d;

						_css(target, 'transition', 'none');
						_css(target, 'transform', 'translate3d('
							+ (prevRect.left - currentRect.left) / (scaleX ? scaleX : 1) + 'px,'
							+ (prevRect.top - currentRect.top) / (scaleY ? scaleY : 1) + 'px,0)'
						);

						forRepaintDummy = target.offsetWidth; // repaint
						_css(target, 'transition', 'transform ' + ms + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
						_css(target, 'transform', 'translate3d(0,0,0)');
					}

					(typeof target.animated === 'number') && clearTimeout(target.animated);
					target.animated = setTimeout(function () {
						_css(target, 'transition', '');
						_css(target, 'transform', '');
						target.animated = false;
					}, ms);
				}
			},

			_offUpEvents: function () {
				var ownerDocument = this.el.ownerDocument;

				_off(document, 'touchmove', this._onTouchMove);
				_off(document, 'pointermove', this._onTouchMove);
				_off(ownerDocument, 'mouseup', this._onDrop);
				_off(ownerDocument, 'touchend', this._onDrop);
				_off(ownerDocument, 'pointerup', this._onDrop);
				_off(ownerDocument, 'touchcancel', this._onDrop);
				_off(document, 'selectstart', this);
			},

			_onDrop: function (/**Event*/evt) {
				var el = this.el,
					options = this.options;
				awaitingDragStarted = false;
				scrolling = false;
				isCircumstantialInvert = false;
				pastFirstInvertThresh = false;

				clearInterval(this._loopId);

				clearInterval(pointerElemChangedInterval);
				_clearAutoScrolls();
				_cancelThrottle();

				clearTimeout(this._dragStartTimer);

				_cancelNextTick(this._cloneId);
				_cancelNextTick(this._dragStartId);

				// Unbind events
				_off(document, 'mousemove', this._onTouchMove);


				if (this.nativeDraggable) {
					_off(document, 'drop', this);
					_off(el, 'dragstart', this._onDragStart);
					_off(document, 'dragover', this._handleAutoScroll);
					_off(document, 'dragover', _checkAlignment);
				}

				this._offUpEvents();

				if (evt) {
					if (moved) {
						evt.cancelable && evt.preventDefault();
						!options.dropBubble && evt.stopPropagation();
					}

					ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

					if (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {
						// Remove clone
						cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
					}

					if (dragEl) {
						if (this.nativeDraggable) {
							_off(dragEl, 'dragend', this);
						}

						_disableDraggable(dragEl);
						dragEl.style['will-change'] = '';

						// Remove class's
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
						_toggleClass(dragEl, this.options.chosenClass, false);

						// Drag stop event
						_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, evt);

						if (rootEl !== parentEl) {
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// Add event
								_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

								// Remove event
								_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

								// drag from one list and drop into another
								_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
							}

							putSortable && putSortable.save();
						}
						else {
							if (dragEl.nextSibling !== nextEl) {
								// Get the index of the dragged element within its parent
								newIndex = _index(dragEl, options.draggable);

								if (newIndex >= 0) {
									// drag & drop within the same list
									_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
									_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								}
							}
						}

						if (Sortable.active) {
							/* jshint eqnull:true */
							if (newIndex == null || newIndex === -1) {
								newIndex = oldIndex;
							}

							_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

							// Save sorting
							this.save();
						}
					}

				}
				this._nulling();
			},

			_nulling: function() {
				rootEl =
				dragEl =
				parentEl =
				ghostEl =
				nextEl =
				cloneEl =
				lastDownEl =

				scrollEl =
				scrollParentEl =
				autoScrolls.length =

				pointerElemChangedInterval =
				lastPointerElemX =
				lastPointerElemY =

				tapEvt =
				touchEvt =

				moved =
				newIndex =
				oldIndex =

				lastTarget =
				lastDirection =

				forRepaintDummy =
				realDragElRect =

				putSortable =
				activeGroup =
				Sortable.active = null;

				savedInputChecked.forEach(function (el) {
					el.checked = true;
				});

				savedInputChecked.length = 0;
			},

			handleEvent: function (/**Event*/evt) {
				switch (evt.type) {
					case 'drop':
					case 'dragend':
						this._onDrop(evt);
						break;

					case 'dragenter':
					case 'dragover':
						if (dragEl) {
							this._onDragOver(evt);
							_globalDragOver(evt);
						}
						break;

					case 'selectstart':
						evt.preventDefault();
						break;
				}
			},


			/**
			 * Serializes the item into an array of string.
			 * @returns {String[]}
			 */
			toArray: function () {
				var order = [],
					el,
					children = this.el.children,
					i = 0,
					n = children.length,
					options = this.options;

				for (; i < n; i++) {
					el = children[i];
					if (_closest(el, options.draggable, this.el, false)) {
						order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
					}
				}

				return order;
			},


			/**
			 * Sorts the elements according to the array.
			 * @param  {String[]}  order  order of the items
			 */
			sort: function (order) {
				var items = {}, rootEl = this.el;

				this.toArray().forEach(function (id, i) {
					var el = rootEl.children[i];

					if (_closest(el, this.options.draggable, rootEl, false)) {
						items[id] = el;
					}
				}, this);

				order.forEach(function (id) {
					if (items[id]) {
						rootEl.removeChild(items[id]);
						rootEl.appendChild(items[id]);
					}
				});
			},


			/**
			 * Save the current sorting
			 */
			save: function () {
				var store = this.options.store;
				store && store.set && store.set(this);
			},


			/**
			 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
			 * @param   {HTMLElement}  el
			 * @param   {String}       [selector]  default: `options.draggable`
			 * @returns {HTMLElement|null}
			 */
			closest: function (el, selector) {
				return _closest(el, selector || this.options.draggable, this.el, false);
			},


			/**
			 * Set/get option
			 * @param   {string} name
			 * @param   {*}      [value]
			 * @returns {*}
			 */
			option: function (name, value) {
				var options = this.options;

				if (value === void 0) {
					return options[name];
				} else {
					options[name] = value;

					if (name === 'group') {
						_prepareGroup(options);
					}
				}
			},


			/**
			 * Destroy
			 */
			destroy: function () {
				var el = this.el;

				el[expando] = null;

				_off(el, 'mousedown', this._onTapStart);
				_off(el, 'touchstart', this._onTapStart);
				_off(el, 'pointerdown', this._onTapStart);

				if (this.nativeDraggable) {
					_off(el, 'dragover', this);
					_off(el, 'dragenter', this);
				}
				// Remove draggable attributes
				Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
					el.removeAttribute('draggable');
				});

				this._onDrop();

				sortables.splice(sortables.indexOf(this.el), 1);

				this.el = el = null;
			},

			_hideClone: function() {
				if (!cloneEl.cloneHidden) {
					_css(cloneEl, 'display', 'none');
					cloneEl.cloneHidden = true;
					if (cloneEl.parentNode && this.options.removeCloneOnHide) {
						cloneEl.parentNode.removeChild(cloneEl);
					}
				}
			},

			_showClone: function(putSortable) {
				if (putSortable.lastPutMode !== 'clone') {
					this._hideClone();
					return;
				}

				if (cloneEl.cloneHidden) {
					// show clone at dragEl or original position
					if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
						rootEl.insertBefore(cloneEl, dragEl);
					} else if (nextEl) {
						rootEl.insertBefore(cloneEl, nextEl);
					} else {
						rootEl.appendChild(cloneEl);
					}

					if (this.options.group.revertClone) {
						this._animate(dragEl, cloneEl);
					}
					_css(cloneEl, 'display', '');
					cloneEl.cloneHidden = false;
				}
			}
		};

		function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
			if (el) {
				ctx = ctx || document;

				do {
					if (
						selector != null &&
						(
							selector[0] === '>' && el.parentNode === ctx && _matches(el, selector.substring(1)) ||
							_matches(el, selector)
						) ||
						includeCTX && el === ctx
					) {
						return el;
					}

					if (el === ctx) { break; }
					/* jshint boss:true */
				} while (el = _getParentOrHost(el));
			}

			return null;
		}


		function _getParentOrHost(el) {
			return (el.host && el !== document && el.host.nodeType)
				? el.host
				: el.parentNode;
		}


		function _globalDragOver(/**Event*/evt) {
			if (evt.dataTransfer) {
				evt.dataTransfer.dropEffect = 'move';
			}
			evt.cancelable && evt.preventDefault();
		}


		function _on(el, event, fn) {
			el.addEventListener(event, fn, captureMode);
		}


		function _off(el, event, fn) {
			el.removeEventListener(event, fn, captureMode);
		}


		function _toggleClass(el, name, state) {
			if (el && name) {
				if (el.classList) {
					el.classList[state ? 'add' : 'remove'](name);
				}
				else {
					var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
					el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
				}
			}
		}


		function _css(el, prop, val) {
			var style = el && el.style;

			if (style) {
				if (val === void 0) {
					if (document.defaultView && document.defaultView.getComputedStyle) {
						val = document.defaultView.getComputedStyle(el, '');
					}
					else if (el.currentStyle) {
						val = el.currentStyle;
					}

					return prop === void 0 ? val : val[prop];
				}
				else {
					if (!(prop in style) && prop.indexOf('webkit') === -1) {
						prop = '-webkit-' + prop;
					}

					style[prop] = val + (typeof val === 'string' ? '' : 'px');
				}
			}
		}

		function _matrix(el) {
			var appliedTransforms = '';
			do {
				var transform = _css(el, 'transform');

				if (transform && transform !== 'none') {
					appliedTransforms = transform + ' ' + appliedTransforms;
				}
				/* jshint boss:true */
			} while (el = el.parentNode);

			if (window.DOMMatrix) {
				return new DOMMatrix(appliedTransforms);
			} else if (window.WebKitCSSMatrix) {
				return new WebKitCSSMatrix(appliedTransforms);
			} else if (window.CSSMatrix) {
				return new CSSMatrix(appliedTransforms);
			}
		}


		function _find(ctx, tagName, iterator) {
			if (ctx) {
				var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

				if (iterator) {
					for (; i < n; i++) {
						iterator(list[i], i);
					}
				}

				return list;
			}

			return [];
		}



		function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex, originalEvt) {
			sortable = (sortable || rootEl[expando]);
			var evt,
				options = sortable.options,
				onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
			// Support for new CustomEvent feature
			if (window.CustomEvent && !IE11OrLess && !Edge) {
				evt = new CustomEvent(name, {
					bubbles: true,
					cancelable: true
				});
			} else {
				evt = document.createEvent('Event');
				evt.initEvent(name, true, true);
			}

			evt.to = toEl || rootEl;
			evt.from = fromEl || rootEl;
			evt.item = targetEl || rootEl;
			evt.clone = cloneEl;

			evt.oldIndex = startIndex;
			evt.newIndex = newIndex;

			evt.originalEvent = originalEvt;

			if (rootEl) {
				rootEl.dispatchEvent(evt);
		        }

			if (options[onName]) {
				options[onName].call(sortable, evt);
			}
		}


		function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
			var evt,
				sortable = fromEl[expando],
				onMoveFn = sortable.options.onMove,
				retVal;
			// Support for new CustomEvent feature
			if (window.CustomEvent && !IE11OrLess && !Edge) {
				evt = new CustomEvent('move', {
					bubbles: true,
					cancelable: true
				});
			} else {
				evt = document.createEvent('Event');
				evt.initEvent('move', true, true);
			}

			evt.to = toEl;
			evt.from = fromEl;
			evt.dragged = dragEl;
			evt.draggedRect = dragRect;
			evt.related = targetEl || toEl;
			evt.relatedRect = targetRect || _getRect(toEl);
			evt.willInsertAfter = willInsertAfter;

			evt.originalEvent = originalEvt;

			fromEl.dispatchEvent(evt);

			if (onMoveFn) {
				retVal = onMoveFn.call(sortable, evt, originalEvt);
			}

			return retVal;
		}

		function _disableDraggable(el) {
			el.draggable = false;
		}

		function _unsilent() {
			_silent = false;
		}

		/**
		 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
		 * and non-draggable elements
		 * @param  {HTMLElement} el       The parent element
		 * @param  {Number} childNum      The index of the child
		 * @param  {Object} options       Parent Sortable's options
		 * @return {HTMLElement}          The child at index childNum, or null if not found
		 */
		function _getChild(el, childNum, options) {
			var currentChild = 0,
				i = 0,
				children = el.children;

			while (i < children.length) {
				if (
					children[i].style.display !== 'none' &&
					children[i] !== ghostEl &&
					children[i] !== dragEl &&
					_closest(children[i], options.draggable, el, false)
				) {
					if (currentChild === childNum) {
						return children[i];
					}
					currentChild++;
				}

				i++;
			}
			return null;
		}

		/**
		 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
		 * @param  {HTMLElement} el       Parent element
		 * @return {HTMLElement}          The last child, ignoring ghostEl
		 */
		function _lastChild(el) {
			var last = el.lastElementChild;

			while (last === ghostEl || last.style.display === 'none') {
				last = last.previousElementSibling;

				if (!last) { break; }
			}

			return last || null;
		}

		function _ghostIsLast(evt, axis, el) {
			var elRect = _getRect(_lastChild(el)),
				mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
				mouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,
				targetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,
				targetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,
				targetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,
				spacer = 10;

			return (
				axis === 'vertical' ?
					(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :
					(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)
			);
		}

		function _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
			var targetRect = _getRect(target),
				mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
				targetLength = axis === 'vertical' ? targetRect.height : targetRect.width,
				targetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,
				targetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,
				dragRect = _getRect(dragEl),
				invert = false;


			if (!invertSwap) {
				// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
				if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
					// check if past first invert threshold on side opposite of lastDirection
					if (!pastFirstInvertThresh &&
						(lastDirection === 1 ?
							(
								mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2
							) :
							(
								mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2
							)
						)
					)
					{
						// past first invert threshold, do not restrict inverted threshold to dragEl shadow
						pastFirstInvertThresh = true;
					}

					if (!pastFirstInvertThresh) {
						var dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,
							dragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;
						// dragEl shadow (target move distance shadow)
						if (
							lastDirection === 1 ?
							(
								mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
							) :
							(
								mouseOnAxis > targetS2 - targetMoveDistance
							)
						)
						{
							return lastDirection * -1;
						}
					} else {
						invert = true;
					}
				} else {
					// Regular
					if (
						mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&
						mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)
					) {
						return ((mouseOnAxis > targetS1 + targetLength / 2) ? -1 : 1);
					}
				}
			}

			invert = invert || invertSwap;

			if (invert) {
				// Invert of regular
				if (
					mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||
					mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)
				)
				{
					return ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);
				}
			}

			return 0;
		}

		/**
		 * Gets the direction dragEl must be swapped relative to target in order to make it
		 * seem that dragEl has been "inserted" into that element's position
		 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
		 * @param  {Object} options           options of the parent sortable
		 * @return {Number}                   Direction dragEl must be swapped
		 */
		function _getInsertDirection(target, options) {
			var dragElIndex = _index(dragEl, options.draggable),
				targetIndex = _index(target, options.draggable);

			if (dragElIndex < targetIndex) {
				return 1;
			} else {
				return -1;
			}
		}


		/**
		 * Generate id
		 * @param   {HTMLElement} el
		 * @returns {String}
		 * @private
		 */
		function _generateId(el) {
			var str = el.tagName + el.className + el.src + el.href + el.textContent,
				i = str.length,
				sum = 0;

			while (i--) {
				sum += str.charCodeAt(i);
			}

			return sum.toString(36);
		}

		/**
		 * Returns the index of an element within its parent for a selected set of
		 * elements
		 * @param  {HTMLElement} el
		 * @param  {selector} selector
		 * @return {number}
		 */
		function _index(el, selector) {
			var index = 0;

			if (!el || !el.parentNode) {
				return -1;
			}

			while (el && (el = el.previousElementSibling)) {
				if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== cloneEl) {
					index++;
				}
			}

			return index;
		}

		function _matches(/**HTMLElement*/el, /**String*/selector) {
			if (el) {
				try {
					if (el.matches) {
						return el.matches(selector);
					} else if (el.msMatchesSelector) {
						return el.msMatchesSelector(selector);
					} else if (el.webkitMatchesSelector) {
						return el.webkitMatchesSelector(selector);
					}
				} catch(_) {
					return false;
				}
			}

			return false;
		}

		var _throttleTimeout;
		function _throttle(callback, ms) {
			return function () {
				if (!_throttleTimeout) {
					var args = arguments,
						_this = this;

					_throttleTimeout = setTimeout(function () {
						if (args.length === 1) {
							callback.call(_this, args[0]);
						} else {
							callback.apply(_this, args);
						}

						_throttleTimeout = void 0;
					}, ms);
				}
			};
		}

		function _cancelThrottle() {
			clearTimeout(_throttleTimeout);
			_throttleTimeout = void 0;
		}

		function _extend(dst, src) {
			if (dst && src) {
				for (var key in src) {
					if (src.hasOwnProperty(key)) {
						dst[key] = src[key];
					}
				}
			}

			return dst;
		}

		function _clone(el) {
			if (Polymer && Polymer.dom) {
				return Polymer.dom(el).cloneNode(true);
			}
			else if ($) {
				return $(el).clone(true)[0];
			}
			else {
				return el.cloneNode(true);
			}
		}

		function _saveInputCheckedState(root) {
			savedInputChecked.length = 0;

			var inputs = root.getElementsByTagName('input');
			var idx = inputs.length;

			while (idx--) {
				var el = inputs[idx];
				el.checked && savedInputChecked.push(el);
			}
		}

		function _nextTick(fn) {
			return setTimeout(fn, 0);
		}

		function _cancelNextTick(id) {
			return clearTimeout(id);
		}


		/**
		 * Returns the "bounding client rect" of given element
		 * @param  {HTMLElement} el                The element whose boundingClientRect is wanted
		 * @param  {[HTMLElement]} container       the parent the element will be placed in
		 * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform
		 * (used for fixed positioning on el)
		 * @return {Object}                        The boundingClientRect of el
		 */
		function _getRect(el, container, adjustForTransform) {
			if (!el.getBoundingClientRect && el !== win) { return; }

			var elRect,
				top,
				left,
				bottom,
				right,
				height,
				width;

			if (el !== win) {
				elRect = el.getBoundingClientRect();
				top = elRect.top;
				left = elRect.left;
				bottom = elRect.bottom;
				right = elRect.right;
				height = elRect.height;
				width = elRect.width;
			} else {
				top = 0;
				left = 0;
				bottom = window.innerHeight;
				right = window.innerWidth;
				height = window.innerHeight;
				width = window.innerWidth;
			}

			if (adjustForTransform && el !== win) {
				// Adjust for translate()
				container = container || el.parentNode;

				// solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
				// Not needed on <= IE11
				if (!IE11OrLess) {
					do {
						if (container && container.getBoundingClientRect && _css(container, 'transform') !== 'none') {
							var containerRect = container.getBoundingClientRect();

							// Set relative to edges of padding box of container
							top -= containerRect.top + parseInt(_css(container, 'border-top-width'));
							left -= containerRect.left + parseInt(_css(container, 'border-left-width'));
							bottom = top + elRect.height;
							right = left + elRect.width;

							break;
						}
						/* jshint boss:true */
					} while (container = container.parentNode);
				}

				// Adjust for scale()
				var matrix = _matrix(el),
					scaleX = matrix && matrix.a,
					scaleY = matrix && matrix.d;

				if (matrix) {
					top /= scaleY;
					left /= scaleX;

					width /= scaleX;
					height /= scaleY;

					bottom = top + height;
					right = left + width;
				}
			}

			return {
				top: top,
				left: left,
				bottom: bottom,
				right: right,
				width: width,
				height: height
			};
		}


		/**
		 * Checks if a side of an element is scrolled past a side of it's parents
		 * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question
		 * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')
		 * @return {Boolean}               Whether the element is overflowing the viewport on the given side of it's parent
		 */
		function _isScrolledPast(el, side) {
			var parent = _getParentAutoScrollElement(parent, true),
				elSide = _getRect(el)[side];

			/* jshint boss:true */
			while (parent) {
				var parentSide = _getRect(parent)[side],
					visible;

				if (side === 'top' || side === 'left') {
					visible = elSide >= parentSide;
				} else {
					visible = elSide <= parentSide;
				}

				if (!visible) { return true; }

				if (parent === win) { break; }

				parent = _getParentAutoScrollElement(parent, false);
			}

			return false;
		}

		// Fixed #973:
		_on(document, 'touchmove', function(evt) {
			if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
				evt.preventDefault();
			}
		});


		// Export utils
		Sortable.utils = {
			on: _on,
			off: _off,
			css: _css,
			find: _find,
			is: function (el, selector) {
				return !!_closest(el, selector, el, false);
			},
			extend: _extend,
			throttle: _throttle,
			closest: _closest,
			toggleClass: _toggleClass,
			clone: _clone,
			index: _index,
			nextTick: _nextTick,
			cancelNextTick: _cancelNextTick,
			detectDirection: _detectDirection,
			getChild: _getChild
		};


		/**
		 * Create sortable instance
		 * @param {HTMLElement}  el
		 * @param {Object}      [options]
		 */
		Sortable.create = function (el, options) {
			return new Sortable(el, options);
		};


		// Export
		Sortable.version = '1.8.3';
		return Sortable;
	});
	});

	var Sortable$2 = /*#__PURE__*/Object.freeze({
		default: Sortable$1,
		__moduleExports: Sortable$1
	});

	var require$$0 = ( Sortable$2 && Sortable$1 ) || Sortable$2;

	var frappeDatatable_cjs = createCommonjsModule(function (module) {

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var Sortable = _interopDefault(require$$0);

	function $(expr, con) {
	    return typeof expr === 'string' ?
	        (con || document).querySelector(expr) :
	        expr || null;
	}

	$.each = function (expr, con) {
	    return typeof expr === 'string' ?
	        Array.from((con || document).querySelectorAll(expr)) :
	        expr || null;
	};

	$.create = function (tag, o) {
	    var element = document.createElement(tag);

	    var loop = function ( i ) {
	        var val = o[i];

	        if (i === 'inside') {
	            $(val).appendChild(element);
	        } else
	        if (i === 'around') {
	            var ref = $(val);
	            ref.parentNode.insertBefore(element, ref);
	            element.appendChild(ref);
	        } else
	        if (i === 'styles') {
	            if (typeof val === 'object') {
	                Object.keys(val).map(function (prop) {
	                    element.style[prop] = val[prop];
	                });
	            }
	        } else
	        if (i in element) {
	            element[i] = val;
	        } else {
	            element.setAttribute(i, val);
	        }
	    };

	    for (var i in o) loop( i );

	    return element;
	};

	$.on = function (element, event, selector, callback) {
	    if (!callback) {
	        callback = selector;
	        $.bind(element, event, callback);
	    } else {
	        $.delegate(element, event, selector, callback);
	    }
	};

	$.off = function (element, event, handler) {
	    element.removeEventListener(event, handler);
	};

	$.bind = function (element, event, callback) {
	    event.split(/\s+/).forEach(function (event) {
	        element.addEventListener(event, callback);
	    });
	};

	$.delegate = function (element, event, selector, callback) {
	    element.addEventListener(event, function (e) {
	        var delegatedTarget = e.target.closest(selector);
	        if (delegatedTarget) {
	            e.delegatedTarget = delegatedTarget;
	            callback.call(this, e, delegatedTarget);
	        }
	    });
	};

	$.unbind = function (element, o) {
	    if (element) {
	        var loop = function ( event ) {
	            var callback = o[event];

	            event.split(/\s+/).forEach(function (event) {
	                element.removeEventListener(event, callback);
	            });
	        };

	        for (var event in o) loop( event );
	    }
	};

	$.fire = function (target, type, properties) {
	    var evt = document.createEvent('HTMLEvents');

	    evt.initEvent(type, true, true);

	    for (var j in properties) {
	        evt[j] = properties[j];
	    }

	    return target.dispatchEvent(evt);
	};

	$.data = function (element, attrs) { // eslint-disable-line
	    if (!attrs) {
	        return element.dataset;
	    }

	    for (var attr in attrs) {
	        element.dataset[attr] = attrs[attr];
	    }
	};

	$.style = function (elements, styleMap) { // eslint-disable-line

	    if (typeof styleMap === 'string') {
	        return $.getStyle(elements, styleMap);
	    }

	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    elements.map(function (element) {
	        for (var prop in styleMap) {
	            element.style[prop] = styleMap[prop];
	        }
	    });
	};

	$.removeStyle = function (elements, styleProps) {
	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    if (!Array.isArray(styleProps)) {
	        styleProps = [styleProps];
	    }

	    elements.map(function (element) {
	        for (var i = 0, list = styleProps; i < list.length; i += 1) {
	            var prop = list[i];

	          element.style[prop] = '';
	        }
	    });
	};

	$.getStyle = function (element, prop) {
	    if (!prop) {
	        return getComputedStyle(element);
	    }

	    var val = getComputedStyle(element)[prop];

	    if (['width', 'height'].includes(prop)) {
	        val = parseFloat(val);
	    }

	    return val;
	};

	$.closest = function (selector, element) {
	    if (!element) { return null; }

	    if (element.matches(selector)) {
	        return element;
	    }

	    return $.closest(selector, element.parentNode);
	};

	$.inViewport = function (el, parentEl) {
	    var ref = el.getBoundingClientRect();
	    var top = ref.top;
	    var left = ref.left;
	    var bottom = ref.bottom;
	    var right = ref.right;
	    var ref$1 = parentEl.getBoundingClientRect();
	    var pTop = ref$1.top;
	    var pLeft = ref$1.left;
	    var pBottom = ref$1.bottom;
	    var pRight = ref$1.right;

	    return top >= pTop && left >= pLeft && bottom <= pBottom && right <= pRight;
	};

	$.scrollTop = function scrollTop(element, pixels) {
	    requestAnimationFrame(function () {
	        element.scrollTop = pixels;
	    });
	};

	$.scrollbarSize = function scrollbarSize() {
	    if (!$.scrollBarSizeValue) {
	        $.scrollBarSizeValue = getScrollBarSize();
	    }
	    return $.scrollBarSizeValue;
	};

	function getScrollBarSize() {
	    // assume scrollbar width and height would be the same

	    // Create the measurement node
	    var scrollDiv = document.createElement('div');
	    $.style(scrollDiv, {
	        width: '100px',
	        height: '100px',
	        overflow: 'scroll',
	        position: 'absolute',
	        top: '-9999px'
	    });
	    document.body.appendChild(scrollDiv);

	    // Get the scrollbar width
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

	    // Delete the DIV
	    document.body.removeChild(scrollDiv);

	    return scrollbarWidth;
	}

	$.hasVerticalOverflow = function (element) {
	    return element.scrollHeight > element.offsetHeight + 10;
	};

	$.hasHorizontalOverflow = function (element) {
	    return element.scrollWidth > element.offsetWidth + 10;
	};

	$.measureTextWidth = function (text) {
	    var div = document.createElement('div');
	    div.style.position = 'absolute';
	    div.style.visibility = 'hidden';
	    div.style.height = 'auto';
	    div.style.width = 'auto';
	    div.style.whiteSpace = 'nowrap';
	    div.innerText = text;
	    document.body.appendChild(div);
	    return div.clientWidth + 1;
	};

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	var commonjsGlobal$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return _root.Date.now();
	};

	var now_1 = now;

	/** Built-in value references. */
	var Symbol = _root.Symbol;

	var _Symbol = Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol_1(value)) {
	    return NAN;
	  }
	  if (isObject_1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject_1(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	var toNumber_1 = toNumber;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber_1(wait) || 0;
	  if (isObject_1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now_1();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now_1());
	  }

	  function debounced() {
	    var time = now_1(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	var debounce_1 = debounce;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  if (isObject_1(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce_1(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	var throttle_1 = throttle;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _baseFindIndex = baseFindIndex;

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	var _baseIsNaN = baseIsNaN;

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _strictIndexOf = strictIndexOf;

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? _strictIndexOf(array, value, fromIndex)
	    : _baseFindIndex(array, _baseIsNaN, fromIndex);
	}

	var _baseIndexOf = baseIndexOf;

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && _baseIndexOf(array, value, 0) > -1;
	}

	var _arrayIncludes = arrayIncludes;

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arrayIncludesWith = arrayIncludesWith;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/* Built-in method references that are verified to be native. */
	var Set = _getNative(_root, 'Set');

	var _Set = Set;

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	var noop_1 = noop;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY) ? noop_1 : function(values) {
	  return new _Set(values);
	};

	var _createSet = createSet;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = _arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = _arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : _createSet(array);
	    if (set) {
	      return _setToArray(set);
	    }
	    isCommon = false;
	    includes = _cacheHas;
	    seen = new _SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	var _baseUniq = baseUniq;

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length) ? _baseUniq(array) : [];
	}

	var uniq_1 = uniq;

	function camelCaseToDash(str) {
	    return str.replace(/([A-Z])/g, function (g) { return ("-" + (g[0].toLowerCase())); });
	}

	function makeDataAttributeString(props) {
	    var keys = Object.keys(props);

	    return keys
	        .map(function (key) {
	            var _key = camelCaseToDash(key);
	            var val = props[key];

	            if (val === undefined) { return ''; }
	            return ("data-" + _key + "=\"" + val + "\" ");
	        })
	        .join('')
	        .trim();
	}

	function copyTextToClipboard(text) {
	    // https://stackoverflow.com/a/30810322/5353542
	    var textArea = document.createElement('textarea');

	    //
	    // *** This styling is an extra step which is likely not required. ***
	    //
	    // Why is it here? To ensure:
	    // 1. the element is able to have focus and selection.
	    // 2. if element was to flash render it has minimal visual impact.
	    // 3. less flakyness with selection and copying which **might** occur if
	    //    the textarea element is not visible.
	    //
	    // The likelihood is the element won't even render, not even a flash,
	    // so some of these are just precautions. However in IE the element
	    // is visible whilst the popup box asking the user for permission for
	    // the web page to copy to the clipboard.
	    //

	    // Place in top-left corner of screen regardless of scroll position.
	    textArea.style.position = 'fixed';
	    textArea.style.top = 0;
	    textArea.style.left = 0;

	    // Ensure it has a small width and height. Setting to 1px / 1em
	    // doesn't work as this gives a negative w/h on some browsers.
	    textArea.style.width = '2em';
	    textArea.style.height = '2em';

	    // We don't need padding, reducing the size if it does flash render.
	    textArea.style.padding = 0;

	    // Clean up any borders.
	    textArea.style.border = 'none';
	    textArea.style.outline = 'none';
	    textArea.style.boxShadow = 'none';

	    // Avoid flash of white box if rendered for any reason.
	    textArea.style.background = 'transparent';

	    textArea.value = text;

	    document.body.appendChild(textArea);

	    textArea.select();

	    try {
	        document.execCommand('copy');
	    } catch (err) {
	        console.log('Oops, unable to copy');
	    }

	    document.body.removeChild(textArea);
	}

	function isNumeric(val) {
	    return !isNaN(val);
	}

	var throttle$1 = throttle_1;

	var debounce$1 = debounce_1;

	function nextTick(fn, context) {
	    if ( context === void 0 ) context = null;

	    return function () {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        return new Promise(function (resolve) {
	            var execute = function () {
	                var out = fn.apply(context, args);
	                resolve(out);
	            };
	            setTimeout(execute);
	        });
	    };
	}
	function linkProperties(target, source, properties) {
	    var props = properties.reduce(function (acc, prop) {
	        acc[prop] = {
	            get: function get() {
	                return source[prop];
	            }
	        };
	        return acc;
	    }, {});
	    Object.defineProperties(target, props);
	}
	function isSet(val) {
	    return val !== undefined || val !== null;
	}

	function notSet(val) {
	    return !isSet(val);
	}

	function isNumber(val) {
	    return !isNaN(val);
	}

	function ensureArray(val) {
	    if (!Array.isArray(val)) {
	        return [val];
	    }
	    return val;
	}

	function uniq$1(arr) {
	    return uniq_1(arr);
	}

	function numberSortAsc(a, b) {
	    return a - b;
	}
	function stripHTML(html) {
	    return html.replace(/<[^>]*>/g, '');
	}

	class DataManager {
	    constructor(options) {
	        this.options = options;
	        this.sortRows = nextTick(this.sortRows, this);
	        this.switchColumn = nextTick(this.switchColumn, this);
	        this.removeColumn = nextTick(this.removeColumn, this);
	        this.options.filterRows = nextTick(this.options.filterRows, this);
	    }

	    init(data, columns) {
	        if (!data) {
	            data = this.options.data;
	        }
	        if (columns) {
	            this.options.columns = columns;
	        }

	        this.data = data;

	        this.rowCount = 0;
	        this.columns = [];
	        this.rows = [];

	        this.prepareColumns();
	        this.prepareRows();
	        this.prepareTreeRows();
	        this.prepareRowView();
	        this.prepareNumericColumns();
	    }

	    // computed property
	    get currentSort() {
	        var col = this.columns.find(function (col) { return col.sortOrder !== 'none'; });
	        return col || {
	            colIndex: -1,
	            sortOrder: 'none'
	        };
	    }

	    prepareColumns() {
	        this.columns = [];
	        this.validateColumns();
	        this.prepareDefaultColumns();
	        this.prepareHeader();
	    }

	    prepareDefaultColumns() {
	        if (this.options.checkboxColumn && !this.hasColumnById('_checkbox')) {
	            var cell = {
	                id: '_checkbox',
	                content: this.getCheckboxHTML(),
	                editable: false,
	                resizable: false,
	                sortable: false,
	                focusable: false,
	                dropdown: false,
	                width: 32
	            };
	            this.columns.push(cell);
	        }

	        if (this.options.serialNoColumn && !this.hasColumnById('_rowIndex')) {
	            var cell$1 = {
	                id: '_rowIndex',
	                content: '',
	                align: 'center',
	                editable: false,
	                resizable: false,
	                focusable: false,
	                dropdown: false
	            };

	            this.columns.push(cell$1);
	        }
	    }

	    prepareHeader() {
	        var this$1 = this;

	        var columns = this.columns.concat(this.options.columns);
	        var baseCell = {
	            isHeader: 1,
	            editable: true,
	            sortable: true,
	            resizable: true,
	            focusable: true,
	            dropdown: true,
	            width: null,
	            format: function (value) {
	                if (value === null || value === undefined) {
	                    return '';
	                }
	                return value + '';
	            }
	        };

	        this.columns = columns
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (col) { return Object.assign({}, baseCell, col); })
	            .map(function (col) {
	                col.content = col.content || col.name || '';
	                col.id = col.id || col.content;
	                return col;
	            });
	    }

	    prepareCell(content, i) {
	        var cell = {
	            content: '',
	            sortOrder: 'none',
	            colIndex: i,
	            column: this.columns[i]
	        };

	        if (content !== null && typeof content === 'object') {
	            // passed as column/header
	            Object.assign(cell, content);
	        } else {
	            cell.content = content;
	        }

	        return cell;
	    }

	    prepareNumericColumns() {
	        var row0 = this.getRow(0);
	        if (!row0) { return; }
	        this.columns = this.columns.map(function (column, i) {

	            var cellValue = row0[i].content;
	            if (!column.align && isNumeric(cellValue)) {
	                column.align = 'right';
	            }

	            return column;
	        });
	    }

	    prepareRows() {
	        var this$1 = this;

	        this.validateData(this.data);

	        this.rows = this.data.map(function (d, i) {
	            var index = this$1._getNextRowCount();

	            var row = [];
	            var meta = {
	                rowIndex: index
	            };

	            if (Array.isArray(d)) {
	                // row is an array
	                if (this$1.options.checkboxColumn) {
	                    row.push(this$1.getCheckboxHTML());
	                }
	                if (this$1.options.serialNoColumn) {
	                    row.push((index + 1) + '');
	                }
	                row = row.concat(d);

	                while (row.length < this$1.columns.length) {
	                    row.push('');
	                }

	            } else {
	                // row is an object
	                for (var i$1 = 0, list = this$1.columns; i$1 < list.length; i$1 += 1) {
	                    var col = list[i$1];

	                  if (col.id === '_checkbox') {
	                        row.push(this$1.getCheckboxHTML());
	                    } else if (col.id === '_rowIndex') {
	                        row.push((index + 1) + '');
	                    } else {
	                        row.push(d[col.id]);
	                    }
	                }

	                meta.indent = d.indent || 0;
	            }

	            return this$1.prepareRow(row, meta);
	        });
	    }

	    prepareTreeRows() {
	        var this$1 = this;

	        this.rows.forEach(function (row, i) {
	            if (isNumber(row.meta.indent)) {
	                // if (i === 36) debugger;
	                var nextRow = this$1.getRow(i + 1);
	                row.meta.isLeaf = !nextRow ||
	                    notSet(nextRow.meta.indent) ||
	                    nextRow.meta.indent <= row.meta.indent;
	                row.meta.isTreeNodeClose = false;
	            }
	        });
	    }

	    prepareRowView() {
	        // This is order in which rows will be rendered in the table.
	        // When sorting happens, only this.rowViewOrder will change
	        // and not the original this.rows
	        this.rowViewOrder = this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    prepareRow(row, meta) {
	        var this$1 = this;

	        var baseRowCell = {
	            rowIndex: meta.rowIndex,
	            indent: meta.indent
	        };

	        row = row
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (cell) { return Object.assign({}, baseRowCell, cell); });

	        // monkey patched in array object
	        row.meta = meta;
	        return row;
	    }

	    validateColumns() {
	        var columns = this.options.columns;
	        if (!Array.isArray(columns)) {
	            throw new DataError('`columns` must be an array');
	        }

	        columns.forEach(function (column, i) {
	            if (typeof column !== 'string' && typeof column !== 'object') {
	                throw new DataError(("column \"" + i + "\" must be a string or an object"));
	            }
	        });
	    }

	    validateData(data) {
	        if (Array.isArray(data) &&
	            (data.length === 0 || Array.isArray(data[0]) || typeof data[0] === 'object')) {
	            return true;
	        }
	        throw new DataError('`data` must be an array of arrays or objects');
	    }

	    appendRows(rows) {
	        var ref;

	        this.validateData(rows);

	        (ref = this.rows).push.apply(ref, this.prepareRows(rows));
	    }

	    sortRows(colIndex, sortOrder) {
	        if ( sortOrder === void 0 ) sortOrder = 'none';

	        colIndex = +colIndex;

	        // reset sortOrder and update for colIndex
	        this.getColumns()
	            .map(function (col) {
	                if (col.colIndex === colIndex) {
	                    col.sortOrder = sortOrder;
	                } else {
	                    col.sortOrder = 'none';
	                }
	            });

	        this._sortRows(colIndex, sortOrder);
	    }

	    _sortRows(colIndex, sortOrder) {
	        var this$1 = this;


	        if (this.currentSort.colIndex === colIndex) {
	            // reverse the array if only sortOrder changed
	            if (
	                (this.currentSort.sortOrder === 'asc' && sortOrder === 'desc') ||
	                (this.currentSort.sortOrder === 'desc' && sortOrder === 'asc')
	            ) {
	                this.reverseArray(this.rowViewOrder);
	                this.currentSort.sortOrder = sortOrder;
	                return;
	            }
	        }

	        this.rowViewOrder.sort(function (a, b) {
	            var aIndex = a;
	            var bIndex = b;

	            var aContent = this$1.getCell(colIndex, a).content;
	            var bContent = this$1.getCell(colIndex, b).content;
	            aContent = aContent == null ? '' : aContent;
	            bContent = bContent == null ? '' : bContent;

	            if (sortOrder === 'none') {
	                return aIndex - bIndex;
	            } else if (sortOrder === 'asc') {
	                if (aContent < bContent) { return -1; }
	                if (aContent > bContent) { return 1; }
	                if (aContent === bContent) { return 0; }
	            } else if (sortOrder === 'desc') {
	                if (aContent < bContent) { return 1; }
	                if (aContent > bContent) { return -1; }
	                if (aContent === bContent) { return 0; }
	            }
	            return 0;
	        });

	        if (this.hasColumnById('_rowIndex')) {
	            // update row index
	            var srNoColIndex = this.getColumnIndexById('_rowIndex');
	            this.rows.forEach(function (row, index) {
	                var viewIndex = this$1.rowViewOrder.indexOf(index);
	                var cell = row[srNoColIndex];
	                cell.content = (viewIndex + 1) + '';
	            });
	        }
	    }

	    reverseArray(array) {
	        var left = null;
	        var right = null;
	        var length = array.length;

	        for (left = 0, right = length - 1; left < right; left += 1, right -= 1) {
	            var temporary = array[left];

	            array[left] = array[right];
	            array[right] = temporary;
	        }
	    }

	    switchColumn(index1, index2) {
	        // update columns
	        var temp = this.columns[index1];
	        this.columns[index1] = this.columns[index2];
	        this.columns[index2] = temp;

	        this.columns[index1].colIndex = index1;
	        this.columns[index2].colIndex = index2;

	        // update rows
	        this.rows.forEach(function (row) {
	            var newCell1 = Object.assign({}, row[index1], {
	                colIndex: index2
	            });
	            var newCell2 = Object.assign({}, row[index2], {
	                colIndex: index1
	            });

	            row[index2] = newCell1;
	            row[index1] = newCell2;
	        });
	    }

	    removeColumn(index) {
	        index = +index;
	        var filter = function (cell) { return cell.colIndex !== index; };
	        var map = function (cell, i) { return Object.assign({}, cell, {
	            colIndex: i
	        }); };
	        // update columns
	        this.columns = this.columns
	            .filter(filter)
	            .map(map);

	        // update rows
	        this.rows.forEach(function (row) {
	            // remove cell
	            row.splice(index, 1);
	            // update colIndex
	            row.forEach(function (cell, i) {
	                cell.colIndex = i;
	            });
	        });
	    }

	    updateRow(row, rowIndex) {
	        if (row.length < this.columns.length) {
	            if (this.hasColumnById('_rowIndex')) {
	                var val = (rowIndex + 1) + '';

	                row = [val].concat(row);
	            }

	            if (this.hasColumnById('_checkbox')) {
	                var val$1 = '<input type="checkbox" />';

	                row = [val$1].concat(row);
	            }
	        }

	        var _row = this.prepareRow(row, {rowIndex: rowIndex});
	        var index = this.rows.findIndex(function (row) { return row[0].rowIndex === rowIndex; });
	        this.rows[index] = _row;

	        return _row;
	    }

	    updateCell(colIndex, rowIndex, options) {
	        var cell;
	        if (typeof colIndex === 'object') {
	            // cell object was passed,
	            // must have colIndex, rowIndex
	            cell = colIndex;
	            colIndex = cell.colIndex;
	            rowIndex = cell.rowIndex;
	            // the object passed must be merged with original cell
	            options = cell;
	        }
	        cell = this.getCell(colIndex, rowIndex);

	        // mutate object directly
	        for (var key in options) {
	            var newVal = options[key];
	            if (newVal !== undefined) {
	                cell[key] = newVal;
	            }
	        }

	        return cell;
	    }

	    updateColumn(colIndex, keyValPairs) {
	        var column = this.getColumn(colIndex);
	        for (var key in keyValPairs) {
	            var newVal = keyValPairs[key];
	            if (newVal !== undefined) {
	                column[key] = newVal;
	            }
	        }
	        return column;
	    }

	    filterRows(filters) {
	        var this$1 = this;

	        return this.options.filterRows(this.rows, filters)
	            .then(function (result) {
	                if (!result) {
	                    result = this$1.getAllRowIndices();
	                }

	                if (!result.then) {
	                    result = Promise.resolve(result);
	                }

	                return result.then(function (rowsToShow) {
	                    this$1._filteredRows = rowsToShow;

	                    var rowsToHide = this$1.getAllRowIndices()
	                        .filter(function (index) { return !rowsToShow.includes(index); });

	                    return {
	                        rowsToHide: rowsToHide,
	                        rowsToShow: rowsToShow
	                    };
	                });
	            });
	    }

	    getFilteredRowIndices() {
	        return this._filteredRows || this.getAllRowIndices();
	    }

	    getAllRowIndices() {
	        return this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    getRowCount() {
	        return this.rowCount;
	    }

	    _getNextRowCount() {
	        var val = this.rowCount;

	        this.rowCount++;
	        return val;
	    }

	    getRows(start, end) {
	        return this.rows.slice(start, end);
	    }

	    getRowsForView(start, end) {
	        var this$1 = this;

	        var rows = this.rowViewOrder.map(function (i) { return this$1.rows[i]; });
	        return rows.slice(start, end);
	    }

	    getColumns(skipStandardColumns) {
	        var columns = this.columns;

	        if (skipStandardColumns) {
	            columns = columns.slice(this.getStandardColumnCount());
	        }

	        return columns;
	    }

	    getStandardColumnCount() {
	        if (this.options.checkboxColumn && this.options.serialNoColumn) {
	            return 2;
	        }

	        if (this.options.checkboxColumn || this.options.serialNoColumn) {
	            return 1;
	        }

	        return 0;
	    }

	    getColumnCount(skipStandardColumns) {
	        var val = this.columns.length;

	        if (skipStandardColumns) {
	            val = val - this.getStandardColumnCount();
	        }

	        return val;
	    }

	    getColumn(colIndex) {
	        colIndex = +colIndex;

	        if (colIndex < 0) {
	            // negative indexes
	            colIndex = this.columns.length + colIndex;
	        }

	        return this.columns.find(function (col) { return col.colIndex === colIndex; });
	    }

	    getColumnById(id) {
	        return this.columns.find(function (col) { return col.id === id; });
	    }

	    getRow(rowIndex) {
	        rowIndex = +rowIndex;
	        return this.rows[rowIndex];
	    }

	    getCell(colIndex, rowIndex) {
	        rowIndex = +rowIndex;
	        colIndex = +colIndex;
	        return this.getRow(rowIndex)[colIndex];
	    }

	    getChildren(parentRowIndex) {
	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this.getRow(i);
	            if (isNaN(row.meta.indent)) { continue; }

	            if (row.meta.indent > parentIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    getImmediateChildren(parentRowIndex) {
	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];
	        var childIndent = parentIndent + 1;

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this.getRow(i);
	            if (isNaN(row.meta.indent) || row.meta.indent > childIndent) { continue; }

	            if (row.meta.indent === childIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    get() {
	        return {
	            columns: this.columns,
	            rows: this.rows
	        };
	    }

	    /**
	     * Returns the original data which was passed
	     * based on rowIndex
	     * @param {Number} rowIndex
	     * @returns Array|Object
	     * @memberof DataManager
	     */
	    getData(rowIndex) {
	        return this.data[rowIndex];
	    }

	    hasColumn(name) {
	        return Boolean(this.columns.find(function (col) { return col.content === name; }));
	    }

	    hasColumnById(id) {
	        return Boolean(this.columns.find(function (col) { return col.id === id; }));
	    }

	    getColumnIndex(name) {
	        return this.columns.findIndex(function (col) { return col.content === name; });
	    }

	    getColumnIndexById(id) {
	        return this.columns.findIndex(function (col) { return col.id === id; });
	    }

	    getCheckboxHTML() {
	        return '<input type="checkbox" />';
	    }
	}

	// Custom Errors
	class DataError extends TypeError {}

	/* eslint-disable max-len */

	// Icons from https://feathericons.com/

	var icons = {
	    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>',
	    chevronRight: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>'
	};

	class CellManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'wrapper',
	            'options',
	            'style',
	            'header',
	            'bodyScrollable',
	            'columnmanager',
	            'rowmanager',
	            'datamanager',
	            'keyboard'
	        ]);

	        this.bindEvents();
	    }

	    bindEvents() {
	        this.bindFocusCell();
	        this.bindEditCell();
	        this.bindKeyboardSelection();
	        this.bindCopyCellContents();
	        this.bindMouseEvents();
	        this.bindTreeEvents();
	    }

	    bindFocusCell() {
	        this.bindKeyboardNav();
	    }

	    bindEditCell() {
	        var this$1 = this;

	        this.$editingCell = null;

	        $.on(this.bodyScrollable, 'dblclick', '.dt-cell', function (e, cell) {
	            this$1.activateEditing(cell);
	        });

	        this.keyboard.on('enter', function () {
	            if (this$1.$focusedCell && !this$1.$editingCell) {
	                // enter keypress on focused cell
	                this$1.activateEditing(this$1.$focusedCell);
	            } else if (this$1.$editingCell) {
	                // enter keypress on editing cell
	                this$1.deactivateEditing();
	            }
	        });
	    }

	    bindKeyboardNav() {
	        var this$1 = this;

	        var focusLastCell = function (direction) {
	            if (!this$1.$focusedCell || this$1.$editingCell) {
	                return false;
	            }

	            var $cell = this$1.$focusedCell;
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var colIndex = ref.colIndex;

	            if (direction === 'left') {
	                $cell = this$1.getLeftMostCell$(rowIndex);
	            } else if (direction === 'right') {
	                $cell = this$1.getRightMostCell$(rowIndex);
	            } else if (direction === 'up') {
	                $cell = this$1.getTopMostCell$(colIndex);
	            } else if (direction === 'down') {
	                $cell = this$1.getBottomMostCell$(colIndex);
	            }

	            this$1.focusCell($cell);
	            return true;
	        };

	        ['left', 'right', 'up', 'down', 'tab', 'shift+tab']
	            .map(function (direction) { return this$1.keyboard.on(direction, function () { return this$1.focusCellInDirection(direction); }); });

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("ctrl+" + direction), function () { return focusLastCell(direction); }); });

	        this.keyboard.on('esc', function () {
	            this$1.deactivateEditing(false);
	            this$1.columnmanager.toggleFilter(false);
	        });

	        if (this.options.inlineFilters) {
	            this.keyboard.on('ctrl+f', function (e) {
	                var $cell = $.closest('.dt-cell', e.target);
	                var ref = $.data($cell);
	                var colIndex = ref.colIndex;

	                this$1.activateFilter(colIndex);
	                return true;
	            });

	            $.on(this.header, 'focusin', '.dt-filter', function () {
	                this$1.unfocusCell(this$1.$focusedCell);
	            });
	        }
	    }

	    bindKeyboardSelection() {
	        var this$1 = this;

	        var getNextSelectionCursor = function (direction) {
	            var $selectionCursor = this$1.getSelectionCursor();

	            if (direction === 'left') {
	                $selectionCursor = this$1.getLeftCell$($selectionCursor);
	            } else if (direction === 'right') {
	                $selectionCursor = this$1.getRightCell$($selectionCursor);
	            } else if (direction === 'up') {
	                $selectionCursor = this$1.getAboveCell$($selectionCursor);
	            } else if (direction === 'down') {
	                $selectionCursor = this$1.getBelowCell$($selectionCursor);
	            }

	            return $selectionCursor;
	        };

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("shift+" + direction), function () { return this$1.selectArea(getNextSelectionCursor(direction)); }); });
	    }

	    bindCopyCellContents() {
	        var this$1 = this;

	        this.keyboard.on('ctrl+c', function () {
	            var noOfCellsCopied = this$1.copyCellContents(this$1.$focusedCell, this$1.$selectionCursor);
	            var message = noOfCellsCopied + " cell" + (noOfCellsCopied > 1 ? 's' : '') + " copied";
	            if (noOfCellsCopied) {
	                this$1.instance.showToastMessage(message, 2);
	            }
	        });

	        if (this.options.pasteFromClipboard) {
	            this.keyboard.on('ctrl+v', function (e) {
	                // hack
	                // https://stackoverflow.com/a/2177059/5353542
	                this$1.instance.pasteTarget.focus();

	                setTimeout(function () {
	                    var data = this$1.instance.pasteTarget.value;
	                    this$1.instance.pasteTarget.value = '';
	                    this$1.pasteContentInCell(data);
	                }, 10);

	                return false;
	            });
	        }
	    }

	    bindMouseEvents() {
	        var this$1 = this;

	        var mouseDown = null;

	        $.on(this.bodyScrollable, 'mousedown', '.dt-cell', function (e) {
	            mouseDown = true;
	            this$1.focusCell($(e.delegatedTarget));
	        });

	        $.on(this.bodyScrollable, 'mouseup', function () {
	            mouseDown = false;
	        });

	        var selectArea = function (e) {
	            if (!mouseDown) { return; }
	            this$1.selectArea($(e.delegatedTarget));
	        };

	        $.on(this.bodyScrollable, 'mousemove', '.dt-cell', throttle$1(selectArea, 50));
	    }

	    bindTreeEvents() {
	        var this$1 = this;

	        $.on(this.bodyScrollable, 'click', '.dt-tree-node__toggle', function (e, $toggle) {
	            var $cell = $.closest('.dt-cell', $toggle);
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;

	            if ($cell.classList.contains('dt-cell--tree-close')) {
	                this$1.rowmanager.openSingleNode(rowIndex);
	            } else {
	                this$1.rowmanager.closeSingleNode(rowIndex);
	            }
	        });
	    }

	    focusCell($cell, ref) {
	        if ( ref === void 0 ) ref = {};
	        var skipClearSelection = ref.skipClearSelection; if ( skipClearSelection === void 0 ) skipClearSelection = 0;
	        var skipDOMFocus = ref.skipDOMFocus; if ( skipDOMFocus === void 0 ) skipDOMFocus = 0;
	        var skipScrollToCell = ref.skipScrollToCell; if ( skipScrollToCell === void 0 ) skipScrollToCell = 0;

	        if (!$cell) { return; }

	        // don't focus if already editing cell
	        if ($cell === this.$editingCell) { return; }

	        var ref$1 = $.data($cell);
	        var colIndex = ref$1.colIndex;
	        var isHeader = ref$1.isHeader;
	        if (isHeader) {
	            return;
	        }

	        var column = this.columnmanager.getColumn(colIndex);
	        if (column.focusable === false) {
	            return;
	        }

	        if (!skipScrollToCell) {
	            this.scrollToCell($cell);
	        }

	        this.deactivateEditing();
	        if (!skipClearSelection) {
	            this.clearSelection();
	        }

	        if (this.$focusedCell) {
	            this.$focusedCell.classList.remove('dt-cell--focus');
	        }

	        this.$focusedCell = $cell;
	        $cell.classList.add('dt-cell--focus');

	        if (!skipDOMFocus) {
	            // so that keyboard nav works
	            $cell.focus();
	        }

	        this.highlightRowColumnHeader($cell);
	    }

	    unfocusCell($cell) {
	        if (!$cell) { return; }

	        // remove cell border
	        $cell.classList.remove('dt-cell--focus');
	        this.$focusedCell = null;

	        // reset header background
	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header && header.classList.remove('dt-cell--highlight'); });
	        }
	    }

	    highlightRowColumnHeader($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var srNoColIndex = this.datamanager.getColumnIndexById('_rowIndex');
	        var colHeaderSelector = ".dt-cell--header-" + colIndex;
	        var rowHeaderSelector = ".dt-cell--" + srNoColIndex + "-" + rowIndex;

	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header && header.classList.remove('dt-cell--highlight'); });
	        }

	        var colHeader = $(colHeaderSelector, this.wrapper);
	        var rowHeader = $(rowHeaderSelector, this.wrapper);

	        this.lastHeaders = [colHeader, rowHeader];
	        this.lastHeaders.forEach(function (header) { return header && header.classList.add('dt-cell--highlight'); });
	    }

	    selectAreaOnClusterChanged() {
	        if (!(this.$focusedCell && this.$selectionCursor)) { return; }
	        var ref = $.data(this.$selectionCursor);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell || $cell === this.$selectionCursor) { return; }

	        // selectArea needs $focusedCell
	        var fCell = $.data(this.$focusedCell);
	        this.$focusedCell = this.getCell$(fCell.colIndex, fCell.rowIndex);

	        this.selectArea($cell);
	    }

	    focusCellOnClusterChanged() {
	        if (!this.$focusedCell) { return; }

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell) { return; }
	        // this function is called after hyperlist renders the rows after scroll,
	        // focusCell calls clearSelection which resets the area selection
	        // so a flag to skip it
	        // we also skip DOM focus and scroll to cell
	        // because it fights with the user scroll
	        this.focusCell($cell, {
	            skipClearSelection: 1,
	            skipDOMFocus: 1,
	            skipScrollToCell: 1
	        });
	    }

	    selectArea($selectionCursor) {
	        if (!this.$focusedCell) { return; }

	        if (this._selectArea(this.$focusedCell, $selectionCursor)) {
	            // valid selection
	            this.$selectionCursor = $selectionCursor;
	        }
	    }

	    _selectArea($cell1, $cell2) {
	        var this$1 = this;

	        if ($cell1 === $cell2) { return false; }

	        var cells = this.getCellsInRange($cell1, $cell2);
	        if (!cells) { return false; }

	        this.clearSelection();
	        this._selectedCells = cells.map(function (index) {
	          var ref;

	          return (ref = this$1).getCell$.apply(ref, index);
	        });
	        requestAnimationFrame(function () {
	            this$1._selectedCells.map(function ($cell) { return $cell.classList.add('dt-cell--highlight'); });
	        });
	        return true;
	    }

	    getCellsInRange($cell1, $cell2) {
	        var assign, assign$1, assign$2;

	        var colIndex1, rowIndex1, colIndex2, rowIndex2;

	        if (typeof $cell1 === 'number') {
	            (assign = arguments, colIndex1 = assign[0], rowIndex1 = assign[1], colIndex2 = assign[2], rowIndex2 = assign[3]);
	        } else
	        if (typeof $cell1 === 'object') {
	            if (!($cell1 && $cell2)) {
	                return false;
	            }

	            var cell1 = $.data($cell1);
	            var cell2 = $.data($cell2);

	            colIndex1 = +cell1.colIndex;
	            rowIndex1 = +cell1.rowIndex;
	            colIndex2 = +cell2.colIndex;
	            rowIndex2 = +cell2.rowIndex;
	        }

	        if (rowIndex1 > rowIndex2) {
	            (assign$1 = [rowIndex2, rowIndex1], rowIndex1 = assign$1[0], rowIndex2 = assign$1[1]);
	        }

	        if (colIndex1 > colIndex2) {
	            (assign$2 = [colIndex2, colIndex1], colIndex1 = assign$2[0], colIndex2 = assign$2[1]);
	        }

	        if (this.isStandardCell(colIndex1) || this.isStandardCell(colIndex2)) {
	            return false;
	        }

	        var cells = [];
	        var colIndex = colIndex1;
	        var rowIndex = rowIndex1;
	        var rowIndices = [];

	        while (rowIndex <= rowIndex2) {
	            rowIndices.push(rowIndex);
	            rowIndex += 1;
	        }

	        rowIndices.map(function (rowIndex) {
	            while (colIndex <= colIndex2) {
	                cells.push([colIndex, rowIndex]);
	                colIndex++;
	            }
	            colIndex = colIndex1;
	        });

	        return cells;
	    }

	    clearSelection() {
	        (this._selectedCells || [])
	            .forEach(function ($cell) { return $cell.classList.remove('dt-cell--highlight'); });

	        this._selectedCells = [];
	        this.$selectionCursor = null;
	    }

	    getSelectionCursor() {
	        return this.$selectionCursor || this.$focusedCell;
	    }

	    activateEditing($cell) {
	        this.focusCell($cell);
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;

	        var col = this.columnmanager.getColumn(colIndex);
	        if (col && (col.editable === false || col.focusable === false)) {
	            return;
	        }

	        var cell = this.getCell(colIndex, rowIndex);
	        if (cell && cell.editable === false) {
	            return;
	        }

	        if (this.$editingCell) {
	            var ref$1 = $.data(this.$editingCell);
	            var _rowIndex = ref$1._rowIndex;
	            var _colIndex = ref$1._colIndex;

	            if (rowIndex === _rowIndex && colIndex === _colIndex) {
	                // editing the same cell
	                return;
	            }
	        }

	        this.$editingCell = $cell;
	        $cell.classList.add('dt-cell--editing');

	        var $editCell = $('.dt-cell__edit', $cell);
	        $editCell.innerHTML = '';

	        var editor = this.getEditor(colIndex, rowIndex, cell.content, $editCell);

	        if (editor) {
	            this.currentCellEditor = editor;
	            // initialize editing input with cell value
	            editor.initValue(cell.content, rowIndex, col);
	        }
	    }

	    deactivateEditing(submitValue) {
	        if ( submitValue === void 0 ) submitValue = true;

	        if (submitValue) {
	            this.submitEditing();
	        }
	        // keep focus on the cell so that keyboard navigation works
	        if (this.$focusedCell) { this.$focusedCell.focus(); }

	        if (!this.$editingCell) { return; }
	        this.$editingCell.classList.remove('dt-cell--editing');
	        this.$editingCell = null;
	    }

	    getEditor(colIndex, rowIndex, value, parent) {
	        var column = this.datamanager.getColumn(colIndex);
	        var row = this.datamanager.getRow(rowIndex);
	        var data = this.datamanager.getData(rowIndex);
	        var editor = this.options.getEditor ?
	            this.options.getEditor(colIndex, rowIndex, value, parent, column, row, data) :
	            this.getDefaultEditor(parent);

	        if (editor === false) {
	            // explicitly returned false
	            return false;
	        }
	        if (editor === undefined) {
	            // didn't return editor, fallback to default
	            editor = this.getDefaultEditor(parent);
	        }

	        return editor;
	    }

	    getDefaultEditor(parent) {
	        var $input = $.create('input', {
	            class: 'dt-input',
	            type: 'text',
	            inside: parent
	        });

	        return {
	            initValue: function initValue(value) {
	                $input.focus();
	                $input.value = value;
	            },
	            getValue: function getValue() {
	                return $input.value;
	            },
	            setValue: function setValue(value) {
	                $input.value = value;
	            }
	        };
	    }

	    submitEditing() {
	        var this$1 = this;

	        var promise = Promise.resolve();
	        if (!this.$editingCell) { return promise; }

	        var $cell = this.$editingCell;
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;
	        var col = this.datamanager.getColumn(colIndex);

	        if ($cell) {
	            var editor = this.currentCellEditor;

	            if (editor) {
	                var valuePromise = editor.getValue();

	                // convert to stubbed Promise
	                if (!valuePromise.then) {
	                    valuePromise = Promise.resolve(valuePromise);
	                }

	                promise = valuePromise.then(function (value) {
	                    var done = editor.setValue(value, rowIndex, col);
	                    var oldValue = this$1.getCell(colIndex, rowIndex).content;

	                    // update cell immediately
	                    this$1.updateCell(colIndex, rowIndex, value);
	                    $cell.focus();

	                    if (done && done.then) {
	                        // revert to oldValue if promise fails
	                        done.catch(function (e) {
	                            console.log(e);
	                            this$1.updateCell(colIndex, rowIndex, oldValue);
	                        });
	                    }
	                    return done;
	                });
	            }
	        }

	        this.currentCellEditor = null;
	        return promise;
	    }

	    copyCellContents($cell1, $cell2) {
	        var this$1 = this;

	        if (!$cell2 && $cell1) {
	            // copy only focusedCell
	            var ref = $.data($cell1);
	            var colIndex = ref.colIndex;
	            var rowIndex = ref.rowIndex;
	            var cell = this.getCell(colIndex, rowIndex);
	            copyTextToClipboard(cell.content);
	            return 1;
	        }
	        var cells = this.getCellsInRange($cell1, $cell2);

	        if (!cells) { return 0; }

	        var rows = cells
	            // get cell objects
	            .map(function (index) {
	              var ref;

	              return (ref = this$1).getCell.apply(ref, index);
	        })
	            // convert to array of rows
	            .reduce(function (acc, curr) {
	                var rowIndex = curr.rowIndex;

	                acc[rowIndex] = acc[rowIndex] || [];
	                acc[rowIndex].push(curr.content);

	                return acc;
	            }, []);

	        var values = rows
	            // join values by tab
	            .map(function (row) { return row.join('\t'); })
	            // join rows by newline
	            .join('\n');

	        copyTextToClipboard(values);

	        // return no of cells copied
	        return rows.reduce(function (total, row) { return total + row.length; }, 0);
	    }

	    pasteContentInCell(data) {
	        var this$1 = this;

	        if (!this.$focusedCell) { return; }

	        var matrix = data
	            .split('\n')
	            .map(function (row) { return row.split('\t'); })
	            .filter(function (row) { return row.length && row.every(function (it) { return it; }); });

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var focusedCell = {
	            colIndex: +colIndex,
	            rowIndex: +rowIndex
	        };

	        matrix.forEach(function (row, i) {
	            var rowIndex = i + focusedCell.rowIndex;
	            row.forEach(function (cell, j) {
	                var colIndex = j + focusedCell.colIndex;
	                this$1.updateCell(colIndex, rowIndex, cell);
	            });
	        });
	    }

	    activateFilter(colIndex) {
	        this.columnmanager.toggleFilter();
	        this.columnmanager.focusFilter(colIndex);

	        if (!this.columnmanager.isFilterShown) {
	            // put focus back on cell
	            this.$focusedCell && this.$focusedCell.focus();
	        }
	    }

	    updateCell(colIndex, rowIndex, value) {
	        var cell = this.datamanager.updateCell(colIndex, rowIndex, {
	            content: value
	        });
	        this.refreshCell(cell);
	    }

	    refreshCell(cell) {
	        var $cell = $(this.selector(cell.colIndex, cell.rowIndex), this.bodyScrollable);
	        $cell.innerHTML = this.getCellContent(cell);
	    }

	    toggleTreeButton(rowIndex, flag) {
	        var colIndex = this.columnmanager.getFirstColumnIndex();
	        var $cell = this.getCell$(colIndex, rowIndex);
	        if ($cell) {
	            $cell.classList[flag ? 'remove' : 'add']('dt-cell--tree-close');
	        }
	    }

	    isStandardCell(colIndex) {
	        // Standard cells are in Sr. No and Checkbox column
	        return colIndex < this.columnmanager.getFirstColumnIndex();
	    }

	    focusCellInDirection(direction) {
	        if (!this.$focusedCell) {
	            return false;
	        } else if (this.$editingCell && ['tab', 'shift+tab'].includes(direction)) {
	            this.deactivateEditing();
	        }

	        var $cell = this.$focusedCell;

	        if (direction === 'left' || direction === 'shift+tab') {
	            $cell = this.getLeftCell$($cell);
	        } else if (direction === 'right' || direction === 'tab') {
	            $cell = this.getRightCell$($cell);
	        } else if (direction === 'up') {
	            $cell = this.getAboveCell$($cell);
	        } else if (direction === 'down') {
	            $cell = this.getBelowCell$($cell);
	        }

	        if (!$cell) {
	            return false;
	        }

	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var column = this.columnmanager.getColumn(colIndex);

	        if (!column.focusable) {
	            var $prevFocusedCell = this.$focusedCell;
	            this.unfocusCell($prevFocusedCell);
	            this.$focusedCell = $cell;
	            var ret = this.focusCellInDirection(direction);
	            if (!ret) {
	                this.focusCell($prevFocusedCell);
	            }
	            return ret;
	        }

	        this.focusCell($cell);
	        return true;
	    }

	    getCell$(colIndex, rowIndex) {
	        return $(this.selector(colIndex, rowIndex), this.bodyScrollable);
	    }

	    getAboveCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $aboveRow = $cell.parentElement.previousElementSibling;
	        while ($aboveRow && $aboveRow.classList.contains('dt-row--hide')) {
	            $aboveRow = $aboveRow.previousElementSibling;
	        }

	        if (!$aboveRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $aboveRow);
	    }

	    getBelowCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $belowRow = $cell.parentElement.nextElementSibling;
	        while ($belowRow && $belowRow.classList.contains('dt-row--hide')) {
	            $belowRow = $belowRow.nextElementSibling;
	        }

	        if (!$belowRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $belowRow);
	    }

	    getLeftCell$($cell) {
	        return $cell.previousElementSibling;
	    }

	    getRightCell$($cell) {
	        return $cell.nextElementSibling;
	    }

	    getLeftMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getFirstColumnIndex(), rowIndex);
	    }

	    getRightMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getLastColumnIndex(), rowIndex);
	    }

	    getTopMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getFirstRowIndex());
	    }

	    getBottomMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getLastRowIndex());
	    }

	    getCell(colIndex, rowIndex) {
	        return this.instance.datamanager.getCell(colIndex, rowIndex);
	    }

	    getRowHeight() {
	        return $.style($('.dt-row', this.bodyScrollable), 'height');
	    }

	    scrollToCell($cell) {
	        if ($.inViewport($cell, this.bodyScrollable)) { return false; }

	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        this.rowmanager.scrollToRow(rowIndex);
	        return false;
	    }

	    getRowCountPerPage() {
	        return Math.ceil(this.instance.getViewportHeight() / this.getRowHeight());
	    }

	    getCellHTML(cell) {
	        var rowIndex = cell.rowIndex;
	        var colIndex = cell.colIndex;
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var isTotalRow = cell.isTotalRow;
	        var dataAttr = makeDataAttributeString({
	            rowIndex: rowIndex,
	            colIndex: colIndex,
	            isHeader: isHeader,
	            isFilter: isFilter,
	            isTotalRow: isTotalRow
	        });

	        var row = this.datamanager.getRow(rowIndex);

	        var isBodyCell = !(isHeader || isFilter || isTotalRow);

	        var className = [
	            'dt-cell',
	            'dt-cell--col-' + colIndex,
	            isBodyCell ? ("dt-cell--" + colIndex + "-" + rowIndex) : '',
	            isBodyCell ? 'dt-cell--row-' + rowIndex : '',
	            isHeader ? 'dt-cell--header' : '',
	            isHeader ? ("dt-cell--header-" + colIndex) : '',
	            isFilter ? 'dt-cell--filter' : '',
	            isBodyCell && (row && row.meta.isTreeNodeClose) ? 'dt-cell--tree-close' : ''
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\" " + dataAttr + " tabindex=\"0\">\n                " + (this.getCellContent(cell)) + "\n            </div>\n        ");
	    }

	    getCellContent(cell) {
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var colIndex = cell.colIndex;

	        var editable = !isHeader && cell.editable !== false;
	        var editCellHTML = editable ? this.getEditCellHTML(colIndex) : '';

	        var sortable = isHeader && cell.sortable !== false;
	        var sortIndicator = sortable ?
	            ("<span class=\"sort-indicator\">\n                " + (this.options.sortIndicator[cell.sortOrder]) + "\n            </span>") :
	            '';

	        var resizable = isHeader && cell.resizable !== false;
	        var resizeColumn = resizable ? '<span class="dt-cell__resize-handle"></span>' : '';

	        var hasDropdown = isHeader && cell.dropdown !== false;
	        var dropdown = hasDropdown ? this.columnmanager.getDropdownHTML() : '';

	        var customFormatter = cell.format || (cell.column && cell.column.format) || null;

	        var contentHTML;
	        if (isHeader || isFilter || !customFormatter) {
	            contentHTML = cell.content;
	        } else {
	            var row = this.datamanager.getRow(cell.rowIndex);
	            var data = this.datamanager.getData(cell.rowIndex);
	            contentHTML = customFormatter(cell.content, row, cell.column, data);
	        }

	        cell.html = contentHTML;

	        if (this.options.treeView && !(isHeader || isFilter) && cell.indent !== undefined) {
	            var nextRow = this.datamanager.getRow(cell.rowIndex + 1);
	            var addToggle = nextRow && nextRow.meta.indent > cell.indent;
	            var leftPadding = 20;
	            var unit = 'px';

	            // Add toggle and indent in the first column
	            var firstColumnIndex = this.datamanager.getColumnIndexById('_rowIndex') + 1;
	            if (firstColumnIndex === cell.colIndex) {
	                var padding = ((cell.indent || 0)) * leftPadding;
	                var toggleHTML = addToggle ?
	                    ("<span class=\"dt-tree-node__toggle\" style=\"left: " + (padding - leftPadding) + unit + "\">\n                        <span class=\"icon-open\">" + (icons.chevronDown) + "</span>\n                        <span class=\"icon-close\">" + (icons.chevronRight) + "</span>\n                    </span>") : '';
	                contentHTML = "<span class=\"dt-tree-node\" style=\"padding-left: " + padding + unit + "\">\n                    " + toggleHTML + "\n                    <span>" + contentHTML + "</span>\n                </span>";
	            }
	        }

	        var className = [
	            'dt-cell__content',
	            isHeader ? ("dt-cell__content--header-" + colIndex) : ("dt-cell__content--col-" + colIndex)
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\">\n                " + contentHTML + "\n                " + sortIndicator + "\n                " + resizeColumn + "\n                " + dropdown + "\n            </div>\n            " + editCellHTML + "\n        ");
	    }

	    getEditCellHTML(colIndex) {
	        return ("<div class=\"dt-cell__edit dt-cell__edit--col-" + colIndex + "\"></div>");
	    }

	    selector(colIndex, rowIndex) {
	        return (".dt-cell--" + colIndex + "-" + rowIndex);
	    }
	}

	class ColumnManager {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'header',
	            'datamanager',
	            'cellmanager',
	            'style',
	            'wrapper',
	            'rowmanager',
	            'bodyScrollable',
	            'bodyRenderer'
	        ]);

	        this.bindEvents();
	    }

	    renderHeader() {
	        this.header.innerHTML = '<div></div>';
	        this.refreshHeader();
	    }

	    refreshHeader() {
	        var columns = this.datamanager.getColumns();

	        // refresh html
	        $('div', this.header).innerHTML = this.getHeaderHTML(columns);

	        this.$filterRow = $('.dt-row-filter', this.header);
	        if (this.$filterRow) {
	            $.style(this.$filterRow, { display: 'none' });
	        }
	        // reset columnMap
	        this.$columnMap = [];
	        this.bindMoveColumn();
	    }

	    getHeaderHTML(columns) {
	        var html = this.rowmanager.getRowHTML(columns, {
	            isHeader: 1
	        });
	        if (this.options.inlineFilters) {
	            html += this.rowmanager.getRowHTML(columns, {
	                isFilter: 1
	            });
	        }
	        return html;
	    }

	    bindEvents() {
	        this.bindDropdown();
	        this.bindResizeColumn();
	        this.bindPerfectColumnWidth();
	        this.bindFilter();
	    }

	    bindDropdown() {
	        var this$1 = this;

	        var toggleClass = '.dt-dropdown__toggle';
	        var dropdownClass = '.dt-dropdown__list';

	        // attach the dropdown list to container
	        this.instance.dropdownContainer.innerHTML = this.getDropdownListHTML();
	        this.$dropdownList = this.instance.dropdownContainer.firstElementChild;

	        $.on(this.header, 'click', toggleClass, function (e) {
	            this$1.openDropdown(e);
	        });

	        var deactivateDropdownOnBodyClick = function (e) {
	            var selector = [
	                toggleClass, toggleClass + ' *',
	                dropdownClass, dropdownClass + ' *'
	            ].join(',');
	            if (e.target.matches(selector)) { return; }
	            deactivateDropdown();
	        };
	        $.on(document.body, 'click', deactivateDropdownOnBodyClick);
	        document.addEventListener('scroll', deactivateDropdown, true);

	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'click', deactivateDropdownOnBodyClick);
	            $.off(document, 'scroll', deactivateDropdown);
	        });

	        $.on(this.$dropdownList, 'click', '.dt-dropdown__list-item', function (e, $item) {
	            if (!this$1._dropdownActiveColIndex) { return; }
	            var dropdownItems = this$1.options.headerDropdown;
	            var ref = $.data($item);
	            var index = ref.index;
	            var colIndex = this$1._dropdownActiveColIndex;
	            var callback = dropdownItems[index].action;

	            callback && callback.call(this$1.instance, this$1.getColumn(colIndex));
	            this$1.hideDropdown();
	        });

	        var _this = this;
	        function deactivateDropdown(e) {
	            _this.hideDropdown();
	        }

	        this.hideDropdown();
	    }

	    openDropdown(e) {
	        if (!this._dropdownWidth) {
	            $.style(this.$dropdownList, { display: '' });
	            this._dropdownWidth = $.style(this.$dropdownList, 'width');
	        }
	        $.style(this.$dropdownList, {
	            display: '',
	            left: (e.clientX - this._dropdownWidth + 4) + 'px',
	            top: (e.clientY + 4) + 'px'
	        });
	        var $cell = $.closest('.dt-cell', e.target);
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        this._dropdownActiveColIndex = colIndex;
	    }

	    hideDropdown() {
	        $.style(this.$dropdownList, {
	            display: 'none'
	        });
	        this._dropdownActiveColIndex = null;
	    }

	    bindResizeColumn() {
	        var this$1 = this;

	        var isDragging = false;
	        var $resizingCell, startWidth, startX;

	        $.on(this.header, 'mousedown', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            document.body.classList.add('dt-resize');
	            var $cell = $handle.parentNode.parentNode;
	            $resizingCell = $cell;
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            var col = this$1.getColumn(colIndex);

	            if (col && col.resizable === false) {
	                return;
	            }

	            isDragging = true;
	            startWidth = $.style($('.dt-cell__content', $resizingCell), 'width');
	            startX = e.pageX;
	        });

	        var onMouseup = function (e) {
	            document.body.classList.remove('dt-resize');
	            if (!$resizingCell) { return; }
	            isDragging = false;

	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            this$1.setColumnWidth(colIndex);
	            this$1.style.setBodyStyle();
	            $resizingCell = null;
	        };
	        $.on(document.body, 'mouseup', onMouseup);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mouseup', onMouseup);
	        });

	        var onMouseMove = function (e) {
	            if (!isDragging) { return; }
	            var finalWidth = startWidth + (e.pageX - startX);
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;

	            var columnMinWidth = this$1.options.minimumColumnWidth;
	            if (columnMinWidth > finalWidth) {
	                // don't resize past 30 pixels
	                return;
	            }
	            this$1.datamanager.updateColumn(colIndex, {
	                width: finalWidth
	            });
	            this$1.setColumnHeaderWidth(colIndex);
	        };
	        $.on(document.body, 'mousemove', onMouseMove);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mousemove', onMouseMove);
	        });
	    }

	    bindPerfectColumnWidth() {
	        var this$1 = this;

	        $.on(this.header, 'dblclick', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            var $cell = $handle.parentNode.parentNode;
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;

	            var longestCell = this$1.bodyRenderer.visibleRows
	                .map(function (d) { return d[colIndex]; })
	                .reduce(function (acc, curr) { return acc.content.length > curr.content.length ? acc : curr; });

	            var $longestCellHTML = this$1.cellmanager.getCellHTML(longestCell);
	            var $div = document.createElement('div');
	            $div.innerHTML = $longestCellHTML;
	            var cellText = $div.querySelector('.dt-cell__content').textContent;

	            var ref$1 = $.getStyle(this$1.bodyScrollable.querySelector('.dt-cell__content'));
	            var borderLeftWidth = ref$1.borderLeftWidth;
	            var borderRightWidth = ref$1.borderRightWidth;
	            var paddingLeft = ref$1.paddingLeft;
	            var paddingRight = ref$1.paddingRight;

	            var padding = [borderLeftWidth, borderRightWidth, paddingLeft, paddingRight]
	                .map(parseFloat)
	                .reduce(function (sum, val) { return sum + val; });

	            var width = $.measureTextWidth(cellText) + padding;
	            this$1.datamanager.updateColumn(colIndex, { width: width });
	            this$1.setColumnHeaderWidth(colIndex);
	            this$1.setColumnWidth(colIndex);
	        });
	    }

	    bindMoveColumn() {
	        var this$1 = this;

	        if (this.options.disableReorderColumn) { return; }

	        var $parent = $('.dt-row', this.header);

	        this.sortable = Sortable.create($parent, {
	            onEnd: function (e) {
	                var oldIndex = e.oldIndex;
	                var newIndex = e.newIndex;
	                var $draggedCell = e.item;
	                var ref = $.data($draggedCell);
	                var colIndex = ref.colIndex;
	                if (+colIndex === newIndex) { return; }

	                this$1.switchColumn(oldIndex, newIndex);
	            },
	            preventOnFilter: false,
	            filter: '.dt-cell__resize-handle, .dt-dropdown',
	            chosenClass: 'dt-cell--dragging',
	            animation: 150
	        });
	    }

	    sortColumn(colIndex, nextSortOrder) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.sortRows(colIndex, nextSortOrder)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onSortColumn', this$1.getColumn(colIndex));
	            });
	    }

	    removeColumn(colIndex) {
	        var this$1 = this;

	        var removedCol = this.getColumn(colIndex);
	        this.instance.freeze();
	        this.datamanager.removeColumn(colIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onRemoveColumn', removedCol);
	            });
	    }

	    switchColumn(oldIndex, newIndex) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.datamanager.switchColumn(oldIndex, newIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () {
	                this$1.setColumnWidth(oldIndex);
	                this$1.setColumnWidth(newIndex);
	                this$1.instance.unfreeze();
	            })
	            .then(function () {
	                this$1.fireEvent('onSwitchColumn',
	                    this$1.getColumn(oldIndex), this$1.getColumn(newIndex)
	                );
	            });
	    }

	    toggleFilter(flag) {
	        if (!this.options.inlineFilters) { return; }

	        var showFilter;
	        if (flag === undefined) {
	            showFilter = !this.isFilterShown;
	        } else {
	            showFilter = flag;
	        }

	        if (showFilter) {
	            $.style(this.$filterRow, { display: '' });
	        } else {
	            $.style(this.$filterRow, { display: 'none' });
	        }

	        this.isFilterShown = showFilter;
	        this.style.setBodyStyle();
	    }

	    focusFilter(colIndex) {
	        if (!this.isFilterShown) { return; }

	        var $filterInput = $((".dt-cell--col-" + colIndex + " .dt-filter"), this.$filterRow);
	        $filterInput.focus();
	    }

	    bindFilter() {
	        var this$1 = this;

	        if (!this.options.inlineFilters) { return; }
	        var handler = function (e) {
	            this$1.applyFilter(this$1.getAppliedFilters());
	        };
	        $.on(this.header, 'keydown', '.dt-filter', debounce$1(handler, 300));
	    }

	    applyFilter(filters) {
	        var this$1 = this;

	        this.datamanager.filterRows(filters)
	            .then(function (ref) {
	                var rowsToShow = ref.rowsToShow;

	                this$1.rowmanager.showRows(rowsToShow);
	            });
	    }

	    getAppliedFilters() {
	        var filters = {};
	        $.each('.dt-filter', this.header).map(function (input) {
	            var value = input.value;
	            if (value) {
	                filters[input.dataset.colIndex] = value;
	            }
	        });
	        return filters;
	    }

	    applyDefaultSortOrder() {
	        // sort rows if any 1 column has a default sortOrder set
	        var columnsToSort = this.getColumns().filter(function (col) { return col.sortOrder !== 'none'; });

	        if (columnsToSort.length === 1) {
	            var column = columnsToSort[0];
	            this.sortColumn(column.colIndex, column.sortOrder);
	        }
	    }

	    sortRows(colIndex, sortOrder) {
	        return this.datamanager.sortRows(colIndex, sortOrder);
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    setColumnWidth(colIndex, width) {
	        colIndex = +colIndex;

	        var columnWidth = width || this.getColumn(colIndex).width;

	        var selector = [
	            (".dt-cell__content--col-" + colIndex),
	            (".dt-cell__edit--col-" + colIndex)
	        ].join(', ');

	        var styles = {
	            width: columnWidth + 'px'
	        };

	        this.style.setStyle(selector, styles);
	    }

	    setColumnHeaderWidth(colIndex) {
	        colIndex = +colIndex;
	        this.$columnMap = this.$columnMap || [];
	        var selector = ".dt-cell__content--header-" + colIndex;
	        var ref = this.getColumn(colIndex);
	        var width = ref.width;

	        var $column = this.$columnMap[colIndex];
	        if (!$column) {
	            $column = this.header.querySelector(selector);
	            this.$columnMap[colIndex] = $column;
	        }

	        $column.style.width = width + 'px';
	    }

	    getColumnMinWidth(colIndex) {
	        colIndex = +colIndex;
	        return this.getColumn(colIndex).minWidth || 24;
	    }

	    getFirstColumnIndex() {
	        return this.datamanager.getColumnIndexById('_rowIndex') + 1;
	    }

	    getHeaderCell$(colIndex) {
	        return $((".dt-cell--header-" + colIndex), this.header);
	    }

	    getLastColumnIndex() {
	        return this.datamanager.getColumnCount() - 1;
	    }

	    getDropdownHTML() {
	        var ref = this.options;
	        var dropdownButton = ref.dropdownButton;

	        return ("\n            <div class=\"dt-dropdown\">\n                <div class=\"dt-dropdown__toggle\">" + dropdownButton + "</div>\n            </div>\n      ");
	    }

	    getDropdownListHTML() {
	        var ref = this.options;
	        var dropdownItems = ref.headerDropdown;

	        return ("\n            <div class=\"dt-dropdown__list\">\n            " + (dropdownItems.map(function (d, i) { return ("\n                <div class=\"dt-dropdown__list-item\" data-index=\"" + i + "\">" + (d.label) + "</div>\n            "); }).join('')) + "\n            </div>\n        ");
	    }
	}

	class RowManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'wrapper',
	            'bodyScrollable',
	            'bodyRenderer',
	            'style'
	        ]);

	        this.bindEvents();
	        this.refreshRows = nextTick(this.refreshRows, this);
	    }

	    get datamanager() {
	        return this.instance.datamanager;
	    }

	    get cellmanager() {
	        return this.instance.cellmanager;
	    }

	    bindEvents() {
	        this.bindCheckbox();
	    }

	    bindCheckbox() {
	        var this$1 = this;

	        if (!this.options.checkboxColumn) { return; }

	        // map of checked rows
	        this.checkMap = [];

	        $.on(this.wrapper, 'click', '.dt-cell--col-0 [type="checkbox"]', function (e, $checkbox) {
	            var $cell = $checkbox.closest('.dt-cell');
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var isHeader = ref.isHeader;
	            var checked = $checkbox.checked;

	            if (isHeader) {
	                this$1.checkAll(checked);
	            } else {
	                this$1.checkRow(rowIndex, checked);
	            }
	        });
	    }

	    refreshRows() {
	        this.instance.renderBody();
	        this.instance.setDimensions();
	    }

	    refreshRow(row, rowIndex) {
	        var this$1 = this;

	        var _row = this.datamanager.updateRow(row, rowIndex);

	        _row.forEach(function (cell) {
	            this$1.cellmanager.refreshCell(cell);
	        });
	    }

	    getCheckedRows() {
	        if (!this.checkMap) {
	            return [];
	        }

	        var out = [];
	        for (var rowIndex in this.checkMap) {
	            var checked = this.checkMap[rowIndex];
	            if (checked === 1) {
	                out.push(rowIndex);
	            }
	        }

	        return out;
	    }

	    highlightCheckedRows() {
	        var this$1 = this;

	        this.getCheckedRows()
	            .map(function (rowIndex) { return this$1.checkRow(rowIndex, true); });
	    }

	    checkRow(rowIndex, toggle) {
	        var value = toggle ? 1 : 0;
	        var selector = function (rowIndex) { return (".dt-cell--0-" + rowIndex + " [type=\"checkbox\"]"); };
	        // update internal map
	        this.checkMap[rowIndex] = value;
	        // set checkbox value explicitly
	        $.each(selector(rowIndex), this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight row
	        this.highlightRow(rowIndex, toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow', this.datamanager.getRow(rowIndex));
	    }

	    checkAll(toggle) {
	        var value = toggle ? 1 : 0;

	        // update internal map
	        if (toggle) {
	            this.checkMap = Array.from(Array(this.getTotalRows())).map(function (c) { return value; });
	        } else {
	            this.checkMap = [];
	        }
	        // set checkbox value
	        $.each('.dt-cell--col-0 [type="checkbox"]', this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight all
	        this.highlightAll(toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow');
	    }

	    showCheckStatus() {
	        if (!this.options.checkedRowStatus) { return; }
	        var checkedRows = this.getCheckedRows();
	        var count = checkedRows.length;
	        if (count > 0) {
	            this.bodyRenderer.showToastMessage((count + " row" + (count > 1 ? 's' : '') + " selected"));
	        } else {
	            this.bodyRenderer.clearToastMessage();
	        }
	    }

	    highlightRow(rowIndex, toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        var $row = this.getRow$(rowIndex);
	        if (!$row) { return; }

	        if (!toggle && this.bodyScrollable.classList.contains('dt-scrollable--highlight-all')) {
	            $row.classList.add('dt-row--unhighlight');
	            return;
	        }

	        if (toggle && $row.classList.contains('dt-row--unhighlight')) {
	            $row.classList.remove('dt-row--unhighlight');
	        }

	        this._highlightedRows = this._highlightedRows || {};

	        if (toggle) {
	            $row.classList.add('dt-row--highlight');
	            this._highlightedRows[rowIndex] = $row;
	        } else {
	            $row.classList.remove('dt-row--highlight');
	            delete this._highlightedRows[rowIndex];
	        }
	    }

	    highlightAll(toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        if (toggle) {
	            this.bodyScrollable.classList.add('dt-scrollable--highlight-all');
	        } else {
	            this.bodyScrollable.classList.remove('dt-scrollable--highlight-all');
	            for (var rowIndex in this._highlightedRows) {
	                var $row = this._highlightedRows[rowIndex];
	                $row.classList.remove('dt-row--highlight');
	            }
	            this._highlightedRows = {};
	        }
	    }

	    showRows(rowIndices) {
	        var this$1 = this;

	        rowIndices = ensureArray(rowIndices);
	        var rows = rowIndices.map(function (rowIndex) { return this$1.datamanager.getRow(rowIndex); });
	        this.bodyRenderer.renderRows(rows);
	    }

	    showAllRows() {
	        var rowIndices = this.datamanager.getAllRowIndices();
	        this.showRows(rowIndices);
	    }

	    getChildrenToShowForNode(rowIndex) {
	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = false;

	        return this.datamanager.getImmediateChildren(rowIndex);
	    }

	    openSingleNode(rowIndex) {
	        var childrenToShow = this.getChildrenToShowForNode(rowIndex);
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    getChildrenToHideForNode(rowIndex) {
	        var this$1 = this;

	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = true;

	        var rowsToHide = this.datamanager.getChildren(rowIndex);
	        rowsToHide.forEach(function (rowIndex) {
	            var row = this$1.datamanager.getRow(rowIndex);
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });

	        return rowsToHide;
	    }

	    closeSingleNode(rowIndex) {
	        var rowsToHide = this.getChildrenToHideForNode(rowIndex);
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    expandAllNodes() {
	        var this$1 = this;

	        var rows = this.datamanager.getRows();
	        var rootNodes = rows.filter(function (row) { return !row.meta.isLeaf; });

	        var childrenToShow = rootNodes.map(function (row) { return this$1.getChildrenToShowForNode(row.meta.rowIndex); }).flat();
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    collapseAllNodes() {
	        var this$1 = this;

	        var rows = this.datamanager.getRows();
	        var rootNodes = rows.filter(function (row) { return row.meta.indent === 0; });

	        var rowsToHide = rootNodes.map(function (row) { return this$1.getChildrenToHideForNode(row.meta.rowIndex); }).flat();
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    setTreeDepth(depth) {
	        var rows = this.datamanager.getRows();

	        var rowsToOpen = rows.filter(function (row) { return row.meta.indent < depth; });
	        var rowsToClose = rows.filter(function (row) { return row.meta.indent >= depth; });
	        var rowsToHide = rowsToClose.filter(function (row) { return row.meta.indent > depth; });

	        rowsToClose.forEach(function (row) {
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });
	        rowsToOpen.forEach(function (row) {
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = false;
	            }
	        });

	        var rowsToShow = rows
	            .filter(function (row) { return !rowsToHide.includes(row); })
	            .map(function (row) { return row.meta.rowIndex; })
	            .sort(numberSortAsc);
	        this.showRows(rowsToShow);
	    }

	    getRow$(rowIndex) {
	        return $(this.selector(rowIndex), this.bodyScrollable);
	    }

	    getTotalRows() {
	        return this.datamanager.getRowCount();
	    }

	    getFirstRowIndex() {
	        return 0;
	    }

	    getLastRowIndex() {
	        return this.datamanager.getRowCount() - 1;
	    }

	    scrollToRow(rowIndex) {
	        rowIndex = +rowIndex;
	        this._lastScrollTo = this._lastScrollTo || 0;
	        var $row = this.getRow$(rowIndex);
	        if ($.inViewport($row, this.bodyScrollable)) { return; }

	        var ref = $row.getBoundingClientRect();
	        var height = ref.height;
	        var ref$1 = this.bodyScrollable.getBoundingClientRect();
	        var top = ref$1.top;
	        var bottom = ref$1.bottom;
	        var rowsInView = Math.floor((bottom - top) / height);

	        var offset = 0;
	        if (rowIndex > this._lastScrollTo) {
	            offset = height * ((rowIndex + 1) - rowsInView);
	        } else {
	            offset = height * ((rowIndex + 1) - 1);
	        }

	        this._lastScrollTo = rowIndex;
	        $.scrollTop(this.bodyScrollable, offset);
	    }

	    getRowHTML(row, props) {
	        var this$1 = this;

	        var dataAttr = makeDataAttributeString(props);
	        var rowIdentifier = props.rowIndex;

	        if (props.isFilter) {
	            row = row.map(function (cell) { return (Object.assign({}, cell, {
	                content: this$1.getFilterInput({
	                    colIndex: cell.colIndex
	                }),
	                isFilter: 1,
	                isHeader: undefined,
	                editable: false
	            })); });

	            rowIdentifier = 'filter';
	        }

	        if (props.isHeader) {
	            rowIdentifier = 'header';
	        }

	        return ("\n            <div class=\"dt-row dt-row-" + rowIdentifier + "\" " + dataAttr + ">\n                " + (row.map(function (cell) { return this$1.cellmanager.getCellHTML(cell); }).join('')) + "\n            </div>\n        ");
	    }

	    getFilterInput(props) {
	        var dataAttr = makeDataAttributeString(props);
	        return ("<input class=\"dt-filter dt-input\" type=\"text\" " + dataAttr + " tabindex=\"1\" />");
	    }

	    selector(rowIndex) {
	        return (".dt-row-" + rowIndex);
	    }
	}

	var hyperlist = createCommonjsModule(function (module, exports) {
	(function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a){ return a(o,!0); }if(i){ return i(o,!0); }var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++){ s(r[o]); }return s})({1:[function(_dereq_,module,exports){

	// Default configuration.

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaultConfig = {
	  width: '100%',
	  height: '100%'
	};

	// Check for valid number.
	var isNumber = function isNumber(input) {
	  return Number(input) === Number(input);
	};

	/**
	 * Creates a HyperList instance that virtually scrolls very large amounts of
	 * data effortlessly.
	 */

	var HyperList = function () {
	  _createClass(HyperList, null, [{
	    key: 'create',
	    value: function create(element, userProvidedConfig) {
	      return new HyperList(element, userProvidedConfig);
	    }

	    /**
	     * Merge given css style on an element
	     * @param {DOMElement} element
	     * @param {Object} style
	     */

	  }, {
	    key: 'mergeStyle',
	    value: function mergeStyle(element, style) {
	      for (var i in style) {
	        if (element.style[i] !== style[i]) {
	          element.style[i] = style[i];
	        }
	      }
	    }
	  }, {
	    key: 'getMaxBrowserHeight',
	    value: function getMaxBrowserHeight() {
	      // Create two elements, the wrapper is `1px` tall and is transparent and
	      // positioned at the top of the page. Inside that is an element that gets
	      // set to 1 billion pixels. Then reads the max height the browser can
	      // calculate.
	      var wrapper = document.createElement('div');
	      var fixture = document.createElement('div');

	      // As said above, these values get set to put the fixture elements into the
	      // right visual state.
	      HyperList.mergeStyle(wrapper, { position: 'absolute', height: '1px', opacity: 0 });
	      HyperList.mergeStyle(fixture, { height: '1e7px' });

	      // Add the fixture into the wrapper element.
	      wrapper.appendChild(fixture);

	      // Apply to the page, the values won't kick in unless this is attached.
	      document.body.appendChild(wrapper);

	      // Get the maximum element height in pixels.
	      var maxElementHeight = fixture.offsetHeight;

	      // Remove the element immediately after reading the value.
	      document.body.removeChild(wrapper);

	      return maxElementHeight;
	    }
	  }]);

	  function HyperList(element, userProvidedConfig) {
	    var _this = this;

	    _classCallCheck(this, HyperList);

	    this._config = {};
	    this._lastRepaint = null;
	    this._maxElementHeight = HyperList.getMaxBrowserHeight();

	    this.refresh(element, userProvidedConfig);

	    var config = this._config;

	    // Create internal render loop.
	    var render = function render() {
	      var scrollTop = _this._getScrollPosition();
	      var lastRepaint = _this._lastRepaint;

	      _this._renderAnimationFrame = window.requestAnimationFrame(render);

	      if (scrollTop === lastRepaint) {
	        return;
	      }

	      if (!lastRepaint || Math.abs(scrollTop - lastRepaint) > _this._averageHeight) {
	        var rendered = _this._renderChunk();

	        _this._lastRepaint = scrollTop;

	        if (rendered !== false && typeof config.afterRender === 'function') {
	          config.afterRender();
	        }
	      }
	    };

	    render();
	  }

	  _createClass(HyperList, [{
	    key: 'destroy',
	    value: function destroy() {
	      window.cancelAnimationFrame(this._renderAnimationFrame);
	    }
	  }, {
	    key: 'refresh',
	    value: function refresh(element, userProvidedConfig) {
	      var _this2 = this;

	      Object.assign(this._config, defaultConfig, userProvidedConfig);

	      if (!element || element.nodeType !== 1) {
	        throw new Error('HyperList requires a valid DOM Node container');
	      }

	      this._element = element;

	      var config = this._config;

	      var scroller = this._scroller || config.scroller || document.createElement(config.scrollerTagName || 'tr');

	      // Default configuration option `useFragment` to `true`.
	      if (typeof config.useFragment !== 'boolean') {
	        this._config.useFragment = true;
	      }

	      if (!config.generate) {
	        throw new Error('Missing required `generate` function');
	      }

	      if (!isNumber(config.total)) {
	        throw new Error('Invalid required `total` value, expected number');
	      }

	      if (!Array.isArray(config.itemHeight) && !isNumber(config.itemHeight)) {
	        throw new Error('\n        Invalid required `itemHeight` value, expected number or array\n      '.trim());
	      } else if (isNumber(config.itemHeight)) {
	        this._itemHeights = Array(config.total).fill(config.itemHeight);
	      } else {
	        this._itemHeights = config.itemHeight;
	      }

	      // Width and height should be coerced to string representations. Either in
	      // `%` or `px`.
	      Object.keys(defaultConfig).filter(function (prop) {
	        return prop in config;
	      }).forEach(function (prop) {
	        var value = config[prop];
	        var isValueNumber = isNumber(value);
	        var isValuePercent = isValueNumber ? false : value.slice(-1) === '%';

	        if (value && typeof value !== 'string' && typeof value !== 'number') {
	          var msg = 'Invalid optional `' + prop + '`, expected string or number';
	          throw new Error(msg);
	        } else if (isValueNumber) {
	          config[prop] = value + 'px';
	        }

	        if (prop !== 'height') {
	          return;
	        }

	        // Compute the containerHeight as number
	        var numberValue = isValueNumber ? value : parseInt(value.replace(/px|%/, ''), 10);

	        if (isValuePercent) {
	          _this2._containerHeight = window.innerHeight * numberValue / 100;
	        } else {
	          _this2._containerHeight = isNumber(value) ? value : numberValue;
	        }
	      });

	      // Decorate the container element with styles that will match
	      // the user supplied configuration.
	      var elementStyle = {
	        width: '' + config.width,
	        height: '' + config.height,
	        overflow: 'auto',
	        position: 'relative'
	      };

	      HyperList.mergeStyle(element, elementStyle);

	      var scrollerHeight = config.itemHeight * config.total;
	      var maxElementHeight = this._maxElementHeight;

	      if (scrollerHeight > maxElementHeight) {
	        console.warn(['HyperList: The maximum element height', maxElementHeight + 'px has', 'been exceeded; please reduce your item height.'].join(' '));
	      }

	      var scrollerStyle = {
	        opacity: '0',
	        position: 'absolute',
	        width: '1px',
	        height: scrollerHeight + 'px'
	      };

	      HyperList.mergeStyle(scroller, scrollerStyle);

	      // Only append the scroller element once.
	      if (!this._scroller) {
	        element.appendChild(scroller);
	      }

	      // Set the scroller instance.
	      this._scroller = scroller;
	      this._scrollHeight = this._computeScrollHeight();

	      // Reuse the item positions if refreshed, otherwise set to empty array.
	      this._itemPositions = this._itemPositions || Array(config.total).fill(0);

	      // Each index in the array should represent the position in the DOM.
	      this._computePositions(0);

	      // Render after refreshing. Force render if we're calling refresh manually.
	      this._renderChunk(this._lastRepaint !== null);

	      if (typeof config.afterRender === 'function') {
	        config.afterRender();
	      }
	    }
	  }, {
	    key: '_getRow',
	    value: function _getRow(i) {
	      var config = this._config;
	      var item = config.generate(i);
	      var height = item.height;

	      if (height !== undefined && isNumber(height)) {
	        item = item.element;

	        // The height isn't the same as predicted, compute positions again
	        if (height !== this._itemHeights) {
	          this._itemHeights[i] = height;
	          this._computePositions(i);
	          this._scrollHeight = this._computeScrollHeight(i);
	        }
	      } else {
	        height = this._itemHeights[i];
	      }

	      if (!item || item.nodeType !== 1) {
	        throw new Error('Generator did not return a DOM Node for index: ' + i);
	      }

	      var oldClass = item.getAttribute('class') || '';
	      item.setAttribute('class', oldClass + ' ' + (config.rowClassName || 'vrow'));

	      var top = this._itemPositions[i];

	      HyperList.mergeStyle(item, {
	        position: 'absolute',
	        top: top + 'px'
	      });

	      return item;
	    }
	  }, {
	    key: '_getScrollPosition',
	    value: function _getScrollPosition() {
	      var config = this._config;

	      if (typeof config.overrideScrollPosition === 'function') {
	        return config.overrideScrollPosition();
	      }

	      return this._element.scrollTop;
	    }
	  }, {
	    key: '_renderChunk',
	    value: function _renderChunk(force) {
	      var config = this._config;
	      var element = this._element;
	      var scrollTop = this._getScrollPosition();
	      var total = config.total;

	      var from = config.reverse ? this._getReverseFrom(scrollTop) : this._getFrom(scrollTop) - 1;

	      if (from < 0 || from - this._screenItemsLen < 0) {
	        from = 0;
	      }

	      if (!force && this._lastFrom === from) {
	        return false;
	      }

	      this._lastFrom = from;

	      var to = from + this._cachedItemsLen;

	      if (to > total || to + this._cachedItemsLen > total) {
	        to = total;
	      }

	      // Append all the new rows in a document fragment that we will later append
	      // to the parent node
	      var fragment = config.useFragment ? document.createDocumentFragment() : []
	      // Sometimes you'll pass fake elements to this tool and Fragments require
	      // real elements.


	      // The element that forces the container to scroll.
	      ;var scroller = this._scroller;

	      // Keep the scroller in the list of children.
	      fragment[config.useFragment ? 'appendChild' : 'push'](scroller);

	      for (var i = from; i < to; i++) {
	        var row = this._getRow(i);

	        fragment[config.useFragment ? 'appendChild' : 'push'](row);
	      }

	      if (config.applyPatch) {
	        return config.applyPatch(element, fragment);
	      }

	      element.innerHTML = '';
	      element.appendChild(fragment);
	    }
	  }, {
	    key: '_computePositions',
	    value: function _computePositions() {
	      var from = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

	      var config = this._config;
	      var total = config.total;
	      var reverse = config.reverse;

	      if (from < 1 && !reverse) {
	        from = 1;
	      }

	      for (var i = from; i < total; i++) {
	        if (reverse) {
	          if (i === 0) {
	            this._itemPositions[0] = this._scrollHeight - this._itemHeights[0];
	          } else {
	            this._itemPositions[i] = this._itemPositions[i - 1] - this._itemHeights[i];
	          }
	        } else {
	          this._itemPositions[i] = this._itemHeights[i - 1] + this._itemPositions[i - 1];
	        }
	      }
	    }
	  }, {
	    key: '_computeScrollHeight',
	    value: function _computeScrollHeight() {
	      var _this3 = this;

	      var config = this._config;
	      var total = config.total;
	      var scrollHeight = this._itemHeights.reduce(function (a, b) {
	        return a + b;
	      }, 0);

	      HyperList.mergeStyle(this._scroller, {
	        opacity: 0,
	        position: 'absolute',
	        width: '1px',
	        height: scrollHeight + 'px'
	      });

	      // Calculate the height median
	      var sortedItemHeights = this._itemHeights.slice(0).sort(function (a, b) {
	        return a - b;
	      });
	      var middle = Math.floor(total / 2);
	      var averageHeight = total % 2 === 0 ? (sortedItemHeights[middle] + sortedItemHeights[middle - 1]) / 2 : sortedItemHeights[middle];

	      var containerHeight = this._element.clientHeight ? this._element.clientHeight : this._containerHeight;
	      this._screenItemsLen = Math.ceil(containerHeight / averageHeight);
	      this._containerHeight = containerHeight;

	      // Cache 3 times the number of items that fit in the container viewport.
	      this._cachedItemsLen = Math.max(this._cachedItemsLen || 0, this._screenItemsLen * 3);
	      this._averageHeight = averageHeight;

	      if (config.reverse) {
	        window.requestAnimationFrame(function () {
	          _this3._element.scrollTop = scrollHeight;
	        });
	      }

	      return scrollHeight;
	    }
	  }, {
	    key: '_getFrom',
	    value: function _getFrom(scrollTop) {
	      var i = 0;

	      while (this._itemPositions[i] < scrollTop) {
	        i++;
	      }

	      return i;
	    }
	  }, {
	    key: '_getReverseFrom',
	    value: function _getReverseFrom(scrollTop) {
	      var i = this._config.total - 1;

	      while (i > 0 && this._itemPositions[i] < scrollTop + this._containerHeight) {
	        i--;
	      }

	      return i;
	    }
	  }]);

	  return HyperList;
	}();

	exports.default = HyperList;
	module.exports = exports['default'];

	},{}]},{},[1])(1)
	});
	});

	var HyperList = unwrapExports(hyperlist);

	class BodyRenderer {
	    constructor(instance) {
	        this.instance = instance;
	        this.options = instance.options;
	        this.datamanager = instance.datamanager;
	        this.rowmanager = instance.rowmanager;
	        this.cellmanager = instance.cellmanager;
	        this.bodyScrollable = instance.bodyScrollable;
	        this.footer = this.instance.footer;
	        this.log = instance.log;
	    }

	    renderRows(rows) {
	        var this$1 = this;

	        this.visibleRows = rows;
	        this.visibleRowIndices = rows.map(function (row) { return row.meta.rowIndex; });

	        if (rows.length === 0) {
	            this.bodyScrollable.innerHTML = this.getNoDataHTML();
	            return;
	        }

	        var rowViewOrder = this.datamanager.rowViewOrder.map(function (index) {
	            if (this$1.visibleRowIndices.includes(index)) {
	                return index;
	            }
	            return null;
	        }).filter(function (index) { return index !== null; });

	        var computedStyle = getComputedStyle(this.bodyScrollable);

	        var config = {
	            width: computedStyle.width,
	            height: computedStyle.height,
	            itemHeight: this.options.cellHeight,
	            total: rows.length,
	            generate: function (index) {
	                var el = document.createElement('div');
	                var rowIndex = rowViewOrder[index];
	                var row = this$1.datamanager.getRow(rowIndex);
	                var rowHTML = this$1.rowmanager.getRowHTML(row, row.meta);
	                el.innerHTML = rowHTML;
	                return el.children[0];
	            },
	            afterRender: function () {
	                this$1.restoreState();
	            }
	        };

	        if (!this.hyperlist) {
	            this.hyperlist = new HyperList(this.bodyScrollable, config);
	        } else {
	            this.hyperlist.refresh(this.bodyScrollable, config);
	        }

	        this.renderFooter();
	    }

	    render() {
	        var rows = this.datamanager.getRowsForView();
	        this.renderRows(rows);
	        // setDimensions requires atleast 1 row to exist in dom
	        this.instance.setDimensions();
	    }

	    renderFooter() {
	        if (!this.options.showTotalRow) { return; }

	        var totalRow = this.getTotalRow();
	        var html = this.rowmanager.getRowHTML(totalRow, { isTotalRow: 1, rowIndex: 'totalRow' });

	        this.footer.innerHTML = html;
	    }

	    getTotalRow() {
	        var this$1 = this;

	        var columns = this.datamanager.getColumns();
	        var totalRowTemplate = columns.map(function (col) {
	            var content = null;
	            if (['_rowIndex', '_checkbox'].includes(col.id)) {
	                content = '';
	            }
	            return {
	                content: content,
	                isTotalRow: 1,
	                colIndex: col.colIndex,
	                column: col
	            };
	        });

	        var totalRow = totalRowTemplate.map(function (cell, i) {
	            if (cell.content === '') { return cell; }

	            if (this$1.options.hooks.columnTotal) {
	                var columnValues = this$1.visibleRows.map(function (row) { return row[i].content; });
	                var result = this$1.options.hooks.columnTotal.call(this$1.instance, columnValues, cell);
	                if (result != null) {
	                    cell.content = result;
	                    return cell;
	                }
	            }

	            cell.content = this$1.visibleRows.reduce(function (acc, prevRow) {
	                var prevCell = prevRow[i];
	                if (typeof prevCell.content === 'number') {
	                    if (acc == null) { acc = 0; }
	                    return acc + prevCell.content;
	                }
	                return acc;
	            }, cell.content);

	            return cell;
	        });

	        return totalRow;
	    }

	    restoreState() {
	        this.rowmanager.highlightCheckedRows();
	        this.cellmanager.selectAreaOnClusterChanged();
	        this.cellmanager.focusCellOnClusterChanged();
	    }

	    showToastMessage(message, hideAfter) {
	        var this$1 = this;

	        this.instance.toastMessage.innerHTML = this.getToastMessageHTML(message);

	        if (hideAfter) {
	            setTimeout(function () {
	                this$1.clearToastMessage();
	            }, hideAfter * 1000);
	        }
	    }

	    clearToastMessage() {
	        this.instance.toastMessage.innerHTML = '';
	    }

	    getNoDataHTML() {
	        return ("<div class=\"dt-scrollable__no-data\">" + (this.options.noDataMessage) + "</div>");
	    }

	    getToastMessageHTML(message) {
	        return ("<span class=\"dt-toast__message\">" + message + "</span>");
	    }
	}

	class Style {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options', 'datamanager', 'columnmanager',
	            'header', 'footer', 'bodyScrollable', 'datatableWrapper',
	            'getColumn', 'bodyRenderer'
	        ]);

	        this.scopeClass = 'dt-instance-' + instance.constructor.instances;
	        instance.datatableWrapper.classList.add(this.scopeClass);

	        var styleEl = document.createElement('style');
	        instance.wrapper.insertBefore(styleEl, instance.datatableWrapper);
	        this.styleEl = styleEl;

	        this.bindResizeWindow();
	        this.bindScrollHeader();
	    }

	    get stylesheet() {
	        return this.styleEl.sheet;
	    }

	    bindResizeWindow() {
	        this.onWindowResize = this.onWindowResize.bind(this);
	        this.onWindowResize = throttle$1(this.onWindowResize, 300);

	        if (this.options.layout === 'fluid') {
	            $.on(window, 'resize', this.onWindowResize);
	        }
	    }

	    bindScrollHeader() {
	        var this$1 = this;

	        this._settingHeaderPosition = false;

	        $.on(this.bodyScrollable, 'scroll', function (e) {
	            if (this$1._settingHeaderPosition) { return; }

	            this$1._settingHeaderPosition = true;

	            requestAnimationFrame(function () {
	                var left = -e.target.scrollLeft;

	                $.style(this$1.header, {
	                    transform: ("translateX(" + left + "px)")
	                });
	                $.style(this$1.footer, {
	                    transform: ("translateX(" + left + "px)")
	                });
	                this$1._settingHeaderPosition = false;
	            });
	        });
	    }

	    onWindowResize() {
	        this.distributeRemainingWidth();
	        this.refreshColumnWidth();
	        this.setBodyStyle();
	    }

	    destroy() {
	        this.styleEl.remove();
	        $.off(window, 'resize', this.onWindowResize);
	    }

	    setStyle(selector, styleObject) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.setStyle(selector, styleObject);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        this._styleRulesMap = this._styleRulesMap || {};
	        var prefixedSelector = this._getPrefixedSelector(selector);

	        if (this._styleRulesMap[prefixedSelector]) {
	            this.removeStyle(selector);

	            // merge with old styleobject
	            styleObject = Object.assign({}, this._styleRulesMap[prefixedSelector], styleObject);
	        }

	        var styleString = this._getRuleString(styleObject);
	        var ruleString = prefixedSelector + " { " + styleString + " }";

	        this._styleRulesMap[prefixedSelector] = styleObject;
	        this.stylesheet.insertRule(ruleString);
	    }

	    removeStyle(selector) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.removeStyle(selector);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        // find and remove
	        var prefixedSelector = this._getPrefixedSelector(selector);
	        var index = Array.from(this.stylesheet.cssRules)
	            .findIndex(function (rule) { return rule.selectorText === prefixedSelector; });

	        if (index === -1) { return; }
	        this.stylesheet.deleteRule(index);
	    }

	    _getPrefixedSelector(selector) {
	        return ("." + (this.scopeClass) + " " + selector);
	    }

	    _getRuleString(styleObject) {
	        return Object.keys(styleObject)
	            .map(function (prop) {
	                var dashed = prop;
	                if (!prop.includes('-')) {
	                    dashed = camelCaseToDash(prop);
	                }
	                return (dashed + ":" + (styleObject[prop]) + ";");
	            })
	            .join('');
	    }

	    setDimensions() {
	        this.setCellHeight();
	        this.setupMinWidth();
	        this.setupNaturalColumnWidth();
	        this.setupColumnWidth();
	        this.distributeRemainingWidth();
	        this.setColumnStyle();
	        this.setBodyStyle();
	    }

	    setCellHeight() {
	        this.setStyle('.dt-cell', {
	            height: this.options.cellHeight + 'px'
	        });
	    }

	    setupMinWidth() {
	        var this$1 = this;

	        $.each('.dt-cell--header', this.header).map(function (col) {
	            var ref = $.data(col);
	            var colIndex = ref.colIndex;
	            var column = this$1.getColumn(colIndex);

	            if (!column.minWidth) {
	                var width = $.style($('.dt-cell__content', col), 'width');
	                // only set this once
	                column.minWidth = width;
	            }
	        });
	    }

	    setupNaturalColumnWidth() {
	        var this$1 = this;

	        if (!$('.dt-row')) { return; }

	        $.each('.dt-row-header .dt-cell', this.header).map(function ($headerCell) {
	            var ref = $.data($headerCell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);
	            var width = $.style($('.dt-cell__content', $headerCell), 'width');
	            if (typeof width === 'number' && width >= this$1.options.minimumColumnWidth) {
	                column.naturalWidth = width;
	            } else {
	                column.naturalWidth = this$1.options.minimumColumnWidth;
	            }
	        });

	        // set initial width as naturally calculated by table's first row
	        $.each('.dt-row-0 .dt-cell', this.bodyScrollable).map(function ($cell) {
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);

	            var naturalWidth = $.style($('.dt-cell__content', $cell), 'width');

	            if (typeof naturalWidth === 'number' && naturalWidth >= column.naturalWidth) {
	                column.naturalWidth = naturalWidth;
	            } else {
	                column.naturalWidth = column.naturalWidth;
	            }
	        });
	    }

	    setupColumnWidth() {
	        var this$1 = this;

	        if (this.options.layout === 'ratio') {
	            var totalWidth = $.style(this.datatableWrapper, 'width');

	            if (this.options.serialNoColumn) {
	                var rowIndexColumn = this.datamanager.getColumnById('_rowIndex');
	                totalWidth = totalWidth - rowIndexColumn.width - 1;
	            }

	            if (this.options.checkboxColumn) {
	                var rowIndexColumn$1 = this.datamanager.getColumnById('_checkbox');
	                totalWidth = totalWidth - rowIndexColumn$1.width - 1;
	            }

	            var totalParts = this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') {
	                        return 0;
	                    }
	                    if (!column.width) {
	                        column.width = 1;
	                    }
	                    column.ratioWidth = parseInt(column.width, 10);
	                    return column.ratioWidth;
	                })
	                .reduce(function (a, c) { return a + c; });

	            var onePart = totalWidth / totalParts;

	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') { return; }
	                    column.width = Math.floor(onePart * column.ratioWidth) - 1;
	                });
	        } else {
	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (!column.width) {
	                        column.width = column.naturalWidth;
	                    }
	                    if (column.id === '_rowIndex') {
	                        column.width = this$1.getRowIndexColumnWidth();
	                    }
	                    if (column.width < this$1.options.minimumColumnWidth) {
	                        column.width = this$1.options.minimumColumnWidth;
	                    }
	                });
	        }
	    }

	    distributeRemainingWidth() {
	        var this$1 = this;

	        if (this.options.layout !== 'fluid') { return; }

	        var wrapperWidth = $.style(this.instance.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        var firstRowWidth = wrapperWidth;
	        if (!firstRow) {
	            var headerRow = $('.dt-row', this.instance.header);
	            var cellWidths = Array.from(headerRow.children)
	                .map(function (cell) { return cell.offsetWidth; });
	            firstRowWidth = cellWidths.reduce(function (sum, a) { return sum + a; }, 0);
	        } else {
	            firstRowWidth = $.style(firstRow, 'width');
	        }
	        var resizableColumns = this.datamanager.getColumns().filter(function (col) { return col.resizable; });
	        var deltaWidth = (wrapperWidth - firstRowWidth) / resizableColumns.length;

	        resizableColumns.map(function (col) {
	            var width = $.style(this$1.getColumnHeaderElement(col.colIndex), 'width');
	            var finalWidth = Math.floor(width + deltaWidth) - 2;

	            this$1.datamanager.updateColumn(col.colIndex, {
	                width: finalWidth
	            });
	        });
	    }

	    setColumnStyle() {
	        var this$1 = this;

	        // align columns
	        this.datamanager.getColumns()
	            .map(function (column) {
	                // alignment
	                if (!column.align) {
	                    column.align = 'left';
	                }
	                if (!['left', 'center', 'right'].includes(column.align)) {
	                    column.align = 'left';
	                }
	                this$1.setStyle((".dt-cell--col-" + (column.colIndex)), {
	                    'text-align': column.align
	                });

	                // width
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    refreshColumnWidth() {
	        var this$1 = this;

	        this.datamanager.getColumns()
	            .map(function (column) {
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    setBodyStyle() {
	        var bodyWidth = $.style(this.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        if (!firstRow) { return; }
	        var rowWidth = $.style(firstRow, 'width');

	        var width = bodyWidth > rowWidth ? rowWidth : bodyWidth;
	        $.style(this.bodyScrollable, {
	            width: width + 'px'
	        });

	        // remove the body height, so that it resets to it's original
	        $.removeStyle(this.bodyScrollable, 'height');

	        // when there are less rows than the container
	        // adapt the container height
	        var bodyHeight = $.getStyle(this.bodyScrollable, 'height');
	        var scrollHeight = (this.bodyRenderer.hyperlist || {})._scrollHeight || Infinity;
	        var hasHorizontalOverflow = $.hasHorizontalOverflow(this.bodyScrollable);

	        var height;

	        if (scrollHeight < bodyHeight) {
	            height = scrollHeight;

	            // account for scrollbar size when
	            // there is horizontal overflow
	            if (hasHorizontalOverflow) {
	                height += $.scrollbarSize();
	            }

	            $.style(this.bodyScrollable, {
	                height: height + 'px'
	            });
	        }

	        var verticalOverflow = this.bodyScrollable.scrollHeight - this.bodyScrollable.offsetHeight;
	        if (verticalOverflow < $.scrollbarSize()) {
	            // if verticalOverflow is less than scrollbar size
	            // then most likely scrollbar is causing the scroll
	            // which is not needed
	            $.style(this.bodyScrollable, {
	                overflowY: 'hidden'
	            });
	        }

	        if (this.options.layout === 'fluid') {
	            $.style(this.bodyScrollable, {
	                overflowX: 'hidden'
	            });
	        }
	    }

	    getColumnHeaderElement(colIndex) {
	        colIndex = +colIndex;
	        if (colIndex < 0) { return null; }
	        return $((".dt-cell--col-" + colIndex), this.header);
	    }

	    getRowIndexColumnWidth() {
	        var rowCount = this.datamanager.getRowCount();
	        var padding = 22;
	        return $.measureTextWidth(rowCount + '') + padding;
	    }
	}

	var KEYCODES = {
	    13: 'enter',
	    91: 'meta',
	    16: 'shift',
	    17: 'ctrl',
	    18: 'alt',
	    37: 'left',
	    38: 'up',
	    39: 'right',
	    40: 'down',
	    9: 'tab',
	    27: 'esc',
	    67: 'c',
	    70: 'f',
	    86: 'v'
	};

	class Keyboard {
	    constructor(element) {
	        this.listeners = {};
	        $.on(element, 'keydown', this.handler.bind(this));
	    }

	    handler(e) {
	        var key = KEYCODES[e.keyCode];

	        if (e.shiftKey && key !== 'shift') {
	            key = 'shift+' + key;
	        }

	        if ((e.ctrlKey && key !== 'ctrl') || (e.metaKey && key !== 'meta')) {
	            key = 'ctrl+' + key;
	        }

	        var listeners = this.listeners[key];

	        if (listeners && listeners.length > 0) {
	            for (var i = 0, list = listeners; i < list.length; i += 1) {
	                var listener = list[i];

	              var preventBubbling = listener(e);
	                if (preventBubbling === undefined || preventBubbling === true) {
	                    e.preventDefault();
	                }
	            }
	        }
	    }

	    on(key, listener) {
	        var this$1 = this;

	        var keys = key.split(',').map(function (k) { return k.trim(); });

	        keys.map(function (key) {
	            this$1.listeners[key] = this$1.listeners[key] || [];
	            this$1.listeners[key].push(listener);
	        });
	    }
	}

	function filterRows(rows, filters) {
	    var filteredRowIndices = [];

	    if (Object.keys(filters).length === 0) {
	        return rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    var loop = function ( colIndex ) {
	        var keyword = filters[colIndex];

	        var filteredRows = filteredRowIndices.length ?
	            filteredRowIndices.map(function (i) { return rows[i]; }) :
	            rows;

	        var cells = filteredRows.map(function (row) { return row[colIndex]; });

	        var filter = guessFilter(keyword);
	        var filterMethod = getFilterMethod(filter);

	        if (filterMethod) {
	            filteredRowIndices = filterMethod(filter.text, cells);
	        } else {
	            filteredRowIndices = cells.map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    for (var colIndex in filters) loop( colIndex );

	    return filteredRowIndices;
	}
	function getFilterMethod(filter) {
	    var stringCompareValue = function (cell) { return String(stripHTML(cell.html || '') || cell.content || '').toLowerCase(); };

	    var numberCompareValue = function (cell) { return parseFloat(cell.content); };

	    var getCompareValues = function (cell, keyword) {
	        if (cell.column.compareValue) {
	            var compareValues = cell.column.compareValue(cell, keyword);
	            if (compareValues && Array.isArray(compareValues)) { return compareValues; }
	        }

	        // check if it can be converted to number
	        var float = numberCompareValue(cell);
	        if (!isNaN(float)) {
	            return [float, keyword];
	        }

	        return [stringCompareValue(cell), keyword];
	    };

	    var filterMethodMap = {
	        contains: function contains(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var hay = stringCompareValue(cell);
	                    var needle = (keyword || '').toLowerCase();
	                    return !needle || hay.includes(needle);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        greaterThan: function greaterThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue > keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        lessThan: function lessThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue < keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        equals: function equals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value === keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        notEquals: function notEquals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value !== keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        range: function range(rangeValues, cells) {
	            return cells
	                .filter(function (cell) {
	                    var values1 = getCompareValues(cell, rangeValues[0]);
	                    var values2 = getCompareValues(cell, rangeValues[1]);
	                    var value = values1[0];
	                    return value >= values1[1] && value <= values2[1];
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        containsNumber: function containsNumber(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var number = parseFloat(keyword, 10);
	                    var string = keyword;
	                    var hayNumber = numberCompareValue(cell);
	                    var hayString = stringCompareValue(cell);

	                    return number === hayNumber || hayString.includes(string);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    return filterMethodMap[filter.type];
	}

	function guessFilter(keyword) {
	    if ( keyword === void 0 ) keyword = '';

	    if (keyword.length === 0) { return {}; }

	    var compareString = keyword;

	    if (['>', '<', '='].includes(compareString[0])) {
	        compareString = keyword.slice(1);
	    } else if (compareString.startsWith('!=')) {
	        compareString = keyword.slice(2);
	    }

	    if (keyword.startsWith('>')) {
	        if (compareString) {
	            return {
	                type: 'greaterThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('<')) {
	        if (compareString) {
	            return {
	                type: 'lessThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'equals',
	                text: Number(keyword.slice(1).trim())
	            };
	        }
	    }

	    if (isNumber(compareString)) {
	        return {
	            type: 'containsNumber',
	            text: compareString
	        };
	    }

	    if (keyword.startsWith('!=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'notEquals',
	                text: Number(keyword.slice(2).trim())
	            };
	        }
	    }

	    if (keyword.split(':').length === 2) {
	        compareString = keyword.split(':');
	        return {
	            type: 'range',
	            text: compareString.map(function (v) { return v.trim(); })
	        };
	    }

	    return {
	        type: 'contains',
	        text: compareString.toLowerCase()
	    };
	}

	var DEFAULT_OPTIONS = {
	    columns: [],
	    data: [],
	    dropdownButton: icons.chevronDown,
	    headerDropdown: [
	        {
	            label: 'Sort Ascending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'asc');
	            }
	        },
	        {
	            label: 'Sort Descending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'desc');
	            }
	        },
	        {
	            label: 'Reset sorting',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'none');
	            }
	        },
	        {
	            label: 'Remove column',
	            action: function (column) {
	                this.removeColumn(column.colIndex);
	            }
	        }
	    ],
	    events: {
	        onRemoveColumn: function onRemoveColumn(column) {},
	        onSwitchColumn: function onSwitchColumn(column1, column2) {},
	        onSortColumn: function onSortColumn(column) {},
	        onCheckRow: function onCheckRow(row) {},
	        onDestroy: function onDestroy() {}
	    },
	    hooks: {
	        columnTotal: null
	    },
	    sortIndicator: {
	        asc: '↑',
	        desc: '↓',
	        none: ''
	    },
	    overrideComponents: {
	        // ColumnManager: CustomColumnManager
	    },
	    filterRows: filterRows,
	    freezeMessage: '',
	    getEditor: null,
	    serialNoColumn: true,
	    checkboxColumn: false,
	    clusterize: true,
	    logs: false,
	    layout: 'fixed', // fixed, fluid, ratio
	    noDataMessage: 'No Data',
	    cellHeight: 40,
	    minimumColumnWidth: 30,
	    inlineFilters: false,
	    treeView: false,
	    checkedRowStatus: true,
	    dynamicRowHeight: false,
	    pasteFromClipboard: false,
	    showTotalRow: false,
	    direction: 'ltr',
	    disableReorderColumn: false
	};

	var defaultComponents = {
	    DataManager: DataManager,
	    CellManager: CellManager,
	    ColumnManager: ColumnManager,
	    RowManager: RowManager,
	    BodyRenderer: BodyRenderer,
	    Style: Style,
	    Keyboard: Keyboard
	};

	class DataTable {
	    constructor(wrapper, options) {
	        DataTable.instances++;

	        if (typeof wrapper === 'string') {
	            // css selector
	            wrapper = document.querySelector(wrapper);
	        }
	        this.wrapper = wrapper;
	        if (!(this.wrapper instanceof HTMLElement)) {
	            throw new Error('Invalid argument given for `wrapper`');
	        }

	        this.buildOptions(options);
	        this.prepare();
	        this.initializeComponents();

	        if (this.options.data) {
	            this.refresh();
	            this.columnmanager.applyDefaultSortOrder();
	        }
	    }

	    buildOptions(options) {
	        this.options = this.options || {};

	        this.options = Object.assign(
	            {}, DEFAULT_OPTIONS,
	            this.options || {}, options
	        );

	        options.headerDropdown = options.headerDropdown || [];
	        this.options.headerDropdown = DEFAULT_OPTIONS.headerDropdown.concat( options.headerDropdown
	        );

	        // custom user events
	        this.events = Object.assign(
	            {}, DEFAULT_OPTIONS.events,
	            this.options.events || {},
	            options.events || {}
	        );
	        this.fireEvent = this.fireEvent.bind(this);
	    }

	    prepare() {
	        this.prepareDom();
	        this.unfreeze();
	    }

	    initializeComponents() {
	        var components = Object.assign({}, defaultComponents, this.options.overrideComponents);
	        var Style$$1 = components.Style;
	        var Keyboard$$1 = components.Keyboard;
	        var DataManager$$1 = components.DataManager;
	        var RowManager$$1 = components.RowManager;
	        var ColumnManager$$1 = components.ColumnManager;
	        var CellManager$$1 = components.CellManager;
	        var BodyRenderer$$1 = components.BodyRenderer;

	        this.style = new Style$$1(this);
	        this.keyboard = new Keyboard$$1(this.wrapper);
	        this.datamanager = new DataManager$$1(this.options);
	        this.rowmanager = new RowManager$$1(this);
	        this.columnmanager = new ColumnManager$$1(this);
	        this.cellmanager = new CellManager$$1(this);
	        this.bodyRenderer = new BodyRenderer$$1(this);
	    }

	    prepareDom() {
	        this.wrapper.innerHTML = "\n            <div class=\"datatable\" dir=\"" + (this.options.direction) + "\">\n                <div class=\"dt-header\"></div>\n                <div class=\"dt-scrollable\"></div>\n                <div class=\"dt-footer\"></div>\n                <div class=\"dt-freeze\">\n                    <span class=\"dt-freeze__message\">\n                        " + (this.options.freezeMessage) + "\n                    </span>\n                </div>\n                <div class=\"dt-toast\"></div>\n                <div class=\"dt-dropdown-container\"></div>\n                <textarea class=\"dt-paste-target\"></textarea>\n            </div>\n        ";

	        this.datatableWrapper = $('.datatable', this.wrapper);
	        this.header = $('.dt-header', this.wrapper);
	        this.footer = $('.dt-footer', this.wrapper);
	        this.bodyScrollable = $('.dt-scrollable', this.wrapper);
	        this.freezeContainer = $('.dt-freeze', this.wrapper);
	        this.toastMessage = $('.dt-toast', this.wrapper);
	        this.pasteTarget = $('.dt-paste-target', this.wrapper);
	        this.dropdownContainer = $('.dt-dropdown-container', this.wrapper);
	    }

	    refresh(data, columns) {
	        this.datamanager.init(data, columns);
	        this.render();
	        this.setDimensions();
	    }

	    destroy() {
	        this.wrapper.innerHTML = '';
	        this.style.destroy();
	        this.fireEvent('onDestroy');
	    }

	    appendRows(rows) {
	        this.datamanager.appendRows(rows);
	        this.rowmanager.refreshRows();
	    }

	    refreshRow(row, rowIndex) {
	        this.rowmanager.refreshRow(row, rowIndex);
	    }

	    render() {
	        this.renderHeader();
	        this.renderBody();
	    }

	    renderHeader() {
	        this.columnmanager.renderHeader();
	    }

	    renderBody() {
	        this.bodyRenderer.render();
	    }

	    setDimensions() {
	        this.style.setDimensions();
	    }

	    showToastMessage(message, hideAfter) {
	        this.bodyRenderer.showToastMessage(message, hideAfter);
	    }

	    clearToastMessage() {
	        this.bodyRenderer.clearToastMessage();
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    getRows() {
	        return this.datamanager.getRows();
	    }

	    getCell(colIndex, rowIndex) {
	        return this.datamanager.getCell(colIndex, rowIndex);
	    }

	    getColumnHeaderElement(colIndex) {
	        return this.columnmanager.getColumnHeaderElement(colIndex);
	    }

	    getViewportHeight() {
	        if (!this.viewportHeight) {
	            this.viewportHeight = $.style(this.bodyScrollable, 'height');
	        }

	        return this.viewportHeight;
	    }

	    sortColumn(colIndex, sortOrder) {
	        this.columnmanager.sortColumn(colIndex, sortOrder);
	    }

	    removeColumn(colIndex) {
	        this.columnmanager.removeColumn(colIndex);
	    }

	    scrollToLastColumn() {
	        this.datatableWrapper.scrollLeft = 9999;
	    }

	    freeze() {
	        $.style(this.freezeContainer, {
	            display: ''
	        });
	    }

	    unfreeze() {
	        $.style(this.freezeContainer, {
	            display: 'none'
	        });
	    }

	    updateOptions(options) {
	        this.buildOptions(options);
	    }

	    fireEvent(eventName) {
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        // fire internalEventHandlers if any
	        // and then user events
	        var handlers = (this._internalEventHandlers[eventName] || []).concat( [this.events[eventName]]
	        ).filter(Boolean);

	        for (var i = 0, list = handlers; i < list.length; i += 1) {
	            var handler = list[i];

	          handler.apply(this, args);
	        }
	    }

	    on(event, handler) {
	        this._internalEventHandlers = this._internalEventHandlers || {};
	        this._internalEventHandlers[event] = this._internalEventHandlers[event] || [];
	        this._internalEventHandlers[event].push(handler);
	    }

	    log() {
	        if (this.options.logs) {
	            console.log.apply(console, arguments);
	        }
	    }
	}

	DataTable.instances = 0;

	var name = "frappe-datatable";
	var version = "0.0.0-development";
	var description = "A modern datatable library for the web";
	var main = "dist/frappe-datatable.cjs.js";
	var unpkg = "dist/frappe-datatable.min.js";
	var jsdelivr = "dist/frappe-datatable.min.js";
	var scripts = {"start":"yarn run dev","build":"rollup -c && NODE_ENV=production rollup -c","dev":"rollup -c -w","cy:server":"http-server -p 8989","cy:open":"cypress open","cy:run":"cypress run","test":"start-server-and-test cy:server http://localhost:8989 cy:run","test-local":"start-server-and-test cy:server http://localhost:8989 cy:open","travis-deploy-once":"travis-deploy-once","semantic-release":"semantic-release","lint":"eslint src","commit":"npx git-cz"};
	var files = ["dist","src"];
	var devDependencies = {"autoprefixer":"^9.0.0","chai":"3.5.0","cypress":"3.0.1","cz-conventional-changelog":"^2.1.0","deepmerge":"^2.0.1","eslint":"^5.0.1","eslint-config-airbnb":"^16.1.0","eslint-config-airbnb-base":"^12.1.0","eslint-plugin-import":"^2.11.0","http-server":"^0.11.1","mocha":"3.3.0","postcss-custom-properties":"^7.0.0","postcss-nested":"^3.0.0","rollup":"^0.59.4","rollup-plugin-commonjs":"^8.3.0","rollup-plugin-eslint":"^4.0.0","rollup-plugin-json":"^2.3.0","rollup-plugin-node-resolve":"^3.0.3","rollup-plugin-postcss":"^1.2.8","rollup-plugin-uglify-es":"^0.0.1","semantic-release":"^17.1.1","start-server-and-test":"^1.4.1","travis-deploy-once":"^5.0.1"};
	var repository = {"type":"git","url":"https://github.com/frappe/datatable.git"};
	var keywords = ["datatable","data","grid","table"];
	var author = "Faris Ansari";
	var license = "MIT";
	var bugs = {"url":"https://github.com/frappe/datatable/issues"};
	var homepage = "https://frappe.github.io/datatable";
	var dependencies = {"hyperlist":"^1.0.0-beta","lodash":"^4.17.5","sortablejs":"^1.7.0"};
	var config = {"commitizen":{"path":"cz-conventional-changelog"}};
	var packageJson = {
		name: name,
		version: version,
		description: description,
		main: main,
		unpkg: unpkg,
		jsdelivr: jsdelivr,
		scripts: scripts,
		files: files,
		devDependencies: devDependencies,
		repository: repository,
		keywords: keywords,
		author: author,
		license: license,
		bugs: bugs,
		homepage: homepage,
		dependencies: dependencies,
		config: config
	};

	DataTable.__version__ = packageJson.version;

	module.exports = DataTable;
	});

	var DataTable = unwrapExports(frappeDatatable_cjs);

	frappe.DataTable = DataTable;

	var driver_min = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e();}(window,function(){return function(t){var e={};function n(o){if(e[o]){ return e[o].exports; }var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o});},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e){ return t; }if(4&e&&"object"==typeof t&&t&&t.__esModule){ return t; }var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t){ for(var i in t){ n.d(o,i,function(e){return t[e]}.bind(null,i)); } }return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="/dist/",n(n.s=57)}([function(t,e,n){var o=n(2),i=n(11),r=n(4),s=n(13),a=n(22),c=function(t,e,n){var u,l,h,f,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,g=t&c.B,m=d?o:v?o[e]||(o[e]={}):(o[e]||{}).prototype,b=d?i:i[e]||(i[e]={}),w=b.prototype||(b.prototype={});for(u in d&&(n=e),n){ h=((l=!p&&m&&void 0!==m[u])?m:n)[u],f=g&&l?a(h,o):y&&"function"==typeof h?a(Function.call,h):h,m&&s(m,u,h,t&c.U),b[u]!=h&&r(b,u,f),y&&w[u]!=h&&(w[u]=h); }};o.core=i,c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c;},function(t,e,n){var o=n(17)("wks"),i=n(14),r=n(2).Symbol,s="function"==typeof r;(t.exports=function(t){return o[t]||(o[t]=s&&r[t]||(s?r:i)("Symbol."+t))}).store=o;},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n);},function(t,e){t.exports=function(t){return "object"==typeof t?null!==t:"function"==typeof t};},function(t,e,n){var o=n(5),i=n(16);t.exports=n(6)?function(t,e,n){return o.f(t,e,i(1,n))}:function(t,e,n){return t[e]=n,t};},function(t,e,n){var o=n(12),i=n(35),r=n(21),s=Object.defineProperty;e.f=n(6)?Object.defineProperty:function(t,e,n){if(o(t),e=r(e,!0),o(n),i){ try{return s(t,e,n)}catch(t){} }if("get"in n||"set"in n){ throw TypeError("Accessors not supported!"); }return "value"in n&&(t[e]=n.value),t};},function(t,e,n){t.exports=!n(7)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a});},function(t,e){t.exports=function(t){try{return !!t()}catch(t){return !0}};},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)};},function(t,e,n){var o=n(39),i=n(24);t.exports=function(t){return o(i(t))};},function(t,e,n){var o=n(0);o(o.S+o.F*!n(6),"Object",{defineProperty:n(5).f});},function(t,e){var n=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=n);},function(t,e,n){var o=n(3);t.exports=function(t){if(!o(t)){ throw TypeError(t+" is not an object!"); }return t};},function(t,e,n){var o=n(2),i=n(4),r=n(8),s=n(14)("src"),a=n(59),c=(""+a).split("toString");n(11).inspectSource=function(t){return a.call(t)},(t.exports=function(t,e,n,a){var u="function"==typeof n;u&&(r(n,"name")||i(n,"name",e)),t[e]!==n&&(u&&(r(n,s)||i(n,s,t[e]?""+t[e]:c.join(String(e)))),t===o?t[e]=n:a?t[e]?t[e]=n:i(t,e,n):(delete t[e],i(t,e,n)));})(Function.prototype,"toString",function(){return "function"==typeof this&&this[s]||a.call(this)});},function(t,e){var n=0,o=Math.random();t.exports=function(t){return "Symbol(".concat(void 0===t?"":t,")_",(++n+o).toString(36))};},function(t,e,n){var o=n(45),i=n(28);t.exports=Object.keys||function(t){return o(t,i)};},function(t,e){t.exports=function(t,e){return {enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}};},function(t,e,n){var o=n(11),i=n(2),r=i["__core-js_shared__"]||(i["__core-js_shared__"]={});(t.exports=function(t,e){return r[t]||(r[t]=void 0!==e?e:{})})("versions",[]).push({version:o.version,mode:n(18)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"});},function(t,e){t.exports=!1;},function(t,e,n){var o=n(24);t.exports=function(t){return Object(o(t))};},function(t,e,n){var o=n(2),i=n(8),r=n(6),s=n(0),a=n(13),c=n(62).KEY,u=n(7),l=n(17),h=n(26),f=n(14),p=n(1),d=n(43),v=n(44),y=n(63),g=n(42),m=n(12),b=n(3),w=n(19),x=n(9),S=n(21),O=n(16),k=n(30),P=n(67),E=n(49),N=n(47),j=n(5),L=n(15),T=E.f,C=j.f,_=P.f,M=o.Symbol,H=o.JSON,B=H&&H.stringify,F=p("_hidden"),I=p("toPrimitive"),R={}.propertyIsEnumerable,A=l("symbol-registry"),z=l("symbols"),D=l("op-symbols"),V=Object.prototype,W="function"==typeof M&&!!N.f,q=o.QObject,G=!q||!q.prototype||!q.prototype.findChild,K=r&&u(function(){return 7!=k(C({},"a",{get:function(){return C(this,"a",{value:7}).a}})).a})?function(t,e,n){var o=T(V,e);o&&delete V[e],C(t,e,n),o&&t!==V&&C(V,e,o);}:C,U=function(t){var e=z[t]=k(M.prototype);return e._k=t,e},Y=W&&"symbol"==typeof M.iterator?function(t){return "symbol"==typeof t}:function(t){return t instanceof M},J=function(t,e,n){return t===V&&J(D,e,n),m(t),e=S(e,!0),m(n),i(z,e)?(n.enumerable?(i(t,F)&&t[F][e]&&(t[F][e]=!1),n=k(n,{enumerable:O(0,!1)})):(i(t,F)||C(t,F,O(1,{})),t[F][e]=!0),K(t,e,n)):C(t,e,n)},X=function(t,e){m(t);for(var n,o=y(e=x(e)),i=0,r=o.length;r>i;){ J(t,n=o[i++],e[n]); }return t},Q=function(t){var e=R.call(this,t=S(t,!0));return !(this===V&&i(z,t)&&!i(D,t))&&(!(e||!i(this,t)||!i(z,t)||i(this,F)&&this[F][t])||e)},$=function(t,e){if(t=x(t),e=S(e,!0),t!==V||!i(z,e)||i(D,e)){var n=T(t,e);return !n||!i(z,e)||i(t,F)&&t[F][e]||(n.enumerable=!0),n}},Z=function(t){for(var e,n=_(x(t)),o=[],r=0;n.length>r;){ i(z,e=n[r++])||e==F||e==c||o.push(e); }return o},tt=function(t){for(var e,n=t===V,o=_(n?D:x(t)),r=[],s=0;o.length>s;){ !i(z,e=o[s++])||n&&!i(V,e)||r.push(z[e]); }return r};W||(a((M=function(){if(this instanceof M){ throw TypeError("Symbol is not a constructor!"); }var t=f(arguments.length>0?arguments[0]:void 0),e=function(n){this===V&&e.call(D,n),i(this,F)&&i(this[F],t)&&(this[F][t]=!1),K(this,t,O(1,n));};return r&&G&&K(V,t,{configurable:!0,set:e}),U(t)}).prototype,"toString",function(){return this._k}),E.f=$,j.f=J,n(48).f=P.f=Z,n(29).f=Q,N.f=tt,r&&!n(18)&&a(V,"propertyIsEnumerable",Q,!0),d.f=function(t){return U(p(t))}),s(s.G+s.W+s.F*!W,{Symbol:M});for(var et="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),nt=0;et.length>nt;){ p(et[nt++]); }for(var ot=L(p.store),it=0;ot.length>it;){ v(ot[it++]); }s(s.S+s.F*!W,"Symbol",{for:function(t){return i(A,t+="")?A[t]:A[t]=M(t)},keyFor:function(t){if(!Y(t)){ throw TypeError(t+" is not a symbol!"); }for(var e in A){ if(A[e]===t){ return e } }},useSetter:function(){G=!0;},useSimple:function(){G=!1;}}),s(s.S+s.F*!W,"Object",{create:function(t,e){return void 0===e?k(t):X(k(t),e)},defineProperty:J,defineProperties:X,getOwnPropertyDescriptor:$,getOwnPropertyNames:Z,getOwnPropertySymbols:tt});var rt=u(function(){N.f(1);});s(s.S+s.F*rt,"Object",{getOwnPropertySymbols:function(t){return N.f(w(t))}}),H&&s(s.S+s.F*(!W||u(function(){var t=M();return "[null]"!=B([t])||"{}"!=B({a:t})||"{}"!=B(Object(t))})),"JSON",{stringify:function(t){
	var arguments$1 = arguments;
	for(var e,n,o=[t],i=1;arguments.length>i;){ o.push(arguments$1[i++]); }if(n=e=o[1],(b(e)||void 0!==t)&&!Y(t)){ return g(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!Y(e)){ return e }}),o[1]=e,B.apply(H,o) }}}),M.prototype[I]||n(4)(M.prototype,I,M.prototype.valueOf),h(M,"Symbol"),h(Math,"Math",!0),h(o.JSON,"JSON",!0);},function(t,e,n){var o=n(3);t.exports=function(t,e){if(!o(t)){ return t; }var n,i;if(e&&"function"==typeof(n=t.toString)&&!o(i=n.call(t))){ return i; }if("function"==typeof(n=t.valueOf)&&!o(i=n.call(t))){ return i; }if(!e&&"function"==typeof(n=t.toString)&&!o(i=n.call(t))){ return i; }throw TypeError("Can't convert object to primitive value")};},function(t,e,n){var o=n(37);t.exports=function(t,e,n){if(o(t),void 0===e){ return t; }switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,o){return t.call(e,n,o)};case 3:return function(n,o,i){return t.call(e,n,o,i)}}return function(){return t.apply(e,arguments)}};},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)};},function(t,e){t.exports=function(t){if(null==t){ throw TypeError("Can't call method on  "+t); }return t};},function(t,e,n){var o=n(7);t.exports=function(t,e){return !!t&&o(function(){e?t.call(null,function(){},1):t.call(null);})};},function(t,e,n){var o=n(5).f,i=n(8),r=n(1)("toStringTag");t.exports=function(t,e,n){t&&!i(t=n?t:t.prototype,r)&&o(t,r,{configurable:!0,value:e});};},function(t,e,n){var o=n(17)("keys"),i=n(14);t.exports=function(t){return o[t]||(o[t]=i(t))};},function(t,e){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");},function(t,e){e.f={}.propertyIsEnumerable;},function(t,e,n){var o=n(12),i=n(65),r=n(28),s=n(27)("IE_PROTO"),a=function(){},c=function(){var t,e=n(36)("iframe"),o=r.length;for(e.style.display="none",n(66).appendChild(e),e.src="javascript:",(t=e.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),c=t.F;o--;){ delete c.prototype[r[o]]; }return c()};t.exports=Object.create||function(t,e){var n;return null!==t?(a.prototype=o(t),n=new a,a.prototype=null,n[s]=t):n=c(),void 0===e?n:i(n,e)};},function(t,e,n){var o=n(68),i=n(69),r=n(32),s=n(9);t.exports=n(70)(Array,"Array",function(t,e){this._t=s(t),this._i=0,this._k=e;},function(){var t=this._t,e=this._k,n=this._i++;return !t||n>=t.length?(this._t=void 0,i(1)):i(0,"keys"==e?n:"values"==e?t[n]:[n,t[n]])},"values"),r.Arguments=r.Array,o("keys"),o("values"),o("entries");},function(t,e){t.exports={};},function(t,e,n){n(44)("asyncIterator");},function(t,e,n){var o=n(0),i=n(38)(0),r=n(25)([].forEach,!0);o(o.P+o.F*!r,"Array",{forEach:function(t){return i(this,t,arguments[1])}});},function(t,e,n){t.exports=!n(6)&&!n(7)(function(){return 7!=Object.defineProperty(n(36)("div"),"a",{get:function(){return 7}}).a});},function(t,e,n){var o=n(3),i=n(2).document,r=o(i)&&o(i.createElement);t.exports=function(t){return r?i.createElement(t):{}};},function(t,e){t.exports=function(t){if("function"!=typeof t){ throw TypeError(t+" is not a function!"); }return t};},function(t,e,n){var o=n(22),i=n(39),r=n(19),s=n(40),a=n(60);t.exports=function(t,e){var n=1==t,c=2==t,u=3==t,l=4==t,h=6==t,f=5==t||h,p=e||a;return function(e,a,d){for(var v,y,g=r(e),m=i(g),b=o(a,d,3),w=s(m.length),x=0,S=n?p(e,w):c?p(e,0):void 0;w>x;x++){ if((f||x in m)&&(y=b(v=m[x],x,g),t)){ if(n){ S[x]=y; }else if(y){ switch(t){case 3:return !0;case 5:return v;case 6:return x;case 2:S.push(v);} }else if(l){ return !1; } } }return h?-1:u||l?l:S}};},function(t,e,n){var o=n(23);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return "String"==o(t)?t.split(""):Object(t)};},function(t,e,n){var o=n(41),i=Math.min;t.exports=function(t){return t>0?i(o(t),9007199254740991):0};},function(t,e){var n=Math.ceil,o=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?o:n)(t)};},function(t,e,n){var o=n(23);t.exports=Array.isArray||function(t){return "Array"==o(t)};},function(t,e,n){e.f=n(1);},function(t,e,n){var o=n(2),i=n(11),r=n(18),s=n(43),a=n(5).f;t.exports=function(t){var e=i.Symbol||(i.Symbol=r?{}:o.Symbol||{});"_"==t.charAt(0)||t in e||a(e,t,{value:s.f(t)});};},function(t,e,n){var o=n(8),i=n(9),r=n(46)(!1),s=n(27)("IE_PROTO");t.exports=function(t,e){var n,a=i(t),c=0,u=[];for(n in a){ n!=s&&o(a,n)&&u.push(n); }for(;e.length>c;){ o(a,n=e[c++])&&(~r(u,n)||u.push(n)); }return u};},function(t,e,n){var o=n(9),i=n(40),r=n(64);t.exports=function(t){return function(e,n,s){var a,c=o(e),u=i(c.length),l=r(s,u);if(t&&n!=n){for(;u>l;){ if((a=c[l++])!=a){ return !0 } }}else { for(;u>l;l++){ if((t||l in c)&&c[l]===n){ return t||l||0; } } }return !t&&-1}};},function(t,e){e.f=Object.getOwnPropertySymbols;},function(t,e,n){var o=n(45),i=n(28).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return o(t,i)};},function(t,e,n){var o=n(29),i=n(16),r=n(9),s=n(21),a=n(8),c=n(35),u=Object.getOwnPropertyDescriptor;e.f=n(6)?u:function(t,e){if(t=r(t),e=s(e,!0),c){ try{return u(t,e)}catch(t){} }if(a(t,e)){ return i(!o.f.call(t,e),t[e]) }};},function(t,e,n){for(var o=n(31),i=n(15),r=n(13),s=n(2),a=n(4),c=n(32),u=n(1),l=u("iterator"),h=u("toStringTag"),f=c.Array,p={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},d=i(p),v=0;v<d.length;v++){var y,g=d[v],m=p[g],b=s[g],w=b&&b.prototype;if(w&&(w[l]||a(w,l,f),w[h]||a(w,h,g),c[g]=f,m)){ for(y in o){ w[y]||r(w,y,o[y],!0); } }}},function(t,e,n){var o=n(73),i={};i[n(1)("toStringTag")]="z",i+""!="[object z]"&&n(13)(Object.prototype,"toString",function(){return "[object "+o(this)+"]"},!0);},function(t,e,n){var o=n(19),i=n(15);n(74)("keys",function(){return function(t){return i(o(t))}});},function(t,e,n){var o=n(0),i=n(38)(2);o(o.P+o.F*!n(25)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}});},function(t,e,n){var o=n(0);o(o.P,"Function",{bind:n(75)});},function(t,e,n){var o=n(0);o(o.S,"Object",{create:n(30)});},function(t,e,n){var o=n(0);o(o.S,"Object",{setPrototypeOf:n(81).set});},function(t,e,n){n(58),t.exports=n(82);},function(t,e){},function(t,e,n){t.exports=n(17)("native-function-to-string",Function.toString);},function(t,e,n){var o=n(61);t.exports=function(t,e){return new(o(t))(e)};},function(t,e,n){var o=n(3),i=n(42),r=n(1)("species");t.exports=function(t){var e;return i(t)&&("function"!=typeof(e=t.constructor)||e!==Array&&!i(e.prototype)||(e=void 0),o(e)&&null===(e=e[r])&&(e=void 0)),void 0===e?Array:e};},function(t,e,n){var o=n(14)("meta"),i=n(3),r=n(8),s=n(5).f,a=0,c=Object.isExtensible||function(){return !0},u=!n(7)(function(){return c(Object.preventExtensions({}))}),l=function(t){s(t,o,{value:{i:"O"+ ++a,w:{}}});},h=t.exports={KEY:o,NEED:!1,fastKey:function(t,e){if(!i(t)){ return "symbol"==typeof t?t:("string"==typeof t?"S":"P")+t; }if(!r(t,o)){if(!c(t)){ return "F"; }if(!e){ return "E"; }l(t);}return t[o].i},getWeak:function(t,e){if(!r(t,o)){if(!c(t)){ return !0; }if(!e){ return !1; }l(t);}return t[o].w},onFreeze:function(t){return u&&h.NEED&&c(t)&&!r(t,o)&&l(t),t}};},function(t,e,n){var o=n(15),i=n(47),r=n(29);t.exports=function(t){var e=o(t),n=i.f;if(n){ for(var s,a=n(t),c=r.f,u=0;a.length>u;){ c.call(t,s=a[u++])&&e.push(s); } }return e};},function(t,e,n){var o=n(41),i=Math.max,r=Math.min;t.exports=function(t,e){return (t=o(t))<0?i(t+e,0):r(t,e)};},function(t,e,n){var o=n(5),i=n(12),r=n(15);t.exports=n(6)?Object.defineProperties:function(t,e){i(t);for(var n,s=r(e),a=s.length,c=0;a>c;){ o.f(t,n=s[c++],e[n]); }return t};},function(t,e,n){var o=n(2).document;t.exports=o&&o.documentElement;},function(t,e,n){var o=n(9),i=n(48).f,r={}.toString,s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return s&&"[object Window]"==r.call(t)?function(t){try{return i(t)}catch(t){return s.slice()}}(t):i(o(t))};},function(t,e,n){var o=n(1)("unscopables"),i=Array.prototype;null==i[o]&&n(4)(i,o,{}),t.exports=function(t){i[o][t]=!0;};},function(t,e){t.exports=function(t,e){return {value:e,done:!!t}};},function(t,e,n){var o=n(18),i=n(0),r=n(13),s=n(4),a=n(32),c=n(71),u=n(26),l=n(72),h=n(1)("iterator"),f=!([].keys&&"next"in[].keys()),p=function(){return this};t.exports=function(t,e,n,d,v,y,g){c(n,e,d);var m,b,w,x=function(t){if(!f&&t in P){ return P[t]; }switch(t){case"keys":case"values":return function(){return new n(this,t)}}return function(){return new n(this,t)}},S=e+" Iterator",O="values"==v,k=!1,P=t.prototype,E=P[h]||P["@@iterator"]||v&&P[v],N=E||x(v),j=v?O?x("entries"):N:void 0,L="Array"==e&&P.entries||E;if(L&&(w=l(L.call(new t)))!==Object.prototype&&w.next&&(u(w,S,!0),o||"function"==typeof w[h]||s(w,h,p)),O&&E&&"values"!==E.name&&(k=!0,N=function(){return E.call(this)}),o&&!g||!f&&!k&&P[h]||s(P,h,N),a[e]=N,a[S]=p,v){ if(m={values:O?N:x("values"),keys:y?N:x("keys"),entries:j},g){ for(b in m){ b in P||r(P,b,m[b]); } }else { i(i.P+i.F*(f||k),e,m); } }return m};},function(t,e,n){var o=n(30),i=n(16),r=n(26),s={};n(4)(s,n(1)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=o(s,{next:i(1,n)}),r(t,e+" Iterator");};},function(t,e,n){var o=n(8),i=n(19),r=n(27)("IE_PROTO"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),o(t,r)?t[r]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null};},function(t,e,n){var o=n(23),i=n(1)("toStringTag"),r="Arguments"==o(function(){return arguments}());t.exports=function(t){var e,n,s;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),i))?n:r?o(e):"Object"==(s=o(e))&&"function"==typeof e.callee?"Arguments":s};},function(t,e,n){var o=n(0),i=n(11),r=n(7);t.exports=function(t,e){var n=(i.Object||{})[t]||Object[t],s={};s[t]=e(n),o(o.S+o.F*r(function(){n(1);}),"Object",s);};},function(t,e,n){var o=n(37),i=n(3),r=n(76),s=[].slice,a={};t.exports=Function.bind||function(t){var e=o(this),n=s.call(arguments,1),c=function(){var o=n.concat(s.call(arguments));return this instanceof c?function(t,e,n){if(!(e in a)){for(var o=[],i=0;i<e;i++){ o[i]="a["+i+"]"; }a[e]=Function("F,a","return new F("+o.join(",")+")");}return a[e](t,n)}(e,o.length,o):r(e,o,t)};return i(e.prototype)&&(c.prototype=e.prototype),c};},function(t,e){t.exports=function(t,e,n){var o=void 0===n;switch(e.length){case 0:return o?t():t.call(n);case 1:return o?t(e[0]):t.call(n,e[0]);case 2:return o?t(e[0],e[1]):t.call(n,e[0],e[1]);case 3:return o?t(e[0],e[1],e[2]):t.call(n,e[0],e[1],e[2]);case 4:return o?t(e[0],e[1],e[2],e[3]):t.call(n,e[0],e[1],e[2],e[3])}return t.apply(n,e)};},function(t,e,n){n(78)("trim",function(t){return function(){return t(this,3)}});},function(t,e,n){var o=n(0),i=n(24),r=n(7),s=n(79),a="["+s+"]",c=RegExp("^"+a+a+"*"),u=RegExp(a+a+"*$"),l=function(t,e,n){var i={},a=r(function(){return !!s[t]()||"​"!="​"[t]()}),c=i[t]=a?e(h):s[t];n&&(i[n]=c),o(o.P+o.F*a,"String",i);},h=l.trim=function(t,e){return t=String(i(t)),1&e&&(t=t.replace(c,"")),2&e&&(t=t.replace(u,"")),t};t.exports=l;},function(t,e){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff";},function(t,e,n){var o=n(0),i=n(46)(!1),r=[].indexOf,s=!!r&&1/[1].indexOf(1,-0)<0;o(o.P+o.F*(s||!n(25)(r)),"Array",{indexOf:function(t){return s?r.apply(this,arguments)||0:i(this,t,arguments[1])}});},function(t,e,n){var o=n(3),i=n(12),r=function(t,e){if(i(t),!o(e)&&null!==e){ throw TypeError(e+": can't set as prototype!") }};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,e,o){try{(o=n(22)(Function.call,n(49).f(Object.prototype,"__proto__").set,2))(t,[]),e=!(t instanceof Array);}catch(t){e=!0;}return function(t,n){return r(t,n),e?t.__proto__=n:o(t,n),t}}({},!1):void 0),check:r};},function(t,e,n){n.r(e);n(34),n(20),n(50),n(31),n(51),n(52),n(10),n(53),n(54);var o=.75,i=10,r=!0,s=!0,a=!0,c=!1,u="driver-highlighted-element-stage",l='<div id="'.concat("driver-page-overlay",'"></div>'),h='<div id="'.concat(u,'"></div>');n(33),n(77);function f(t){return (f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var p=function(t){var e=document.createElement("div");return e.innerHTML=t.trim(),e.firstChild},d=function t(e,n){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2]){for(var o=["","-webkit-","-ms-","moz-","-o-"],i=0;i<o.length;i++){var r=t(e,o[i]+n);if(r){ return r }}return ""}var s="";return e.currentStyle?s=e.currentStyle[n]:document.defaultView&&document.defaultView.getComputedStyle&&(s=document.defaultView.getComputedStyle(e,null).getPropertyValue(n)),s&&s.toLowerCase?s.toLowerCase():s},v=function(t){return t&&"object"===f(t)&&"nodeType"in t};function y(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}var g=function(){function t(e,n,o){!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.options=e,this.highlightedElement=null,this.lastHighlightedElement=null,this.hideTimer=null,this.window=n,this.document=o,this.removeNode=this.removeNode.bind(this);}var e,n;return e=t,(n=[{key:"attachNode",value:function(){var t=this.document.getElementById("driver-page-overlay");t||(t=p(l),document.body.appendChild(t)),this.node=t,this.node.style.opacity="0",this.options.animate||this.node.parentElement&&this.node.parentElement.removeChild(this.node);}},{key:"highlight",value:function(t){t&&t.node?t.isSame(this.highlightedElement)||(this.window.clearTimeout(this.hideTimer),t.onHighlightStarted(),this.highlightedElement&&!this.highlightedElement.isSame(this.lastHighlightedElement)&&this.highlightedElement.onDeselected(),t.getCalculatedPosition().canHighlight()&&(this.lastHighlightedElement=this.highlightedElement,this.highlightedElement=t,this.show(),this.highlightedElement.onHighlighted())):console.warn("Invalid element to highlight. Must be an instance of `Element`");}},{key:"show",value:function(){var t=this;this.node&&this.node.parentElement||(this.attachNode(),window.setTimeout(function(){t.node.style.opacity="".concat(t.options.opacity),t.node.style.position="fixed",t.node.style.left="0",t.node.style.top="0",t.node.style.bottom="0",t.node.style.right="0";}));}},{key:"getHighlightedElement",value:function(){return this.highlightedElement}},{key:"getLastHighlightedElement",value:function(){return this.lastHighlightedElement}},{key:"clear",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.options.onReset&&this.options.onReset(this.highlightedElement),this.highlightedElement){this.highlightedElement.onDeselected(!0);}this.highlightedElement=null,this.lastHighlightedElement=null,this.node&&(this.window.clearTimeout(this.hideTimer),this.options.animate&&!t?(this.node.style.opacity="0",this.hideTimer=this.window.setTimeout(this.removeNode,300)):this.removeNode());}},{key:"removeNode",value:function(){this.node&&this.node.parentElement&&this.node.parentElement.removeChild(this.node);}},{key:"refresh",value:function(){this.highlightedElement&&(this.highlightedElement.showPopover(),this.highlightedElement.showStage());}}])&&y(e.prototype,n),t}();n(80);function m(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}var b=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.left,o=void 0===n?0:n,i=e.top,r=void 0===i?0:i,s=e.right,a=void 0===s?0:s,c=e.bottom,u=void 0===c?0:c;!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.left=o,this.right=a,this.top=r,this.bottom=u;}var e,n;return e=t,(n=[{key:"canHighlight",value:function(){return this.left<this.right&&this.top<this.bottom}}])&&m(e.prototype,n),t}();function w(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}var x=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.node,o=e.options,i=e.popover,r=e.stage,s=e.overlay,a=e.window,c=e.document;!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.node=n,this.document=c,this.window=a,this.options=o,this.overlay=s,this.popover=i,this.stage=r,this.animationTimeout=null;}var e,n;return e=t,(n=[{key:"isInView",value:function(){for(var t=this.node.offsetTop,e=this.node.offsetLeft,n=this.node.offsetWidth,o=this.node.offsetHeight,i=this.node;i.offsetParent;){ t+=(i=i.offsetParent).offsetTop,e+=i.offsetLeft; }return t>=this.window.pageYOffset&&e>=this.window.pageXOffset&&t+o<=this.window.pageYOffset+this.window.innerHeight&&e+n<=this.window.pageXOffset+this.window.innerWidth}},{key:"scrollManually",value:function(){var t=this.node.getBoundingClientRect().top+this.window.pageYOffset-this.window.innerHeight/2;this.window.scrollTo(0,t);}},{key:"bringInView",value:function(){if(this.node&&!this.isInView()){ if(this.node.scrollIntoView){ try{this.node.scrollIntoView(this.options.scrollIntoViewOptions||{behavior:"instant",block:"center"});}catch(t){this.scrollManually();} }else { this.scrollManually(); } }}},{key:"getCalculatedPosition",value:function(){var t=this.document.body,e=this.document.documentElement,n=this.window,o=this.window.pageYOffset||e.scrollTop||t.scrollTop,i=n.pageXOffset||e.scrollLeft||t.scrollLeft,r=this.node.getBoundingClientRect();return new b({top:r.top+o,left:r.left+i,right:r.left+i+r.width,bottom:r.top+o+r.height})}},{key:"getPopover",value:function(){return this.popover}},{key:"onDeselected",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.hidePopover(),t&&this.hideStage(),this.removeHighlightClasses(),this.window.clearTimeout(this.animationTimeout),this.options.onDeselected&&this.options.onDeselected(this);}},{key:"isSame",value:function(t){return !(!t||!t.node)&&t.node===this.node}},{key:"onHighlightStarted",value:function(){this.options.onHighlightStarted&&this.options.onHighlightStarted(this);}},{key:"onHighlighted",value:function(){this.isInView()||this.bringInView(),this.showPopover(),this.showStage(),this.addHighlightClasses(),this.options.onHighlighted&&this.options.onHighlighted(this);}},{key:"removeHighlightClasses",value:function(){this.node.classList.remove("driver-highlighted-element"),this.node.classList.remove("driver-position-relative");for(var t=this.document.querySelectorAll(".".concat("driver-fix-stacking")),e=0;e<t.length;e++){ t[e].classList.remove("driver-fix-stacking"); }}},{key:"addHighlightClasses",value:function(){this.node.classList.add("driver-highlighted-element"),this.canMakeRelative()&&this.node.classList.add("driver-position-relative"),this.fixStackingContext();}},{key:"fixStackingContext",value:function(){for(var t=this.node.parentNode;t&&t.tagName&&"body"!==t.tagName.toLowerCase();){var e=d(t,"z-index"),n=parseFloat(d(t,"opacity")),o=d(t,"transform",!0),i=d(t,"transform-style",!0),r=d(t,"transform-box",!0),s=d(t,"filter",!0),a=d(t,"perspective",!0);(/[0-9]+/.test(e)||n<1||o&&"none"!==o||i&&"flat"!==i||r&&"border-box"!==r||s&&"none"!==s||a&&"none"!==a)&&t.classList.add("driver-fix-stacking"),t=t.parentNode;}}},{key:"canMakeRelative",value:function(){var t=this.getStyleProperty("position");return -1===["absolute","fixed","relative"].indexOf(t)}},{key:"getStyleProperty",value:function(t){return d(this.node,t)}},{key:"showStage",value:function(){this.stage.show(this.getCalculatedPosition());}},{key:"getNode",value:function(){return this.node}},{key:"hideStage",value:function(){this.stage.hide();}},{key:"hidePopover",value:function(){this.popover&&this.popover.hide();}},{key:"showPopover",value:function(){var t=this;if(this.popover){var e=this.getCalculatedPosition(),n=300;this.options.animate&&this.overlay.lastHighlightedElement||(n=0),this.animationTimeout=this.window.setTimeout(function(){t.popover.show(e);},n);}}},{key:"getFullPageSize",value:function(){var t=this.document.body,e=this.document.documentElement;return {height:Math.max(t.scrollHeight,t.offsetHeight,e.scrollHeight,e.offsetHeight),width:Math.max(t.scrollWidth,t.offsetWidth,e.scrollWidth,e.offsetWidth)}}},{key:"getSize",value:function(){return {height:Math.max(this.node.scrollHeight,this.node.offsetHeight),width:Math.max(this.node.scrollWidth,this.node.offsetWidth)}}}])&&w(e.prototype,n),t}();n(55),n(56);function S(t){return (S="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function O(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function k(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}function P(t,e){return !e||"object"!==S(e)&&"function"!=typeof e?function(t){if(void 0===t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return t}(t):e}function E(t){return (E=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function N(t,e){return (N=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var j=function(t){function e(t,n,o){var i;return function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,e),(i=P(this,E(e).call(this))).options=function(t){
	var arguments$1 = arguments;
	for(var e=1;e<arguments.length;e++){var n=null!=arguments$1[e]?arguments$1[e]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),o.forEach(function(e){O(t,e,n[e]);});}return t}({isFirst:!0,isLast:!0,totalCount:1,currentIndex:0,offset:0,showButtons:!0,closeBtnText:"Close",doneBtnText:"Done",startBtnText:"Next &rarr;",nextBtnText:"Next &rarr;",prevBtnText:"&larr; Previous"},t),i.window=n,i.document=o,i}var n,o;return function(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function"); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&N(t,e);}(e,x),n=e,(o=[{key:"attachNode",value:function(){var t=this.document.getElementById("driver-popover-item");t&&t.parentElement.removeChild(t),t=p(function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return '\n  <div id="'.concat("driver-popover-item",'" class="').concat(t,'">\n    <div class="').concat("driver-popover-tip",'"></div>\n    <div class="').concat("driver-popover-title",'">Popover Title</div>\n    <div class="').concat("driver-popover-description",'">Popover Description</div>\n    <div class="driver-clearfix ').concat("driver-popover-footer",'">\n      <button class="').concat("driver-close-btn",'">Close</button>\n      <span class="driver-btn-group ').concat("driver-navigation-btns",'">\n        <button class="').concat("driver-prev-btn",'">&larr; Previous</button>\n        <button class="').concat("driver-next-btn",'">Next &rarr;</button>\n      </span>\n    </div>\n  </div>')}(this.options.className)),document.body.appendChild(t),this.node=t,this.tipNode=t.querySelector(".".concat("driver-popover-tip")),this.titleNode=t.querySelector(".".concat("driver-popover-title")),this.descriptionNode=t.querySelector(".".concat("driver-popover-description")),this.footerNode=t.querySelector(".".concat("driver-popover-footer")),this.nextBtnNode=t.querySelector(".".concat("driver-next-btn")),this.prevBtnNode=t.querySelector(".".concat("driver-prev-btn")),this.closeBtnNode=t.querySelector(".".concat("driver-close-btn"));}},{key:"getTitleNode",value:function(){return this.titleNode}},{key:"getDescriptionNode",value:function(){return this.descriptionNode}},{key:"hide",value:function(){this.node&&(this.node.style.display="none");}},{key:"setInitialState",value:function(){this.node.style.display="block",this.node.style.left="0",this.node.style.top="0",this.node.style.bottom="",this.node.style.right="",this.node.querySelector(".".concat("driver-popover-tip")).className="driver-popover-tip";}},{key:"show",value:function(t){switch(this.attachNode(),this.setInitialState(),this.titleNode.innerHTML=this.options.title,this.descriptionNode.innerHTML=this.options.description||"",this.renderFooter(),this.options.position){case"left":case"left-top":this.positionOnLeft(t);break;case"left-center":this.positionOnLeftCenter(t);break;case"left-bottom":this.positionOnLeftBottom(t);break;case"right":case"right-top":this.positionOnRight(t);break;case"right-center":this.positionOnRightCenter(t);break;case"right-bottom":this.positionOnRightBottom(t);break;case"top":case"top-left":this.positionOnTop(t);break;case"top-center":this.positionOnTopCenter(t);break;case"top-right":this.positionOnTopRight(t);break;case"bottom":case"bottom-left":this.positionOnBottom(t);break;case"bottom-center":this.positionOnBottomCenter(t);break;case"bottom-right":this.positionOnBottomRight(t);break;case"mid-center":this.positionOnMidCenter(t);break;case"auto":default:this.autoPosition(t);}this.bringInView();}},{key:"renderFooter",value:function(){this.nextBtnNode.innerHTML=this.options.nextBtnText,this.prevBtnNode.innerHTML=this.options.prevBtnText,this.closeBtnNode.innerHTML=this.options.closeBtnText;var t=this.options.totalCount&&1!==this.options.totalCount;this.options.showButtons?(t?(this.nextBtnNode.style.display="inline-block",this.prevBtnNode.style.display="inline-block",this.closeBtnNode.classList.remove("driver-close-only-btn")):(this.nextBtnNode.style.display="none",this.prevBtnNode.style.display="none",this.closeBtnNode.classList.add("driver-close-only-btn")),this.footerNode.style.display="block",this.options.isFirst?(this.prevBtnNode.classList.add("driver-disabled"),this.nextBtnNode.innerHTML=this.options.startBtnText):this.prevBtnNode.classList.remove("driver-disabled"),this.options.isLast?this.nextBtnNode.innerHTML=this.options.doneBtnText:this.nextBtnNode.innerHTML=this.options.nextBtnText):this.footerNode.style.display="none";}},{key:"positionOnLeft",value:function(t){var e=this.getSize().width,n=this.options.padding+10;this.node.style.left="".concat(t.left-e-n,"px"),this.node.style.top="".concat(t.top+this.options.offset-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("right");}},{key:"positionOnLeftBottom",value:function(t){var e=this.getSize(),n=e.width,o=this.options.padding+10;this.node.style.left="".concat(t.left-n-o,"px"),this.node.style.top="".concat(t.bottom+this.options.padding+this.options.offset-e.height,"px"),this.node.style.bottom="",this.node.style.right="",this.tipNode.classList.add("right","position-bottom");}},{key:"positionOnLeftCenter",value:function(t){var e=this.getSize(),n=e.width,o=e.height/2,i=this.options.padding+10,r=(t.bottom-t.top)/2,s=t.top-o+r+this.options.offset;this.node.style.left="".concat(t.left-n-i,"px"),this.node.style.top="".concat(s,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("right","position-center");}},{key:"positionOnRight",value:function(t){var e=this.options.padding+10;this.node.style.left="".concat(t.right+e,"px"),this.node.style.top="".concat(t.top+this.options.offset-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("left");}},{key:"positionOnRightCenter",value:function(t){var e=this.getSize(),n=this.options.padding+10,o=e.height/2,i=(t.bottom-t.top)/2,r=t.top-o+i+this.options.offset;this.node.style.left="".concat(t.right+n,"px"),this.node.style.top="".concat(r,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("left","position-center");}},{key:"positionOnRightBottom",value:function(t){var e=this.options.padding+10,n=this.getSize();this.node.style.left="".concat(t.right+e,"px"),this.node.style.top="".concat(t.bottom+this.options.padding+this.options.offset-n.height,"px"),this.node.style.bottom="",this.node.style.right="",this.tipNode.classList.add("left","position-bottom");}},{key:"positionOnTop",value:function(t){var e=this.getSize().height,n=this.options.padding+10;this.node.style.top="".concat(t.top-e-n,"px"),this.node.style.left="".concat(t.left-this.options.padding+this.options.offset,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("bottom");}},{key:"positionOnTopCenter",value:function(t){var e=this.getSize(),n=e.height,o=e.width/2,i=this.options.padding+10,r=this.options.offset+t.left+(t.right-t.left)/2;this.node.style.top="".concat(t.top-n-i,"px"),this.node.style.left="".concat(r-o-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("bottom","position-center");}},{key:"positionOnTopRight",value:function(t){var e=this.getSize(),n=e.height,o=this.options.padding+10;this.node.style.top="".concat(t.top-n-o,"px"),this.node.style.left="".concat(t.right+this.options.padding+this.options.offset-e.width,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("bottom","position-right");}},{key:"positionOnBottom",value:function(t){var e=this.options.padding+10;this.node.style.top="".concat(t.bottom+e,"px"),this.node.style.left="".concat(t.left-this.options.padding+this.options.offset,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("top");}},{key:"positionOnBottomCenter",value:function(t){var e=this.getSize().width/2,n=this.options.padding+10,o=this.options.offset+t.left+(t.right-t.left)/2;this.node.style.top="".concat(t.bottom+n,"px"),this.node.style.left="".concat(o-e-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("top","position-center");}},{key:"positionOnBottomRight",value:function(t){var e=this.getSize(),n=this.options.padding+10;this.node.style.top="".concat(t.bottom+n,"px"),this.node.style.left="".concat(t.right+this.options.padding+this.options.offset-e.width,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("top","position-right");}},{key:"positionOnMidCenter",value:function(t){var e=this.getSize(),n=e.height,o=e.width/2,i=n/2,r=(t.bottom-t.top)/2,s=t.top-i+r+this.options.offset,a=this.options.offset+t.left+(t.right-t.left)/2;this.node.style.top="".concat(s,"px"),this.node.style.left="".concat(a-o-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("mid-center");}},{key:"autoPosition",value:function(t){var e=this.getFullPageSize(),n=this.getSize(),o=e.height,i=n.height,r=this.options.padding+10;t.bottom+i+r>=o?this.positionOnTop(t):this.positionOnBottom(t);}}])&&k(n.prototype,o),e}();function L(t){return (L="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function T(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}function C(t,e){return !e||"object"!==L(e)&&"function"!=typeof e?function(t){if(void 0===t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return t}(t):e}function _(t){return (_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function M(t,e){return (M=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var H=function(t){function e(t,n,o){var i;return function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,e),(i=C(this,_(e).call(this))).options=t,i.window=n,i.document=o,i}var n,o;return function(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function"); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&M(t,e);}(e,x),n=e,(o=[{key:"attachNode",value:function(){var t=this.document.getElementById(u);t||(t=p(h),document.body.appendChild(t)),this.node=t,this.options.animate?this.node.classList.remove("driver-stage-no-animation"):this.node.classList.add("driver-stage-no-animation");}},{key:"hide",value:function(){this.node&&this.node.parentElement&&this.node.parentElement.removeChild(this.node);}},{key:"setInitialStyle",value:function(){this.node.style.display="block",this.node.style.left="0",this.node.style.top="0",this.node.style.bottom="",this.node.style.right="";}},{key:"show",value:function(t){this.attachNode(),this.setInitialStyle();var e=2*this.options.padding,n=t.right-t.left+e,o=t.bottom-t.top+e;this.node.style.display="block",this.node.style.position="absolute",this.node.style.width="".concat(n,"px"),this.node.style.height="".concat(o,"px"),this.node.style.top="".concat(t.top-e/2,"px"),this.node.style.left="".concat(t.left-e/2,"px"),this.node.style.backgroundColor=this.options.stageBackground;}}])&&T(n.prototype,o),e}();function B(t){
	var arguments$1 = arguments;
	for(var e=1;e<arguments.length;e++){var n=null!=arguments$1[e]?arguments$1[e]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),o.forEach(function(e){F(t,e,n[e]);});}return t}function F(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function I(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}n.d(e,"default",function(){return R});var R=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.options=B({animate:r,opacity:o,padding:i,scrollIntoViewOptions:null,allowClose:s,keyboardControl:a,overlayClickNext:c,stageBackground:"#ffffff",onHighlightStarted:function(){return null},onHighlighted:function(){return null},onDeselected:function(){return null},onReset:function(){return null},onNext:function(){return null},onPrevious:function(){return null}},e),this.document=document,this.window=window,this.isActivated=!1,this.steps=[],this.currentStep=0,this.currentMovePrevented=!1,this.overlay=new g(this.options,window,document),this.onResize=this.onResize.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onClick=this.onClick.bind(this),this.moveNext=this.moveNext.bind(this),this.movePrevious=this.movePrevious.bind(this),this.preventMove=this.preventMove.bind(this),this.bind();}var e,n;return e=t,(n=[{key:"getSteps",value:function(){return this.steps}},{key:"setSteps",value:function(t){this.steps=t;}},{key:"bind",value:function(){this.window.addEventListener("resize",this.onResize,!1),this.window.addEventListener("keyup",this.onKeyUp,!1),"ontouchstart"in document.documentElement?this.window.addEventListener("touchstart",this.onClick,!1):this.window.addEventListener("click",this.onClick,!1);}},{key:"onClick",value:function(t){if(this.isActivated&&this.hasHighlightedElement()){t.stopPropagation();var e=this.overlay.getHighlightedElement(),n=this.document.getElementById("driver-popover-item"),o=e.node.contains(t.target),i=n&&n.contains(t.target);if(o||i||!this.options.overlayClickNext){ if(o||i||!this.options.allowClose){var r=t.target.classList.contains("driver-next-btn"),s=t.target.classList.contains("driver-prev-btn");t.target.classList.contains("driver-close-btn")?this.reset():r?this.handleNext():s&&this.handlePrevious();}else { this.reset(); } }else { this.handleNext(); }}}},{key:"onResize",value:function(){this.isActivated&&this.refresh();}},{key:"refresh",value:function(){this.overlay.refresh();}},{key:"onKeyUp",value:function(t){if(this.isActivated&&this.options.keyboardControl){ if(27!==t.keyCode){var e=this.getHighlightedElement();e&&e.popover&&(39===t.keyCode?this.handleNext():37===t.keyCode&&this.handlePrevious());}else { this.reset(); } }}},{key:"movePrevious",value:function(){var t=this.steps[this.currentStep-1];t?(this.overlay.highlight(t),this.currentStep-=1):this.reset();}},{key:"preventMove",value:function(){this.currentMovePrevented=!0;}},{key:"handleNext",value:function(){this.currentMovePrevented=!1;var t=this.steps[this.currentStep];t&&t.options&&t.options.onNext&&t.options.onNext(this.overlay.highlightedElement),this.currentMovePrevented||this.moveNext();}},{key:"handlePrevious",value:function(){this.currentMovePrevented=!1;var t=this.steps[this.currentStep];t&&t.options&&t.options.onPrevious&&t.options.onPrevious(this.overlay.highlightedElement),this.currentMovePrevented||this.movePrevious();}},{key:"moveNext",value:function(){var t=this.steps[this.currentStep+1];t?(this.overlay.highlight(t),this.currentStep+=1):this.reset();}},{key:"hasNextStep",value:function(){return !!this.steps[this.currentStep+1]}},{key:"hasPreviousStep",value:function(){return !!this.steps[this.currentStep-1]}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.currentStep=0,this.isActivated=!1,this.overlay.clear(t);}},{key:"hasHighlightedElement",value:function(){var t=this.overlay.getHighlightedElement();return t&&t.node}},{key:"getHighlightedElement",value:function(){return this.overlay.getHighlightedElement()}},{key:"getLastHighlightedElement",value:function(){return this.overlay.getLastHighlightedElement()}},{key:"defineSteps",value:function(t){this.steps=[];for(var e=0;e<t.length;e++){var n=this.prepareElementFromStep(t[e],t,e);n&&this.steps.push(n);}}},{key:"prepareElementFromStep",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=B({},this.options),i=t,r="string"!=typeof t&&!v(t);if(!t||r&&!t.element){ throw new Error("Element is required in step ".concat(n)); }r&&(i=t.element,o=B({},this.options,t));var s=v(i)?i:this.document.querySelector(i);if(!s){ return console.warn("Element to highlight ".concat(i," not found")),null; }var a=null;if(o.popover&&o.popover.title){var c=[this.options.className,o.popover.className].filter(function(t){return t}).join(" "),u=B({},o,o.popover,{className:c,totalCount:e.length,currentIndex:n,isFirst:0===n,isLast:0===e.length||n===e.length-1});a=new j(u,this.window,this.document);}var l=B({},o),h=new H(l,this.window,this.document);return new x({node:s,options:o,popover:a,stage:h,overlay:this.overlay,window:this.window,document:this.document})}},{key:"start",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!this.steps||0===this.steps.length){ throw new Error("There are no steps defined to iterate"); }this.isActivated=!0,this.currentStep=t,this.overlay.highlight(this.steps[t]);}},{key:"highlight",value:function(t){this.isActivated=!0;var e=this.prepareElementFromStep(t);e&&this.overlay.highlight(e);}}])&&I(e.prototype,n),t}();}]).default});

	});

	var Driver = unwrapExports(driver_min);
	var driver_min_1 = driver_min.Driver;

	frappe.Driver = Driver;

	typeof navigator === "object" && // Polyfill for creating CustomEvents on IE9/10/11
	// code pulled from:
	// https://github.com/d4tocchini/customevent-polyfill
	// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill
	(function () {
	  if (typeof window === 'undefined') {
	    return;
	  }

	  try {
	    var ce = new window.CustomEvent('test', {
	      cancelable: true
	    });
	    ce.preventDefault();

	    if (ce.defaultPrevented !== true) {
	      // IE has problems with .preventDefault() on custom events
	      // http://stackoverflow.com/questions/23349191
	      throw new Error('Could not prevent default');
	    }
	  } catch (e) {
	    var CustomEvent = function CustomEvent(event, params) {
	      var evt, origPrevent;
	      params = params || {};
	      params.bubbles = !!params.bubbles;
	      params.cancelable = !!params.cancelable;
	      evt = document.createEvent('CustomEvent');
	      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
	      origPrevent = evt.preventDefault;

	      evt.preventDefault = function () {
	        origPrevent.call(this);

	        try {
	          Object.defineProperty(this, 'defaultPrevented', {
	            get: function get() {
	              return true;
	            }
	          });
	        } catch (e) {
	          this.defaultPrevented = true;
	        }
	      };

	      return evt;
	    };

	    CustomEvent.prototype = window.Event.prototype;
	    window.CustomEvent = CustomEvent; // expose definition to window
	  }
	})();

	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1) ||
	  // eslint-disable-next-line no-new-func
	  Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f$1 = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f$1
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) { throw TypeError("Can't call method on " + it); }
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) { return input; }
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) { return val; }
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) { return val; }
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$1$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) { try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ } }
	  if (has(O, P)) { return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]); }
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1$1
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) { try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$1 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

	var shared = createCommonjsModule$1(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.6.5',
	  mode:  'global',
	  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$2 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$2();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule$1(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has(value, 'name')) { createNonEnumerableProperty(value, 'name', key); }
	    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	  }
	  if (O === global_1) {
	    if (simple) { O[key] = value; }
	    else { setGlobal(key, value); }
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) { O[key] = value; }
	  else { createNonEnumerableProperty(O, key, value); }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path = global_1;

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) { while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) { return true; }
	    // Array#indexOf ignores holes, Array#includes - not
	    } } else { for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) { return IS_INCLUDES || index || 0; }
	    } } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) { !has(hiddenKeys, key) && has(O, key) && result.push(key); }
	  // Don't enum bug & hidden keys
	  while (names.length > i) { if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  } }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) { defineProperty(target, key, getOwnPropertyDescriptor(source, key)); }
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) { for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else { targetProperty = target[key]; }
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) { continue; }
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  } }
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol.iterator == 'symbol';

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray$1 = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) { objectDefineProperty.f(O, key = keys[index++], Properties[key]); }
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) { delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]; }
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else { result = NullProtoObject(); }
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$5
	};

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) { WellKnownSymbolsStore[name] = Symbol$1[name]; }
	    else { WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name); }
	  } return WellKnownSymbolsStore[name];
	};

	var f$6 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$6
	};

	var defineProperty = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) { defineProperty(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  }); }
	};

	var defineProperty$1 = objectDefineProperty.f;



	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty$1(it, TO_STRING_TAG, { configurable: true, value: TAG });
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var SPECIES = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray$1(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray$1(C.prototype))) { C = undefined; }
	    else if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) { C = undefined; }
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) { if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) { target[index] = result; } // map
	        else if (result) { switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } } else if (IS_EVERY) { return false; }  // every
	      }
	    } }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6)
	};

	var $forEach = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(SYMBOL);
	var ObjectPrototype = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty$1({}, 'a', {
	    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
	  if (ObjectPrototypeDescriptor) { delete ObjectPrototype[P]; }
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
	    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;

	var wrap = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
	  setInternalState(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) { symbol.description = description; }
	  return symbol;
	};

	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype) { $defineProperty(ObjectPrototypeSymbols, P, Attributes); }
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) { nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {})); }
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) { O[HIDDEN][key] = false; }
	      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty$1(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) { $defineProperty(O, key, properties[key]); }
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) { return false; }
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) { return; }
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) { result.push(key); }
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) { throw TypeError('Symbol is not a constructor'); }
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype) { setter.call(ObjectPrototypeSymbols, value); }
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) { this[HIDDEN][tag] = false; }
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) { setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter }); }
	    return wrap(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) { return StringToSymbolRegistry[string]; }
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) { throw TypeError(sym + ' is not a symbol'); }
	    if (has(SymbolToStringRegistry, sym)) { return SymbolToStringRegistry[sym]; }
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var arguments$1 = arguments;

	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) { args.push(arguments$1[index++]); }
	      $replacer = replacer;
	      if (!isObject(replacer) && it === undefined || isSymbol(it)) { return; } // IE8 returns string on undefined
	      if (!isArray$1(replacer)) { replacer = function (key, value) {
	        if (typeof $replacer == 'function') { value = $replacer.call(this, key, value); }
	        if (!isSymbol(value)) { return value; }
	      }; }
	      args[1] = replacer;
	      return $stringify.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys[HIDDEN] = true;

	var defineProperty$2 = objectDefineProperty.f;


	var NativeSymbol = global_1.Symbol;

	if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
	  // Safari 12 bug
	  NativeSymbol().description !== undefined
	)) {
	  var EmptyStringDescriptionStore = {};
	  // wrap Symbol constructor for correct work with undefined description
	  var SymbolWrapper = function Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var result = this instanceof SymbolWrapper
	      ? new NativeSymbol(description)
	      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	      : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') { EmptyStringDescriptionStore[result] = true; }
	    return result;
	  };
	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
	  symbolPrototype.constructor = SymbolWrapper;

	  var symbolToString = symbolPrototype.toString;
	  var native = String(NativeSymbol('test')) == 'Symbol(test)';
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  defineProperty$2(symbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = isObject(this) ? this.valueOf() : this;
	      var string = symbolToString.call(symbol);
	      if (has(EmptyStringDescriptionStore, symbol)) { return ''; }
	      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });

	  _export({ global: true, forced: true }, {
	    Symbol: SymbolWrapper
	  });
	}

	// `Symbol.iterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var defineProperty$3 = Object.defineProperty;
	var cache = {};

	var thrower = function (it) { throw it; };

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) { return cache[METHOD_NAME]; }
	  if (!options) { options = {}; }
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;

	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) { return true; }
	    var O = { length: -1 };

	    if (ACCESSORS) { defineProperty$3(O, 1, { enumerable: true, get: thrower }); }
	    else { O[1] = 1; }

	    method.call(O, argument0, argument1);
	  });
	};

	var $forEach$1 = arrayIteration.forEach;



	var STRICT_METHOD = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	var arrayForEach = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var $indexOf = arrayIncludes.indexOf;



	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$1 = arrayMethodIsStrict('indexOf');
	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$1 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype[UNSCOPABLES][key] = true;
	};

	var iterators = {};

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype$1 = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) { return O[IE_PROTO$1]; }
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype$1 : null;
	};

	var ITERATOR = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) { BUGGY_SAFARI_ITERATORS = true; }
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) { IteratorPrototype = PrototypeOfArrayIteratorPrototype; }
	  }
	}

	if (IteratorPrototype == undefined) { IteratorPrototype = {}; }

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if ( !has(IteratorPrototype, ITERATOR)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) { setter.call(O, proto); }
	    else { O.__proto__ = proto; }
	    return O;
	  };
	}() : undefined);

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) { return defaultIterator; }
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) { return IterablePrototype[KIND]; }
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) { for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } } else { _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods); }
	  }

	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$1(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') { return { value: index, done: false }; }
	  if (kind == 'values') { return { value: target[index], done: false }; }
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var nativeJoin = [].join;

	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$2 = arrayMethodIsStrict('join', ',');

	// `Array.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.join
	_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$2 }, {
	  join: function join(separator) {
	    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) { objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value)); }
	  else { object[propertyKey] = value; }
	};

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process = global_1.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) { version = match[1]; }
	  }
	}

	var engineV8Version = version && +version;

	var SPECIES$1 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$1] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
	var USES_TO_LENGTH$2 = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

	var SPECIES$2 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$2 }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray$1(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray$1(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject(Constructor)) {
	        Constructor = Constructor[SPECIES$2];
	        if (Constructor === null) { Constructor = undefined; }
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) { if (k in O) { createProperty(result, n, O[k]); } }
	    result.length = n;
	    return result;
	  }
	});

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG$1] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	// `Object.prototype.toString` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
	}

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) { result += 'g'; }
	  if (that.ignoreCase) { result += 'i'; }
	  if (that.multiline) { result += 'm'; }
	  if (that.dotAll) { result += 's'; }
	  if (that.unicode) { result += 'u'; }
	  if (that.sticky) { result += 'y'; }
	  return result;
	};

	// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
	// so we use an intermediate function.
	function RE(s, f) {
	  return RegExp(s, f);
	}

	var UNSUPPORTED_Y = fails(function () {
	  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	  var re = RE('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	});

	var BROKEN_CARET = fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = RE('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});

	var regexpStickyHelpers = {
		UNSUPPORTED_Y: UNSUPPORTED_Y,
		BROKEN_CARET: BROKEN_CARET
	};

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	})();

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;
	    var sticky = UNSUPPORTED_Y$1 && re.sticky;
	    var flags = regexpFlags.call(re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = flags.replace('y', '');
	      if (flags.indexOf('g') === -1) {
	        flags += 'g';
	      }

	      strCopy = String(str).slice(re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) { lastIndex = re.lastIndex; }

	    match = nativeExec.call(sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = match.input.slice(charsAdded);
	        match[0] = match[0].slice(charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else { re.lastIndex = 0; }
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      nativeReplace.call(match[0], reCopy, function () {
	        var arguments$1 = arguments;

	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments$1[i] === undefined) { match[i] = undefined; }
	        }
	      });
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
	  exec: regexpExec
	});

	var TO_STRING = 'toString';
	var RegExpPrototype = RegExp.prototype;
	var nativeToString = RegExpPrototype[TO_STRING];

	var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
	// FF44- RegExp#toString has a wrong name
	var INCORRECT_NAME = nativeToString.name != TO_STRING;

	// `RegExp.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING, function toString() {
	    var R = anObject(this);
	    var p = String(R.source);
	    var rf = R.flags;
	    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
	    return '/' + p + '/' + f;
	  }, { unsafe: true });
	}

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$2 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) { return CONVERT_TO_STRING ? '' : undefined; }
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$2(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$2(true)
	};

	var charAt = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState$2 = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$2(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$2(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) { return { value: undefined, done: true }; }
	  point = charAt(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points







	var SPECIES$3 = wellKnownSymbol('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = (function () {
	  return 'a'.replace(/./, '$0') === '$0';
	})();

	var REPLACE = wellKnownSymbol('replace');
	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }
	  return false;
	})();

	// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	});

	var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
	  var SYMBOL = wellKnownSymbol(KEY);

	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$3] = function () { return re; };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () { execCalled = true; return null; };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !(
	      REPLACE_SUPPORTS_NAMED_GROUPS &&
	      REPLACE_KEEPS_$0 &&
	      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    )) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      if (regexp.exec === regexpExec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	        }
	        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	      }
	      return { done: false };
	    }, {
	      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
	      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    });
	    var stringMethod = methods[0];
	    var regexMethod = methods[1];

	    redefine(String.prototype, KEY, stringMethod);
	    redefine(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return regexMethod.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return regexMethod.call(string, this); }
	    );
	  }

	  if (sham) { createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true); }
	};

	var charAt$1 = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt$1(S, index).length : 1);
	};

	// `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }

	  if (classofRaw(R) !== 'RegExp') {
	    throw TypeError('RegExp#exec called on incompatible receiver');
	  }

	  return regexpExec.call(R, S);
	};

	var max$2 = Math.max;
	var min$2 = Math.min;
	var floor$1 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
	  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
	  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = requireObjectCoercible(this);
	      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return replacer !== undefined
	        ? replacer.call(searchValue, O, replaceValue)
	        : nativeReplace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      if (
	        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
	        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
	      ) {
	        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
	        if (res.done) { return res.value; }
	      }

	      var rx = anObject(regexp);
	      var S = String(this);

	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) { replaceValue = String(replaceValue); }

	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regexpExecAbstract(rx, S);
	        if (result === null) { break; }

	        results.push(result);
	        if (!global) { break; }

	        var matchStr = String(result[0]);
	        if (matchStr === '') { rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); }
	      }

	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];

	        var matched = String(result[0]);
	        var position = max$2(min$2(toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) { captures.push(maybeToString(result[j])); }
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) { replacerArgs.push(namedCaptures); }
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	  // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return nativeReplace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) { return match; }
	          if (n > m) {
	            var f = floor$1(n / 10);
	            if (f === 0) { return match; }
	            if (f <= m) { return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1); }
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// `SameValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-samevalue
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// @@search logic
	fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = requireObjectCoercible(this);
	      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
	      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative(nativeSearch, regexp, this);
	      if (res.done) { return res.value; }

	      var rx = anObject(regexp);
	      var S = String(this);

	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) { rx.lastIndex = 0; }
	      var result = regexpExecAbstract(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) { rx.lastIndex = previousLastIndex; }
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var SPECIES$4 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$4]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var arrayPush = [].push;
	var min$3 = Math.min;
	var MAX_UINT32 = 0xFFFFFFFF;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

	// @@split logic
	fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'.split(/(b)*/)[1] == 'c' ||
	    'test'.split(/(?:)/, -1).length != 4 ||
	    'ab'.split(/(?:ab)*/).length != 2 ||
	    '.'.split(/(.?)(.?)/).length != 4 ||
	    '.'.split(/()()/).length > 1 ||
	    ''.split(/.?/).length
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) { return []; }
	      if (separator === undefined) { return [string]; }
	      // If `separator` is not a regex, use native split
	      if (!isRegexp(separator)) {
	        return nativeSplit.call(string, separator, lim);
	      }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) { arrayPush.apply(output, match.slice(1)); }
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) { break; }
	        }
	        if (separatorCopy.lastIndex === match.index) { separatorCopy.lastIndex++; } // Avoid an infinite loop
	      }
	      if (lastLastIndex === string.length) {
	        if (lastLength || !separatorCopy.test('')) { output.push(''); }
	      } else { output.push(string.slice(lastLastIndex)); }
	      return output.length > lim ? output.slice(0, lim) : output;
	    };
	  // Chakra, V8
	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
	    };
	  } else { internalSplit = nativeSplit; }

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = requireObjectCoercible(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
	      if (res.done) { return res.value; }

	      var rx = anObject(regexp);
	      var S = String(this);
	      var C = speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) { return []; }
	      if (S.length === 0) { return regexpExecAbstract(splitter, S) === null ? [S] : []; }
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = min$3(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) { return A; }
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) { return A; }
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	}, !SUPPORTS_Y);

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) { try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  } }
	}

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	for (var COLLECTION_NAME$1 in domIterables) {
	  var Collection$1 = global_1[COLLECTION_NAME$1];
	  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
	  if (CollectionPrototype$1) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype$1[ITERATOR$2] !== ArrayValues) { try {
	      createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$2, ArrayValues);
	    } catch (error) {
	      CollectionPrototype$1[ITERATOR$2] = ArrayValues;
	    } }
	    if (!CollectionPrototype$1[TO_STRING_TAG$3]) {
	      createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$3, COLLECTION_NAME$1);
	    }
	    if (domIterables[COLLECTION_NAME$1]) { for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) { try {
	        createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      } }
	    } }
	  }
	}

	var ITERATOR$3 = wellKnownSymbol('iterator');

	var nativeUrl = !fails(function () {
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return !searchParams.sort
	    || url.href !== 'http://a/c%20d?a=1&c=3'
	    || searchParams.get('c') !== '3'
	    || String(new URLSearchParams('?a=1')) !== 'a=1'
	    || !searchParams[ITERATOR$3]
	    // throws in Edge
	    || new URL('https://a@b').username !== 'a'
	    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
	    // not punycoded in Edge
	    || new URL('http://тест').host !== 'xn--e1aybc'
	    // not escaped in Chrome 62-
	    || new URL('http://a#б').hash !== '#%D0%B1'
	    // fails in Chrome 66-
	    || result !== 'a1c3'
	    // throws in Safari
	    || new URL('http://x', undefined).host !== 'x';
	});

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var nativeAssign = Object.assign;
	var defineProperty$4 = Object.defineProperty;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	var objectAssign = !nativeAssign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$4({}, 'a', {
	    enumerable: true,
	    get: function () {
	      defineProperty$4(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), { b: 2 })).b !== 1) { return true; }
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) {
	  var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments$1[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) { T[key] = S[key]; }
	    }
	  } return T;
	} : nativeAssign;

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    var returnMethod = iterator['return'];
	    if (returnMethod !== undefined) { anObject(returnMethod.call(iterator)); }
	    throw error;
	  }
	};

	var ITERATOR$4 = wellKnownSymbol('iterator');
	var ArrayPrototype$1 = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$4] === it);
	};

	var ITERATOR$5 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) { return it[ITERATOR$5]
	    || it['@@iterator']
	    || iterators[classof(it)]; }
	};

	// `Array.from` method implementation
	// https://tc39.github.io/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) { mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); }
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'
	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;
	var floor$2 = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */
	var ucs2decode = function (string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;
	  while (counter < length) {
	    var value = string.charCodeAt(counter++);
	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = string.charCodeAt(counter++);
	      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
	        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        output.push(value);
	        counter--;
	      }
	    } else {
	      output.push(value);
	    }
	  }
	  return output;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 */
	var digitToBasic = function (digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */
	var adapt = function (delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$2(delta / damp) : delta >> 1;
	  delta += floor$2(delta / numPoints);
	  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
	    delta = floor$2(delta / baseMinusTMin);
	  }
	  return floor$2(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */
	// eslint-disable-next-line  max-statements
	var encode = function (input) {
	  var output = [];

	  // Convert the input in UCS-2 to an array of Unicode code points.
	  input = ucs2decode(input);

	  // Cache the length.
	  var inputLength = input.length;

	  // Initialize the state.
	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue;

	  // Handle the basic code points.
	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];
	    if (currentValue < 0x80) {
	      output.push(stringFromCharCode(currentValue));
	    }
	  }

	  var basicLength = output.length; // number of basic code points.
	  var handledCPCount = basicLength; // number of code points that have been handled;

	  // Finish the basic string with a delimiter unless it's empty.
	  if (basicLength) {
	    output.push(delimiter);
	  }

	  // Main encoding loop:
	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    }

	    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
	    var handledCPCountPlusOne = handledCPCount + 1;
	    if (m - n > floor$2((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError(OVERFLOW_ERROR);
	    }

	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError(OVERFLOW_ERROR);
	      }
	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        for (var k = base; /* no condition */; k += base) {
	          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	          if (q < t) { break; }
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$2(qMinusT / baseMinusT);
	        }

	        output.push(stringFromCharCode(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        ++handledCPCount;
	      }
	    }

	    ++delta;
	    ++n;
	  }
	  return output.join('');
	};

	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
	  var i, label;
	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
	  }
	  return encoded.join('.');
	};

	var redefineAll = function (target, src, options) {
	  for (var key in src) { redefine(target, key, src[key], options); }
	  return target;
	};

	var getIterator = function (it) {
	  var iteratorMethod = getIteratorMethod(it);
	  if (typeof iteratorMethod != 'function') {
	    throw TypeError(String(it) + ' is not iterable');
	  } return anObject(iteratorMethod.call(it));
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`





















	var $fetch = getBuiltIn('fetch');
	var Headers = getBuiltIn('Headers');
	var ITERATOR$6 = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$3 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);

	var plus = /\+/g;
	var sequences = Array(4);

	var percentSequence = function (bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};

	var percentDecode = function (sequence) {
	  try {
	    return decodeURIComponent(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};

	var deserialize = function (it) {
	  var result = it.replace(plus, ' ');
	  var bytes = 4;
	  try {
	    return decodeURIComponent(result);
	  } catch (error) {
	    while (bytes) {
	      result = result.replace(percentSequence(bytes--), percentDecode);
	    }
	    return result;
	  }
	};

	var find = /[!'()~]|%20/g;

	var replace = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};

	var replacer = function (match) {
	  return replace[match];
	};

	var serialize = function (it) {
	  return encodeURIComponent(it).replace(find, replacer);
	};

	var parseSearchParams = function (result, query) {
	  if (query) {
	    var attributes = query.split('&');
	    var index = 0;
	    var attribute, entry;
	    while (index < attributes.length) {
	      attribute = attributes[index++];
	      if (attribute.length) {
	        entry = attribute.split('=');
	        result.push({
	          key: deserialize(entry.shift()),
	          value: deserialize(entry.join('='))
	        });
	      }
	    }
	  }
	};

	var updateSearchParams = function (query) {
	  this.entries.length = 0;
	  parseSearchParams(this.entries, query);
	};

	var validateArgumentsLength = function (passed, required) {
	  if (passed < required) { throw TypeError('Not enough arguments'); }
	};

	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$3(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;
	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  } return step;
	});

	// `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams
	var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
	  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  var that = this;
	  var entries = [];
	  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;

	  setInternalState$3(that, {
	    type: URL_SEARCH_PARAMS,
	    entries: entries,
	    updateURL: function () { /* empty */ },
	    updateSearchParams: updateSearchParams
	  });

	  if (init !== undefined) {
	    if (isObject(init)) {
	      iteratorMethod = getIteratorMethod(init);
	      if (typeof iteratorMethod === 'function') {
	        iterator = iteratorMethod.call(init);
	        next = iterator.next;
	        while (!(step = next.call(iterator)).done) {
	          entryIterator = getIterator(anObject(step.value));
	          entryNext = entryIterator.next;
	          if (
	            (first = entryNext.call(entryIterator)).done ||
	            (second = entryNext.call(entryIterator)).done ||
	            !entryNext.call(entryIterator).done
	          ) { throw TypeError('Expected sequence with length 2'); }
	          entries.push({ key: first.value + '', value: second.value + '' });
	        }
	      } else { for (key in init) { if (has(init, key)) { entries.push({ key: key, value: init[key] + '' }); } } }
	    } else {
	      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
	    }
	  }
	};

	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.appent` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    state.entries.push({ key: name + '', value: value + '' });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function (name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index].key === key) { entries.splice(index, 1); }
	      else { index++; }
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) { return entries[index].value; }
	    }
	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var result = [];
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) { result.push(entries[index].value); }
	    }
	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index++].key === key) { return true; }
	    }
	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = name + '';
	    var val = value + '';
	    var index = 0;
	    var entry;
	    for (; index < entries.length; index++) {
	      entry = entries[index];
	      if (entry.key === key) {
	        if (found) { entries.splice(index--, 1); }
	        else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }
	    if (!found) { entries.push({ key: key, value: val }); }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    // Array#sort is not stable in some engines
	    var slice = entries.slice();
	    var entry, entriesIndex, sliceIndex;
	    entries.length = 0;
	    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
	      entry = slice[sliceIndex];
	      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
	        if (entries[entriesIndex].key > entry.key) {
	          entries.splice(entriesIndex, 0, entry);
	          break;
	        }
	      }
	      if (entriesIndex === sliceIndex) { entries.push(entry); }
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback /* , thisArg */) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, { enumerable: true });

	// `URLSearchParams.prototype[@@iterator]` method
	redefine(URLSearchParamsPrototype, ITERATOR$6, URLSearchParamsPrototype.entries);

	// `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  var entries = getInternalParamsState(this).entries;
	  var result = [];
	  var index = 0;
	  var entry;
	  while (index < entries.length) {
	    entry = entries[index++];
	    result.push(serialize(entry.key) + '=' + serialize(entry.value));
	  } return result.join('&');
	}, { enumerable: true });

	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

	_export({ global: true, forced: !nativeUrl }, {
	  URLSearchParams: URLSearchParamsConstructor
	});

	// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
	// https://github.com/zloirock/core-js/issues/674
	if (!nativeUrl && typeof $fetch == 'function' && typeof Headers == 'function') {
	  _export({ global: true, enumerable: true, forced: true }, {
	    fetch: function fetch(input /* , init */) {
	      var args = [input];
	      var init, body, headers;
	      if (arguments.length > 1) {
	        init = arguments[1];
	        if (isObject(init)) {
	          body = init.body;
	          if (classof(body) === URL_SEARCH_PARAMS) {
	            headers = init.headers ? new Headers(init.headers) : new Headers();
	            if (!headers.has('content-type')) {
	              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	            init = objectCreate(init, {
	              body: createPropertyDescriptor(0, String(body)),
	              headers: createPropertyDescriptor(0, headers)
	            });
	          }
	        }
	        args.push(init);
	      } return $fetch.apply(this, args);
	    }
	  });
	}

	var web_urlSearchParams = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`











	var codeAt = stringMultibyte.codeAt;





	var NativeURL = global_1.URL;
	var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams.getState;
	var setInternalState$4 = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var floor$3 = Math.floor;
	var pow = Math.pow;

	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';

	var ALPHA = /[A-Za-z]/;
	var ALPHANUMERIC = /[\d+-.A-Za-z]/;
	var DIGIT = /\d/;
	var HEX_START = /^(0x|0X)/;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\dA-Fa-f]+$/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
	// eslint-disable-next-line no-control-regex
	var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
	var EOF;

	var parseHost = function (url, input) {
	  var result, codePoints, index;
	  if (input.charAt(0) == '[') {
	    if (input.charAt(input.length - 1) != ']') { return INVALID_HOST; }
	    result = parseIPv6(input.slice(1, -1));
	    if (!result) { return INVALID_HOST; }
	    url.host = result;
	  // opaque host
	  } else if (!isSpecial(url)) {
	    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) { return INVALID_HOST; }
	    result = '';
	    codePoints = arrayFrom(input);
	    for (index = 0; index < codePoints.length; index++) {
	      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	    }
	    url.host = result;
	  } else {
	    input = stringPunycodeToAscii(input);
	    if (FORBIDDEN_HOST_CODE_POINT.test(input)) { return INVALID_HOST; }
	    result = parseIPv4(input);
	    if (result === null) { return INVALID_HOST; }
	    url.host = result;
	  }
	};

	var parseIPv4 = function (input) {
	  var parts = input.split('.');
	  var partsLength, numbers, index, part, radix, number, ipv4;
	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.pop();
	  }
	  partsLength = parts.length;
	  if (partsLength > 4) { return input; }
	  numbers = [];
	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') { return input; }
	    radix = 10;
	    if (part.length > 1 && part.charAt(0) == '0') {
	      radix = HEX_START.test(part) ? 16 : 8;
	      part = part.slice(radix == 8 ? 1 : 2);
	    }
	    if (part === '') {
	      number = 0;
	    } else {
	      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) { return input; }
	      number = parseInt(part, radix);
	    }
	    numbers.push(number);
	  }
	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];
	    if (index == partsLength - 1) {
	      if (number >= pow(256, 5 - partsLength)) { return null; }
	    } else if (number > 255) { return null; }
	  }
	  ipv4 = numbers.pop();
	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow(256, 3 - index);
	  }
	  return ipv4;
	};

	// eslint-disable-next-line max-statements
	var parseIPv6 = function (input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

	  var char = function () {
	    return input.charAt(pointer);
	  };

	  if (char() == ':') {
	    if (input.charAt(1) != ':') { return; }
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }
	  while (char()) {
	    if (pieceIndex == 8) { return; }
	    if (char() == ':') {
	      if (compress !== null) { return; }
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }
	    value = length = 0;
	    while (length < 4 && HEX.test(char())) {
	      value = value * 16 + parseInt(char(), 16);
	      pointer++;
	      length++;
	    }
	    if (char() == '.') {
	      if (length == 0) { return; }
	      pointer -= length;
	      if (pieceIndex > 6) { return; }
	      numbersSeen = 0;
	      while (char()) {
	        ipv4Piece = null;
	        if (numbersSeen > 0) {
	          if (char() == '.' && numbersSeen < 4) { pointer++; }
	          else { return; }
	        }
	        if (!DIGIT.test(char())) { return; }
	        while (DIGIT.test(char())) {
	          number = parseInt(char(), 10);
	          if (ipv4Piece === null) { ipv4Piece = number; }
	          else if (ipv4Piece == 0) { return; }
	          else { ipv4Piece = ipv4Piece * 10 + number; }
	          if (ipv4Piece > 255) { return; }
	          pointer++;
	        }
	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) { pieceIndex++; }
	      }
	      if (numbersSeen != 4) { return; }
	      break;
	    } else if (char() == ':') {
	      pointer++;
	      if (!char()) { return; }
	    } else if (char()) { return; }
	    address[pieceIndex++] = value;
	  }
	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) { return; }
	  return address;
	};

	var findLongestZeroSequence = function (ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;
	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }
	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) { currStart = index; }
	      ++currLength;
	    }
	  }
	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }
	  return maxIndex;
	};

	var serializeHost = function (host) {
	  var result, index, compress, ignore0;
	  // ipv4
	  if (typeof host == 'number') {
	    result = [];
	    for (index = 0; index < 4; index++) {
	      result.unshift(host % 256);
	      host = floor$3(host / 256);
	    } return result.join('.');
	  // ipv6
	  } else if (typeof host == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);
	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) { continue; }
	      if (ignore0) { ignore0 = false; }
	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += host[index].toString(16);
	        if (index < 7) { result += ':'; }
	      }
	    }
	    return '[' + result + ']';
	  } return host;
	};

	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1, '?': 1, '{': 1, '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
	});

	var percentEncode = function (char, set) {
	  var code = codeAt(char, 0);
	  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
	};

	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};

	var isSpecial = function (url) {
	  return has(specialSchemes, url.scheme);
	};

	var includesCredentials = function (url) {
	  return url.username != '' || url.password != '';
	};

	var cannotHaveUsernamePasswordPort = function (url) {
	  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
	};

	var isWindowsDriveLetter = function (string, normalized) {
	  var second;
	  return string.length == 2 && ALPHA.test(string.charAt(0))
	    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
	};

	var startsWithWindowsDriveLetter = function (string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
	    string.length == 2 ||
	    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
	  );
	};

	var shortenURLsPath = function (url) {
	  var path = url.path;
	  var pathSize = path.length;
	  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	    path.pop();
	  }
	};

	var isSingleDot = function (segment) {
	  return segment === '.' || segment.toLowerCase() === '%2e';
	};

	var isDoubleDot = function (segment) {
	  segment = segment.toLowerCase();
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	};

	// States:
	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	// eslint-disable-next-line max-statements
	var parseURL = function (url, input, stateOverride, base) {
	  var state = stateOverride || SCHEME_START;
	  var pointer = 0;
	  var buffer = '';
	  var seenAt = false;
	  var seenBracket = false;
	  var seenPasswordToken = false;
	  var codePoints, char, bufferCodePoints, failure;

	  if (!stateOverride) {
	    url.scheme = '';
	    url.username = '';
	    url.password = '';
	    url.host = null;
	    url.port = null;
	    url.path = [];
	    url.query = null;
	    url.fragment = null;
	    url.cannotBeABaseURL = false;
	    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	  }

	  input = input.replace(TAB_AND_NEW_LINE, '');

	  codePoints = arrayFrom(input);

	  while (pointer <= codePoints.length) {
	    char = codePoints[pointer];
	    switch (state) {
	      case SCHEME_START:
	        if (char && ALPHA.test(char)) {
	          buffer += char.toLowerCase();
	          state = SCHEME;
	        } else if (!stateOverride) {
	          state = NO_SCHEME;
	          continue;
	        } else { return INVALID_SCHEME; }
	        break;

	      case SCHEME:
	        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
	          buffer += char.toLowerCase();
	        } else if (char == ':') {
	          if (stateOverride && (
	            (isSpecial(url) != has(specialSchemes, buffer)) ||
	            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
	            (url.scheme == 'file' && !url.host)
	          )) { return; }
	          url.scheme = buffer;
	          if (stateOverride) {
	            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) { url.port = null; }
	            return;
	          }
	          buffer = '';
	          if (url.scheme == 'file') {
	            state = FILE;
	          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
	            state = SPECIAL_RELATIVE_OR_AUTHORITY;
	          } else if (isSpecial(url)) {
	            state = SPECIAL_AUTHORITY_SLASHES;
	          } else if (codePoints[pointer + 1] == '/') {
	            state = PATH_OR_AUTHORITY;
	            pointer++;
	          } else {
	            url.cannotBeABaseURL = true;
	            url.path.push('');
	            state = CANNOT_BE_A_BASE_URL_PATH;
	          }
	        } else if (!stateOverride) {
	          buffer = '';
	          state = NO_SCHEME;
	          pointer = 0;
	          continue;
	        } else { return INVALID_SCHEME; }
	        break;

	      case NO_SCHEME:
	        if (!base || (base.cannotBeABaseURL && char != '#')) { return INVALID_SCHEME; }
	        if (base.cannotBeABaseURL && char == '#') {
	          url.scheme = base.scheme;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          url.cannotBeABaseURL = true;
	          state = FRAGMENT;
	          break;
	        }
	        state = base.scheme == 'file' ? FILE : RELATIVE;
	        continue;

	      case SPECIAL_RELATIVE_OR_AUTHORITY:
	        if (char == '/' && codePoints[pointer + 1] == '/') {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          pointer++;
	        } else {
	          state = RELATIVE;
	          continue;
	        } break;

	      case PATH_OR_AUTHORITY:
	        if (char == '/') {
	          state = AUTHORITY;
	          break;
	        } else {
	          state = PATH;
	          continue;
	        }

	      case RELATIVE:
	        url.scheme = base.scheme;
	        if (char == EOF) {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
	          state = RELATIVE_SLASH;
	        } else if (char == '?') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          state = FRAGMENT;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.path.pop();
	          state = PATH;
	          continue;
	        } break;

	      case RELATIVE_SLASH:
	        if (isSpecial(url) && (char == '/' || char == '\\')) {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        } else if (char == '/') {
	          state = AUTHORITY;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          state = PATH;
	          continue;
	        } break;

	      case SPECIAL_AUTHORITY_SLASHES:
	        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        if (char != '/' || buffer.charAt(pointer + 1) != '/') { continue; }
	        pointer++;
	        break;

	      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	        if (char != '/' && char != '\\') {
	          state = AUTHORITY;
	          continue;
	        } break;

	      case AUTHORITY:
	        if (char == '@') {
	          if (seenAt) { buffer = '%40' + buffer; }
	          seenAt = true;
	          bufferCodePoints = arrayFrom(buffer);
	          for (var i = 0; i < bufferCodePoints.length; i++) {
	            var codePoint = bufferCodePoints[i];
	            if (codePoint == ':' && !seenPasswordToken) {
	              seenPasswordToken = true;
	              continue;
	            }
	            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	            if (seenPasswordToken) { url.password += encodedCodePoints; }
	            else { url.username += encodedCodePoints; }
	          }
	          buffer = '';
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (seenAt && buffer == '') { return INVALID_AUTHORITY; }
	          pointer -= arrayFrom(buffer).length + 1;
	          buffer = '';
	          state = HOST;
	        } else { buffer += char; }
	        break;

	      case HOST:
	      case HOSTNAME:
	        if (stateOverride && url.scheme == 'file') {
	          state = FILE_HOST;
	          continue;
	        } else if (char == ':' && !seenBracket) {
	          if (buffer == '') { return INVALID_HOST; }
	          failure = parseHost(url, buffer);
	          if (failure) { return failure; }
	          buffer = '';
	          state = PORT;
	          if (stateOverride == HOSTNAME) { return; }
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (isSpecial(url) && buffer == '') { return INVALID_HOST; }
	          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) { return; }
	          failure = parseHost(url, buffer);
	          if (failure) { return failure; }
	          buffer = '';
	          state = PATH_START;
	          if (stateOverride) { return; }
	          continue;
	        } else {
	          if (char == '[') { seenBracket = true; }
	          else if (char == ']') { seenBracket = false; }
	          buffer += char;
	        } break;

	      case PORT:
	        if (DIGIT.test(char)) {
	          buffer += char;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url)) ||
	          stateOverride
	        ) {
	          if (buffer != '') {
	            var port = parseInt(buffer, 10);
	            if (port > 0xFFFF) { return INVALID_PORT; }
	            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
	            buffer = '';
	          }
	          if (stateOverride) { return; }
	          state = PATH_START;
	          continue;
	        } else { return INVALID_PORT; }
	        break;

	      case FILE:
	        url.scheme = 'file';
	        if (char == '/' || char == '\\') { state = FILE_SLASH; }
	        else if (base && base.scheme == 'file') {
	          if (char == EOF) {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	          } else if (char == '?') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	              url.host = base.host;
	              url.path = base.path.slice();
	              shortenURLsPath(url);
	            }
	            state = PATH;
	            continue;
	          }
	        } else {
	          state = PATH;
	          continue;
	        } break;

	      case FILE_SLASH:
	        if (char == '/' || char == '\\') {
	          state = FILE_HOST;
	          break;
	        }
	        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	          if (isWindowsDriveLetter(base.path[0], true)) { url.path.push(base.path[0]); }
	          else { url.host = base.host; }
	        }
	        state = PATH;
	        continue;

	      case FILE_HOST:
	        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
	          if (!stateOverride && isWindowsDriveLetter(buffer)) {
	            state = PATH;
	          } else if (buffer == '') {
	            url.host = '';
	            if (stateOverride) { return; }
	            state = PATH_START;
	          } else {
	            failure = parseHost(url, buffer);
	            if (failure) { return failure; }
	            if (url.host == 'localhost') { url.host = ''; }
	            if (stateOverride) { return; }
	            buffer = '';
	            state = PATH_START;
	          } continue;
	        } else { buffer += char; }
	        break;

	      case PATH_START:
	        if (isSpecial(url)) {
	          state = PATH;
	          if (char != '/' && char != '\\') { continue; }
	        } else if (!stateOverride && char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          state = PATH;
	          if (char != '/') { continue; }
	        } break;

	      case PATH:
	        if (
	          char == EOF || char == '/' ||
	          (char == '\\' && isSpecial(url)) ||
	          (!stateOverride && (char == '?' || char == '#'))
	        ) {
	          if (isDoubleDot(buffer)) {
	            shortenURLsPath(url);
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else if (isSingleDot(buffer)) {
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else {
	            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	              if (url.host) { url.host = ''; }
	              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
	            }
	            url.path.push(buffer);
	          }
	          buffer = '';
	          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
	            while (url.path.length > 1 && url.path[0] === '') {
	              url.path.shift();
	            }
	          }
	          if (char == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          }
	        } else {
	          buffer += percentEncode(char, pathPercentEncodeSet);
	        } break;

	      case CANNOT_BE_A_BASE_URL_PATH:
	        if (char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case QUERY:
	        if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          if (char == "'" && isSpecial(url)) { url.query += '%27'; }
	          else if (char == '#') { url.query += '%23'; }
	          else { url.query += percentEncode(char, C0ControlPercentEncodeSet); }
	        } break;

	      case FRAGMENT:
	        if (char != EOF) { url.fragment += percentEncode(char, fragmentPercentEncodeSet); }
	        break;
	    }

	    pointer++;
	  }
	};

	// `URL` constructor
	// https://url.spec.whatwg.org/#url-class
	var URLConstructor = function URL(url /* , base */) {
	  var that = anInstance(this, URLConstructor, 'URL');
	  var base = arguments.length > 1 ? arguments[1] : undefined;
	  var urlString = String(url);
	  var state = setInternalState$4(that, { type: 'URL' });
	  var baseState, failure;
	  if (base !== undefined) {
	    if (base instanceof URLConstructor) { baseState = getInternalURLState(base); }
	    else {
	      failure = parseURL(baseState = {}, String(base));
	      if (failure) { throw TypeError(failure); }
	    }
	  }
	  failure = parseURL(state, urlString, null, baseState);
	  if (failure) { throw TypeError(failure); }
	  var searchParams = state.searchParams = new URLSearchParams$1();
	  var searchParamsState = getInternalSearchParamsState(searchParams);
	  searchParamsState.updateSearchParams(state.query);
	  searchParamsState.updateURL = function () {
	    state.query = String(searchParams) || null;
	  };
	  if (!descriptors) {
	    that.href = serializeURL.call(that);
	    that.origin = getOrigin.call(that);
	    that.protocol = getProtocol.call(that);
	    that.username = getUsername.call(that);
	    that.password = getPassword.call(that);
	    that.host = getHost.call(that);
	    that.hostname = getHostname.call(that);
	    that.port = getPort.call(that);
	    that.pathname = getPathname.call(that);
	    that.search = getSearch.call(that);
	    that.searchParams = getSearchParams.call(that);
	    that.hash = getHash.call(that);
	  }
	};

	var URLPrototype = URLConstructor.prototype;

	var serializeURL = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var username = url.username;
	  var password = url.password;
	  var host = url.host;
	  var port = url.port;
	  var path = url.path;
	  var query = url.query;
	  var fragment = url.fragment;
	  var output = scheme + ':';
	  if (host !== null) {
	    output += '//';
	    if (includesCredentials(url)) {
	      output += username + (password ? ':' + password : '') + '@';
	    }
	    output += serializeHost(host);
	    if (port !== null) { output += ':' + port; }
	  } else if (scheme == 'file') { output += '//'; }
	  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	  if (query !== null) { output += '?' + query; }
	  if (fragment !== null) { output += '#' + fragment; }
	  return output;
	};

	var getOrigin = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var port = url.port;
	  if (scheme == 'blob') { try {
	    return new URL(scheme.path[0]).origin;
	  } catch (error) {
	    return 'null';
	  } }
	  if (scheme == 'file' || !isSpecial(url)) { return 'null'; }
	  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
	};

	var getProtocol = function () {
	  return getInternalURLState(this).scheme + ':';
	};

	var getUsername = function () {
	  return getInternalURLState(this).username;
	};

	var getPassword = function () {
	  return getInternalURLState(this).password;
	};

	var getHost = function () {
	  var url = getInternalURLState(this);
	  var host = url.host;
	  var port = url.port;
	  return host === null ? ''
	    : port === null ? serializeHost(host)
	    : serializeHost(host) + ':' + port;
	};

	var getHostname = function () {
	  var host = getInternalURLState(this).host;
	  return host === null ? '' : serializeHost(host);
	};

	var getPort = function () {
	  var port = getInternalURLState(this).port;
	  return port === null ? '' : String(port);
	};

	var getPathname = function () {
	  var url = getInternalURLState(this);
	  var path = url.path;
	  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	};

	var getSearch = function () {
	  var query = getInternalURLState(this).query;
	  return query ? '?' + query : '';
	};

	var getSearchParams = function () {
	  return getInternalURLState(this).searchParams;
	};

	var getHash = function () {
	  var fragment = getInternalURLState(this).fragment;
	  return fragment ? '#' + fragment : '';
	};

	var accessorDescriptor = function (getter, setter) {
	  return { get: getter, set: setter, configurable: true, enumerable: true };
	};

	if (descriptors) {
	  objectDefineProperties(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor(serializeURL, function (href) {
	      var url = getInternalURLState(this);
	      var urlString = String(href);
	      var failure = parseURL(url, urlString);
	      if (failure) { throw TypeError(failure); }
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor(getOrigin),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor(getProtocol, function (protocol) {
	      var url = getInternalURLState(this);
	      parseURL(url, String(protocol) + ':', SCHEME_START);
	    }),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor(getUsername, function (username) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(username));
	      if (cannotHaveUsernamePasswordPort(url)) { return; }
	      url.username = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor(getPassword, function (password) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(password));
	      if (cannotHaveUsernamePasswordPort(url)) { return; }
	      url.password = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor(getHost, function (host) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) { return; }
	      parseURL(url, String(host), HOST);
	    }),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor(getHostname, function (hostname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) { return; }
	      parseURL(url, String(hostname), HOSTNAME);
	    }),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor(getPort, function (port) {
	      var url = getInternalURLState(this);
	      if (cannotHaveUsernamePasswordPort(url)) { return; }
	      port = String(port);
	      if (port == '') { url.port = null; }
	      else { parseURL(url, port, PORT); }
	    }),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor(getPathname, function (pathname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) { return; }
	      url.path = [];
	      parseURL(url, pathname + '', PATH_START);
	    }),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor(getSearch, function (search) {
	      var url = getInternalURLState(this);
	      search = String(search);
	      if (search == '') {
	        url.query = null;
	      } else {
	        if ('?' == search.charAt(0)) { search = search.slice(1); }
	        url.query = '';
	        parseURL(url, search, QUERY);
	      }
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor(getSearchParams),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor(getHash, function (hash) {
	      var url = getInternalURLState(this);
	      hash = String(hash);
	      if (hash == '') {
	        url.fragment = null;
	        return;
	      }
	      if ('#' == hash.charAt(0)) { hash = hash.slice(1); }
	      url.fragment = '';
	      parseURL(url, hash, FRAGMENT);
	    })
	  });
	}

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	// `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior
	redefine(URLPrototype, 'toString', function toString() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
	  // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeCreateObjectURL) { redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
	    return nativeCreateObjectURL.apply(NativeURL, arguments);
	  }); }
	  // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeRevokeObjectURL) { redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
	    return nativeRevokeObjectURL.apply(NativeURL, arguments);
	  }); }
	}

	setToStringTag(URLConstructor, 'URL');

	_export({ global: true, forced: !nativeUrl, sham: !descriptors }, {
	  URL: URLConstructor
	});

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) { descriptor.writable = true; }
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) { _defineProperties(Constructor.prototype, protoProps); }
	  if (staticProps) { _defineProperties(Constructor, staticProps); }
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys$1(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) { symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    }); }
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  var arguments$1 = arguments;

	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments$1[i] != null ? arguments$1[i] : {};

	    if (i % 2) {
	      ownKeys$1(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys$1(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) { return {}; }
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) { continue; }
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) { return {}; }

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) { continue; }
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) { continue; }
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) { return _arrayLikeToArray(arr); }
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) { return arr; }
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) { return Array.from(iter); }
	}

	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) { return; }
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) { break; }
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) { _i["return"](); }
	    } finally {
	      if (_d) { throw _e; }
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) { return; }
	  if (typeof o === "string") { return _arrayLikeToArray(o, minLen); }
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) { n = o.constructor.name; }
	  if (n === "Map" || n === "Set") { return Array.from(o); }
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) { return _arrayLikeToArray(o, minLen); }
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) { len = arr.length; }

	  for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; }

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	(function (global) {
	  /**
	   * Polyfill URLSearchParams
	   *
	   * Inspired from : https://github.com/WebReflection/url-search-params/blob/master/src/url-search-params.js
	   */
	  var checkIfIteratorIsSupported = function checkIfIteratorIsSupported() {
	    try {
	      return !!Symbol.iterator;
	    } catch (error) {
	      return false;
	    }
	  };

	  var iteratorSupported = checkIfIteratorIsSupported();

	  var createIterator = function createIterator(items) {
	    var iterator = {
	      next: function next() {
	        var value = items.shift();
	        return {
	          done: value === void 0,
	          value: value
	        };
	      }
	    };

	    if (iteratorSupported) {
	      iterator[Symbol.iterator] = function () {
	        return iterator;
	      };
	    }

	    return iterator;
	  };
	  /**
	   * Search param name and values should be encoded according to https://url.spec.whatwg.org/#urlencoded-serializing
	   * encodeURIComponent() produces the same result except encoding spaces as `%20` instead of `+`.
	   */


	  var serializeParam = function serializeParam(value) {
	    return encodeURIComponent(value).replace(/%20/g, '+');
	  };

	  var deserializeParam = function deserializeParam(value) {
	    return decodeURIComponent(String(value).replace(/\+/g, ' '));
	  };

	  var polyfillURLSearchParams = function polyfillURLSearchParams() {
	    var URLSearchParams = function URLSearchParams(searchString) {
	      Object.defineProperty(this, '_entries', {
	        writable: true,
	        value: {}
	      });

	      var typeofSearchString = _typeof(searchString);

	      if (typeofSearchString === 'undefined') ; else if (typeofSearchString === 'string') {
	        if (searchString !== '') {
	          this._fromString(searchString);
	        }
	      } else if (searchString instanceof URLSearchParams) {
	        var _this = this;

	        searchString.forEach(function (value, name) {
	          _this.append(name, value);
	        });
	      } else if (searchString !== null && typeofSearchString === 'object') {
	        if (Object.prototype.toString.call(searchString) === '[object Array]') {
	          for (var i = 0; i < searchString.length; i++) {
	            var entry = searchString[i];

	            if (Object.prototype.toString.call(entry) === '[object Array]' || entry.length !== 2) {
	              this.append(entry[0], entry[1]);
	            } else {
	              throw new TypeError('Expected [string, any] as entry at index ' + i + ' of URLSearchParams\'s input');
	            }
	          }
	        } else {
	          for (var key in searchString) {
	            if (searchString.hasOwnProperty(key)) {
	              this.append(key, searchString[key]);
	            }
	          }
	        }
	      } else {
	        throw new TypeError('Unsupported input\'s type for URLSearchParams');
	      }
	    };

	    var proto = URLSearchParams.prototype;

	    proto.append = function (name, value) {
	      if (name in this._entries) {
	        this._entries[name].push(String(value));
	      } else {
	        this._entries[name] = [String(value)];
	      }
	    };

	    proto.delete = function (name) {
	      delete this._entries[name];
	    };

	    proto.get = function (name) {
	      return name in this._entries ? this._entries[name][0] : null;
	    };

	    proto.getAll = function (name) {
	      return name in this._entries ? this._entries[name].slice(0) : [];
	    };

	    proto.has = function (name) {
	      return name in this._entries;
	    };

	    proto.set = function (name, value) {
	      this._entries[name] = [String(value)];
	    };

	    proto.forEach = function (callback, thisArg) {
	      var entries;

	      for (var name in this._entries) {
	        if (this._entries.hasOwnProperty(name)) {
	          entries = this._entries[name];

	          for (var i = 0; i < entries.length; i++) {
	            callback.call(thisArg, entries[i], name, this);
	          }
	        }
	      }
	    };

	    proto.keys = function () {
	      var items = [];
	      this.forEach(function (value, name) {
	        items.push(name);
	      });
	      return createIterator(items);
	    };

	    proto.values = function () {
	      var items = [];
	      this.forEach(function (value) {
	        items.push(value);
	      });
	      return createIterator(items);
	    };

	    proto.entries = function () {
	      var items = [];
	      this.forEach(function (value, name) {
	        items.push([name, value]);
	      });
	      return createIterator(items);
	    };

	    if (iteratorSupported) {
	      proto[Symbol.iterator] = proto.entries;
	    }

	    proto.toString = function () {
	      var searchArray = [];
	      this.forEach(function (value, name) {
	        searchArray.push(serializeParam(name) + '=' + serializeParam(value));
	      });
	      return searchArray.join('&');
	    };

	    global.URLSearchParams = URLSearchParams;
	  };

	  var checkIfURLSearchParamsSupported = function checkIfURLSearchParamsSupported() {
	    try {
	      var URLSearchParams = global.URLSearchParams;
	      return new URLSearchParams('?a=1').toString() === 'a=1' && typeof URLSearchParams.prototype.set === 'function';
	    } catch (e) {
	      return false;
	    }
	  };

	  if (!checkIfURLSearchParamsSupported()) {
	    polyfillURLSearchParams();
	  }

	  var proto = global.URLSearchParams.prototype;

	  if (typeof proto.sort !== 'function') {
	    proto.sort = function () {
	      var _this = this;

	      var items = [];
	      this.forEach(function (value, name) {
	        items.push([name, value]);

	        if (!_this._entries) {
	          _this.delete(name);
	        }
	      });
	      items.sort(function (a, b) {
	        if (a[0] < b[0]) {
	          return -1;
	        } else if (a[0] > b[0]) {
	          return +1;
	        } else {
	          return 0;
	        }
	      });

	      if (_this._entries) {
	        // force reset because IE keeps keys index
	        _this._entries = {};
	      }

	      for (var i = 0; i < items.length; i++) {
	        this.append(items[i][0], items[i][1]);
	      }
	    };
	  }

	  if (typeof proto._fromString !== 'function') {
	    Object.defineProperty(proto, '_fromString', {
	      enumerable: false,
	      configurable: false,
	      writable: false,
	      value: function value(searchString) {
	        if (this._entries) {
	          this._entries = {};
	        } else {
	          var keys = [];
	          this.forEach(function (value, name) {
	            keys.push(name);
	          });

	          for (var i = 0; i < keys.length; i++) {
	            this.delete(keys[i]);
	          }
	        }

	        searchString = searchString.replace(/^\?/, '');
	        var attributes = searchString.split('&');
	        var attribute;

	        for (var i = 0; i < attributes.length; i++) {
	          attribute = attributes[i].split('=');
	          this.append(deserializeParam(attribute[0]), attribute.length > 1 ? deserializeParam(attribute[1]) : '');
	        }
	      }
	    });
	  } // HTMLAnchorElement

	})(typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : commonjsGlobal$1);

	(function (global) {
	  /**
	   * Polyfill URL
	   *
	   * Inspired from : https://github.com/arv/DOM-URL-Polyfill/blob/master/src/url.js
	   */
	  var checkIfURLIsSupported = function checkIfURLIsSupported() {
	    try {
	      var u = new global.URL('b', 'http://a');
	      u.pathname = 'c d';
	      return u.href === 'http://a/c%20d' && u.searchParams;
	    } catch (e) {
	      return false;
	    }
	  };

	  var polyfillURL = function polyfillURL() {
	    var _URL = global.URL;

	    var URL = function URL(url, base) {
	      if (typeof url !== 'string') { url = String(url); } // Only create another document if the base is different from current location.

	      var doc = document,
	          baseElement;

	      if (base && (global.location === void 0 || base !== global.location.href)) {
	        doc = document.implementation.createHTMLDocument('');
	        baseElement = doc.createElement('base');
	        baseElement.href = base;
	        doc.head.appendChild(baseElement);

	        try {
	          if (baseElement.href.indexOf(base) !== 0) { throw new Error(baseElement.href); }
	        } catch (err) {
	          throw new Error('URL unable to set base ' + base + ' due to ' + err);
	        }
	      }

	      var anchorElement = doc.createElement('a');
	      anchorElement.href = url;

	      if (baseElement) {
	        doc.body.appendChild(anchorElement);
	        anchorElement.href = anchorElement.href; // force href to refresh
	      }

	      if (anchorElement.protocol === ':' || !/:/.test(anchorElement.href)) {
	        throw new TypeError('Invalid URL');
	      }

	      Object.defineProperty(this, '_anchorElement', {
	        value: anchorElement
	      }); // create a linked searchParams which reflect its changes on URL

	      var searchParams = new global.URLSearchParams(this.search);
	      var enableSearchUpdate = true;
	      var enableSearchParamsUpdate = true;

	      var _this = this;

	      ['append', 'delete', 'set'].forEach(function (methodName) {
	        var method = searchParams[methodName];

	        searchParams[methodName] = function () {
	          method.apply(searchParams, arguments);

	          if (enableSearchUpdate) {
	            enableSearchParamsUpdate = false;
	            _this.search = searchParams.toString();
	            enableSearchParamsUpdate = true;
	          }
	        };
	      });
	      Object.defineProperty(this, 'searchParams', {
	        value: searchParams,
	        enumerable: true
	      });
	      var search = void 0;
	      Object.defineProperty(this, '_updateSearchParams', {
	        enumerable: false,
	        configurable: false,
	        writable: false,
	        value: function value() {
	          if (this.search !== search) {
	            search = this.search;

	            if (enableSearchParamsUpdate) {
	              enableSearchUpdate = false;

	              this.searchParams._fromString(this.search);

	              enableSearchUpdate = true;
	            }
	          }
	        }
	      });
	    };

	    var proto = URL.prototype;

	    var linkURLWithAnchorAttribute = function linkURLWithAnchorAttribute(attributeName) {
	      Object.defineProperty(proto, attributeName, {
	        get: function get() {
	          return this._anchorElement[attributeName];
	        },
	        set: function set(value) {
	          this._anchorElement[attributeName] = value;
	        },
	        enumerable: true
	      });
	    };

	    ['hash', 'host', 'hostname', 'port', 'protocol'].forEach(function (attributeName) {
	      linkURLWithAnchorAttribute(attributeName);
	    });
	    Object.defineProperty(proto, 'search', {
	      get: function get() {
	        return this._anchorElement['search'];
	      },
	      set: function set(value) {
	        this._anchorElement['search'] = value;

	        this._updateSearchParams();
	      },
	      enumerable: true
	    });
	    Object.defineProperties(proto, {
	      'toString': {
	        get: function get() {
	          var _this = this;

	          return function () {
	            return _this.href;
	          };
	        }
	      },
	      'href': {
	        get: function get() {
	          return this._anchorElement.href.replace(/\?$/, '');
	        },
	        set: function set(value) {
	          this._anchorElement.href = value;

	          this._updateSearchParams();
	        },
	        enumerable: true
	      },
	      'pathname': {
	        get: function get() {
	          return this._anchorElement.pathname.replace(/(^\/?)/, '/');
	        },
	        set: function set(value) {
	          this._anchorElement.pathname = value;
	        },
	        enumerable: true
	      },
	      'origin': {
	        get: function get() {
	          // get expected port from protocol
	          var expectedPort = {
	            'http:': 80,
	            'https:': 443,
	            'ftp:': 21
	          }[this._anchorElement.protocol]; // add port to origin if, expected port is different than actual port
	          // and it is not empty f.e http://foo:8080
	          // 8080 != 80 && 8080 != ''

	          var addPortToOrigin = this._anchorElement.port != expectedPort && this._anchorElement.port !== '';
	          return this._anchorElement.protocol + '//' + this._anchorElement.hostname + (addPortToOrigin ? ':' + this._anchorElement.port : '');
	        },
	        enumerable: true
	      },
	      'password': {
	        // TODO
	        get: function get() {
	          return '';
	        },
	        set: function set(value) {},
	        enumerable: true
	      },
	      'username': {
	        // TODO
	        get: function get() {
	          return '';
	        },
	        set: function set(value) {},
	        enumerable: true
	      }
	    });

	    URL.createObjectURL = function (blob) {
	      return _URL.createObjectURL.apply(_URL, arguments);
	    };

	    URL.revokeObjectURL = function (url) {
	      return _URL.revokeObjectURL.apply(_URL, arguments);
	    };

	    global.URL = URL;
	  };

	  if (!checkIfURLIsSupported()) {
	    polyfillURL();
	  }

	  if (global.location !== void 0 && !('origin' in global.location)) {
	    var getOrigin = function getOrigin() {
	      return global.location.protocol + '//' + global.location.hostname + (global.location.port ? ':' + global.location.port : '');
	    };

	    try {
	      Object.defineProperty(global.location, 'origin', {
	        get: getOrigin,
	        enumerable: true
	      });
	    } catch (e) {
	      setInterval(function () {
	        global.location.origin = getOrigin();
	      }, 100);
	    }
	  }
	})(typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : commonjsGlobal$1);

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject(O)) { return false; }
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray$1(O);
	};

	var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED }, {
	  concat: function concat(arg) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments$1[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER) { throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED); }
	        for (k = 0; k < len; k++, n++) { if (k in E) { createProperty(A, n, E[k]); } }
	      } else {
	        if (n >= MAX_SAFE_INTEGER) { throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED); }
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var $filter = arrayIteration.filter;



	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('filter');
	// Edge 14- issue
	var USES_TO_LENGTH$3 = arrayMethodUsesToLength('filter');

	// `Array.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3 }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $find = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES = true;

	var USES_TO_LENGTH$4 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) { Array(1)[FIND](function () { SKIPS_HOLES = false; }); }

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$4 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var ITERATOR$7 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$7] = function () {
	    return this;
	  };
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) { return false; }
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$7] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
	});

	// `Array.from` method
	// https://tc39.github.io/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
	  from: arrayFrom
	});

	var $includes = arrayIncludes.includes;



	var USES_TO_LENGTH$5 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$5 }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var $map = arrayIteration.map;



	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('map');
	// FF49- issue
	var USES_TO_LENGTH$6 = arrayMethodUsesToLength('map');

	// `Array.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$6 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	    // it can work only with native `setPrototypeOf`
	    objectSetPrototypeOf &&
	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	    typeof (NewTarget = dummy.constructor) == 'function' &&
	    NewTarget !== Wrapper &&
	    isObject(NewTargetPrototype = NewTarget.prototype) &&
	    NewTargetPrototype !== Wrapper.prototype
	  ) { objectSetPrototypeOf($this, NewTargetPrototype); }
	  return $this;
	};

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$3 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) { string = string.replace(ltrim, ''); }
	    if (TYPE & 2) { string = string.replace(rtrim, ''); }
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$3(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$3(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$3(3)
	};

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$5 = objectDefineProperty.f;
	var trim = stringTrim.trim;

	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;

	// Opera ~12 has broken Object#toString
	var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

	// `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (typeof it == 'string' && it.length > 2) {
	    it = trim(it);
	    first = it.charCodeAt(0);
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) { return NaN; } // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
	        default: return +it;
	      }
	      digits = it.slice(2);
	      length = digits.length;
	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) { return NaN; }
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	// `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor
	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper
	      // check on 1..constructor(foo) case
	      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
	        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
	  };
	  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES2015 (in case, if modules with ES2015 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j$1 = 0, key; keys$1.length > j$1; j$1++) {
	    if (has(NativeNumber, key = keys$1[j$1]) && !has(NumberWrapper, key)) {
	      defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
	    }
	  }
	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (e) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (f) { /* empty */ }
	  } return false;
	};

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule$1(function (module) {
	var defineProperty = objectDefineProperty.f;



	var METADATA = uid('meta');
	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + ++id, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject(it)) { return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; }
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) { return 'F'; }
	    // not necessary to add metadata
	    if (!create) { return 'E'; }
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) { return true; }
	    // not necessary to add metadata
	    if (!create) { return false; }
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) { setMetadata(it); }
	  return it;
	};

	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys[METADATA] = true;
	});
	var internalMetadata_1 = internalMetadata.REQUIRED;
	var internalMetadata_2 = internalMetadata.fastKey;
	var internalMetadata_3 = internalMetadata.getWeakData;
	var internalMetadata_4 = internalMetadata.onFreeze;

	var iterate_1 = createCommonjsModule$1(function (module) {
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
	  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
	  var iterator, iterFn, index, length, result, next, step;

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') { throw TypeError('Target is not iterable'); }
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = AS_ENTRIES
	          ? boundFunction(anObject(step = iterable[index])[0], step[1])
	          : boundFunction(iterable[index]);
	        if (result && result instanceof Result) { return result; }
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
	    if (typeof result == 'object' && result && result instanceof Result) { return result; }
	  } return new Result(false);
	};

	iterate.stop = function (result) {
	  return new Result(true, result);
	};
	});

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};

	  var fixMethod = function (KEY) {
	    var nativeMethod = NativePrototype[KEY];
	    redefine(NativePrototype, KEY,
	      KEY == 'add' ? function add(value) {
	        nativeMethod.call(this, value === 0 ? 0 : value);
	        return this;
	      } : KEY == 'delete' ? function (key) {
	        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'get' ? function get(key) {
	        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'has' ? function has(key) {
	        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : function set(key, value) {
	        nativeMethod.call(this, key === 0 ? 0 : key, value);
	        return this;
	      }
	    );
	  };

	  // eslint-disable-next-line max-len
	  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	    new NativeConstructor().entries().next();
	  })))) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new
	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;
	      while (index--) { $instance[ADDER](index, index); }
	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) { iterate_1(iterable, that[ADDER], that, IS_MAP); }
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) { fixMethod(ADDER); }

	    // weak collections should not contains .clear method
	    if (IS_WEAK && NativePrototype.clear) { delete NativePrototype.clear; }
	  }

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: Constructor != NativeConstructor }, exported);

	  setToStringTag(Constructor, CONSTRUCTOR_NAME);

	  if (!IS_WEAK) { common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP); }

	  return Constructor;
	};

	var getWeakData = internalMetadata.getWeakData;








	var setInternalState$5 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;
	var find$1 = arrayIteration.find;
	var findIndex = arrayIteration.findIndex;
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (store) {
	  return store.frozen || (store.frozen = new UncaughtFrozenStore());
	};

	var UncaughtFrozenStore = function () {
	  this.entries = [];
	};

	var findUncaughtFrozen = function (store, key) {
	  return find$1(store.entries, function (it) {
	    return it[0] === key;
	  });
	};

	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) { return entry[1]; }
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) { entry[1] = value; }
	    else { this.entries.push([key, value]); }
	  },
	  'delete': function (key) {
	    var index = findIndex(this.entries, function (it) {
	      return it[0] === key;
	    });
	    if (~index) { this.entries.splice(index, 1); }
	    return !!~index;
	  }
	};

	var collectionWeak = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$5(that, {
	        type: CONSTRUCTOR_NAME,
	        id: id$1++,
	        frozen: undefined
	      });
	      if (iterable != undefined) { iterate_1(iterable, that[ADDER], that, IS_MAP); }
	    });

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var data = getWeakData(anObject(key), true);
	      if (data === true) { uncaughtFrozenStore(state).set(key, value); }
	      else { data[state.id] = value; }
	      return that;
	    };

	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        var state = getInternalState(this);
	        if (!isObject(key)) { return false; }
	        var data = getWeakData(key);
	        if (data === true) { return uncaughtFrozenStore(state)['delete'](key); }
	        return data && has(data, state.id) && delete data[state.id];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$1(key) {
	        var state = getInternalState(this);
	        if (!isObject(key)) { return false; }
	        var data = getWeakData(key);
	        if (data === true) { return uncaughtFrozenStore(state).has(key); }
	        return data && has(data, state.id);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.3.3.3 WeakMap.prototype.get(key)
	      get: function get(key) {
	        var state = getInternalState(this);
	        if (isObject(key)) {
	          var data = getWeakData(key);
	          if (data === true) { return uncaughtFrozenStore(state).get(key); }
	          return data ? data[state.id] : undefined;
	        }
	      },
	      // 23.3.3.5 WeakMap.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key, value);
	      }
	    } : {
	      // 23.4.3.1 WeakSet.prototype.add(value)
	      add: function add(value) {
	        return define(this, value, true);
	      }
	    });

	    return C;
	  }
	};

	var es_weakMap = createCommonjsModule$1(function (module) {






	var enforceIternalState = internalState.enforce;


	var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
	var isExtensible = Object.isExtensible;
	var InternalWeakMap;

	var wrapper = function (init) {
	  return function WeakMap() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	};

	// `WeakMap` constructor
	// https://tc39.github.io/ecma262/#sec-weakmap-constructor
	var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);

	// IE11 WeakMap frozen keys fix
	// We can't use feature detection because it crash some old IE builds
	// https://github.com/zloirock/core-js/issues/485
	if (nativeWeakMap && IS_IE11) {
	  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
	  internalMetadata.REQUIRED = true;
	  var WeakMapPrototype = $WeakMap.prototype;
	  var nativeDelete = WeakMapPrototype['delete'];
	  var nativeHas = WeakMapPrototype.has;
	  var nativeGet = WeakMapPrototype.get;
	  var nativeSet = WeakMapPrototype.set;
	  redefineAll(WeakMapPrototype, {
	    'delete': function (key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) { state.frozen = new InternalWeakMap(); }
	        return nativeDelete.call(this, key) || state.frozen['delete'](key);
	      } return nativeDelete.call(this, key);
	    },
	    has: function has(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) { state.frozen = new InternalWeakMap(); }
	        return nativeHas.call(this, key) || state.frozen.has(key);
	      } return nativeHas.call(this, key);
	    },
	    get: function get(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) { state.frozen = new InternalWeakMap(); }
	        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
	      } return nativeGet.call(this, key);
	    },
	    set: function set(key, value) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) { state.frozen = new InternalWeakMap(); }
	        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
	      } else { nativeSet.call(this, key, value); }
	      return this;
	    }
	  });
	}
	});

	var $every = arrayIteration.every;



	var STRICT_METHOD$3 = arrayMethodIsStrict('every');
	var USES_TO_LENGTH$7 = arrayMethodUsesToLength('every');

	// `Array.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.every
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 || !USES_TO_LENGTH$7 }, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var $some = arrayIteration.some;



	var STRICT_METHOD$4 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$8 = arrayMethodUsesToLength('some');

	// `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$4 || !USES_TO_LENGTH$8 }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `thisNumberValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-thisnumbervalue
	var thisNumberValue = function (value) {
	  if (typeof value != 'number' && classofRaw(value) != 'Number') {
	    throw TypeError('Incorrect invocation');
	  }
	  return +value;
	};

	// `String.prototype.repeat` method implementation
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	var stringRepeat = ''.repeat || function repeat(count) {
	  var str = String(requireObjectCoercible(this));
	  var result = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) { throw RangeError('Wrong number of repetitions'); }
	  for (;n > 0; (n >>>= 1) && (str += str)) { if (n & 1) { result += str; } }
	  return result;
	};

	var nativeToFixed = 1.0.toFixed;
	var floor$4 = Math.floor;

	var pow$1 = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow$1(x, n - 1, acc * x) : pow$1(x * x, n / 2, acc);
	};

	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	var FORCED$1 = nativeToFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToFixed.call({});
	});

	// `Number.prototype.toFixed` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
	_export({ target: 'Number', proto: true, forced: FORCED$1 }, {
	  // eslint-disable-next-line max-statements
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toInteger(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k;

	    var multiply = function (n, c) {
	      var index = -1;
	      var c2 = c;
	      while (++index < 6) {
	        c2 += n * data[index];
	        data[index] = c2 % 1e7;
	        c2 = floor$4(c2 / 1e7);
	      }
	    };

	    var divide = function (n) {
	      var index = 6;
	      var c = 0;
	      while (--index >= 0) {
	        c += data[index];
	        data[index] = floor$4(c / n);
	        c = (c % n) * 1e7;
	      }
	    };

	    var dataToString = function () {
	      var index = 6;
	      var s = '';
	      while (--index >= 0) {
	        if (s !== '' || index === 0 || data[index] !== 0) {
	          var t = String(data[index]);
	          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
	        }
	      } return s;
	    };

	    if (fractDigits < 0 || fractDigits > 20) { throw RangeError('Incorrect fraction digits'); }
	    // eslint-disable-next-line no-self-compare
	    if (number != number) { return 'NaN'; }
	    if (number <= -1e21 || number >= 1e21) { return String(number); }
	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }
	    if (number > 1e-21) {
	      e = log(number * pow$1(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow$1(2, -e, 1) : number / pow$1(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = fractDigits;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow$1(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        result = dataToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        result = dataToString() + stringRepeat.call('0', fractDigits);
	      }
	    }
	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits
	        ? '0.' + stringRepeat.call('0', fractDigits - k) + result
	        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
	    } else {
	      result = sign + result;
	    } return result;
	  }
	});

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod$4 = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.github.io/ecma262/#sec-object.entries
	  entries: createMethod$4(true),
	  // `Object.values` method
	  // https://tc39.github.io/ecma262/#sec-object.values
	  values: createMethod$4(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.github.io/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.github.io/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `Number.isNaN` method
	// https://tc39.github.io/ecma262/#sec-number.isnan
	_export({ target: 'Number', stat: true }, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


	var FAILS_ON_PRIMITIVES$1 = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
	var FORCED$2 = !descriptors || FAILS_ON_PRIMITIVES$1;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	_export({ target: 'Object', stat: true, forced: FORCED$2, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
	  }
	});

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;
	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) { createProperty(result, key, descriptor); }
	    }
	    return result;
	  }
	});

	// @@match logic
	fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = requireObjectCoercible(this);
	      var matcher = regexp == undefined ? undefined : regexp[MATCH];
	      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative(nativeMatch, regexp, this);
	      if (res.done) { return res.value; }

	      var rx = anObject(regexp);
	      var S = String(this);

	      if (!rx.global) { return regexpExecAbstract(rx, S); }

	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') { rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); }
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	function _classCallCheck$1(e, t) {
	  if (!(e instanceof t)) { throw new TypeError("Cannot call a class as a function"); }
	}

	function _defineProperties$1(e, t) {
	  for (var n = 0; n < t.length; n++) {
	    var r = t[n];
	    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
	  }
	}

	function _createClass$1(e, t, n) {
	  return t && _defineProperties$1(e.prototype, t), n && _defineProperties$1(e, n), e;
	}

	function _defineProperty$1(e, t, n) {
	  return t in e ? Object.defineProperty(e, t, {
	    value: n,
	    enumerable: !0,
	    configurable: !0,
	    writable: !0
	  }) : e[t] = n, e;
	}

	function ownKeys$2(e, t) {
	  var n = Object.keys(e);

	  if (Object.getOwnPropertySymbols) {
	    var r = Object.getOwnPropertySymbols(e);
	    t && (r = r.filter(function (t) {
	      return Object.getOwnPropertyDescriptor(e, t).enumerable;
	    })), n.push.apply(n, r);
	  }

	  return n;
	}

	function _objectSpread2$1(e) {
	  var arguments$1 = arguments;

	  for (var t = 1; t < arguments.length; t++) {
	    var n = null != arguments$1[t] ? arguments$1[t] : {};
	    t % 2 ? ownKeys$2(Object(n), !0).forEach(function (t) {
	      _defineProperty$1(e, t, n[t]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys$2(Object(n)).forEach(function (t) {
	      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
	    });
	  }

	  return e;
	}

	var defaults = {
	  addCSS: !0,
	  thumbWidth: 15,
	  watch: !0
	};

	function matches(e, t) {
	  return function () {
	    return Array.from(document.querySelectorAll(t)).includes(this);
	  }.call(e, t);
	}

	function trigger(e, t) {
	  if (e && t) {
	    var n = new Event(t, {
	      bubbles: !0
	    });
	    e.dispatchEvent(n);
	  }
	}

	var getConstructor = function getConstructor(e) {
	  return null != e ? e.constructor : null;
	},
	    instanceOf = function instanceOf(e, t) {
	  return !!(e && t && e instanceof t);
	},
	    isNullOrUndefined = function isNullOrUndefined(e) {
	  return null == e;
	},
	    isObject$1 = function isObject(e) {
	  return getConstructor(e) === Object;
	},
	    isNumber = function isNumber(e) {
	  return getConstructor(e) === Number && !Number.isNaN(e);
	},
	    isString = function isString(e) {
	  return getConstructor(e) === String;
	},
	    isBoolean = function isBoolean(e) {
	  return getConstructor(e) === Boolean;
	},
	    isFunction = function isFunction(e) {
	  return getConstructor(e) === Function;
	},
	    isArray$1$1 = function isArray(e) {
	  return Array.isArray(e);
	},
	    isNodeList = function isNodeList(e) {
	  return instanceOf(e, NodeList);
	},
	    isElement = function isElement(e) {
	  return instanceOf(e, Element);
	},
	    isEvent = function isEvent(e) {
	  return instanceOf(e, Event);
	},
	    isEmpty = function isEmpty(e) {
	  return isNullOrUndefined(e) || (isString(e) || isArray$1$1(e) || isNodeList(e)) && !e.length || isObject$1(e) && !Object.keys(e).length;
	},
	    is = {
	  nullOrUndefined: isNullOrUndefined,
	  object: isObject$1,
	  number: isNumber,
	  string: isString,
	  boolean: isBoolean,
	  function: isFunction,
	  array: isArray$1$1,
	  nodeList: isNodeList,
	  element: isElement,
	  event: isEvent,
	  empty: isEmpty
	};

	function getDecimalPlaces(e) {
	  var t = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
	  return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;
	}

	function round(e, t) {
	  if (1 > t) {
	    var n = getDecimalPlaces(t);
	    return parseFloat(e.toFixed(n));
	  }

	  return Math.round(e / t) * t;
	}

	var RangeTouch = function () {
	  function e(t, n) {
	    _classCallCheck$1(this, e), is.element(t) ? this.element = t : is.string(t) && (this.element = document.querySelector(t)), is.element(this.element) && is.empty(this.element.rangeTouch) && (this.config = _objectSpread2$1({}, defaults, {}, n), this.init());
	  }

	  return _createClass$1(e, [{
	    key: "init",
	    value: function value() {
	      e.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this);
	    }
	  }, {
	    key: "destroy",
	    value: function value() {
	      e.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null);
	    }
	  }, {
	    key: "listeners",
	    value: function value(e) {
	      var t = this,
	          n = e ? "addEventListener" : "removeEventListener";
	      ["touchstart", "touchmove", "touchend"].forEach(function (e) {
	        t.element[n](e, function (e) {
	          return t.set(e);
	        }, !1);
	      });
	    }
	  }, {
	    key: "get",
	    value: function value(t) {
	      if (!e.enabled || !is.event(t)) { return null; }
	      var n,
	          r = t.target,
	          i = t.changedTouches[0],
	          o = parseFloat(r.getAttribute("min")) || 0,
	          s = parseFloat(r.getAttribute("max")) || 100,
	          u = parseFloat(r.getAttribute("step")) || 1,
	          c = r.getBoundingClientRect(),
	          a = 100 / c.width * (this.config.thumbWidth / 2) / 100;
	      return 0 > (n = 100 / c.width * (i.clientX - c.left)) ? n = 0 : 100 < n && (n = 100), 50 > n ? n -= (100 - 2 * n) * a : 50 < n && (n += 2 * (n - 50) * a), o + round(n / 100 * (s - o), u);
	    }
	  }, {
	    key: "set",
	    value: function value(t) {
	      e.enabled && is.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), trigger(t.target, "touchend" === t.type ? "change" : "input"));
	    }
	  }], [{
	    key: "setup",
	    value: function value(t) {
	      var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
	          r = null;
	      if (is.empty(t) || is.string(t) ? r = Array.from(document.querySelectorAll(is.string(t) ? t : 'input[type="range"]')) : is.element(t) ? r = [t] : is.nodeList(t) ? r = Array.from(t) : is.array(t) && (r = t.filter(is.element)), is.empty(r)) { return null; }

	      var i = _objectSpread2$1({}, defaults, {}, n);

	      if (is.string(t) && i.watch) {
	        var o = new MutationObserver(function (n) {
	          Array.from(n).forEach(function (n) {
	            Array.from(n.addedNodes).forEach(function (n) {
	              is.element(n) && matches(n, t) && new e(n, i);
	            });
	          });
	        });
	        o.observe(document.body, {
	          childList: !0,
	          subtree: !0
	        });
	      }

	      return r.map(function (t) {
	        return new e(t, n);
	      });
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return "ontouchstart" in document.documentElement;
	    }
	  }]), e;
	}();

	var nativePromiseConstructor = global_1.Promise;

	var SPECIES$5 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$5]) {
	    defineProperty(Constructor, SPECIES$5, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location$1 = global_1.location;
	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$1 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$1 || !clear) {
	  set$1 = function setImmediate(fn) {
	    var arguments$1 = arguments;

	    var args = [];
	    var i = 1;
	    while (arguments.length > i) { args.push(arguments$1[i++]); }
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (classofRaw(process$1) == 'process') {
	    defer = function (id) {
	      process$1.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    !fails(post) &&
	    location$1.protocol !== 'file:'
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$1,
	  clear: clear
	};

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;


	var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var process$2 = global_1.process;
	var Promise$1 = global_1.Promise;
	var IS_NODE = classofRaw(process$2) == 'process';
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (IS_NODE && (parent = process$2.domain)) { parent.exit(); }
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) { notify(); }
	        else { last = undefined; }
	        throw error;
	      }
	    } last = undefined;
	    if (parent) { parent.enter(); }
	  };

	  // Node.js
	  if (IS_NODE) {
	    notify = function () {
	      process$2.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  } else if (MutationObserver$1 && !engineIsIos) {
	    toggle = true;
	    node = document.createTextNode('');
	    new MutationObserver$1(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined);
	    then = promise.then;
	    notify = function () {
	      then.call(promise, flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) { last.next = task; }
	  if (!head) {
	    head = task;
	    notify();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) { throw TypeError('Bad Promise constructor'); }
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction$1(resolve);
	  this.reject = aFunction$1(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$7
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) { return x; }
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var task$1 = task.set;










	var SPECIES$6 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$3 = internalState.get;
	var setInternalState$6 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$2 = global_1.document;
	var process$3 = global_1.process;
	var $fetch$1 = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var IS_NODE$1 = classofRaw(process$3) == 'process';
	var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	var FORCED$3 = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) { return true; }
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') { return true; }
	  }
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) { return false; }
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$6] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION$1 = FORCED$3 || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify$1 = function (promise, state, isReject) {
	  if (state.notified) { return; }
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) { onHandleUnhandled(promise, state); }
	            state.rejection = HANDLED;
	          }
	          if (handler === true) { result = value; }
	          else {
	            if (domain) { domain.enter(); }
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else { resolve(result); }
	        } else { reject(value); }
	      } catch (error) {
	        if (domain && !exited) { domain.exit(); }
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) { onUnhandled(promise, state); }
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$2.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else { event = { promise: promise, reason: reason }; }
	  if (handler = global_1['on' + name]) { handler(event); }
	  else if (name === UNHANDLED_REJECTION) { hostReportErrors('Unhandled promise rejection', reason); }
	};

	var onUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (IS_NODE$1) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else { dispatchEvent(UNHANDLED_REJECTION, promise, value); }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) { throw result.value; }
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    if (IS_NODE$1) {
	      process$3.emit('rejectionHandled', promise);
	    } else { dispatchEvent(REJECTION_HANDLED, promise, state.value); }
	  });
	};

	var bind = function (fn, promise, state, unwrap) {
	  return function (value) {
	    fn(promise, state, value, unwrap);
	  };
	};

	var internalReject = function (promise, state, value, unwrap) {
	  if (state.done) { return; }
	  state.done = true;
	  if (unwrap) { state = unwrap; }
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(promise, state, true);
	};

	var internalResolve = function (promise, state, value, unwrap) {
	  if (state.done) { return; }
	  state.done = true;
	  if (unwrap) { state = unwrap; }
	  try {
	    if (promise === value) { throw TypeError$1("Promise can't be resolved itself"); }
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind(internalResolve, promise, wrapper, state),
	            bind(internalReject, promise, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(promise, wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(promise, state, false);
	    }
	  } catch (error) {
	    internalReject(promise, { done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$3) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction$1(executor);
	    Internal.call(this);
	    var state = getInternalState$3(this);
	    try {
	      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
	    } catch (error) {
	      internalReject(this, state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState$6(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) { notify$1(this, state, false); }
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$3(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, promise, state);
	    this.reject = bind(internalReject, promise, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };

	  if ( typeof nativePromiseConstructor == 'function') {
	    nativeThen = nativePromiseConstructor.prototype.then;

	    // wrap native Promise#then for native async functions
	    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
	      var that = this;
	      return new PromiseConstructor(function (resolve, reject) {
	        nativeThen.call(that, resolve, reject);
	      }).then(onFulfilled, onRejected);
	    // https://github.com/zloirock/core-js/issues/640
	    }, { unsafe: true });

	    // wrap fetch result
	    if (typeof $fetch$1 == 'function') { _export({ global: true, enumerable: true, forced: true }, {
	      // eslint-disable-next-line no-unused-vars
	      fetch: function fetch(input /* , init */) {
	        return promiseResolve(PromiseConstructor, $fetch$1.apply(global_1, arguments));
	      }
	    }); }
	  }
	}

	_export({ global: true, wrap: true, forced: FORCED$3 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$3 }, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced:  FORCED$3 }, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION$1 }, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) { return; }
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) { reject(result.value); }
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      iterate_1(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) { reject(result.value); }
	    return capability.promise;
	  }
	});

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;






	var nativeStartsWith = ''.startsWith;
	var min$4 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor$4(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$4(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	// ==========================================================================
	// Type checking utils
	// ==========================================================================
	var getConstructor$1 = function getConstructor(input) {
	  return input !== null && typeof input !== 'undefined' ? input.constructor : null;
	};

	var instanceOf$1 = function instanceOf(input, constructor) {
	  return Boolean(input && constructor && input instanceof constructor);
	};

	var isNullOrUndefined$1 = function isNullOrUndefined(input) {
	  return input === null || typeof input === 'undefined';
	};

	var isObject$2 = function isObject(input) {
	  return getConstructor$1(input) === Object;
	};

	var isNumber$1 = function isNumber(input) {
	  return getConstructor$1(input) === Number && !Number.isNaN(input);
	};

	var isString$1 = function isString(input) {
	  return getConstructor$1(input) === String;
	};

	var isBoolean$1 = function isBoolean(input) {
	  return getConstructor$1(input) === Boolean;
	};

	var isFunction$1 = function isFunction(input) {
	  return getConstructor$1(input) === Function;
	};

	var isArray$2 = function isArray(input) {
	  return Array.isArray(input);
	};

	var isWeakMap = function isWeakMap(input) {
	  return instanceOf$1(input, WeakMap);
	};

	var isNodeList$1 = function isNodeList(input) {
	  return instanceOf$1(input, NodeList);
	};

	var isElement$1 = function isElement(input) {
	  return instanceOf$1(input, Element);
	};

	var isTextNode = function isTextNode(input) {
	  return getConstructor$1(input) === Text;
	};

	var isEvent$1 = function isEvent(input) {
	  return instanceOf$1(input, Event);
	};

	var isKeyboardEvent = function isKeyboardEvent(input) {
	  return instanceOf$1(input, KeyboardEvent);
	};

	var isCue = function isCue(input) {
	  return instanceOf$1(input, window.TextTrackCue) || instanceOf$1(input, window.VTTCue);
	};

	var isTrack = function isTrack(input) {
	  return instanceOf$1(input, TextTrack) || !isNullOrUndefined$1(input) && isString$1(input.kind);
	};

	var isPromise = function isPromise(input) {
	  return instanceOf$1(input, Promise) && isFunction$1(input.then);
	};

	var isEmpty$1 = function isEmpty(input) {
	  return isNullOrUndefined$1(input) || (isString$1(input) || isArray$2(input) || isNodeList$1(input)) && !input.length || isObject$2(input) && !Object.keys(input).length;
	};

	var isUrl = function isUrl(input) {
	  // Accept a URL object
	  if (instanceOf$1(input, window.URL)) {
	    return true;
	  } // Must be string from here


	  if (!isString$1(input)) {
	    return false;
	  } // Add the protocol if required


	  var string = input;

	  if (!input.startsWith('http://') || !input.startsWith('https://')) {
	    string = "http://".concat(input);
	  }

	  try {
	    return !isEmpty$1(new URL(string).hostname);
	  } catch (e) {
	    return false;
	  }
	};

	var is$1 = {
	  nullOrUndefined: isNullOrUndefined$1,
	  object: isObject$2,
	  number: isNumber$1,
	  string: isString$1,
	  boolean: isBoolean$1,
	  function: isFunction$1,
	  array: isArray$2,
	  weakMap: isWeakMap,
	  nodeList: isNodeList$1,
	  element: isElement$1,
	  textNode: isTextNode,
	  event: isEvent$1,
	  keyboardEvent: isKeyboardEvent,
	  cue: isCue,
	  track: isTrack,
	  promise: isPromise,
	  url: isUrl,
	  empty: isEmpty$1
	};

	var transitionEndEvent = function () {
	  var element = document.createElement('span');
	  var events = {
	    WebkitTransition: 'webkitTransitionEnd',
	    MozTransition: 'transitionend',
	    OTransition: 'oTransitionEnd otransitionend',
	    transition: 'transitionend'
	  };
	  var type = Object.keys(events).find(function (event) {
	    return element.style[event] !== undefined;
	  });
	  return is$1.string(type) ? events[type] : false;
	}(); // Force repaint of element

	function repaint(element, delay) {
	  setTimeout(function () {
	    try {
	      // eslint-disable-next-line no-param-reassign
	      element.hidden = true; // eslint-disable-next-line no-unused-expressions

	      element.offsetHeight; // eslint-disable-next-line no-param-reassign

	      element.hidden = false;
	    } catch (e) {// Do nothing
	    }
	  }, delay);
	}

	// ==========================================================================
	// Browser sniffing
	// Unfortunately, due to mixed support, UA sniffing is required
	// ==========================================================================
	var browser = {
	  isIE:
	  /* @cc_on!@ */
	   !!document.documentMode,
	  isEdge: window.navigator.userAgent.includes('Edge'),
	  isWebkit: 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent),
	  isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),
	  isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform)
	};

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$5 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction$1(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) { while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    } }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) { if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    } }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$5(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$5(true)
	};

	var $reduce = arrayReduce.left;



	var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
	var USES_TO_LENGTH$9 = arrayMethodUsesToLength('reduce', { 1: 0 });

	// `Array.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9 }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	function cloneDeep(object) {
	  return JSON.parse(JSON.stringify(object));
	} // Get a nested value in an object

	function getDeep(object, path) {
	  return path.split('.').reduce(function (obj, key) {
	    return obj && obj[key];
	  }, object);
	} // Deep extend destination object with N more objects

	function extend() {
	  var arguments$1 = arguments;

	  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    sources[_key - 1] = arguments$1[_key];
	  }

	  if (!sources.length) {
	    return target;
	  }

	  var source = sources.shift();

	  if (!is$1.object(source)) {
	    return target;
	  }

	  Object.keys(source).forEach(function (key) {
	    if (is$1.object(source[key])) {
	      if (!Object.keys(target).includes(key)) {
	        Object.assign(target, _defineProperty({}, key, {}));
	      }

	      extend(target[key], source[key]);
	    } else {
	      Object.assign(target, _defineProperty({}, key, source[key]));
	    }
	  });
	  return extend.apply(void 0, [target].concat(sources));
	}

	function wrap$1(elements, wrapper) {
	  // Convert `elements` to an array, if necessary.
	  var targets = elements.length ? elements : [elements]; // Loops backwards to prevent having to clone the wrapper on the
	  // first element (see `child` below).

	  Array.from(targets).reverse().forEach(function (element, index) {
	    var child = index > 0 ? wrapper.cloneNode(true) : wrapper; // Cache the current parent and sibling.

	    var parent = element.parentNode;
	    var sibling = element.nextSibling; // Wrap the element (is automatically removed from its current
	    // parent).

	    child.appendChild(element); // If the element had a sibling, insert the wrapper before
	    // the sibling to maintain the HTML structure; otherwise, just
	    // append it to the parent.

	    if (sibling) {
	      parent.insertBefore(child, sibling);
	    } else {
	      parent.appendChild(child);
	    }
	  });
	} // Set attributes

	function setAttributes(element, attributes) {
	  if (!is$1.element(element) || is$1.empty(attributes)) {
	    return;
	  } // Assume null and undefined attributes should be left out,
	  // Setting them would otherwise convert them to "null" and "undefined"


	  Object.entries(attributes).filter(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        value = _ref2[1];

	    return !is$1.nullOrUndefined(value);
	  }).forEach(function (_ref3) {
	    var _ref4 = _slicedToArray(_ref3, 2),
	        key = _ref4[0],
	        value = _ref4[1];

	    return element.setAttribute(key, value);
	  });
	} // Create a DocumentFragment

	function createElement(type, attributes, text) {
	  // Create a new <element>
	  var element = document.createElement(type); // Set all passed attributes

	  if (is$1.object(attributes)) {
	    setAttributes(element, attributes);
	  } // Add text node


	  if (is$1.string(text)) {
	    element.innerText = text;
	  } // Return built element


	  return element;
	} // Inaert an element after another

	function insertAfter(element, target) {
	  if (!is$1.element(element) || !is$1.element(target)) {
	    return;
	  }

	  target.parentNode.insertBefore(element, target.nextSibling);
	} // Insert a DocumentFragment

	function insertElement(type, parent, attributes, text) {
	  if (!is$1.element(parent)) {
	    return;
	  }

	  parent.appendChild(createElement(type, attributes, text));
	} // Remove element(s)

	function removeElement(element) {
	  if (is$1.nodeList(element) || is$1.array(element)) {
	    Array.from(element).forEach(removeElement);
	    return;
	  }

	  if (!is$1.element(element) || !is$1.element(element.parentNode)) {
	    return;
	  }

	  element.parentNode.removeChild(element);
	} // Remove all child elements

	function emptyElement(element) {
	  if (!is$1.element(element)) {
	    return;
	  }

	  var length = element.childNodes.length;

	  while (length > 0) {
	    element.removeChild(element.lastChild);
	    length -= 1;
	  }
	} // Replace element

	function replaceElement(newChild, oldChild) {
	  if (!is$1.element(oldChild) || !is$1.element(oldChild.parentNode) || !is$1.element(newChild)) {
	    return null;
	  }

	  oldChild.parentNode.replaceChild(newChild, oldChild);
	  return newChild;
	} // Get an attribute object from a string selector

	function getAttributesFromSelector(sel, existingAttributes) {
	  // For example:
	  // '.test' to { class: 'test' }
	  // '#test' to { id: 'test' }
	  // '[data-test="test"]' to { 'data-test': 'test' }
	  if (!is$1.string(sel) || is$1.empty(sel)) {
	    return {};
	  }

	  var attributes = {};
	  var existing = extend({}, existingAttributes);
	  sel.split(',').forEach(function (s) {
	    // Remove whitespace
	    var selector = s.trim();
	    var className = selector.replace('.', '');
	    var stripped = selector.replace(/[[\]]/g, ''); // Get the parts and value

	    var parts = stripped.split('=');

	    var _parts = _slicedToArray(parts, 1),
	        key = _parts[0];

	    var value = parts.length > 1 ? parts[1].replace(/["']/g, '') : ''; // Get the first character

	    var start = selector.charAt(0);

	    switch (start) {
	      case '.':
	        // Add to existing classname
	        if (is$1.string(existing.class)) {
	          attributes.class = "".concat(existing.class, " ").concat(className);
	        } else {
	          attributes.class = className;
	        }

	        break;

	      case '#':
	        // ID selector
	        attributes.id = selector.replace('#', '');
	        break;

	      case '[':
	        // Attribute selector
	        attributes[key] = value;
	        break;
	    }
	  });
	  return extend(existing, attributes);
	} // Toggle hidden

	function toggleHidden(element, hidden) {
	  if (!is$1.element(element)) {
	    return;
	  }

	  var hide = hidden;

	  if (!is$1.boolean(hide)) {
	    hide = !element.hidden;
	  } // eslint-disable-next-line no-param-reassign


	  element.hidden = hide;
	} // Mirror Element.classList.toggle, with IE compatibility for "force" argument

	function toggleClass(element, className, force) {
	  if (is$1.nodeList(element)) {
	    return Array.from(element).map(function (e) {
	      return toggleClass(e, className, force);
	    });
	  }

	  if (is$1.element(element)) {
	    var method = 'toggle';

	    if (typeof force !== 'undefined') {
	      method = force ? 'add' : 'remove';
	    }

	    element.classList[method](className);
	    return element.classList.contains(className);
	  }

	  return false;
	} // Has class name

	function hasClass(element, className) {
	  return is$1.element(element) && element.classList.contains(className);
	} // Element matches selector

	function matches$1(element, selector) {
	  var _Element = Element,
	      prototype = _Element.prototype;

	  function match() {
	    return Array.from(document.querySelectorAll(selector)).includes(this);
	  }

	  var method = prototype.matches || prototype.webkitMatchesSelector || prototype.mozMatchesSelector || prototype.msMatchesSelector || match;
	  return method.call(element, selector);
	} // Closest ancestor element matching selector (also tests element itself)

	function closest(element, selector) {
	  var _Element2 = Element,
	      prototype = _Element2.prototype; // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill

	  function closestElement() {
	    var el = this;

	    do {
	      if (matches$1.matches(el, selector)) { return el; }
	      el = el.parentElement || el.parentNode;
	    } while (el !== null && el.nodeType === 1);

	    return null;
	  }

	  var method = prototype.closest || closestElement;
	  return method.call(element, selector);
	} // Find all elements

	function getElements(selector) {
	  return this.elements.container.querySelectorAll(selector);
	} // Find a single element

	function getElement(selector) {
	  return this.elements.container.querySelector(selector);
	} // Set focus and tab focus class

	function setFocus() {
	  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	  var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (!is$1.element(element)) {
	    return;
	  } // Set regular focus


	  element.focus({
	    preventScroll: true
	  }); // If we want to mimic keyboard focus via tab

	  if (tabFocus) {
	    toggleClass(element, this.config.classNames.tabFocus);
	  }
	}

	var defaultCodecs = {
	  'audio/ogg': 'vorbis',
	  'audio/wav': '1',
	  'video/webm': 'vp8, vorbis',
	  'video/mp4': 'avc1.42E01E, mp4a.40.2',
	  'video/ogg': 'theora'
	}; // Check for feature support

	var support = {
	  // Basic support
	  audio: 'canPlayType' in document.createElement('audio'),
	  video: 'canPlayType' in document.createElement('video'),
	  // Check for support
	  // Basic functionality vs full UI
	  check: function check(type, provider, playsinline) {
	    var canPlayInline = browser.isIPhone && playsinline && support.playsinline;
	    var api = support[type] || provider !== 'html5';
	    var ui = api && support.rangeInput && (type !== 'video' || !browser.isIPhone || canPlayInline);
	    return {
	      api: api,
	      ui: ui
	    };
	  },
	  // Picture-in-picture support
	  // Safari & Chrome only currently
	  pip: function () {
	    if (browser.isIPhone) {
	      return false;
	    } // Safari
	    // https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls


	    if (is$1.function(createElement('video').webkitSetPresentationMode)) {
	      return true;
	    } // Chrome
	    // https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture


	    if (document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture) {
	      return true;
	    }

	    return false;
	  }(),
	  // Airplay support
	  // Safari only currently
	  airplay: is$1.function(window.WebKitPlaybackTargetAvailabilityEvent),
	  // Inline playback support
	  // https://webkit.org/blog/6784/new-video-policies-for-ios/
	  playsinline: 'playsInline' in document.createElement('video'),
	  // Check for mime type support against a player instance
	  // Credits: http://diveintohtml5.info/everything.html
	  // Related: http://www.leanbackplayer.com/test/h5mt.html
	  mime: function mime(input) {
	    if (is$1.empty(input)) {
	      return false;
	    }

	    var _input$split = input.split('/'),
	        _input$split2 = _slicedToArray(_input$split, 1),
	        mediaType = _input$split2[0];

	    var type = input; // Verify we're using HTML5 and there's no media type mismatch

	    if (!this.isHTML5 || mediaType !== this.type) {
	      return false;
	    } // Add codec if required


	    if (Object.keys(defaultCodecs).includes(type)) {
	      type += "; codecs=\"".concat(defaultCodecs[input], "\"");
	    }

	    try {
	      return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));
	    } catch (e) {
	      return false;
	    }
	  },
	  // Check for textTracks support
	  textTracks: 'textTracks' in document.createElement('video'),
	  // <input type="range"> Sliders
	  rangeInput: function () {
	    var range = document.createElement('input');
	    range.type = 'range';
	    return range.type === 'range';
	  }(),
	  // Touch
	  // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event
	  touch: 'ontouchstart' in document.documentElement,
	  // Detect transitions support
	  transitions: transitionEndEvent !== false,
	  // Reduced motion iOS & MacOS setting
	  // https://webkit.org/blog/7551/responsive-design-for-motion/
	  reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches
	};

	// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
	// https://www.youtube.com/watch?v=NPM6172J22g

	var supportsPassiveListeners = function () {
	  // Test via a getter in the options object to see if the passive property is accessed
	  var supported = false;

	  try {
	    var options = Object.defineProperty({}, 'passive', {
	      get: function get() {
	        supported = true;
	        return null;
	      }
	    });
	    window.addEventListener('test', null, options);
	    window.removeEventListener('test', null, options);
	  } catch (e) {// Do nothing
	  }

	  return supported;
	}(); // Toggle event listener


	function toggleListener(element, event, callback) {
	  var _this = this;

	  var toggle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	  var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	  var capture = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

	  // Bail if no element, event, or callback
	  if (!element || !('addEventListener' in element) || is$1.empty(event) || !is$1.function(callback)) {
	    return;
	  } // Allow multiple events


	  var events = event.split(' '); // Build options
	  // Default to just the capture boolean for browsers with no passive listener support

	  var options = capture; // If passive events listeners are supported

	  if (supportsPassiveListeners) {
	    options = {
	      // Whether the listener can be passive (i.e. default never prevented)
	      passive: passive,
	      // Whether the listener is a capturing listener or not
	      capture: capture
	    };
	  } // If a single node is passed, bind the event listener


	  events.forEach(function (type) {
	    if (_this && _this.eventListeners && toggle) {
	      // Cache event listener
	      _this.eventListeners.push({
	        element: element,
	        type: type,
	        callback: callback,
	        options: options
	      });
	    }

	    element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);
	  });
	} // Bind event handler

	function on(element) {
	  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var callback = arguments.length > 2 ? arguments[2] : undefined;
	  var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	  toggleListener.call(this, element, events, callback, true, passive, capture);
	} // Unbind event handler

	function off(element) {
	  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var callback = arguments.length > 2 ? arguments[2] : undefined;
	  var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	  toggleListener.call(this, element, events, callback, false, passive, capture);
	} // Bind once-only event handler

	function once(element) {
	  var _this2 = this;

	  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var callback = arguments.length > 2 ? arguments[2] : undefined;
	  var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
	  var capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

	  var onceCallback = function onceCallback() {
	    var arguments$1 = arguments;

	    off(element, events, onceCallback, passive, capture);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments$1[_key];
	    }

	    callback.apply(_this2, args);
	  };

	  toggleListener.call(this, element, events, onceCallback, true, passive, capture);
	} // Trigger event

	function triggerEvent(element) {
	  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	  // Bail if no element
	  if (!is$1.element(element) || is$1.empty(type)) {
	    return;
	  } // Create and dispatch the event


	  var event = new CustomEvent(type, {
	    bubbles: bubbles,
	    detail: _objectSpread2(_objectSpread2({}, detail), {}, {
	      plyr: this
	    })
	  }); // Dispatch the event

	  element.dispatchEvent(event);
	} // Unbind all cached event listeners

	function unbindListeners() {
	  if (this && this.eventListeners) {
	    this.eventListeners.forEach(function (item) {
	      var element = item.element,
	          type = item.type,
	          callback = item.callback,
	          options = item.options;
	      element.removeEventListener(type, callback, options);
	    });
	    this.eventListeners = [];
	  }
	} // Run method when / if player is ready

	function ready() {
	  var _this3 = this;

	  return new Promise(function (resolve) {
	    return _this3.ready ? setTimeout(resolve, 0) : on.call(_this3, _this3.elements.container, 'ready', resolve);
	  }).then(function () {});
	}

	/**
	 * Silence a Promise-like object.
	 * This is useful for avoiding non-harmful, but potentially confusing "uncaught
	 * play promise" rejection error messages.
	 * @param  {Object} value An object that may or may not be `Promise`-like.
	 */

	function silencePromise(value) {
	  if (is$1.promise(value)) {
	    value.then(null, function () {});
	  }
	}

	function validateRatio(input) {
	  if (!is$1.array(input) && (!is$1.string(input) || !input.includes(':'))) {
	    return false;
	  }

	  var ratio = is$1.array(input) ? input : input.split(':');
	  return ratio.map(Number).every(is$1.number);
	}
	function reduceAspectRatio(ratio) {
	  if (!is$1.array(ratio) || !ratio.every(is$1.number)) {
	    return null;
	  }

	  var _ratio = _slicedToArray(ratio, 2),
	      width = _ratio[0],
	      height = _ratio[1];

	  var getDivider = function getDivider(w, h) {
	    return h === 0 ? w : getDivider(h, w % h);
	  };

	  var divider = getDivider(width, height);
	  return [width / divider, height / divider];
	}
	function getAspectRatio(input) {
	  var parse = function parse(ratio) {
	    return validateRatio(ratio) ? ratio.split(':').map(Number) : null;
	  }; // Try provided ratio


	  var ratio = parse(input); // Get from config

	  if (ratio === null) {
	    ratio = parse(this.config.ratio);
	  } // Get from embed


	  if (ratio === null && !is$1.empty(this.embed) && is$1.array(this.embed.ratio)) {
	    ratio = this.embed.ratio;
	  } // Get from HTML5 video


	  if (ratio === null && this.isHTML5) {
	    var _this$media = this.media,
	        videoWidth = _this$media.videoWidth,
	        videoHeight = _this$media.videoHeight;
	    ratio = reduceAspectRatio([videoWidth, videoHeight]);
	  }

	  return ratio;
	} // Set aspect ratio for responsive container

	function setAspectRatio(input) {
	  if (!this.isVideo) {
	    return {};
	  }

	  var wrapper = this.elements.wrapper;
	  var ratio = getAspectRatio.call(this, input);

	  var _ref = is$1.array(ratio) ? ratio : [0, 0],
	      _ref2 = _slicedToArray(_ref, 2),
	      w = _ref2[0],
	      h = _ref2[1];

	  var padding = 100 / w * h;
	  wrapper.style.paddingBottom = "".concat(padding, "%"); // For Vimeo we have an extra <div> to hide the standard controls and UI

	  if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
	    var height = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10);
	    var offset = (height - padding) / (height / 50);
	    this.media.style.transform = "translateY(-".concat(offset, "%)");
	  } else if (this.isHTML5) {
	    wrapper.classList.toggle(this.config.classNames.videoFixedRatio, ratio !== null);
	  }

	  return {
	    padding: padding,
	    ratio: ratio
	  };
	}

	var html5 = {
	  getSources: function getSources() {
	    var _this = this;

	    if (!this.isHTML5) {
	      return [];
	    }

	    var sources = Array.from(this.media.querySelectorAll('source')); // Filter out unsupported sources (if type is specified)

	    return sources.filter(function (source) {
	      var type = source.getAttribute('type');

	      if (is$1.empty(type)) {
	        return true;
	      }

	      return support.mime.call(_this, type);
	    });
	  },
	  // Get quality levels
	  getQualityOptions: function getQualityOptions() {
	    // Whether we're forcing all options (e.g. for streaming)
	    if (this.config.quality.forced) {
	      return this.config.quality.options;
	    } // Get sizes from <source> elements


	    return html5.getSources.call(this).map(function (source) {
	      return Number(source.getAttribute('size'));
	    }).filter(Boolean);
	  },
	  setup: function setup() {
	    if (!this.isHTML5) {
	      return;
	    }

	    var player = this; // Set speed options from config

	    player.options.speed = player.config.speed.options; // Set aspect ratio if fixed

	    if (!is$1.empty(this.config.ratio)) {
	      setAspectRatio.call(player);
	    } // Quality


	    Object.defineProperty(player.media, 'quality', {
	      get: function get() {
	        // Get sources
	        var sources = html5.getSources.call(player);
	        var source = sources.find(function (s) {
	          return s.getAttribute('src') === player.source;
	        }); // Return size, if match is found

	        return source && Number(source.getAttribute('size'));
	      },
	      set: function set(input) {
	        if (player.quality === input) {
	          return;
	        } // If we're using an an external handler...


	        if (player.config.quality.forced && is$1.function(player.config.quality.onChange)) {
	          player.config.quality.onChange(input);
	        } else {
	          // Get sources
	          var sources = html5.getSources.call(player); // Get first match for requested size

	          var source = sources.find(function (s) {
	            return Number(s.getAttribute('size')) === input;
	          }); // No matching source found

	          if (!source) {
	            return;
	          } // Get current state


	          var _player$media = player.media,
	              currentTime = _player$media.currentTime,
	              paused = _player$media.paused,
	              preload = _player$media.preload,
	              readyState = _player$media.readyState,
	              playbackRate = _player$media.playbackRate; // Set new source

	          player.media.src = source.getAttribute('src'); // Prevent loading if preload="none" and the current source isn't loaded (#1044)

	          if (preload !== 'none' || readyState) {
	            // Restore time
	            player.once('loadedmetadata', function () {
	              player.speed = playbackRate;
	              player.currentTime = currentTime; // Resume playing

	              if (!paused) {
	                silencePromise(player.play());
	              }
	            }); // Load new source

	            player.media.load();
	          }
	        } // Trigger change event


	        triggerEvent.call(player, player.media, 'qualitychange', false, {
	          quality: input
	        });
	      }
	    });
	  },
	  // Cancel current network requests
	  // See https://github.com/sampotts/plyr/issues/174
	  cancelRequests: function cancelRequests() {
	    if (!this.isHTML5) {
	      return;
	    } // Remove child sources


	    removeElement(html5.getSources.call(this)); // Set blank video src attribute
	    // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error
	    // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection

	    this.media.setAttribute('src', this.config.blankVideo); // Load the new empty source
	    // This will cancel existing requests
	    // See https://github.com/sampotts/plyr/issues/174

	    this.media.load(); // Debugging

	    this.debug.log('Cancelled network requests');
	  }
	};

	function dedupe(array) {
	  if (!is$1.array(array)) {
	    return array;
	  }

	  return array.filter(function (item, index) {
	    return array.indexOf(item) === index;
	  });
	} // Get the closest value in an array

	function closest$1(array, value) {
	  if (!is$1.array(array) || !array.length) {
	    return null;
	  }

	  return array.reduce(function (prev, curr) {
	    return Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev;
	  });
	}

	var defineProperty$6 = objectDefineProperty.f;
	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;





	var setInternalState$7 = internalState.set;



	var MATCH$2 = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype$1 = NativeRegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;

	// "new" should create a new object, old webkit bug
	var CORRECT_NEW = new NativeRegExp(re1) !== re1;

	var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;

	var FORCED$4 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
	  re2[MATCH$2] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	})));

	// `RegExp` constructor
	// https://tc39.github.io/ecma262/#sec-regexp-constructor
	if (FORCED$4) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = this instanceof RegExpWrapper;
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var sticky;

	    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
	      return pattern;
	    }

	    if (CORRECT_NEW) {
	      if (patternIsRegExp && !flagsAreUndefined) { pattern = pattern.source; }
	    } else if (pattern instanceof RegExpWrapper) {
	      if (flagsAreUndefined) { flags = regexpFlags.call(pattern); }
	      pattern = pattern.source;
	    }

	    if (UNSUPPORTED_Y$2) {
	      sticky = !!flags && flags.indexOf('y') > -1;
	      if (sticky) { flags = flags.replace(/y/g, ''); }
	    }

	    var result = inheritIfRequired(
	      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
	      thisIsRegExp ? this : RegExpPrototype$1,
	      RegExpWrapper
	    );

	    if (UNSUPPORTED_Y$2 && sticky) { setInternalState$7(result, { sticky: sticky }); }

	    return result;
	  };
	  var proxy = function (key) {
	    key in RegExpWrapper || defineProperty$6(RegExpWrapper, key, {
	      configurable: true,
	      get: function () { return NativeRegExp[key]; },
	      set: function (it) { NativeRegExp[key] = it; }
	    });
	  };
	  var keys$2 = getOwnPropertyNames$1(NativeRegExp);
	  var index = 0;
	  while (keys$2.length > index) { proxy(keys$2[index++]); }
	  RegExpPrototype$1.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype$1;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
	setSpecies('RegExp');

	function generateId(prefix) {
	  return "".concat(prefix, "-").concat(Math.floor(Math.random() * 10000));
	} // Format string

	function format$1(input) {
	  var arguments$1 = arguments;

	  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments$1[_key];
	  }

	  if (is$1.empty(input)) {
	    return input;
	  }

	  return input.toString().replace(/{(\d+)}/g, function (match, i) {
	    return args[i].toString();
	  });
	} // Get percentage

	function getPercentage(current, max) {
	  if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {
	    return 0;
	  }

	  return (current / max * 100).toFixed(2);
	} // Replace all occurances of a string in a string

	var replaceAll = function replaceAll() {
	  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var find = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	  return input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'), 'g'), replace.toString());
	}; // Convert to title case

	var toTitleCase = function toTitleCase() {
	  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  return input.toString().replace(/\w\S*/g, function (text) {
	    return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();
	  });
	}; // Convert string to pascalCase

	function toPascalCase() {
	  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var string = input.toString(); // Convert kebab case

	  string = replaceAll(string, '-', ' '); // Convert snake case

	  string = replaceAll(string, '_', ' '); // Convert to title case

	  string = toTitleCase(string); // Convert to pascal case

	  return replaceAll(string, ' ', '');
	} // Convert string to pascalCase

	function toCamelCase() {
	  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var string = input.toString(); // Convert to pascal case

	  string = toPascalCase(string); // Convert first character to lowercase

	  return string.charAt(0).toLowerCase() + string.slice(1);
	} // Remove HTML from a string

	function stripHTML(source) {
	  var fragment = document.createDocumentFragment();
	  var element = document.createElement('div');
	  fragment.appendChild(element);
	  element.innerHTML = source;
	  return fragment.firstChild.innerText;
	} // Like outerHTML, but also works for DocumentFragment

	function getHTML(element) {
	  var wrapper = document.createElement('div');
	  wrapper.appendChild(element);
	  return wrapper.innerHTML;
	}

	var resources = {
	  pip: 'PIP',
	  airplay: 'AirPlay',
	  html5: 'HTML5',
	  vimeo: 'Vimeo',
	  youtube: 'YouTube'
	};
	var i18n = {
	  get: function get() {
	    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    if (is$1.empty(key) || is$1.empty(config)) {
	      return '';
	    }

	    var string = getDeep(config.i18n, key);

	    if (is$1.empty(string)) {
	      if (Object.keys(resources).includes(key)) {
	        return resources[key];
	      }

	      return '';
	    }

	    var replace = {
	      '{seektime}': config.seekTime,
	      '{title}': config.title
	    };
	    Object.entries(replace).forEach(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 2),
	          k = _ref2[0],
	          v = _ref2[1];

	      string = replaceAll(string, k, v);
	    });
	    return string;
	  }
	};

	var Storage = /*#__PURE__*/function () {
	  function Storage(player) {
	    _classCallCheck(this, Storage);

	    this.enabled = player.config.storage.enabled;
	    this.key = player.config.storage.key;
	  } // Check for actual support (see if we can use it)


	  _createClass(Storage, [{
	    key: "get",
	    value: function get(key) {
	      if (!Storage.supported || !this.enabled) {
	        return null;
	      }

	      var store = window.localStorage.getItem(this.key);

	      if (is$1.empty(store)) {
	        return null;
	      }

	      var json = JSON.parse(store);
	      return is$1.string(key) && key.length ? json[key] : json;
	    }
	  }, {
	    key: "set",
	    value: function set(object) {
	      // Bail if we don't have localStorage support or it's disabled
	      if (!Storage.supported || !this.enabled) {
	        return;
	      } // Can only store objectst


	      if (!is$1.object(object)) {
	        return;
	      } // Get current storage


	      var storage = this.get(); // Default to empty object

	      if (is$1.empty(storage)) {
	        storage = {};
	      } // Update the working copy of the values


	      extend(storage, object); // Update storage

	      window.localStorage.setItem(this.key, JSON.stringify(storage));
	    }
	  }], [{
	    key: "supported",
	    get: function get() {
	      try {
	        if (!('localStorage' in window)) {
	          return false;
	        }

	        var test = '___test'; // Try to use it (it might be disabled, e.g. user is in private mode)
	        // see: https://github.com/sampotts/plyr/issues/131

	        window.localStorage.setItem(test, test);
	        window.localStorage.removeItem(test);
	        return true;
	      } catch (e) {
	        return false;
	      }
	    }
	  }]);

	  return Storage;
	}();

	// ==========================================================================
	// Fetch wrapper
	// Using XHR to avoid issues with older browsers
	// ==========================================================================
	function fetch$1(url) {
	  var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
	  return new Promise(function (resolve, reject) {
	    try {
	      var request = new XMLHttpRequest(); // Check for CORS support

	      if (!('withCredentials' in request)) {
	        return;
	      }

	      request.addEventListener('load', function () {
	        if (responseType === 'text') {
	          try {
	            resolve(JSON.parse(request.responseText));
	          } catch (e) {
	            resolve(request.responseText);
	          }
	        } else {
	          resolve(request.response);
	        }
	      });
	      request.addEventListener('error', function () {
	        throw new Error(request.status);
	      });
	      request.open('GET', url, true); // Set the required response type

	      request.responseType = responseType;
	      request.send();
	    } catch (e) {
	      reject(e);
	    }
	  });
	}

	// ==========================================================================

	function loadSprite(url, id) {
	  if (!is$1.string(url)) {
	    return;
	  }

	  var prefix = 'cache';
	  var hasId = is$1.string(id);
	  var isCached = false;

	  var exists = function exists() {
	    return document.getElementById(id) !== null;
	  };

	  var update = function update(container, data) {
	    // eslint-disable-next-line no-param-reassign
	    container.innerHTML = data; // Check again incase of race condition

	    if (hasId && exists()) {
	      return;
	    } // Inject the SVG to the body


	    document.body.insertAdjacentElement('afterbegin', container);
	  }; // Only load once if ID set


	  if (!hasId || !exists()) {
	    var useStorage = Storage.supported; // Create container

	    var container = document.createElement('div');
	    container.setAttribute('hidden', '');

	    if (hasId) {
	      container.setAttribute('id', id);
	    } // Check in cache


	    if (useStorage) {
	      var cached = window.localStorage.getItem("".concat(prefix, "-").concat(id));
	      isCached = cached !== null;

	      if (isCached) {
	        var data = JSON.parse(cached);
	        update(container, data.content);
	      }
	    } // Get the sprite


	    fetch$1(url).then(function (result) {
	      if (is$1.empty(result)) {
	        return;
	      }

	      if (useStorage) {
	        window.localStorage.setItem("".concat(prefix, "-").concat(id), JSON.stringify({
	          content: result
	        }));
	      }

	      update(container, result);
	    }).catch(function () {});
	  }
	}

	var ceil$1 = Math.ceil;
	var floor$5 = Math.floor;

	// `Math.trunc` method
	// https://tc39.github.io/ecma262/#sec-math.trunc
	_export({ target: 'Math', stat: true }, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$5 : ceil$1)(it);
	  }
	});

	var getHours = function getHours(value) {
	  return Math.trunc(value / 60 / 60 % 60, 10);
	};
	var getMinutes = function getMinutes(value) {
	  return Math.trunc(value / 60 % 60, 10);
	};
	var getSeconds = function getSeconds(value) {
	  return Math.trunc(value % 60, 10);
	}; // Format time to UI friendly string

	function formatTime() {
	  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  var displayHours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  // Bail if the value isn't a number
	  if (!is$1.number(time)) {
	    return formatTime(undefined, displayHours, inverted);
	  } // Format time component to add leading zero


	  var format = function format(value) {
	    return "0".concat(value).slice(-2);
	  }; // Breakdown to hours, mins, secs


	  var hours = getHours(time);
	  var mins = getMinutes(time);
	  var secs = getSeconds(time); // Do we need to display hours?

	  if (displayHours || hours > 0) {
	    hours = "".concat(hours, ":");
	  } else {
	    hours = '';
	  } // Render


	  return "".concat(inverted && time > 0 ? '-' : '').concat(hours).concat(format(mins), ":").concat(format(secs));
	}

	var controls = {
	  // Get icon URL
	  getIconUrl: function getIconUrl() {
	    var url = new URL(this.config.iconUrl, window.location);
	    var cors = url.host !== window.location.host || browser.isIE && !window.svg4everybody;
	    return {
	      url: this.config.iconUrl,
	      cors: cors
	    };
	  },
	  // Find the UI controls
	  findElements: function findElements() {
	    try {
	      this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper); // Buttons

	      this.elements.buttons = {
	        play: getElements.call(this, this.config.selectors.buttons.play),
	        pause: getElement.call(this, this.config.selectors.buttons.pause),
	        restart: getElement.call(this, this.config.selectors.buttons.restart),
	        rewind: getElement.call(this, this.config.selectors.buttons.rewind),
	        fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),
	        mute: getElement.call(this, this.config.selectors.buttons.mute),
	        pip: getElement.call(this, this.config.selectors.buttons.pip),
	        airplay: getElement.call(this, this.config.selectors.buttons.airplay),
	        settings: getElement.call(this, this.config.selectors.buttons.settings),
	        captions: getElement.call(this, this.config.selectors.buttons.captions),
	        fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen)
	      }; // Progress

	      this.elements.progress = getElement.call(this, this.config.selectors.progress); // Inputs

	      this.elements.inputs = {
	        seek: getElement.call(this, this.config.selectors.inputs.seek),
	        volume: getElement.call(this, this.config.selectors.inputs.volume)
	      }; // Display

	      this.elements.display = {
	        buffer: getElement.call(this, this.config.selectors.display.buffer),
	        currentTime: getElement.call(this, this.config.selectors.display.currentTime),
	        duration: getElement.call(this, this.config.selectors.display.duration)
	      }; // Seek tooltip

	      if (is$1.element(this.elements.progress)) {
	        this.elements.display.seekTooltip = this.elements.progress.querySelector(".".concat(this.config.classNames.tooltip));
	      }

	      return true;
	    } catch (error) {
	      // Log it
	      this.debug.warn('It looks like there is a problem with your custom controls HTML', error); // Restore native video controls

	      this.toggleNativeControls(true);
	      return false;
	    }
	  },
	  // Create <svg> icon
	  createIcon: function createIcon(type, attributes) {
	    var namespace = 'http://www.w3.org/2000/svg';
	    var iconUrl = controls.getIconUrl.call(this);
	    var iconPath = "".concat(!iconUrl.cors ? iconUrl.url : '', "#").concat(this.config.iconPrefix); // Create <svg>

	    var icon = document.createElementNS(namespace, 'svg');
	    setAttributes(icon, extend(attributes, {
	      'aria-hidden': 'true',
	      focusable: 'false'
	    })); // Create the <use> to reference sprite

	    var use = document.createElementNS(namespace, 'use');
	    var path = "".concat(iconPath, "-").concat(type); // Set `href` attributes
	    // https://github.com/sampotts/plyr/issues/460
	    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href

	    if ('href' in use) {
	      use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
	    } // Always set the older attribute even though it's "deprecated" (it'll be around for ages)


	    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path); // Add <use> to <svg>

	    icon.appendChild(use);
	    return icon;
	  },
	  // Create hidden text label
	  createLabel: function createLabel(key) {
	    var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var text = i18n.get(key, this.config);

	    var attributes = _objectSpread2(_objectSpread2({}, attr), {}, {
	      class: [attr.class, this.config.classNames.hidden].filter(Boolean).join(' ')
	    });

	    return createElement('span', attributes, text);
	  },
	  // Create a badge
	  createBadge: function createBadge(text) {
	    if (is$1.empty(text)) {
	      return null;
	    }

	    var badge = createElement('span', {
	      class: this.config.classNames.menu.value
	    });
	    badge.appendChild(createElement('span', {
	      class: this.config.classNames.menu.badge
	    }, text));
	    return badge;
	  },
	  // Create a <button>
	  createButton: function createButton(buttonType, attr) {
	    var _this = this;

	    var attributes = extend({}, attr);
	    var type = toCamelCase(buttonType);
	    var props = {
	      element: 'button',
	      toggle: false,
	      label: null,
	      icon: null,
	      labelPressed: null,
	      iconPressed: null
	    };
	    ['element', 'icon', 'label'].forEach(function (key) {
	      if (Object.keys(attributes).includes(key)) {
	        props[key] = attributes[key];
	        delete attributes[key];
	      }
	    }); // Default to 'button' type to prevent form submission

	    if (props.element === 'button' && !Object.keys(attributes).includes('type')) {
	      attributes.type = 'button';
	    } // Set class name


	    if (Object.keys(attributes).includes('class')) {
	      if (!attributes.class.split(' ').some(function (c) {
	        return c === _this.config.classNames.control;
	      })) {
	        extend(attributes, {
	          class: "".concat(attributes.class, " ").concat(this.config.classNames.control)
	        });
	      }
	    } else {
	      attributes.class = this.config.classNames.control;
	    } // Large play button


	    switch (buttonType) {
	      case 'play':
	        props.toggle = true;
	        props.label = 'play';
	        props.labelPressed = 'pause';
	        props.icon = 'play';
	        props.iconPressed = 'pause';
	        break;

	      case 'mute':
	        props.toggle = true;
	        props.label = 'mute';
	        props.labelPressed = 'unmute';
	        props.icon = 'volume';
	        props.iconPressed = 'muted';
	        break;

	      case 'captions':
	        props.toggle = true;
	        props.label = 'enableCaptions';
	        props.labelPressed = 'disableCaptions';
	        props.icon = 'captions-off';
	        props.iconPressed = 'captions-on';
	        break;

	      case 'fullscreen':
	        props.toggle = true;
	        props.label = 'enterFullscreen';
	        props.labelPressed = 'exitFullscreen';
	        props.icon = 'enter-fullscreen';
	        props.iconPressed = 'exit-fullscreen';
	        break;

	      case 'play-large':
	        attributes.class += " ".concat(this.config.classNames.control, "--overlaid");
	        type = 'play';
	        props.label = 'play';
	        props.icon = 'play';
	        break;

	      default:
	        if (is$1.empty(props.label)) {
	          props.label = type;
	        }

	        if (is$1.empty(props.icon)) {
	          props.icon = buttonType;
	        }

	    }

	    var button = createElement(props.element); // Setup toggle icon and labels

	    if (props.toggle) {
	      // Icon
	      button.appendChild(controls.createIcon.call(this, props.iconPressed, {
	        class: 'icon--pressed'
	      }));
	      button.appendChild(controls.createIcon.call(this, props.icon, {
	        class: 'icon--not-pressed'
	      })); // Label/Tooltip

	      button.appendChild(controls.createLabel.call(this, props.labelPressed, {
	        class: 'label--pressed'
	      }));
	      button.appendChild(controls.createLabel.call(this, props.label, {
	        class: 'label--not-pressed'
	      }));
	    } else {
	      button.appendChild(controls.createIcon.call(this, props.icon));
	      button.appendChild(controls.createLabel.call(this, props.label));
	    } // Merge and set attributes


	    extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));
	    setAttributes(button, attributes); // We have multiple play buttons

	    if (type === 'play') {
	      if (!is$1.array(this.elements.buttons[type])) {
	        this.elements.buttons[type] = [];
	      }

	      this.elements.buttons[type].push(button);
	    } else {
	      this.elements.buttons[type] = button;
	    }

	    return button;
	  },
	  // Create an <input type='range'>
	  createRange: function createRange(type, attributes) {
	    // Seek input
	    var input = createElement('input', extend(getAttributesFromSelector(this.config.selectors.inputs[type]), {
	      type: 'range',
	      min: 0,
	      max: 100,
	      step: 0.01,
	      value: 0,
	      autocomplete: 'off',
	      // A11y fixes for https://github.com/sampotts/plyr/issues/905
	      role: 'slider',
	      'aria-label': i18n.get(type, this.config),
	      'aria-valuemin': 0,
	      'aria-valuemax': 100,
	      'aria-valuenow': 0
	    }, attributes));
	    this.elements.inputs[type] = input; // Set the fill for webkit now

	    controls.updateRangeFill.call(this, input); // Improve support on touch devices

	    RangeTouch.setup(input);
	    return input;
	  },
	  // Create a <progress>
	  createProgress: function createProgress(type, attributes) {
	    var progress = createElement('progress', extend(getAttributesFromSelector(this.config.selectors.display[type]), {
	      min: 0,
	      max: 100,
	      value: 0,
	      role: 'progressbar',
	      'aria-hidden': true
	    }, attributes)); // Create the label inside

	    if (type !== 'volume') {
	      progress.appendChild(createElement('span', null, '0'));
	      var suffixKey = {
	        played: 'played',
	        buffer: 'buffered'
	      }[type];
	      var suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';
	      progress.innerText = "% ".concat(suffix.toLowerCase());
	    }

	    this.elements.display[type] = progress;
	    return progress;
	  },
	  // Create time display
	  createTime: function createTime(type, attrs) {
	    var attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);
	    var container = createElement('div', extend(attributes, {
	      class: "".concat(attributes.class ? attributes.class : '', " ").concat(this.config.classNames.display.time, " ").trim(),
	      'aria-label': i18n.get(type, this.config)
	    }), '00:00'); // Reference for updates

	    this.elements.display[type] = container;
	    return container;
	  },
	  // Bind keyboard shortcuts for a menu item
	  // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
	  bindMenuItemShortcuts: function bindMenuItemShortcuts(menuItem, type) {
	    var _this2 = this;

	    // Navigate through menus via arrow keys and space
	    on.call(this, menuItem, 'keydown keyup', function (event) {
	      // We only care about space and ⬆️ ⬇️️ ➡️
	      if (![32, 38, 39, 40].includes(event.which)) {
	        return;
	      } // Prevent play / seek


	      event.preventDefault();
	      event.stopPropagation(); // We're just here to prevent the keydown bubbling

	      if (event.type === 'keydown') {
	        return;
	      }

	      var isRadioButton = matches$1(menuItem, '[role="menuitemradio"]'); // Show the respective menu

	      if (!isRadioButton && [32, 39].includes(event.which)) {
	        controls.showMenuPanel.call(_this2, type, true);
	      } else {
	        var target;

	        if (event.which !== 32) {
	          if (event.which === 40 || isRadioButton && event.which === 39) {
	            target = menuItem.nextElementSibling;

	            if (!is$1.element(target)) {
	              target = menuItem.parentNode.firstElementChild;
	            }
	          } else {
	            target = menuItem.previousElementSibling;

	            if (!is$1.element(target)) {
	              target = menuItem.parentNode.lastElementChild;
	            }
	          }

	          setFocus.call(_this2, target, true);
	        }
	      }
	    }, false); // Enter will fire a `click` event but we still need to manage focus
	    // So we bind to keyup which fires after and set focus here

	    on.call(this, menuItem, 'keyup', function (event) {
	      if (event.which !== 13) {
	        return;
	      }

	      controls.focusFirstMenuItem.call(_this2, null, true);
	    });
	  },
	  // Create a settings menu item
	  createMenuItem: function createMenuItem(_ref) {
	    var _this3 = this;

	    var value = _ref.value,
	        list = _ref.list,
	        type = _ref.type,
	        title = _ref.title,
	        _ref$badge = _ref.badge,
	        badge = _ref$badge === void 0 ? null : _ref$badge,
	        _ref$checked = _ref.checked,
	        checked = _ref$checked === void 0 ? false : _ref$checked;
	    var attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);
	    var menuItem = createElement('button', extend(attributes, {
	      type: 'button',
	      role: 'menuitemradio',
	      class: "".concat(this.config.classNames.control, " ").concat(attributes.class ? attributes.class : '').trim(),
	      'aria-checked': checked,
	      value: value
	    }));
	    var flex = createElement('span'); // We have to set as HTML incase of special characters

	    flex.innerHTML = title;

	    if (is$1.element(badge)) {
	      flex.appendChild(badge);
	    }

	    menuItem.appendChild(flex); // Replicate radio button behaviour

	    Object.defineProperty(menuItem, 'checked', {
	      enumerable: true,
	      get: function get() {
	        return menuItem.getAttribute('aria-checked') === 'true';
	      },
	      set: function set(check) {
	        // Ensure exclusivity
	        if (check) {
	          Array.from(menuItem.parentNode.children).filter(function (node) {
	            return matches$1(node, '[role="menuitemradio"]');
	          }).forEach(function (node) {
	            return node.setAttribute('aria-checked', 'false');
	          });
	        }

	        menuItem.setAttribute('aria-checked', check ? 'true' : 'false');
	      }
	    });
	    this.listeners.bind(menuItem, 'click keyup', function (event) {
	      if (is$1.keyboardEvent(event) && event.which !== 32) {
	        return;
	      }

	      event.preventDefault();
	      event.stopPropagation();
	      menuItem.checked = true;

	      switch (type) {
	        case 'language':
	          _this3.currentTrack = Number(value);
	          break;

	        case 'quality':
	          _this3.quality = value;
	          break;

	        case 'speed':
	          _this3.speed = parseFloat(value);
	          break;
	      }

	      controls.showMenuPanel.call(_this3, 'home', is$1.keyboardEvent(event));
	    }, type, false);
	    controls.bindMenuItemShortcuts.call(this, menuItem, type);
	    list.appendChild(menuItem);
	  },
	  // Format a time for display
	  formatTime: function formatTime$1() {
	    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    // Bail if the value isn't a number
	    if (!is$1.number(time)) {
	      return time;
	    } // Always display hours if duration is over an hour


	    var forceHours = getHours(this.duration) > 0;
	    return formatTime(time, forceHours, inverted);
	  },
	  // Update the displayed time
	  updateTimeDisplay: function updateTimeDisplay() {
	    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    // Bail if there's no element to display or the value isn't a number
	    if (!is$1.element(target) || !is$1.number(time)) {
	      return;
	    } // eslint-disable-next-line no-param-reassign


	    target.innerText = controls.formatTime(time, inverted);
	  },
	  // Update volume UI and storage
	  updateVolume: function updateVolume() {
	    if (!this.supported.ui) {
	      return;
	    } // Update range


	    if (is$1.element(this.elements.inputs.volume)) {
	      controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);
	    } // Update mute state


	    if (is$1.element(this.elements.buttons.mute)) {
	      this.elements.buttons.mute.pressed = this.muted || this.volume === 0;
	    }
	  },
	  // Update seek value and lower fill
	  setRange: function setRange(target) {
	    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    if (!is$1.element(target)) {
	      return;
	    } // eslint-disable-next-line


	    target.value = value; // Webkit range fill

	    controls.updateRangeFill.call(this, target);
	  },
	  // Update <progress> elements
	  updateProgress: function updateProgress(event) {
	    var _this4 = this;

	    if (!this.supported.ui || !is$1.event(event)) {
	      return;
	    }

	    var value = 0;

	    var setProgress = function setProgress(target, input) {
	      var val = is$1.number(input) ? input : 0;
	      var progress = is$1.element(target) ? target : _this4.elements.display.buffer; // Update value and label

	      if (is$1.element(progress)) {
	        progress.value = val; // Update text label inside

	        var label = progress.getElementsByTagName('span')[0];

	        if (is$1.element(label)) {
	          label.childNodes[0].nodeValue = val;
	        }
	      }
	    };

	    if (event) {
	      switch (event.type) {
	        // Video playing
	        case 'timeupdate':
	        case 'seeking':
	        case 'seeked':
	          value = getPercentage(this.currentTime, this.duration); // Set seek range value only if it's a 'natural' time event

	          if (event.type === 'timeupdate') {
	            controls.setRange.call(this, this.elements.inputs.seek, value);
	          }

	          break;
	        // Check buffer status

	        case 'playing':
	        case 'progress':
	          setProgress(this.elements.display.buffer, this.buffered * 100);
	          break;
	      }
	    }
	  },
	  // Webkit polyfill for lower fill range
	  updateRangeFill: function updateRangeFill(target) {
	    // Get range from event if event passed
	    var range = is$1.event(target) ? target.target : target; // Needs to be a valid <input type='range'>

	    if (!is$1.element(range) || range.getAttribute('type') !== 'range') {
	      return;
	    } // Set aria values for https://github.com/sampotts/plyr/issues/905


	    if (matches$1(range, this.config.selectors.inputs.seek)) {
	      range.setAttribute('aria-valuenow', this.currentTime);
	      var currentTime = controls.formatTime(this.currentTime);
	      var duration = controls.formatTime(this.duration);
	      var format = i18n.get('seekLabel', this.config);
	      range.setAttribute('aria-valuetext', format.replace('{currentTime}', currentTime).replace('{duration}', duration));
	    } else if (matches$1(range, this.config.selectors.inputs.volume)) {
	      var percent = range.value * 100;
	      range.setAttribute('aria-valuenow', percent);
	      range.setAttribute('aria-valuetext', "".concat(percent.toFixed(1), "%"));
	    } else {
	      range.setAttribute('aria-valuenow', range.value);
	    } // WebKit only


	    if (!browser.isWebkit) {
	      return;
	    } // Set CSS custom property


	    range.style.setProperty('--value', "".concat(range.value / range.max * 100, "%"));
	  },
	  // Update hover tooltip for seeking
	  updateSeekTooltip: function updateSeekTooltip(event) {
	    var _this5 = this;

	    // Bail if setting not true
	    if (!this.config.tooltips.seek || !is$1.element(this.elements.inputs.seek) || !is$1.element(this.elements.display.seekTooltip) || this.duration === 0) {
	      return;
	    }

	    var visible = "".concat(this.config.classNames.tooltip, "--visible");

	    var toggle = function toggle(show) {
	      return toggleClass(_this5.elements.display.seekTooltip, visible, show);
	    }; // Hide on touch


	    if (this.touch) {
	      toggle(false);
	      return;
	    } // Determine percentage, if already visible


	    var percent = 0;
	    var clientRect = this.elements.progress.getBoundingClientRect();

	    if (is$1.event(event)) {
	      percent = 100 / clientRect.width * (event.pageX - clientRect.left);
	    } else if (hasClass(this.elements.display.seekTooltip, visible)) {
	      percent = parseFloat(this.elements.display.seekTooltip.style.left, 10);
	    } else {
	      return;
	    } // Set bounds


	    if (percent < 0) {
	      percent = 0;
	    } else if (percent > 100) {
	      percent = 100;
	    } // Display the time a click would seek to


	    controls.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * percent); // Set position

	    this.elements.display.seekTooltip.style.left = "".concat(percent, "%"); // Show/hide the tooltip
	    // If the event is a moues in/out and percentage is inside bounds

	    if (is$1.event(event) && ['mouseenter', 'mouseleave'].includes(event.type)) {
	      toggle(event.type === 'mouseenter');
	    }
	  },
	  // Handle time change event
	  timeUpdate: function timeUpdate(event) {
	    // Only invert if only one time element is displayed and used for both duration and currentTime
	    var invert = !is$1.element(this.elements.display.duration) && this.config.invertTime; // Duration

	    controls.updateTimeDisplay.call(this, this.elements.display.currentTime, invert ? this.duration - this.currentTime : this.currentTime, invert); // Ignore updates while seeking

	    if (event && event.type === 'timeupdate' && this.media.seeking) {
	      return;
	    } // Playing progress


	    controls.updateProgress.call(this, event);
	  },
	  // Show the duration on metadataloaded or durationchange events
	  durationUpdate: function durationUpdate() {
	    // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false
	    if (!this.supported.ui || !this.config.invertTime && this.currentTime) {
	      return;
	    } // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.
	    // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415
	    // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062
	    // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338


	    if (this.duration >= Math.pow(2, 32)) {
	      toggleHidden(this.elements.display.currentTime, true);
	      toggleHidden(this.elements.progress, true);
	      return;
	    } // Update ARIA values


	    if (is$1.element(this.elements.inputs.seek)) {
	      this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);
	    } // If there's a spot to display duration


	    var hasDuration = is$1.element(this.elements.display.duration); // If there's only one time display, display duration there

	    if (!hasDuration && this.config.displayDuration && this.paused) {
	      controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);
	    } // If there's a duration element, update content


	    if (hasDuration) {
	      controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);
	    } // Update the tooltip (if visible)


	    controls.updateSeekTooltip.call(this);
	  },
	  // Hide/show a tab
	  toggleMenuButton: function toggleMenuButton(setting, toggle) {
	    toggleHidden(this.elements.settings.buttons[setting], !toggle);
	  },
	  // Update the selected setting
	  updateSetting: function updateSetting(setting, container, input) {
	    var pane = this.elements.settings.panels[setting];
	    var value = null;
	    var list = container;

	    if (setting === 'captions') {
	      value = this.currentTrack;
	    } else {
	      value = !is$1.empty(input) ? input : this[setting]; // Get default

	      if (is$1.empty(value)) {
	        value = this.config[setting].default;
	      } // Unsupported value


	      if (!is$1.empty(this.options[setting]) && !this.options[setting].includes(value)) {
	        this.debug.warn("Unsupported value of '".concat(value, "' for ").concat(setting));
	        return;
	      } // Disabled value


	      if (!this.config[setting].options.includes(value)) {
	        this.debug.warn("Disabled value of '".concat(value, "' for ").concat(setting));
	        return;
	      }
	    } // Get the list if we need to


	    if (!is$1.element(list)) {
	      list = pane && pane.querySelector('[role="menu"]');
	    } // If there's no list it means it's not been rendered...


	    if (!is$1.element(list)) {
	      return;
	    } // Update the label


	    var label = this.elements.settings.buttons[setting].querySelector(".".concat(this.config.classNames.menu.value));
	    label.innerHTML = controls.getLabel.call(this, setting, value); // Find the radio option and check it

	    var target = list && list.querySelector("[value=\"".concat(value, "\"]"));

	    if (is$1.element(target)) {
	      target.checked = true;
	    }
	  },
	  // Translate a value into a nice label
	  getLabel: function getLabel(setting, value) {
	    switch (setting) {
	      case 'speed':
	        return value === 1 ? i18n.get('normal', this.config) : "".concat(value, "&times;");

	      case 'quality':
	        if (is$1.number(value)) {
	          var label = i18n.get("qualityLabel.".concat(value), this.config);

	          if (!label.length) {
	            return "".concat(value, "p");
	          }

	          return label;
	        }

	        return toTitleCase(value);

	      case 'captions':
	        return captions.getLabel.call(this);

	      default:
	        return null;
	    }
	  },
	  // Set the quality menu
	  setQualityMenu: function setQualityMenu(options) {
	    var _this6 = this;

	    // Menu required
	    if (!is$1.element(this.elements.settings.panels.quality)) {
	      return;
	    }

	    var type = 'quality';
	    var list = this.elements.settings.panels.quality.querySelector('[role="menu"]'); // Set options if passed and filter based on uniqueness and config

	    if (is$1.array(options)) {
	      this.options.quality = dedupe(options).filter(function (quality) {
	        return _this6.config.quality.options.includes(quality);
	      });
	    } // Toggle the pane and tab


	    var toggle = !is$1.empty(this.options.quality) && this.options.quality.length > 1;
	    controls.toggleMenuButton.call(this, type, toggle); // Empty the menu

	    emptyElement(list); // Check if we need to toggle the parent

	    controls.checkMenu.call(this); // If we're hiding, nothing more to do

	    if (!toggle) {
	      return;
	    } // Get the badge HTML for HD, 4K etc


	    var getBadge = function getBadge(quality) {
	      var label = i18n.get("qualityBadge.".concat(quality), _this6.config);

	      if (!label.length) {
	        return null;
	      }

	      return controls.createBadge.call(_this6, label);
	    }; // Sort options by the config and then render options


	    this.options.quality.sort(function (a, b) {
	      var sorting = _this6.config.quality.options;
	      return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;
	    }).forEach(function (quality) {
	      controls.createMenuItem.call(_this6, {
	        value: quality,
	        list: list,
	        type: type,
	        title: controls.getLabel.call(_this6, 'quality', quality),
	        badge: getBadge(quality)
	      });
	    });
	    controls.updateSetting.call(this, type, list);
	  },
	  // Set the looping options

	  /* setLoopMenu() {
	        // Menu required
	        if (!is.element(this.elements.settings.panels.loop)) {
	            return;
	        }
	         const options = ['start', 'end', 'all', 'reset'];
	        const list = this.elements.settings.panels.loop.querySelector('[role="menu"]');
	         // Show the pane and tab
	        toggleHidden(this.elements.settings.buttons.loop, false);
	        toggleHidden(this.elements.settings.panels.loop, false);
	         // Toggle the pane and tab
	        const toggle = !is.empty(this.loop.options);
	        controls.toggleMenuButton.call(this, 'loop', toggle);
	         // Empty the menu
	        emptyElement(list);
	         options.forEach(option => {
	            const item = createElement('li');
	             const button = createElement(
	                'button',
	                extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {
	                    type: 'button',
	                    class: this.config.classNames.control,
	                    'data-plyr-loop-action': option,
	                }),
	                i18n.get(option, this.config)
	            );
	             if (['start', 'end'].includes(option)) {
	                const badge = controls.createBadge.call(this, '00:00');
	                button.appendChild(badge);
	            }
	             item.appendChild(button);
	            list.appendChild(item);
	        });
	    }, */
	  // Get current selected caption language
	  // TODO: rework this to user the getter in the API?
	  // Set a list of available captions languages
	  setCaptionsMenu: function setCaptionsMenu() {
	    var _this7 = this;

	    // Menu required
	    if (!is$1.element(this.elements.settings.panels.captions)) {
	      return;
	    } // TODO: Captions or language? Currently it's mixed


	    var type = 'captions';
	    var list = this.elements.settings.panels.captions.querySelector('[role="menu"]');
	    var tracks = captions.getTracks.call(this);
	    var toggle = Boolean(tracks.length); // Toggle the pane and tab

	    controls.toggleMenuButton.call(this, type, toggle); // Empty the menu

	    emptyElement(list); // Check if we need to toggle the parent

	    controls.checkMenu.call(this); // If there's no captions, bail

	    if (!toggle) {
	      return;
	    } // Generate options data


	    var options = tracks.map(function (track, value) {
	      return {
	        value: value,
	        checked: _this7.captions.toggled && _this7.currentTrack === value,
	        title: captions.getLabel.call(_this7, track),
	        badge: track.language && controls.createBadge.call(_this7, track.language.toUpperCase()),
	        list: list,
	        type: 'language'
	      };
	    }); // Add the "Disabled" option to turn off captions

	    options.unshift({
	      value: -1,
	      checked: !this.captions.toggled,
	      title: i18n.get('disabled', this.config),
	      list: list,
	      type: 'language'
	    }); // Generate options

	    options.forEach(controls.createMenuItem.bind(this));
	    controls.updateSetting.call(this, type, list);
	  },
	  // Set a list of available captions languages
	  setSpeedMenu: function setSpeedMenu() {
	    var _this8 = this;

	    // Menu required
	    if (!is$1.element(this.elements.settings.panels.speed)) {
	      return;
	    }

	    var type = 'speed';
	    var list = this.elements.settings.panels.speed.querySelector('[role="menu"]'); // Filter out invalid speeds

	    this.options.speed = this.options.speed.filter(function (o) {
	      return o >= _this8.minimumSpeed && o <= _this8.maximumSpeed;
	    }); // Toggle the pane and tab

	    var toggle = !is$1.empty(this.options.speed) && this.options.speed.length > 1;
	    controls.toggleMenuButton.call(this, type, toggle); // Empty the menu

	    emptyElement(list); // Check if we need to toggle the parent

	    controls.checkMenu.call(this); // If we're hiding, nothing more to do

	    if (!toggle) {
	      return;
	    } // Create items


	    this.options.speed.forEach(function (speed) {
	      controls.createMenuItem.call(_this8, {
	        value: speed,
	        list: list,
	        type: type,
	        title: controls.getLabel.call(_this8, 'speed', speed)
	      });
	    });
	    controls.updateSetting.call(this, type, list);
	  },
	  // Check if we need to hide/show the settings menu
	  checkMenu: function checkMenu() {
	    var buttons = this.elements.settings.buttons;
	    var visible = !is$1.empty(buttons) && Object.values(buttons).some(function (button) {
	      return !button.hidden;
	    });
	    toggleHidden(this.elements.settings.menu, !visible);
	  },
	  // Focus the first menu item in a given (or visible) menu
	  focusFirstMenuItem: function focusFirstMenuItem(pane) {
	    var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (this.elements.settings.popup.hidden) {
	      return;
	    }

	    var target = pane;

	    if (!is$1.element(target)) {
	      target = Object.values(this.elements.settings.panels).find(function (p) {
	        return !p.hidden;
	      });
	    }

	    var firstItem = target.querySelector('[role^="menuitem"]');
	    setFocus.call(this, firstItem, tabFocus);
	  },
	  // Show/hide menu
	  toggleMenu: function toggleMenu(input) {
	    var popup = this.elements.settings.popup;
	    var button = this.elements.buttons.settings; // Menu and button are required

	    if (!is$1.element(popup) || !is$1.element(button)) {
	      return;
	    } // True toggle by default


	    var hidden = popup.hidden;
	    var show = hidden;

	    if (is$1.boolean(input)) {
	      show = input;
	    } else if (is$1.keyboardEvent(input) && input.which === 27) {
	      show = false;
	    } else if (is$1.event(input)) {
	      // If Plyr is in a shadowDOM, the event target is set to the component, instead of the
	      // Element in the shadowDOM. The path, if available, is complete.
	      var target = is$1.function(input.composedPath) ? input.composedPath()[0] : input.target;
	      var isMenuItem = popup.contains(target); // If the click was inside the menu or if the click
	      // wasn't the button or menu item and we're trying to
	      // show the menu (a doc click shouldn't show the menu)

	      if (isMenuItem || !isMenuItem && input.target !== button && show) {
	        return;
	      }
	    } // Set button attributes


	    button.setAttribute('aria-expanded', show); // Show the actual popup

	    toggleHidden(popup, !show); // Add class hook

	    toggleClass(this.elements.container, this.config.classNames.menu.open, show); // Focus the first item if key interaction

	    if (show && is$1.keyboardEvent(input)) {
	      controls.focusFirstMenuItem.call(this, null, true);
	    } else if (!show && !hidden) {
	      // If closing, re-focus the button
	      setFocus.call(this, button, is$1.keyboardEvent(input));
	    }
	  },
	  // Get the natural size of a menu panel
	  getMenuSize: function getMenuSize(tab) {
	    var clone = tab.cloneNode(true);
	    clone.style.position = 'absolute';
	    clone.style.opacity = 0;
	    clone.removeAttribute('hidden'); // Append to parent so we get the "real" size

	    tab.parentNode.appendChild(clone); // Get the sizes before we remove

	    var width = clone.scrollWidth;
	    var height = clone.scrollHeight; // Remove from the DOM

	    removeElement(clone);
	    return {
	      width: width,
	      height: height
	    };
	  },
	  // Show a panel in the menu
	  showMenuPanel: function showMenuPanel() {
	    var _this9 = this;

	    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var tabFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var target = this.elements.container.querySelector("#plyr-settings-".concat(this.id, "-").concat(type)); // Nothing to show, bail

	    if (!is$1.element(target)) {
	      return;
	    } // Hide all other panels


	    var container = target.parentNode;
	    var current = Array.from(container.children).find(function (node) {
	      return !node.hidden;
	    }); // If we can do fancy animations, we'll animate the height/width

	    if (support.transitions && !support.reducedMotion) {
	      // Set the current width as a base
	      container.style.width = "".concat(current.scrollWidth, "px");
	      container.style.height = "".concat(current.scrollHeight, "px"); // Get potential sizes

	      var size = controls.getMenuSize.call(this, target); // Restore auto height/width

	      var restore = function restore(event) {
	        // We're only bothered about height and width on the container
	        if (event.target !== container || !['width', 'height'].includes(event.propertyName)) {
	          return;
	        } // Revert back to auto


	        container.style.width = '';
	        container.style.height = ''; // Only listen once

	        off.call(_this9, container, transitionEndEvent, restore);
	      }; // Listen for the transition finishing and restore auto height/width


	      on.call(this, container, transitionEndEvent, restore); // Set dimensions to target

	      container.style.width = "".concat(size.width, "px");
	      container.style.height = "".concat(size.height, "px");
	    } // Set attributes on current tab


	    toggleHidden(current, true); // Set attributes on target

	    toggleHidden(target, false); // Focus the first item

	    controls.focusFirstMenuItem.call(this, target, tabFocus);
	  },
	  // Set the download URL
	  setDownloadUrl: function setDownloadUrl() {
	    var button = this.elements.buttons.download; // Bail if no button

	    if (!is$1.element(button)) {
	      return;
	    } // Set attribute


	    button.setAttribute('href', this.download);
	  },
	  // Build the default HTML
	  create: function create(data) {
	    var _this10 = this;

	    var bindMenuItemShortcuts = controls.bindMenuItemShortcuts,
	        createButton = controls.createButton,
	        createProgress = controls.createProgress,
	        createRange = controls.createRange,
	        createTime = controls.createTime,
	        setQualityMenu = controls.setQualityMenu,
	        setSpeedMenu = controls.setSpeedMenu,
	        showMenuPanel = controls.showMenuPanel;
	    this.elements.controls = null; // Larger overlaid play button

	    if (is$1.array(this.config.controls) && this.config.controls.includes('play-large')) {
	      this.elements.container.appendChild(createButton.call(this, 'play-large'));
	    } // Create the container


	    var container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));
	    this.elements.controls = container; // Default item attributes

	    var defaultAttributes = {
	      class: 'plyr__controls__item'
	    }; // Loop through controls in order

	    dedupe(is$1.array(this.config.controls) ? this.config.controls : []).forEach(function (control) {
	      // Restart button
	      if (control === 'restart') {
	        container.appendChild(createButton.call(_this10, 'restart', defaultAttributes));
	      } // Rewind button


	      if (control === 'rewind') {
	        container.appendChild(createButton.call(_this10, 'rewind', defaultAttributes));
	      } // Play/Pause button


	      if (control === 'play') {
	        container.appendChild(createButton.call(_this10, 'play', defaultAttributes));
	      } // Fast forward button


	      if (control === 'fast-forward') {
	        container.appendChild(createButton.call(_this10, 'fast-forward', defaultAttributes));
	      } // Progress


	      if (control === 'progress') {
	        var progressContainer = createElement('div', {
	          class: "".concat(defaultAttributes.class, " plyr__progress__container")
	        });
	        var progress = createElement('div', getAttributesFromSelector(_this10.config.selectors.progress)); // Seek range slider

	        progress.appendChild(createRange.call(_this10, 'seek', {
	          id: "plyr-seek-".concat(data.id)
	        })); // Buffer progress

	        progress.appendChild(createProgress.call(_this10, 'buffer')); // TODO: Add loop display indicator
	        // Seek tooltip

	        if (_this10.config.tooltips.seek) {
	          var tooltip = createElement('span', {
	            class: _this10.config.classNames.tooltip
	          }, '00:00');
	          progress.appendChild(tooltip);
	          _this10.elements.display.seekTooltip = tooltip;
	        }

	        _this10.elements.progress = progress;
	        progressContainer.appendChild(_this10.elements.progress);
	        container.appendChild(progressContainer);
	      } // Media current time display


	      if (control === 'current-time') {
	        container.appendChild(createTime.call(_this10, 'currentTime', defaultAttributes));
	      } // Media duration display


	      if (control === 'duration') {
	        container.appendChild(createTime.call(_this10, 'duration', defaultAttributes));
	      } // Volume controls


	      if (control === 'mute' || control === 'volume') {
	        var volume = _this10.elements.volume; // Create the volume container if needed

	        if (!is$1.element(volume) || !container.contains(volume)) {
	          volume = createElement('div', extend({}, defaultAttributes, {
	            class: "".concat(defaultAttributes.class, " plyr__volume").trim()
	          }));
	          _this10.elements.volume = volume;
	          container.appendChild(volume);
	        } // Toggle mute button


	        if (control === 'mute') {
	          volume.appendChild(createButton.call(_this10, 'mute'));
	        } // Volume range control
	        // Ignored on iOS as it's handled globally
	        // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html


	        if (control === 'volume' && !browser.isIos) {
	          // Set the attributes
	          var attributes = {
	            max: 1,
	            step: 0.05,
	            value: _this10.config.volume
	          }; // Create the volume range slider

	          volume.appendChild(createRange.call(_this10, 'volume', extend(attributes, {
	            id: "plyr-volume-".concat(data.id)
	          })));
	        }
	      } // Toggle captions button


	      if (control === 'captions') {
	        container.appendChild(createButton.call(_this10, 'captions', defaultAttributes));
	      } // Settings button / menu


	      if (control === 'settings' && !is$1.empty(_this10.config.settings)) {
	        var wrapper = createElement('div', extend({}, defaultAttributes, {
	          class: "".concat(defaultAttributes.class, " plyr__menu").trim(),
	          hidden: ''
	        }));
	        wrapper.appendChild(createButton.call(_this10, 'settings', {
	          'aria-haspopup': true,
	          'aria-controls': "plyr-settings-".concat(data.id),
	          'aria-expanded': false
	        }));
	        var popup = createElement('div', {
	          class: 'plyr__menu__container',
	          id: "plyr-settings-".concat(data.id),
	          hidden: ''
	        });
	        var inner = createElement('div');
	        var home = createElement('div', {
	          id: "plyr-settings-".concat(data.id, "-home")
	        }); // Create the menu

	        var menu = createElement('div', {
	          role: 'menu'
	        });
	        home.appendChild(menu);
	        inner.appendChild(home);
	        _this10.elements.settings.panels.home = home; // Build the menu items

	        _this10.config.settings.forEach(function (type) {
	          // TODO: bundle this with the createMenuItem helper and bindings
	          var menuItem = createElement('button', extend(getAttributesFromSelector(_this10.config.selectors.buttons.settings), {
	            type: 'button',
	            class: "".concat(_this10.config.classNames.control, " ").concat(_this10.config.classNames.control, "--forward"),
	            role: 'menuitem',
	            'aria-haspopup': true,
	            hidden: ''
	          })); // Bind menu shortcuts for keyboard users

	          bindMenuItemShortcuts.call(_this10, menuItem, type); // Show menu on click

	          on.call(_this10, menuItem, 'click', function () {
	            showMenuPanel.call(_this10, type, false);
	          });
	          var flex = createElement('span', null, i18n.get(type, _this10.config));
	          var value = createElement('span', {
	            class: _this10.config.classNames.menu.value
	          }); // Speed contains HTML entities

	          value.innerHTML = data[type];
	          flex.appendChild(value);
	          menuItem.appendChild(flex);
	          menu.appendChild(menuItem); // Build the panes

	          var pane = createElement('div', {
	            id: "plyr-settings-".concat(data.id, "-").concat(type),
	            hidden: ''
	          }); // Back button

	          var backButton = createElement('button', {
	            type: 'button',
	            class: "".concat(_this10.config.classNames.control, " ").concat(_this10.config.classNames.control, "--back")
	          }); // Visible label

	          backButton.appendChild(createElement('span', {
	            'aria-hidden': true
	          }, i18n.get(type, _this10.config))); // Screen reader label

	          backButton.appendChild(createElement('span', {
	            class: _this10.config.classNames.hidden
	          }, i18n.get('menuBack', _this10.config))); // Go back via keyboard

	          on.call(_this10, pane, 'keydown', function (event) {
	            // We only care about <-
	            if (event.which !== 37) {
	              return;
	            } // Prevent seek


	            event.preventDefault();
	            event.stopPropagation(); // Show the respective menu

	            showMenuPanel.call(_this10, 'home', true);
	          }, false); // Go back via button click

	          on.call(_this10, backButton, 'click', function () {
	            showMenuPanel.call(_this10, 'home', false);
	          }); // Add to pane

	          pane.appendChild(backButton); // Menu

	          pane.appendChild(createElement('div', {
	            role: 'menu'
	          }));
	          inner.appendChild(pane);
	          _this10.elements.settings.buttons[type] = menuItem;
	          _this10.elements.settings.panels[type] = pane;
	        });

	        popup.appendChild(inner);
	        wrapper.appendChild(popup);
	        container.appendChild(wrapper);
	        _this10.elements.settings.popup = popup;
	        _this10.elements.settings.menu = wrapper;
	      } // Picture in picture button


	      if (control === 'pip' && support.pip) {
	        container.appendChild(createButton.call(_this10, 'pip', defaultAttributes));
	      } // Airplay button


	      if (control === 'airplay' && support.airplay) {
	        container.appendChild(createButton.call(_this10, 'airplay', defaultAttributes));
	      } // Download button


	      if (control === 'download') {
	        var _attributes = extend({}, defaultAttributes, {
	          element: 'a',
	          href: _this10.download,
	          target: '_blank'
	        }); // Set download attribute for HTML5 only


	        if (_this10.isHTML5) {
	          _attributes.download = '';
	        }

	        var download = _this10.config.urls.download;

	        if (!is$1.url(download) && _this10.isEmbed) {
	          extend(_attributes, {
	            icon: "logo-".concat(_this10.provider),
	            label: _this10.provider
	          });
	        }

	        container.appendChild(createButton.call(_this10, 'download', _attributes));
	      } // Toggle fullscreen button


	      if (control === 'fullscreen') {
	        container.appendChild(createButton.call(_this10, 'fullscreen', defaultAttributes));
	      }
	    }); // Set available quality levels

	    if (this.isHTML5) {
	      setQualityMenu.call(this, html5.getQualityOptions.call(this));
	    }

	    setSpeedMenu.call(this);
	    return container;
	  },
	  // Insert controls
	  inject: function inject() {
	    var _this11 = this;

	    // Sprite
	    if (this.config.loadSprite) {
	      var icon = controls.getIconUrl.call(this); // Only load external sprite using AJAX

	      if (icon.cors) {
	        loadSprite(icon.url, 'sprite-plyr');
	      }
	    } // Create a unique ID


	    this.id = Math.floor(Math.random() * 10000); // Null by default

	    var container = null;
	    this.elements.controls = null; // Set template properties

	    var props = {
	      id: this.id,
	      seektime: this.config.seekTime,
	      title: this.config.title
	    };
	    var update = true; // If function, run it and use output

	    if (is$1.function(this.config.controls)) {
	      this.config.controls = this.config.controls.call(this, props);
	    } // Convert falsy controls to empty array (primarily for empty strings)


	    if (!this.config.controls) {
	      this.config.controls = [];
	    }

	    if (is$1.element(this.config.controls) || is$1.string(this.config.controls)) {
	      // HTMLElement or Non-empty string passed as the option
	      container = this.config.controls;
	    } else {
	      // Create controls
	      container = controls.create.call(this, {
	        id: this.id,
	        seektime: this.config.seekTime,
	        speed: this.speed,
	        quality: this.quality,
	        captions: captions.getLabel.call(this) // TODO: Looping
	        // loop: 'None',

	      });
	      update = false;
	    } // Replace props with their value


	    var replace = function replace(input) {
	      var result = input;
	      Object.entries(props).forEach(function (_ref2) {
	        var _ref3 = _slicedToArray(_ref2, 2),
	            key = _ref3[0],
	            value = _ref3[1];

	        result = replaceAll(result, "{".concat(key, "}"), value);
	      });
	      return result;
	    }; // Update markup


	    if (update) {
	      if (is$1.string(this.config.controls)) {
	        container = replace(container);
	      }
	    } // Controls container


	    var target; // Inject to custom location

	    if (is$1.string(this.config.selectors.controls.container)) {
	      target = document.querySelector(this.config.selectors.controls.container);
	    } // Inject into the container by default


	    if (!is$1.element(target)) {
	      target = this.elements.container;
	    } // Inject controls HTML (needs to be before captions, hence "afterbegin")


	    var insertMethod = is$1.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';
	    target[insertMethod]('afterbegin', container); // Find the elements if need be

	    if (!is$1.element(this.elements.controls)) {
	      controls.findElements.call(this);
	    } // Add pressed property to buttons


	    if (!is$1.empty(this.elements.buttons)) {
	      var addProperty = function addProperty(button) {
	        var className = _this11.config.classNames.controlPressed;
	        Object.defineProperty(button, 'pressed', {
	          enumerable: true,
	          get: function get() {
	            return hasClass(button, className);
	          },
	          set: function set() {
	            var pressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	            toggleClass(button, className, pressed);
	          }
	        });
	      }; // Toggle classname when pressed property is set


	      Object.values(this.elements.buttons).filter(Boolean).forEach(function (button) {
	        if (is$1.array(button) || is$1.nodeList(button)) {
	          Array.from(button).filter(Boolean).forEach(addProperty);
	        } else {
	          addProperty(button);
	        }
	      });
	    } // Edge sometimes doesn't finish the paint so force a repaint


	    if (browser.isEdge) {
	      repaint(target);
	    } // Setup tooltips


	    if (this.config.tooltips.controls) {
	      var _this$config = this.config,
	          classNames = _this$config.classNames,
	          selectors = _this$config.selectors;
	      var selector = "".concat(selectors.controls.wrapper, " ").concat(selectors.labels, " .").concat(classNames.hidden);
	      var labels = getElements.call(this, selector);
	      Array.from(labels).forEach(function (label) {
	        toggleClass(label, _this11.config.classNames.hidden, false);
	        toggleClass(label, _this11.config.classNames.tooltip, true);
	      });
	    }
	  }
	};

	/**
	 * Parse a string to a URL object
	 * @param {String} input - the URL to be parsed
	 * @param {Boolean} safe - failsafe parsing
	 */

	function parseUrl(input) {
	  var safe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  var url = input;

	  if (safe) {
	    var parser = document.createElement('a');
	    parser.href = url;
	    url = parser.href;
	  }

	  try {
	    return new URL(url);
	  } catch (e) {
	    return null;
	  }
	} // Convert object to URLSearchParams

	function buildUrlParams(input) {
	  var params = new URLSearchParams();

	  if (is$1.object(input)) {
	    Object.entries(input).forEach(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 2),
	          key = _ref2[0],
	          value = _ref2[1];

	      params.set(key, value);
	    });
	  }

	  return params;
	}

	var captions = {
	  // Setup captions
	  setup: function setup() {
	    // Requires UI support
	    if (!this.supported.ui) {
	      return;
	    } // Only Vimeo and HTML5 video supported at this point


	    if (!this.isVideo || this.isYouTube || this.isHTML5 && !support.textTracks) {
	      // Clear menu and hide
	      if (is$1.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {
	        controls.setCaptionsMenu.call(this);
	      }

	      return;
	    } // Inject the container


	    if (!is$1.element(this.elements.captions)) {
	      this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));
	      insertAfter(this.elements.captions, this.elements.wrapper);
	    } // Fix IE captions if CORS is used
	    // Fetch captions and inject as blobs instead (data URIs not supported!)


	    if (browser.isIE && window.URL) {
	      var elements = this.media.querySelectorAll('track');
	      Array.from(elements).forEach(function (track) {
	        var src = track.getAttribute('src');
	        var url = parseUrl(src);

	        if (url !== null && url.hostname !== window.location.href.hostname && ['http:', 'https:'].includes(url.protocol)) {
	          fetch$1(src, 'blob').then(function (blob) {
	            track.setAttribute('src', window.URL.createObjectURL(blob));
	          }).catch(function () {
	            removeElement(track);
	          });
	        }
	      });
	    } // Get and set initial data
	    // The "preferred" options are not realized unless / until the wanted language has a match
	    // * languages: Array of user's browser languages.
	    // * language:  The language preferred by user settings or config
	    // * active:    The state preferred by user settings or config
	    // * toggled:   The real captions state


	    var browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage || 'en'];
	    var languages = dedupe(browserLanguages.map(function (language) {
	      return language.split('-')[0];
	    }));
	    var language = (this.storage.get('language') || this.config.captions.language || 'auto').toLowerCase(); // Use first browser language when language is 'auto'

	    if (language === 'auto') {
	      var _languages = _slicedToArray(languages, 1);

	      language = _languages[0];
	    }

	    var active = this.storage.get('captions');

	    if (!is$1.boolean(active)) {
	      active = this.config.captions.active;
	    }

	    Object.assign(this.captions, {
	      toggled: false,
	      active: active,
	      language: language,
	      languages: languages
	    }); // Watch changes to textTracks and update captions menu

	    if (this.isHTML5) {
	      var trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';
	      on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));
	    } // Update available languages in list next tick (the event must not be triggered before the listeners)


	    setTimeout(captions.update.bind(this), 0);
	  },
	  // Update available language options in settings based on tracks
	  update: function update() {
	    var _this = this;

	    var tracks = captions.getTracks.call(this, true); // Get the wanted language

	    var _this$captions = this.captions,
	        active = _this$captions.active,
	        language = _this$captions.language,
	        meta = _this$captions.meta,
	        currentTrackNode = _this$captions.currentTrackNode;
	    var languageExists = Boolean(tracks.find(function (track) {
	      return track.language === language;
	    })); // Handle tracks (add event listener and "pseudo"-default)

	    if (this.isHTML5 && this.isVideo) {
	      tracks.filter(function (track) {
	        return !meta.get(track);
	      }).forEach(function (track) {
	        _this.debug.log('Track added', track); // Attempt to store if the original dom element was "default"


	        meta.set(track, {
	          default: track.mode === 'showing'
	        }); // Turn off native caption rendering to avoid double captions
	        // Note: mode='hidden' forces a track to download. To ensure every track
	        // isn't downloaded at once, only 'showing' tracks should be reassigned
	        // eslint-disable-next-line no-param-reassign

	        if (track.mode === 'showing') {
	          // eslint-disable-next-line no-param-reassign
	          track.mode = 'hidden';
	        } // Add event listener for cue changes


	        on.call(_this, track, 'cuechange', function () {
	          return captions.updateCues.call(_this);
	        });
	      });
	    } // Update language first time it matches, or if the previous matching track was removed


	    if (languageExists && this.language !== language || !tracks.includes(currentTrackNode)) {
	      captions.setLanguage.call(this, language);
	      captions.toggle.call(this, active && languageExists);
	    } // Enable or disable captions based on track length


	    toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is$1.empty(tracks)); // Update available languages in list

	    if (is$1.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {
	      controls.setCaptionsMenu.call(this);
	    }
	  },
	  // Toggle captions display
	  // Used internally for the toggleCaptions method, with the passive option forced to false
	  toggle: function toggle(input) {
	    var _this2 = this;

	    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    // If there's no full support
	    if (!this.supported.ui) {
	      return;
	    }

	    var toggled = this.captions.toggled; // Current state

	    var activeClass = this.config.classNames.captions.active; // Get the next state
	    // If the method is called without parameter, toggle based on current value

	    var active = is$1.nullOrUndefined(input) ? !toggled : input; // Update state and trigger event

	    if (active !== toggled) {
	      // When passive, don't override user preferences
	      if (!passive) {
	        this.captions.active = active;
	        this.storage.set({
	          captions: active
	        });
	      } // Force language if the call isn't passive and there is no matching language to toggle to


	      if (!this.language && active && !passive) {
	        var tracks = captions.getTracks.call(this);
	        var track = captions.findTrack.call(this, [this.captions.language].concat(_toConsumableArray(this.captions.languages)), true); // Override user preferences to avoid switching languages if a matching track is added

	        this.captions.language = track.language; // Set caption, but don't store in localStorage as user preference

	        captions.set.call(this, tracks.indexOf(track));
	        return;
	      } // Toggle button if it's enabled


	      if (this.elements.buttons.captions) {
	        this.elements.buttons.captions.pressed = active;
	      } // Add class hook


	      toggleClass(this.elements.container, activeClass, active);
	      this.captions.toggled = active; // Update settings menu

	      controls.updateSetting.call(this, 'captions'); // Trigger event (not used internally)

	      triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');
	    } // Wait for the call stack to clear before setting mode='hidden'
	    // on the active track - forcing the browser to download it


	    setTimeout(function () {
	      if (active && _this2.captions.toggled) {
	        _this2.captions.currentTrackNode.mode = 'hidden';
	      }
	    });
	  },
	  // Set captions by track index
	  // Used internally for the currentTrack setter with the passive option forced to false
	  set: function set(index) {
	    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    var tracks = captions.getTracks.call(this); // Disable captions if setting to -1

	    if (index === -1) {
	      captions.toggle.call(this, false, passive);
	      return;
	    }

	    if (!is$1.number(index)) {
	      this.debug.warn('Invalid caption argument', index);
	      return;
	    }

	    if (!(index in tracks)) {
	      this.debug.warn('Track not found', index);
	      return;
	    }

	    if (this.captions.currentTrack !== index) {
	      this.captions.currentTrack = index;
	      var track = tracks[index];

	      var _ref = track || {},
	          language = _ref.language; // Store reference to node for invalidation on remove


	      this.captions.currentTrackNode = track; // Update settings menu

	      controls.updateSetting.call(this, 'captions'); // When passive, don't override user preferences

	      if (!passive) {
	        this.captions.language = language;
	        this.storage.set({
	          language: language
	        });
	      } // Handle Vimeo captions


	      if (this.isVimeo) {
	        this.embed.enableTextTrack(language);
	      } // Trigger event


	      triggerEvent.call(this, this.media, 'languagechange');
	    } // Show captions


	    captions.toggle.call(this, true, passive);

	    if (this.isHTML5 && this.isVideo) {
	      // If we change the active track while a cue is already displayed we need to update it
	      captions.updateCues.call(this);
	    }
	  },
	  // Set captions by language
	  // Used internally for the language setter with the passive option forced to false
	  setLanguage: function setLanguage(input) {
	    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    if (!is$1.string(input)) {
	      this.debug.warn('Invalid language argument', input);
	      return;
	    } // Normalize


	    var language = input.toLowerCase();
	    this.captions.language = language; // Set currentTrack

	    var tracks = captions.getTracks.call(this);
	    var track = captions.findTrack.call(this, [language]);
	    captions.set.call(this, tracks.indexOf(track), passive);
	  },
	  // Get current valid caption tracks
	  // If update is false it will also ignore tracks without metadata
	  // This is used to "freeze" the language options when captions.update is false
	  getTracks: function getTracks() {
	    var _this3 = this;

	    var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    // Handle media or textTracks missing or null
	    var tracks = Array.from((this.media || {}).textTracks || []); // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)
	    // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)

	    return tracks.filter(function (track) {
	      return !_this3.isHTML5 || update || _this3.captions.meta.has(track);
	    }).filter(function (track) {
	      return ['captions', 'subtitles'].includes(track.kind);
	    });
	  },
	  // Match tracks based on languages and get the first
	  findTrack: function findTrack(languages) {
	    var _this4 = this;

	    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var tracks = captions.getTracks.call(this);

	    var sortIsDefault = function sortIsDefault(track) {
	      return Number((_this4.captions.meta.get(track) || {}).default);
	    };

	    var sorted = Array.from(tracks).sort(function (a, b) {
	      return sortIsDefault(b) - sortIsDefault(a);
	    });
	    var track;
	    languages.every(function (language) {
	      track = sorted.find(function (t) {
	        return t.language === language;
	      });
	      return !track; // Break iteration if there is a match
	    }); // If no match is found but is required, get first

	    return track || (force ? sorted[0] : undefined);
	  },
	  // Get the current track
	  getCurrentTrack: function getCurrentTrack() {
	    return captions.getTracks.call(this)[this.currentTrack];
	  },
	  // Get UI label for track
	  getLabel: function getLabel(track) {
	    var currentTrack = track;

	    if (!is$1.track(currentTrack) && support.textTracks && this.captions.toggled) {
	      currentTrack = captions.getCurrentTrack.call(this);
	    }

	    if (is$1.track(currentTrack)) {
	      if (!is$1.empty(currentTrack.label)) {
	        return currentTrack.label;
	      }

	      if (!is$1.empty(currentTrack.language)) {
	        return track.language.toUpperCase();
	      }

	      return i18n.get('enabled', this.config);
	    }

	    return i18n.get('disabled', this.config);
	  },
	  // Update captions using current track's active cues
	  // Also optional array argument in case there isn't any track (ex: vimeo)
	  updateCues: function updateCues(input) {
	    // Requires UI
	    if (!this.supported.ui) {
	      return;
	    }

	    if (!is$1.element(this.elements.captions)) {
	      this.debug.warn('No captions element to render to');
	      return;
	    } // Only accept array or empty input


	    if (!is$1.nullOrUndefined(input) && !Array.isArray(input)) {
	      this.debug.warn('updateCues: Invalid input', input);
	      return;
	    }

	    var cues = input; // Get cues from track

	    if (!cues) {
	      var track = captions.getCurrentTrack.call(this);
	      cues = Array.from((track || {}).activeCues || []).map(function (cue) {
	        return cue.getCueAsHTML();
	      }).map(getHTML);
	    } // Set new caption text


	    var content = cues.map(function (cueText) {
	      return cueText.trim();
	    }).join('\n');
	    var changed = content !== this.elements.captions.innerHTML;

	    if (changed) {
	      // Empty the container and create a new child element
	      emptyElement(this.elements.captions);
	      var caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));
	      caption.innerHTML = content;
	      this.elements.captions.appendChild(caption); // Trigger event

	      triggerEvent.call(this, this.media, 'cuechange');
	    }
	  }
	};

	// ==========================================================================
	// Plyr default config
	// ==========================================================================
	var defaults$1 = {
	  // Disable
	  enabled: true,
	  // Custom media title
	  title: '',
	  // Logging to console
	  debug: false,
	  // Auto play (if supported)
	  autoplay: false,
	  // Only allow one media playing at once (vimeo only)
	  autopause: true,
	  // Allow inline playback on iOS (this effects YouTube/Vimeo - HTML5 requires the attribute present)
	  // TODO: Remove iosNative fullscreen option in favour of this (logic needs work)
	  playsinline: true,
	  // Default time to skip when rewind/fast forward
	  seekTime: 10,
	  // Default volume
	  volume: 1,
	  muted: false,
	  // Pass a custom duration
	  duration: null,
	  // Display the media duration on load in the current time position
	  // If you have opted to display both duration and currentTime, this is ignored
	  displayDuration: true,
	  // Invert the current time to be a countdown
	  invertTime: true,
	  // Clicking the currentTime inverts it's value to show time left rather than elapsed
	  toggleInvert: true,
	  // Force an aspect ratio
	  // The format must be `'w:h'` (e.g. `'16:9'`)
	  ratio: null,
	  // Click video container to play/pause
	  clickToPlay: true,
	  // Auto hide the controls
	  hideControls: true,
	  // Reset to start when playback ended
	  resetOnEnd: false,
	  // Disable the standard context menu
	  disableContextMenu: true,
	  // Sprite (for icons)
	  loadSprite: true,
	  iconPrefix: 'plyr',
	  iconUrl: 'https://cdn.plyr.io/3.6.2/plyr.svg',
	  // Blank video (used to prevent errors on source change)
	  blankVideo: 'https://cdn.plyr.io/static/blank.mp4',
	  // Quality default
	  quality: {
	    default: 576,
	    // The options to display in the UI, if available for the source media
	    options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
	    forced: false,
	    onChange: null
	  },
	  // Set loops
	  loop: {
	    active: false // start: null,
	    // end: null,

	  },
	  // Speed default and options to display
	  speed: {
	    selected: 1,
	    // The options to display in the UI, if available for the source media (e.g. Vimeo and YouTube only support 0.5x-4x)
	    options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4]
	  },
	  // Keyboard shortcut settings
	  keyboard: {
	    focused: true,
	    global: false
	  },
	  // Display tooltips
	  tooltips: {
	    controls: false,
	    seek: true
	  },
	  // Captions settings
	  captions: {
	    active: false,
	    language: 'auto',
	    // Listen to new tracks added after Plyr is initialized.
	    // This is needed for streaming captions, but may result in unselectable options
	    update: false
	  },
	  // Fullscreen settings
	  fullscreen: {
	    enabled: true,
	    // Allow fullscreen?
	    fallback: true,
	    // Fallback using full viewport/window
	    iosNative: false // Use the native fullscreen in iOS (disables custom controls)
	    // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode
	    // Non-ancestors of the player element will be ignored
	    // container: null, // defaults to the player element

	  },
	  // Local storage
	  storage: {
	    enabled: true,
	    key: 'plyr'
	  },
	  // Default controls
	  controls: ['play-large', // 'restart',
	  // 'rewind',
	  'play', // 'fast-forward',
	  'progress', 'current-time', // 'duration',
	  'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', // 'download',
	  'fullscreen'],
	  settings: ['captions', 'quality', 'speed'],
	  // Localisation
	  i18n: {
	    restart: 'Restart',
	    rewind: 'Rewind {seektime}s',
	    play: 'Play',
	    pause: 'Pause',
	    fastForward: 'Forward {seektime}s',
	    seek: 'Seek',
	    seekLabel: '{currentTime} of {duration}',
	    played: 'Played',
	    buffered: 'Buffered',
	    currentTime: 'Current time',
	    duration: 'Duration',
	    volume: 'Volume',
	    mute: 'Mute',
	    unmute: 'Unmute',
	    enableCaptions: 'Enable captions',
	    disableCaptions: 'Disable captions',
	    download: 'Download',
	    enterFullscreen: 'Enter fullscreen',
	    exitFullscreen: 'Exit fullscreen',
	    frameTitle: 'Player for {title}',
	    captions: 'Captions',
	    settings: 'Settings',
	    pip: 'PIP',
	    menuBack: 'Go back to previous menu',
	    speed: 'Speed',
	    normal: 'Normal',
	    quality: 'Quality',
	    loop: 'Loop',
	    start: 'Start',
	    end: 'End',
	    all: 'All',
	    reset: 'Reset',
	    disabled: 'Disabled',
	    enabled: 'Enabled',
	    advertisement: 'Ad',
	    qualityBadge: {
	      2160: '4K',
	      1440: 'HD',
	      1080: 'HD',
	      720: 'HD',
	      576: 'SD',
	      480: 'SD'
	    }
	  },
	  // URLs
	  urls: {
	    download: null,
	    vimeo: {
	      sdk: 'https://player.vimeo.com/api/player.js',
	      iframe: 'https://player.vimeo.com/video/{0}?{1}',
	      api: 'https://vimeo.com/api/v2/video/{0}.json'
	    },
	    youtube: {
	      sdk: 'https://www.youtube.com/iframe_api',
	      api: 'https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}'
	    },
	    googleIMA: {
	      sdk: 'https://imasdk.googleapis.com/js/sdkloader/ima3.js'
	    }
	  },
	  // Custom control listeners
	  listeners: {
	    seek: null,
	    play: null,
	    pause: null,
	    restart: null,
	    rewind: null,
	    fastForward: null,
	    mute: null,
	    volume: null,
	    captions: null,
	    download: null,
	    fullscreen: null,
	    pip: null,
	    airplay: null,
	    speed: null,
	    quality: null,
	    loop: null,
	    language: null
	  },
	  // Events to watch and bubble
	  events: [// Events to watch on HTML5 media elements and bubble
	  // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events
	  'ended', 'progress', 'stalled', 'playing', 'waiting', 'canplay', 'canplaythrough', 'loadstart', 'loadeddata', 'loadedmetadata', 'timeupdate', 'volumechange', 'play', 'pause', 'error', 'seeking', 'seeked', 'emptied', 'ratechange', 'cuechange', // Custom events
	  'download', 'enterfullscreen', 'exitfullscreen', 'captionsenabled', 'captionsdisabled', 'languagechange', 'controlshidden', 'controlsshown', 'ready', // YouTube
	  'statechange', // Quality
	  'qualitychange', // Ads
	  'adsloaded', 'adscontentpause', 'adscontentresume', 'adstarted', 'adsmidpoint', 'adscomplete', 'adsallcomplete', 'adsimpression', 'adsclick'],
	  // Selectors
	  // Change these to match your template if using custom HTML
	  selectors: {
	    editable: 'input, textarea, select, [contenteditable]',
	    container: '.plyr',
	    controls: {
	      container: null,
	      wrapper: '.plyr__controls'
	    },
	    labels: '[data-plyr]',
	    buttons: {
	      play: '[data-plyr="play"]',
	      pause: '[data-plyr="pause"]',
	      restart: '[data-plyr="restart"]',
	      rewind: '[data-plyr="rewind"]',
	      fastForward: '[data-plyr="fast-forward"]',
	      mute: '[data-plyr="mute"]',
	      captions: '[data-plyr="captions"]',
	      download: '[data-plyr="download"]',
	      fullscreen: '[data-plyr="fullscreen"]',
	      pip: '[data-plyr="pip"]',
	      airplay: '[data-plyr="airplay"]',
	      settings: '[data-plyr="settings"]',
	      loop: '[data-plyr="loop"]'
	    },
	    inputs: {
	      seek: '[data-plyr="seek"]',
	      volume: '[data-plyr="volume"]',
	      speed: '[data-plyr="speed"]',
	      language: '[data-plyr="language"]',
	      quality: '[data-plyr="quality"]'
	    },
	    display: {
	      currentTime: '.plyr__time--current',
	      duration: '.plyr__time--duration',
	      buffer: '.plyr__progress__buffer',
	      loop: '.plyr__progress__loop',
	      // Used later
	      volume: '.plyr__volume--display'
	    },
	    progress: '.plyr__progress',
	    captions: '.plyr__captions',
	    caption: '.plyr__caption'
	  },
	  // Class hooks added to the player in different states
	  classNames: {
	    type: 'plyr--{0}',
	    provider: 'plyr--{0}',
	    video: 'plyr__video-wrapper',
	    embed: 'plyr__video-embed',
	    videoFixedRatio: 'plyr__video-wrapper--fixed-ratio',
	    embedContainer: 'plyr__video-embed__container',
	    poster: 'plyr__poster',
	    posterEnabled: 'plyr__poster-enabled',
	    ads: 'plyr__ads',
	    control: 'plyr__control',
	    controlPressed: 'plyr__control--pressed',
	    playing: 'plyr--playing',
	    paused: 'plyr--paused',
	    stopped: 'plyr--stopped',
	    loading: 'plyr--loading',
	    hover: 'plyr--hover',
	    tooltip: 'plyr__tooltip',
	    cues: 'plyr__cues',
	    hidden: 'plyr__sr-only',
	    hideControls: 'plyr--hide-controls',
	    isIos: 'plyr--is-ios',
	    isTouch: 'plyr--is-touch',
	    uiSupported: 'plyr--full-ui',
	    noTransition: 'plyr--no-transition',
	    display: {
	      time: 'plyr__time'
	    },
	    menu: {
	      value: 'plyr__menu__value',
	      badge: 'plyr__badge',
	      open: 'plyr--menu-open'
	    },
	    captions: {
	      enabled: 'plyr--captions-enabled',
	      active: 'plyr--captions-active'
	    },
	    fullscreen: {
	      enabled: 'plyr--fullscreen-enabled',
	      fallback: 'plyr--fullscreen-fallback'
	    },
	    pip: {
	      supported: 'plyr--pip-supported',
	      active: 'plyr--pip-active'
	    },
	    airplay: {
	      supported: 'plyr--airplay-supported',
	      active: 'plyr--airplay-active'
	    },
	    tabFocus: 'plyr__tab-focus',
	    previewThumbnails: {
	      // Tooltip thumbs
	      thumbContainer: 'plyr__preview-thumb',
	      thumbContainerShown: 'plyr__preview-thumb--is-shown',
	      imageContainer: 'plyr__preview-thumb__image-container',
	      timeContainer: 'plyr__preview-thumb__time-container',
	      // Scrubbing
	      scrubbingContainer: 'plyr__preview-scrubbing',
	      scrubbingContainerShown: 'plyr__preview-scrubbing--is-shown'
	    }
	  },
	  // Embed attributes
	  attributes: {
	    embed: {
	      provider: 'data-plyr-provider',
	      id: 'data-plyr-embed-id'
	    }
	  },
	  // Advertisements plugin
	  // Register for an account here: http://vi.ai/publisher-video-monetization/?aid=plyrio
	  ads: {
	    enabled: false,
	    publisherId: '',
	    tagUrl: ''
	  },
	  // Preview Thumbnails plugin
	  previewThumbnails: {
	    enabled: false,
	    src: ''
	  },
	  // Vimeo plugin
	  vimeo: {
	    byline: false,
	    portrait: false,
	    title: false,
	    speed: true,
	    transparent: false,
	    // Whether the owner of the video has a Pro or Business account
	    // (which allows us to properly hide controls without CSS hacks, etc)
	    premium: false,
	    // Custom settings from Plyr
	    referrerPolicy: null // https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy

	  },
	  // YouTube plugin
	  youtube: {
	    noCookie: true,
	    // Whether to use an alternative version of YouTube without cookies
	    rel: 0,
	    // No related vids
	    showinfo: 0,
	    // Hide info
	    iv_load_policy: 3,
	    // Hide annotations
	    modestbranding: 1 // Hide logos as much as possible (they still show one in the corner when paused)

	  }
	};

	// ==========================================================================
	// Plyr states
	// ==========================================================================
	var pip = {
	  active: 'picture-in-picture',
	  inactive: 'inline'
	};

	// ==========================================================================
	// Plyr supported types and providers
	// ==========================================================================
	var providers = {
	  html5: 'html5',
	  youtube: 'youtube',
	  vimeo: 'vimeo'
	};
	var types = {
	  audio: 'audio',
	  video: 'video'
	};
	/**
	 * Get provider by URL
	 * @param {String} url
	 */

	function getProviderByUrl(url) {
	  // YouTube
	  if (/^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(url)) {
	    return providers.youtube;
	  } // Vimeo


	  if (/^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(url)) {
	    return providers.vimeo;
	  }

	  return null;
	}

	// ==========================================================================
	// Console wrapper
	// ==========================================================================
	var noop = function noop() {};

	var Console = /*#__PURE__*/function () {
	  function Console() {
	    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	    _classCallCheck(this, Console);

	    this.enabled = window.console && enabled;

	    if (this.enabled) {
	      this.log('Debugging enabled');
	    }
	  }

	  _createClass(Console, [{
	    key: "log",
	    get: function get() {
	      // eslint-disable-next-line no-console
	      return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;
	    }
	  }, {
	    key: "warn",
	    get: function get() {
	      // eslint-disable-next-line no-console
	      return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;
	    }
	  }, {
	    key: "error",
	    get: function get() {
	      // eslint-disable-next-line no-console
	      return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;
	    }
	  }]);

	  return Console;
	}();

	var Fullscreen = /*#__PURE__*/function () {
	  function Fullscreen(player) {
	    var _this = this;

	    _classCallCheck(this, Fullscreen);

	    // Keep reference to parent
	    this.player = player; // Get prefix

	    this.prefix = Fullscreen.prefix;
	    this.property = Fullscreen.property; // Scroll position

	    this.scrollPosition = {
	      x: 0,
	      y: 0
	    }; // Force the use of 'full window/browser' rather than fullscreen

	    this.forceFallback = player.config.fullscreen.fallback === 'force'; // Get the fullscreen element
	    // Checks container is an ancestor, defaults to null

	    this.player.elements.fullscreen = player.config.fullscreen.container && closest(this.player.elements.container, player.config.fullscreen.container); // Register event listeners
	    // Handle event (incase user presses escape etc)

	    on.call(this.player, document, this.prefix === 'ms' ? 'MSFullscreenChange' : "".concat(this.prefix, "fullscreenchange"), function () {
	      // TODO: Filter for target??
	      _this.onChange();
	    }); // Fullscreen toggle on double click

	    on.call(this.player, this.player.elements.container, 'dblclick', function (event) {
	      // Ignore double click in controls
	      if (is$1.element(_this.player.elements.controls) && _this.player.elements.controls.contains(event.target)) {
	        return;
	      }

	      _this.toggle();
	    }); // Tap focus when in fullscreen

	    on.call(this, this.player.elements.container, 'keydown', function (event) {
	      return _this.trapFocus(event);
	    }); // Update the UI

	    this.update();
	  } // Determine if native supported


	  _createClass(Fullscreen, [{
	    key: "onChange",
	    value: function onChange() {
	      if (!this.enabled) {
	        return;
	      } // Update toggle button


	      var button = this.player.elements.buttons.fullscreen;

	      if (is$1.element(button)) {
	        button.pressed = this.active;
	      } // Trigger an event


	      triggerEvent.call(this.player, this.target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);
	    }
	  }, {
	    key: "toggleFallback",
	    value: function toggleFallback() {
	      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      // Store or restore scroll position
	      if (toggle) {
	        this.scrollPosition = {
	          x: window.scrollX || 0,
	          y: window.scrollY || 0
	        };
	      } else {
	        window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);
	      } // Toggle scroll


	      document.body.style.overflow = toggle ? 'hidden' : ''; // Toggle class hook

	      toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle); // Force full viewport on iPhone X+

	      if (browser.isIos) {
	        var viewport = document.head.querySelector('meta[name="viewport"]');
	        var property = 'viewport-fit=cover'; // Inject the viewport meta if required

	        if (!viewport) {
	          viewport = document.createElement('meta');
	          viewport.setAttribute('name', 'viewport');
	        } // Check if the property already exists


	        var hasProperty = is$1.string(viewport.content) && viewport.content.includes(property);

	        if (toggle) {
	          this.cleanupViewport = !hasProperty;

	          if (!hasProperty) {
	            viewport.content += ",".concat(property);
	          }
	        } else if (this.cleanupViewport) {
	          viewport.content = viewport.content.split(',').filter(function (part) {
	            return part.trim() !== property;
	          }).join(',');
	        }
	      } // Toggle button and fire events


	      this.onChange();
	    } // Trap focus inside container

	  }, {
	    key: "trapFocus",
	    value: function trapFocus(event) {
	      // Bail if iOS, not active, not the tab key
	      if (browser.isIos || !this.active || event.key !== 'Tab' || event.keyCode !== 9) {
	        return;
	      } // Get the current focused element


	      var focused = document.activeElement;
	      var focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');

	      var _focusable = _slicedToArray(focusable, 1),
	          first = _focusable[0];

	      var last = focusable[focusable.length - 1];

	      if (focused === last && !event.shiftKey) {
	        // Move focus to first element that can be tabbed if Shift isn't used
	        first.focus();
	        event.preventDefault();
	      } else if (focused === first && event.shiftKey) {
	        // Move focus to last element that can be tabbed if Shift is used
	        last.focus();
	        event.preventDefault();
	      }
	    } // Update UI

	  }, {
	    key: "update",
	    value: function update() {
	      if (this.enabled) {
	        var mode;

	        if (this.forceFallback) {
	          mode = 'Fallback (forced)';
	        } else if (Fullscreen.native) {
	          mode = 'Native';
	        } else {
	          mode = 'Fallback';
	        }

	        this.player.debug.log("".concat(mode, " fullscreen enabled"));
	      } else {
	        this.player.debug.log('Fullscreen not supported and fallback disabled');
	      } // Add styling hook to show button


	      toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);
	    } // Make an element fullscreen

	  }, {
	    key: "enter",
	    value: function enter() {
	      if (!this.enabled) {
	        return;
	      } // iOS native fullscreen doesn't need the request step


	      if (browser.isIos && this.player.config.fullscreen.iosNative) {
	        this.target.webkitEnterFullscreen();
	      } else if (!Fullscreen.native || this.forceFallback) {
	        this.toggleFallback(true);
	      } else if (!this.prefix) {
	        this.target.requestFullscreen({
	          navigationUI: 'hide'
	        });
	      } else if (!is$1.empty(this.prefix)) {
	        this.target["".concat(this.prefix, "Request").concat(this.property)]();
	      }
	    } // Bail from fullscreen

	  }, {
	    key: "exit",
	    value: function exit() {
	      if (!this.enabled) {
	        return;
	      } // iOS native fullscreen


	      if (browser.isIos && this.player.config.fullscreen.iosNative) {
	        this.target.webkitExitFullscreen();
	        silencePromise(this.player.play());
	      } else if (!Fullscreen.native || this.forceFallback) {
	        this.toggleFallback(false);
	      } else if (!this.prefix) {
	        (document.cancelFullScreen || document.exitFullscreen).call(document);
	      } else if (!is$1.empty(this.prefix)) {
	        var action = this.prefix === 'moz' ? 'Cancel' : 'Exit';
	        document["".concat(this.prefix).concat(action).concat(this.property)]();
	      }
	    } // Toggle state

	  }, {
	    key: "toggle",
	    value: function toggle() {
	      if (!this.active) {
	        this.enter();
	      } else {
	        this.exit();
	      }
	    }
	  }, {
	    key: "usingNative",
	    // If we're actually using native
	    get: function get() {
	      return Fullscreen.native && !this.forceFallback;
	    } // Get the prefix for handlers

	  }, {
	    key: "enabled",
	    // Determine if fullscreen is enabled
	    get: function get() {
	      return (Fullscreen.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo;
	    } // Get active state

	  }, {
	    key: "active",
	    get: function get() {
	      if (!this.enabled) {
	        return false;
	      } // Fallback using classname


	      if (!Fullscreen.native || this.forceFallback) {
	        return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);
	      }

	      var element = !this.prefix ? document.fullscreenElement : document["".concat(this.prefix).concat(this.property, "Element")];
	      return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;
	    } // Get target element

	  }, {
	    key: "target",
	    get: function get() {
	      return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container;
	    }
	  }], [{
	    key: "native",
	    get: function get() {
	      return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
	    }
	  }, {
	    key: "prefix",
	    get: function get() {
	      // No prefix
	      if (is$1.function(document.exitFullscreen)) {
	        return '';
	      } // Check for fullscreen support by vendor prefix


	      var value = '';
	      var prefixes = ['webkit', 'moz', 'ms'];
	      prefixes.some(function (pre) {
	        if (is$1.function(document["".concat(pre, "ExitFullscreen")]) || is$1.function(document["".concat(pre, "CancelFullScreen")])) {
	          value = pre;
	          return true;
	        }

	        return false;
	      });
	      return value;
	    }
	  }, {
	    key: "property",
	    get: function get() {
	      return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';
	    }
	  }]);

	  return Fullscreen;
	}();

	// `Math.sign` method implementation
	// https://tc39.github.io/ecma262/#sec-math.sign
	var mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	// `Math.sign` method
	// https://tc39.github.io/ecma262/#sec-math.sign
	_export({ target: 'Math', stat: true }, {
	  sign: mathSign
	});

	// ==========================================================================
	// Load image avoiding xhr/fetch CORS issues
	// Server status can't be obtained this way unfortunately, so this uses "naturalWidth" to determine if the image has loaded
	// By default it checks if it is at least 1px, but you can add a second argument to change this
	// ==========================================================================
	function loadImage(src) {
	  var minWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  return new Promise(function (resolve, reject) {
	    var image = new Image();

	    var handler = function handler() {
	      delete image.onload;
	      delete image.onerror;
	      (image.naturalWidth >= minWidth ? resolve : reject)(image);
	    };

	    Object.assign(image, {
	      onload: handler,
	      onerror: handler,
	      src: src
	    });
	  });
	}

	var ui = {
	  addStyleHook: function addStyleHook() {
	    toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);
	    toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);
	  },
	  // Toggle native HTML5 media controls
	  toggleNativeControls: function toggleNativeControls() {
	    var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	    if (toggle && this.isHTML5) {
	      this.media.setAttribute('controls', '');
	    } else {
	      this.media.removeAttribute('controls');
	    }
	  },
	  // Setup the UI
	  build: function build() {
	    var _this = this;

	    // Re-attach media element listeners
	    // TODO: Use event bubbling?
	    this.listeners.media(); // Don't setup interface if no support

	    if (!this.supported.ui) {
	      this.debug.warn("Basic support only for ".concat(this.provider, " ").concat(this.type)); // Restore native controls

	      ui.toggleNativeControls.call(this, true); // Bail

	      return;
	    } // Inject custom controls if not present


	    if (!is$1.element(this.elements.controls)) {
	      // Inject custom controls
	      controls.inject.call(this); // Re-attach control listeners

	      this.listeners.controls();
	    } // Remove native controls


	    ui.toggleNativeControls.call(this); // Setup captions for HTML5

	    if (this.isHTML5) {
	      captions.setup.call(this);
	    } // Reset volume


	    this.volume = null; // Reset mute state

	    this.muted = null; // Reset loop state

	    this.loop = null; // Reset quality setting

	    this.quality = null; // Reset speed

	    this.speed = null; // Reset volume display

	    controls.updateVolume.call(this); // Reset time display

	    controls.timeUpdate.call(this); // Update the UI

	    ui.checkPlaying.call(this); // Check for picture-in-picture support

	    toggleClass(this.elements.container, this.config.classNames.pip.supported, support.pip && this.isHTML5 && this.isVideo); // Check for airplay support

	    toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5); // Add iOS class

	    toggleClass(this.elements.container, this.config.classNames.isIos, browser.isIos); // Add touch class

	    toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch); // Ready for API calls

	    this.ready = true; // Ready event at end of execution stack

	    setTimeout(function () {
	      triggerEvent.call(_this, _this.media, 'ready');
	    }, 0); // Set the title

	    ui.setTitle.call(this); // Assure the poster image is set, if the property was added before the element was created

	    if (this.poster) {
	      ui.setPoster.call(this, this.poster, false).catch(function () {});
	    } // Manually set the duration if user has overridden it.
	    // The event listeners for it doesn't get called if preload is disabled (#701)


	    if (this.config.duration) {
	      controls.durationUpdate.call(this);
	    }
	  },
	  // Setup aria attribute for play and iframe title
	  setTitle: function setTitle() {
	    // Find the current text
	    var label = i18n.get('play', this.config); // If there's a media title set, use that for the label

	    if (is$1.string(this.config.title) && !is$1.empty(this.config.title)) {
	      label += ", ".concat(this.config.title);
	    } // If there's a play button, set label


	    Array.from(this.elements.buttons.play || []).forEach(function (button) {
	      button.setAttribute('aria-label', label);
	    }); // Set iframe title
	    // https://github.com/sampotts/plyr/issues/124

	    if (this.isEmbed) {
	      var iframe = getElement.call(this, 'iframe');

	      if (!is$1.element(iframe)) {
	        return;
	      } // Default to media type


	      var title = !is$1.empty(this.config.title) ? this.config.title : 'video';
	      var format = i18n.get('frameTitle', this.config);
	      iframe.setAttribute('title', format.replace('{title}', title));
	    }
	  },
	  // Toggle poster
	  togglePoster: function togglePoster(enable) {
	    toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);
	  },
	  // Set the poster image (async)
	  // Used internally for the poster setter, with the passive option forced to false
	  setPoster: function setPoster(poster) {
	    var _this2 = this;

	    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    // Don't override if call is passive
	    if (passive && this.poster) {
	      return Promise.reject(new Error('Poster already set'));
	    } // Set property synchronously to respect the call order


	    this.media.setAttribute('data-poster', poster); // Wait until ui is ready

	    return ready.call(this) // Load image
	    .then(function () {
	      return loadImage(poster);
	    }).catch(function (err) {
	      // Hide poster on error unless it's been set by another call
	      if (poster === _this2.poster) {
	        ui.togglePoster.call(_this2, false);
	      } // Rethrow


	      throw err;
	    }).then(function () {
	      // Prevent race conditions
	      if (poster !== _this2.poster) {
	        throw new Error('setPoster cancelled by later call to setPoster');
	      }
	    }).then(function () {
	      Object.assign(_this2.elements.poster.style, {
	        backgroundImage: "url('".concat(poster, "')"),
	        // Reset backgroundSize as well (since it can be set to "cover" for padded thumbnails for youtube)
	        backgroundSize: ''
	      });
	      ui.togglePoster.call(_this2, true);
	      return poster;
	    });
	  },
	  // Check playing state
	  checkPlaying: function checkPlaying(event) {
	    var _this3 = this;

	    // Class hooks
	    toggleClass(this.elements.container, this.config.classNames.playing, this.playing);
	    toggleClass(this.elements.container, this.config.classNames.paused, this.paused);
	    toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped); // Set state

	    Array.from(this.elements.buttons.play || []).forEach(function (target) {
	      Object.assign(target, {
	        pressed: _this3.playing
	      });
	      target.setAttribute('aria-label', i18n.get(_this3.playing ? 'pause' : 'play', _this3.config));
	    }); // Only update controls on non timeupdate events

	    if (is$1.event(event) && event.type === 'timeupdate') {
	      return;
	    } // Toggle controls


	    ui.toggleControls.call(this);
	  },
	  // Check if media is loading
	  checkLoading: function checkLoading(event) {
	    var _this4 = this;

	    this.loading = ['stalled', 'waiting'].includes(event.type); // Clear timer

	    clearTimeout(this.timers.loading); // Timer to prevent flicker when seeking

	    this.timers.loading = setTimeout(function () {
	      // Update progress bar loading class state
	      toggleClass(_this4.elements.container, _this4.config.classNames.loading, _this4.loading); // Update controls visibility

	      ui.toggleControls.call(_this4);
	    }, this.loading ? 250 : 0);
	  },
	  // Toggle controls based on state and `force` argument
	  toggleControls: function toggleControls(force) {
	    var controlsElement = this.elements.controls;

	    if (controlsElement && this.config.hideControls) {
	      // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)
	      var recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now(); // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide

	      this.toggleControls(Boolean(force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek));
	    }
	  },
	  // Migrate any custom properties from the media to the parent
	  migrateStyles: function migrateStyles() {
	    var _this5 = this;

	    // Loop through values (as they are the keys when the object is spread 🤔)
	    Object.values(_objectSpread2({}, this.media.style)) // We're only fussed about Plyr specific properties
	    .filter(function (key) {
	      return !is$1.empty(key) && key.startsWith('--plyr');
	    }).forEach(function (key) {
	      // Set on the container
	      _this5.elements.container.style.setProperty(key, _this5.media.style.getPropertyValue(key)); // Clean up from media element


	      _this5.media.style.removeProperty(key);
	    }); // Remove attribute if empty

	    if (is$1.empty(this.media.style)) {
	      this.media.removeAttribute('style');
	    }
	  }
	};

	var Listeners = /*#__PURE__*/function () {
	  function Listeners(player) {
	    _classCallCheck(this, Listeners);

	    this.player = player;
	    this.lastKey = null;
	    this.focusTimer = null;
	    this.lastKeyDown = null;
	    this.handleKey = this.handleKey.bind(this);
	    this.toggleMenu = this.toggleMenu.bind(this);
	    this.setTabFocus = this.setTabFocus.bind(this);
	    this.firstTouch = this.firstTouch.bind(this);
	  } // Handle key presses


	  _createClass(Listeners, [{
	    key: "handleKey",
	    value: function handleKey(event) {
	      var player = this.player;
	      var elements = player.elements;
	      var code = event.keyCode ? event.keyCode : event.which;
	      var pressed = event.type === 'keydown';
	      var repeat = pressed && code === this.lastKey; // Bail if a modifier key is set

	      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
	        return;
	      } // If the event is bubbled from the media element
	      // Firefox doesn't get the keycode for whatever reason


	      if (!is$1.number(code)) {
	        return;
	      } // Seek by the number keys


	      var seekByKey = function seekByKey() {
	        // Divide the max duration into 10th's and times by the number value
	        player.currentTime = player.duration / 10 * (code - 48);
	      }; // Handle the key on keydown
	      // Reset on keyup


	      if (pressed) {
	        // Check focused element
	        // and if the focused element is not editable (e.g. text input)
	        // and any that accept key input http://webaim.org/techniques/keyboard/
	        var focused = document.activeElement;

	        if (is$1.element(focused)) {
	          var editable = player.config.selectors.editable;
	          var seek = elements.inputs.seek;

	          if (focused !== seek && matches$1(focused, editable)) {
	            return;
	          }

	          if (event.which === 32 && matches$1(focused, 'button, [role^="menuitem"]')) {
	            return;
	          }
	        } // Which keycodes should we prevent default


	        var preventDefault = [32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79]; // If the code is found prevent default (e.g. prevent scrolling for arrows)

	        if (preventDefault.includes(code)) {
	          event.preventDefault();
	          event.stopPropagation();
	        }

	        switch (code) {
	          case 48:
	          case 49:
	          case 50:
	          case 51:
	          case 52:
	          case 53:
	          case 54:
	          case 55:
	          case 56:
	          case 57:
	            // 0-9
	            if (!repeat) {
	              seekByKey();
	            }

	            break;

	          case 32:
	          case 75:
	            // Space and K key
	            if (!repeat) {
	              silencePromise(player.togglePlay());
	            }

	            break;

	          case 38:
	            // Arrow up
	            player.increaseVolume(0.1);
	            break;

	          case 40:
	            // Arrow down
	            player.decreaseVolume(0.1);
	            break;

	          case 77:
	            // M key
	            if (!repeat) {
	              player.muted = !player.muted;
	            }

	            break;

	          case 39:
	            // Arrow forward
	            player.forward();
	            break;

	          case 37:
	            // Arrow back
	            player.rewind();
	            break;

	          case 70:
	            // F key
	            player.fullscreen.toggle();
	            break;

	          case 67:
	            // C key
	            if (!repeat) {
	              player.toggleCaptions();
	            }

	            break;

	          case 76:
	            // L key
	            player.loop = !player.loop;
	            break;
	        } // Escape is handle natively when in full screen
	        // So we only need to worry about non native


	        if (code === 27 && !player.fullscreen.usingNative && player.fullscreen.active) {
	          player.fullscreen.toggle();
	        } // Store last code for next cycle


	        this.lastKey = code;
	      } else {
	        this.lastKey = null;
	      }
	    } // Toggle menu

	  }, {
	    key: "toggleMenu",
	    value: function toggleMenu(event) {
	      controls.toggleMenu.call(this.player, event);
	    } // Device is touch enabled

	  }, {
	    key: "firstTouch",
	    value: function firstTouch() {
	      var player = this.player;
	      var elements = player.elements;
	      player.touch = true; // Add touch class

	      toggleClass(elements.container, player.config.classNames.isTouch, true);
	    }
	  }, {
	    key: "setTabFocus",
	    value: function setTabFocus(event) {
	      var player = this.player;
	      var elements = player.elements;
	      clearTimeout(this.focusTimer); // Ignore any key other than tab

	      if (event.type === 'keydown' && event.which !== 9) {
	        return;
	      } // Store reference to event timeStamp


	      if (event.type === 'keydown') {
	        this.lastKeyDown = event.timeStamp;
	      } // Remove current classes


	      var removeCurrent = function removeCurrent() {
	        var className = player.config.classNames.tabFocus;
	        var current = getElements.call(player, ".".concat(className));
	        toggleClass(current, className, false);
	      }; // Determine if a key was pressed to trigger this event


	      var wasKeyDown = event.timeStamp - this.lastKeyDown <= 20; // Ignore focus events if a key was pressed prior

	      if (event.type === 'focus' && !wasKeyDown) {
	        return;
	      } // Remove all current


	      removeCurrent(); // Delay the adding of classname until the focus has changed
	      // This event fires before the focusin event

	      if (event.type !== 'focusout') {
	        this.focusTimer = setTimeout(function () {
	          var focused = document.activeElement; // Ignore if current focus element isn't inside the player

	          if (!elements.container.contains(focused)) {
	            return;
	          }

	          toggleClass(document.activeElement, player.config.classNames.tabFocus, true);
	        }, 10);
	      }
	    } // Global window & document listeners

	  }, {
	    key: "global",
	    value: function global() {
	      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      var player = this.player; // Keyboard shortcuts

	      if (player.config.keyboard.global) {
	        toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);
	      } // Click anywhere closes menu


	      toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle); // Detect touch by events

	      once.call(player, document.body, 'touchstart', this.firstTouch); // Tab focus detection

	      toggleListener.call(player, document.body, 'keydown focus blur focusout', this.setTabFocus, toggle, false, true);
	    } // Container listeners

	  }, {
	    key: "container",
	    value: function container() {
	      var player = this.player;
	      var config = player.config,
	          elements = player.elements,
	          timers = player.timers; // Keyboard shortcuts

	      if (!config.keyboard.global && config.keyboard.focused) {
	        on.call(player, elements.container, 'keydown keyup', this.handleKey, false);
	      } // Toggle controls on mouse events and entering fullscreen


	      on.call(player, elements.container, 'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen', function (event) {
	        var controlsElement = elements.controls; // Remove button states for fullscreen

	        if (controlsElement && event.type === 'enterfullscreen') {
	          controlsElement.pressed = false;
	          controlsElement.hover = false;
	        } // Show, then hide after a timeout unless another control event occurs


	        var show = ['touchstart', 'touchmove', 'mousemove'].includes(event.type);
	        var delay = 0;

	        if (show) {
	          ui.toggleControls.call(player, true); // Use longer timeout for touch devices

	          delay = player.touch ? 3000 : 2000;
	        } // Clear timer


	        clearTimeout(timers.controls); // Set new timer to prevent flicker when seeking

	        timers.controls = setTimeout(function () {
	          return ui.toggleControls.call(player, false);
	        }, delay);
	      }); // Set a gutter for Vimeo

	      var setGutter = function setGutter(ratio, padding, toggle) {
	        if (!player.isVimeo || player.config.vimeo.premium) {
	          return;
	        }

	        var target = player.elements.wrapper.firstChild;

	        var _ratio = _slicedToArray(ratio, 2),
	            y = _ratio[1];

	        var _getAspectRatio$call = getAspectRatio.call(player),
	            _getAspectRatio$call2 = _slicedToArray(_getAspectRatio$call, 2),
	            videoX = _getAspectRatio$call2[0],
	            videoY = _getAspectRatio$call2[1];

	        target.style.maxWidth = toggle ? "".concat(y / videoY * videoX, "px") : null;
	        target.style.margin = toggle ? '0 auto' : null;
	      }; // Resize on fullscreen change


	      var setPlayerSize = function setPlayerSize(measure) {
	        // If we don't need to measure the viewport
	        if (!measure) {
	          return setAspectRatio.call(player);
	        }

	        var rect = elements.container.getBoundingClientRect();
	        var width = rect.width,
	            height = rect.height;
	        return setAspectRatio.call(player, "".concat(width, ":").concat(height));
	      };

	      var resized = function resized() {
	        clearTimeout(timers.resized);
	        timers.resized = setTimeout(setPlayerSize, 50);
	      };

	      on.call(player, elements.container, 'enterfullscreen exitfullscreen', function (event) {
	        var _player$fullscreen = player.fullscreen,
	            target = _player$fullscreen.target,
	            usingNative = _player$fullscreen.usingNative; // Ignore events not from target

	        if (target !== elements.container) {
	          return;
	        } // If it's not an embed and no ratio specified


	        if (!player.isEmbed && is$1.empty(player.config.ratio)) {
	          return;
	        }

	        var isEnter = event.type === 'enterfullscreen'; // Set the player size when entering fullscreen to viewport size

	        var _setPlayerSize = setPlayerSize(isEnter),
	            padding = _setPlayerSize.padding,
	            ratio = _setPlayerSize.ratio; // Set Vimeo gutter


	        setGutter(ratio, padding, isEnter); // If not using native browser fullscreen API, we need to check for resizes of viewport

	        if (!usingNative) {
	          if (isEnter) {
	            on.call(player, window, 'resize', resized);
	          } else {
	            off.call(player, window, 'resize', resized);
	          }
	        }
	      });
	    } // Listen for media events

	  }, {
	    key: "media",
	    value: function media() {
	      var _this = this;

	      var player = this.player;
	      var elements = player.elements; // Time change on media

	      on.call(player, player.media, 'timeupdate seeking seeked', function (event) {
	        return controls.timeUpdate.call(player, event);
	      }); // Display duration

	      on.call(player, player.media, 'durationchange loadeddata loadedmetadata', function (event) {
	        return controls.durationUpdate.call(player, event);
	      }); // Handle the media finishing

	      on.call(player, player.media, 'ended', function () {
	        // Show poster on end
	        if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {
	          // Restart
	          player.restart(); // Call pause otherwise IE11 will start playing the video again

	          player.pause();
	        }
	      }); // Check for buffer progress

	      on.call(player, player.media, 'progress playing seeking seeked', function (event) {
	        return controls.updateProgress.call(player, event);
	      }); // Handle volume changes

	      on.call(player, player.media, 'volumechange', function (event) {
	        return controls.updateVolume.call(player, event);
	      }); // Handle play/pause

	      on.call(player, player.media, 'playing play pause ended emptied timeupdate', function (event) {
	        return ui.checkPlaying.call(player, event);
	      }); // Loading state

	      on.call(player, player.media, 'waiting canplay seeked playing', function (event) {
	        return ui.checkLoading.call(player, event);
	      }); // Click video

	      if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {
	        // Re-fetch the wrapper
	        var wrapper = getElement.call(player, ".".concat(player.config.classNames.video)); // Bail if there's no wrapper (this should never happen)

	        if (!is$1.element(wrapper)) {
	          return;
	        } // On click play, pause or restart


	        on.call(player, elements.container, 'click', function (event) {
	          var targets = [elements.container, wrapper]; // Ignore if click if not container or in video wrapper

	          if (!targets.includes(event.target) && !wrapper.contains(event.target)) {
	            return;
	          } // Touch devices will just show controls (if hidden)


	          if (player.touch && player.config.hideControls) {
	            return;
	          }

	          if (player.ended) {
	            _this.proxy(event, player.restart, 'restart');

	            _this.proxy(event, function () {
	              silencePromise(player.play());
	            }, 'play');
	          } else {
	            _this.proxy(event, function () {
	              silencePromise(player.togglePlay());
	            }, 'play');
	          }
	        });
	      } // Disable right click


	      if (player.supported.ui && player.config.disableContextMenu) {
	        on.call(player, elements.wrapper, 'contextmenu', function (event) {
	          event.preventDefault();
	        }, false);
	      } // Volume change


	      on.call(player, player.media, 'volumechange', function () {
	        // Save to storage
	        player.storage.set({
	          volume: player.volume,
	          muted: player.muted
	        });
	      }); // Speed change

	      on.call(player, player.media, 'ratechange', function () {
	        // Update UI
	        controls.updateSetting.call(player, 'speed'); // Save to storage


	        player.storage.set({
	          speed: player.speed
	        });
	      }); // Quality change

	      on.call(player, player.media, 'qualitychange', function (event) {
	        // Update UI
	        controls.updateSetting.call(player, 'quality', null, event.detail.quality);
	      }); // Update download link when ready and if quality changes

	      on.call(player, player.media, 'ready qualitychange', function () {
	        controls.setDownloadUrl.call(player);
	      }); // Proxy events to container
	      // Bubble up key events for Edge

	      var proxyEvents = player.config.events.concat(['keyup', 'keydown']).join(' ');
	      on.call(player, player.media, proxyEvents, function (event) {
	        var _event$detail = event.detail,
	            detail = _event$detail === void 0 ? {} : _event$detail; // Get error details from media

	        if (event.type === 'error') {
	          detail = player.media.error;
	        }

	        triggerEvent.call(player, elements.container, event.type, true, detail);
	      });
	    } // Run default and custom handlers

	  }, {
	    key: "proxy",
	    value: function proxy(event, defaultHandler, customHandlerKey) {
	      var player = this.player;
	      var customHandler = player.config.listeners[customHandlerKey];
	      var hasCustomHandler = is$1.function(customHandler);
	      var returned = true; // Execute custom handler

	      if (hasCustomHandler) {
	        returned = customHandler.call(player, event);
	      } // Only call default handler if not prevented in custom handler


	      if (returned !== false && is$1.function(defaultHandler)) {
	        defaultHandler.call(player, event);
	      }
	    } // Trigger custom and default handlers

	  }, {
	    key: "bind",
	    value: function bind(element, type, defaultHandler, customHandlerKey) {
	      var _this2 = this;

	      var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var player = this.player;
	      var customHandler = player.config.listeners[customHandlerKey];
	      var hasCustomHandler = is$1.function(customHandler);
	      on.call(player, element, type, function (event) {
	        return _this2.proxy(event, defaultHandler, customHandlerKey);
	      }, passive && !hasCustomHandler);
	    } // Listen for control events

	  }, {
	    key: "controls",
	    value: function controls$1() {
	      var _this3 = this;

	      var player = this.player;
	      var elements = player.elements; // IE doesn't support input event, so we fallback to change

	      var inputEvent = browser.isIE ? 'change' : 'input'; // Play/pause toggle

	      if (elements.buttons.play) {
	        Array.from(elements.buttons.play).forEach(function (button) {
	          _this3.bind(button, 'click', function () {
	            silencePromise(player.togglePlay());
	          }, 'play');
	        });
	      } // Pause


	      this.bind(elements.buttons.restart, 'click', player.restart, 'restart'); // Rewind

	      this.bind(elements.buttons.rewind, 'click', player.rewind, 'rewind'); // Rewind

	      this.bind(elements.buttons.fastForward, 'click', player.forward, 'fastForward'); // Mute toggle

	      this.bind(elements.buttons.mute, 'click', function () {
	        player.muted = !player.muted;
	      }, 'mute'); // Captions toggle

	      this.bind(elements.buttons.captions, 'click', function () {
	        return player.toggleCaptions();
	      }); // Download

	      this.bind(elements.buttons.download, 'click', function () {
	        triggerEvent.call(player, player.media, 'download');
	      }, 'download'); // Fullscreen toggle

	      this.bind(elements.buttons.fullscreen, 'click', function () {
	        player.fullscreen.toggle();
	      }, 'fullscreen'); // Picture-in-Picture

	      this.bind(elements.buttons.pip, 'click', function () {
	        player.pip = 'toggle';
	      }, 'pip'); // Airplay

	      this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay'); // Settings menu - click toggle

	      this.bind(elements.buttons.settings, 'click', function (event) {
	        // Prevent the document click listener closing the menu
	        event.stopPropagation();
	        event.preventDefault();

	        controls.toggleMenu.call(player, event);
	      }, null, false); // Can't be passive as we're preventing default
	      // Settings menu - keyboard toggle
	      // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143

	      this.bind(elements.buttons.settings, 'keyup', function (event) {
	        var code = event.which; // We only care about space and return

	        if (![13, 32].includes(code)) {
	          return;
	        } // Because return triggers a click anyway, all we need to do is set focus


	        if (code === 13) {
	          controls.focusFirstMenuItem.call(player, null, true);

	          return;
	        } // Prevent scroll


	        event.preventDefault(); // Prevent playing video (Firefox)

	        event.stopPropagation(); // Toggle menu

	        controls.toggleMenu.call(player, event);
	      }, null, false // Can't be passive as we're preventing default
	      ); // Escape closes menu

	      this.bind(elements.settings.menu, 'keydown', function (event) {
	        if (event.which === 27) {
	          controls.toggleMenu.call(player, event);
	        }
	      }); // Set range input alternative "value", which matches the tooltip time (#954)

	      this.bind(elements.inputs.seek, 'mousedown mousemove', function (event) {
	        var rect = elements.progress.getBoundingClientRect();
	        var percent = 100 / rect.width * (event.pageX - rect.left);
	        event.currentTarget.setAttribute('seek-value', percent);
	      }); // Pause while seeking

	      this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', function (event) {
	        var seek = event.currentTarget;
	        var code = event.keyCode ? event.keyCode : event.which;
	        var attribute = 'play-on-seeked';

	        if (is$1.keyboardEvent(event) && code !== 39 && code !== 37) {
	          return;
	        } // Record seek time so we can prevent hiding controls for a few seconds after seek


	        player.lastSeekTime = Date.now(); // Was playing before?

	        var play = seek.hasAttribute(attribute); // Done seeking

	        var done = ['mouseup', 'touchend', 'keyup'].includes(event.type); // If we're done seeking and it was playing, resume playback

	        if (play && done) {
	          seek.removeAttribute(attribute);
	          silencePromise(player.play());
	        } else if (!done && player.playing) {
	          seek.setAttribute(attribute, '');
	          player.pause();
	        }
	      }); // Fix range inputs on iOS
	      // Super weird iOS bug where after you interact with an <input type="range">,
	      // it takes over further interactions on the page. This is a hack

	      if (browser.isIos) {
	        var inputs = getElements.call(player, 'input[type="range"]');
	        Array.from(inputs).forEach(function (input) {
	          return _this3.bind(input, inputEvent, function (event) {
	            return repaint(event.target);
	          });
	        });
	      } // Seek


	      this.bind(elements.inputs.seek, inputEvent, function (event) {
	        var seek = event.currentTarget; // If it exists, use seek-value instead of "value" for consistency with tooltip time (#954)

	        var seekTo = seek.getAttribute('seek-value');

	        if (is$1.empty(seekTo)) {
	          seekTo = seek.value;
	        }

	        seek.removeAttribute('seek-value');
	        player.currentTime = seekTo / seek.max * player.duration;
	      }, 'seek'); // Seek tooltip

	      this.bind(elements.progress, 'mouseenter mouseleave mousemove', function (event) {
	        return controls.updateSeekTooltip.call(player, event);
	      }); // Preview thumbnails plugin
	      // TODO: Really need to work on some sort of plug-in wide event bus or pub-sub for this

	      this.bind(elements.progress, 'mousemove touchmove', function (event) {
	        var previewThumbnails = player.previewThumbnails;

	        if (previewThumbnails && previewThumbnails.loaded) {
	          previewThumbnails.startMove(event);
	        }
	      }); // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering

	      this.bind(elements.progress, 'mouseleave touchend click', function () {
	        var previewThumbnails = player.previewThumbnails;

	        if (previewThumbnails && previewThumbnails.loaded) {
	          previewThumbnails.endMove(false, true);
	        }
	      }); // Show scrubbing preview

	      this.bind(elements.progress, 'mousedown touchstart', function (event) {
	        var previewThumbnails = player.previewThumbnails;

	        if (previewThumbnails && previewThumbnails.loaded) {
	          previewThumbnails.startScrubbing(event);
	        }
	      });
	      this.bind(elements.progress, 'mouseup touchend', function (event) {
	        var previewThumbnails = player.previewThumbnails;

	        if (previewThumbnails && previewThumbnails.loaded) {
	          previewThumbnails.endScrubbing(event);
	        }
	      }); // Polyfill for lower fill in <input type="range"> for webkit

	      if (browser.isWebkit) {
	        Array.from(getElements.call(player, 'input[type="range"]')).forEach(function (element) {
	          _this3.bind(element, 'input', function (event) {
	            return controls.updateRangeFill.call(player, event.target);
	          });
	        });
	      } // Current time invert
	      // Only if one time element is used for both currentTime and duration


	      if (player.config.toggleInvert && !is$1.element(elements.display.duration)) {
	        this.bind(elements.display.currentTime, 'click', function () {
	          // Do nothing if we're at the start
	          if (player.currentTime === 0) {
	            return;
	          }

	          player.config.invertTime = !player.config.invertTime;

	          controls.timeUpdate.call(player);
	        });
	      } // Volume


	      this.bind(elements.inputs.volume, inputEvent, function (event) {
	        player.volume = event.target.value;
	      }, 'volume'); // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)

	      this.bind(elements.controls, 'mouseenter mouseleave', function (event) {
	        elements.controls.hover = !player.touch && event.type === 'mouseenter';
	      }); // Also update controls.hover state for any non-player children of fullscreen element (as above)

	      if (elements.fullscreen) {
	        Array.from(elements.fullscreen.children).filter(function (c) {
	          return !c.contains(elements.container);
	        }).forEach(function (child) {
	          _this3.bind(child, 'mouseenter mouseleave', function (event) {
	            elements.controls.hover = !player.touch && event.type === 'mouseenter';
	          });
	        });
	      } // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)


	      this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', function (event) {
	        elements.controls.pressed = ['mousedown', 'touchstart'].includes(event.type);
	      }); // Show controls when they receive focus (e.g., when using keyboard tab key)

	      this.bind(elements.controls, 'focusin', function () {
	        var config = player.config,
	            timers = player.timers; // Skip transition to prevent focus from scrolling the parent element

	        toggleClass(elements.controls, config.classNames.noTransition, true); // Toggle

	        ui.toggleControls.call(player, true); // Restore transition

	        setTimeout(function () {
	          toggleClass(elements.controls, config.classNames.noTransition, false);
	        }, 0); // Delay a little more for mouse users

	        var delay = _this3.touch ? 3000 : 4000; // Clear timer

	        clearTimeout(timers.controls); // Hide again after delay

	        timers.controls = setTimeout(function () {
	          return ui.toggleControls.call(player, false);
	        }, delay);
	      }); // Mouse wheel for volume

	      this.bind(elements.inputs.volume, 'wheel', function (event) {
	        // Detect "natural" scroll - suppored on OS X Safari only
	        // Other browsers on OS X will be inverted until support improves
	        var inverted = event.webkitDirectionInvertedFromDevice; // Get delta from event. Invert if `inverted` is true

	        var _map = [event.deltaX, -event.deltaY].map(function (value) {
	          return inverted ? -value : value;
	        }),
	            _map2 = _slicedToArray(_map, 2),
	            x = _map2[0],
	            y = _map2[1]; // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)


	        var direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y); // Change the volume by 2%

	        player.increaseVolume(direction / 50); // Don't break page scrolling at max and min

	        var volume = player.media.volume;

	        if (direction === 1 && volume < 1 || direction === -1 && volume > 0) {
	          event.preventDefault();
	        }
	      }, 'volume', false);
	    }
	  }]);

	  return Listeners;
	}();

	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$a = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

	var max$3 = Math.max;
	var min$5 = Math.min;
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$a }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var arguments$1 = arguments;

	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$5(max$3(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) { createProperty(A, k, O[from]); }
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) { O[to] = O[from]; }
	        else { delete O[to]; }
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) { delete O[k - 1]; }
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) { O[to] = O[from]; }
	        else { delete O[to]; }
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments$1[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var loadjs_umd = createCommonjsModule$1(function (module, exports) {
	  (function (root, factory) {
	    {
	      module.exports = factory();
	    }
	  })(commonjsGlobal$1, function () {
	    /**
	     * Global dependencies.
	     * @global {Object} document - DOM
	     */
	    var devnull = function devnull() {},
	        bundleIdCache = {},
	        bundleResultCache = {},
	        bundleCallbackQueue = {};
	    /**
	     * Subscribe to bundle load event.
	     * @param {string[]} bundleIds - Bundle ids
	     * @param {Function} callbackFn - The callback function
	     */


	    function subscribe(bundleIds, callbackFn) {
	      // listify
	      bundleIds = bundleIds.push ? bundleIds : [bundleIds];
	      var depsNotFound = [],
	          i = bundleIds.length,
	          numWaiting = i,
	          fn,
	          bundleId,
	          r,
	          q; // define callback function

	      fn = function fn(bundleId, pathsNotFound) {
	        if (pathsNotFound.length) { depsNotFound.push(bundleId); }
	        numWaiting--;
	        if (!numWaiting) { callbackFn(depsNotFound); }
	      }; // register callback


	      while (i--) {
	        bundleId = bundleIds[i]; // execute callback if in result cache

	        r = bundleResultCache[bundleId];

	        if (r) {
	          fn(bundleId, r);
	          continue;
	        } // add to callback queue


	        q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
	        q.push(fn);
	      }
	    }
	    /**
	     * Publish bundle load event.
	     * @param {string} bundleId - Bundle id
	     * @param {string[]} pathsNotFound - List of files not found
	     */


	    function publish(bundleId, pathsNotFound) {
	      // exit if id isn't defined
	      if (!bundleId) { return; }
	      var q = bundleCallbackQueue[bundleId]; // cache result

	      bundleResultCache[bundleId] = pathsNotFound; // exit if queue is empty

	      if (!q) { return; } // empty callback queue

	      while (q.length) {
	        q[0](bundleId, pathsNotFound);
	        q.splice(0, 1);
	      }
	    }
	    /**
	     * Execute callbacks.
	     * @param {Object or Function} args - The callback args
	     * @param {string[]} depsNotFound - List of dependencies not found
	     */


	    function executeCallbacks(args, depsNotFound) {
	      // accept function as argument
	      if (args.call) { args = {
	        success: args
	      }; } // success and error callbacks

	      if (depsNotFound.length) { (args.error || devnull)(depsNotFound); }else { (args.success || devnull)(args); }
	    }
	    /**
	     * Load individual file.
	     * @param {string} path - The file path
	     * @param {Function} callbackFn - The callback function
	     */


	    function loadFile(path, callbackFn, args, numTries) {
	      var doc = document,
	          async = args.async,
	          maxTries = (args.numRetries || 0) + 1,
	          beforeCallbackFn = args.before || devnull,
	          pathname = path.replace(/[\?|#].*$/, ''),
	          pathStripped = path.replace(/^(css|img)!/, ''),
	          isLegacyIECss,
	          e;
	      numTries = numTries || 0;

	      if (/(^css!|\.css$)/.test(pathname)) {
	        // css
	        e = doc.createElement('link');
	        e.rel = 'stylesheet';
	        e.href = pathStripped; // tag IE9+

	        isLegacyIECss = 'hideFocus' in e; // use preload in IE Edge (to detect load errors)

	        if (isLegacyIECss && e.relList) {
	          isLegacyIECss = 0;
	          e.rel = 'preload';
	          e.as = 'style';
	        }
	      } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
	        // image
	        e = doc.createElement('img');
	        e.src = pathStripped;
	      } else {
	        // javascript
	        e = doc.createElement('script');
	        e.src = path;
	        e.async = async === undefined ? true : async;
	      }

	      e.onload = e.onerror = e.onbeforeload = function (ev) {
	        var result = ev.type[0]; // treat empty stylesheets as failures to get around lack of onerror
	        // support in IE9-11

	        if (isLegacyIECss) {
	          try {
	            if (!e.sheet.cssText.length) { result = 'e'; }
	          } catch (x) {
	            // sheets objects created from load errors don't allow access to
	            // `cssText` (unless error is Code:18 SecurityError)
	            if (x.code != 18) { result = 'e'; }
	          }
	        } // handle retries in case of load failure


	        if (result == 'e') {
	          // increment counter
	          numTries += 1; // exit function and try again

	          if (numTries < maxTries) {
	            return loadFile(path, callbackFn, args, numTries);
	          }
	        } else if (e.rel == 'preload' && e.as == 'style') {
	          // activate preloaded stylesheets
	          return e.rel = 'stylesheet'; // jshint ignore:line
	        } // execute callback


	        callbackFn(path, result, ev.defaultPrevented);
	      }; // add to document (unless callback returns `false`)


	      if (beforeCallbackFn(path, e) !== false) { doc.head.appendChild(e); }
	    }
	    /**
	     * Load multiple files.
	     * @param {string[]} paths - The file paths
	     * @param {Function} callbackFn - The callback function
	     */


	    function loadFiles(paths, callbackFn, args) {
	      // listify paths
	      paths = paths.push ? paths : [paths];
	      var numWaiting = paths.length,
	          x = numWaiting,
	          pathsNotFound = [],
	          fn,
	          i; // define callback function

	      fn = function fn(path, result, defaultPrevented) {
	        // handle error
	        if (result == 'e') { pathsNotFound.push(path); } // handle beforeload event. If defaultPrevented then that means the load
	        // will be blocked (ex. Ghostery/ABP on Safari)

	        if (result == 'b') {
	          if (defaultPrevented) { pathsNotFound.push(path); }else { return; }
	        }

	        numWaiting--;
	        if (!numWaiting) { callbackFn(pathsNotFound); }
	      }; // load scripts


	      for (i = 0; i < x; i++) {
	        loadFile(paths[i], fn, args);
	      }
	    }
	    /**
	     * Initiate script load and register bundle.
	     * @param {(string|string[])} paths - The file paths
	     * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success
	     *   callback or (3) object literal with success/error arguments, numRetries,
	     *   etc.
	     * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object
	     *   literal with success/error arguments, numRetries, etc.
	     */


	    function loadjs(paths, arg1, arg2) {
	      var bundleId, args; // bundleId (if string)

	      if (arg1 && arg1.trim) { bundleId = arg1; } // args (default is {})

	      args = (bundleId ? arg2 : arg1) || {}; // throw error if bundle is already defined

	      if (bundleId) {
	        if (bundleId in bundleIdCache) {
	          throw "LoadJS";
	        } else {
	          bundleIdCache[bundleId] = true;
	        }
	      }

	      function loadFn(resolve, reject) {
	        loadFiles(paths, function (pathsNotFound) {
	          // execute callbacks
	          executeCallbacks(args, pathsNotFound); // resolve Promise

	          if (resolve) {
	            executeCallbacks({
	              success: resolve,
	              error: reject
	            }, pathsNotFound);
	          } // publish bundle load event


	          publish(bundleId, pathsNotFound);
	        }, args);
	      }

	      if (args.returnPromise) { return new Promise(loadFn); }else { loadFn(); }
	    }
	    /**
	     * Execute callbacks when dependencies have been satisfied.
	     * @param {(string|string[])} deps - List of bundle ids
	     * @param {Object} args - success/error arguments
	     */


	    loadjs.ready = function ready(deps, args) {
	      // subscribe to bundle load event
	      subscribe(deps, function (depsNotFound) {
	        // execute callbacks
	        executeCallbacks(args, depsNotFound);
	      });
	      return loadjs;
	    };
	    /**
	     * Manually satisfy bundle dependencies.
	     * @param {string} bundleId - The bundle id
	     */


	    loadjs.done = function done(bundleId) {
	      publish(bundleId, []);
	    };
	    /**
	     * Reset loadjs dependencies statuses
	     */


	    loadjs.reset = function reset() {
	      bundleIdCache = {};
	      bundleResultCache = {};
	      bundleCallbackQueue = {};
	    };
	    /**
	     * Determine if bundle has already been defined
	     * @param String} bundleId - The bundle id
	     */


	    loadjs.isDefined = function isDefined(bundleId) {
	      return bundleId in bundleIdCache;
	    }; // export


	    return loadjs;
	  });
	});

	function loadScript(url) {
	  return new Promise(function (resolve, reject) {
	    loadjs_umd(url, {
	      success: resolve,
	      error: reject
	    });
	  });
	}

	function parseId(url) {
	  if (is$1.empty(url)) {
	    return null;
	  }

	  if (is$1.number(Number(url))) {
	    return url;
	  }

	  var regex = /^.*(vimeo.com\/|video\/)(\d+).*/;
	  return url.match(regex) ? RegExp.$2 : url;
	} // Set playback state and trigger change (only on actual change)


	function assurePlaybackState(play) {
	  if (play && !this.embed.hasPlayed) {
	    this.embed.hasPlayed = true;
	  }

	  if (this.media.paused === play) {
	    this.media.paused = !play;
	    triggerEvent.call(this, this.media, play ? 'play' : 'pause');
	  }
	}

	var vimeo = {
	  setup: function setup() {
	    var player = this; // Add embed class for responsive

	    toggleClass(player.elements.wrapper, player.config.classNames.embed, true); // Set speed options from config

	    player.options.speed = player.config.speed.options; // Set intial ratio

	    setAspectRatio.call(player); // Load the SDK if not already

	    if (!is$1.object(window.Vimeo)) {
	      loadScript(player.config.urls.vimeo.sdk).then(function () {
	        vimeo.ready.call(player);
	      }).catch(function (error) {
	        player.debug.warn('Vimeo SDK (player.js) failed to load', error);
	      });
	    } else {
	      vimeo.ready.call(player);
	    }
	  },
	  // API Ready
	  ready: function ready() {
	    var _this = this;

	    var player = this;
	    var config = player.config.vimeo;

	    var premium = config.premium,
	        referrerPolicy = config.referrerPolicy,
	        frameParams = _objectWithoutProperties(config, ["premium", "referrerPolicy"]); // If the owner has a pro or premium account then we can hide controls etc


	    if (premium) {
	      Object.assign(frameParams, {
	        controls: false,
	        sidedock: false
	      });
	    } // Get Vimeo params for the iframe


	    var params = buildUrlParams(_objectSpread2({
	      loop: player.config.loop.active,
	      autoplay: player.autoplay,
	      muted: player.muted,
	      gesture: 'media',
	      playsinline: !this.config.fullscreen.iosNative
	    }, frameParams)); // Get the source URL or ID

	    var source = player.media.getAttribute('src'); // Get from <div> if needed

	    if (is$1.empty(source)) {
	      source = player.media.getAttribute(player.config.attributes.embed.id);
	    }

	    var id = parseId(source); // Build an iframe

	    var iframe = createElement('iframe');
	    var src = format$1(player.config.urls.vimeo.iframe, id, params);
	    iframe.setAttribute('src', src);
	    iframe.setAttribute('allowfullscreen', '');
	    iframe.setAttribute('allow', 'autoplay,fullscreen,picture-in-picture'); // Set the referrer policy if required

	    if (!is$1.empty(referrerPolicy)) {
	      iframe.setAttribute('referrerPolicy', referrerPolicy);
	    } // Inject the package


	    var poster = player.poster;

	    if (premium) {
	      iframe.setAttribute('data-poster', poster);
	      player.media = replaceElement(iframe, player.media);
	    } else {
	      var wrapper = createElement('div', {
	        class: player.config.classNames.embedContainer,
	        'data-poster': poster
	      });
	      wrapper.appendChild(iframe);
	      player.media = replaceElement(wrapper, player.media);
	    } // Get poster image


	    fetch$1(format$1(player.config.urls.vimeo.api, id), 'json').then(function (response) {
	      if (is$1.empty(response)) {
	        return;
	      } // Get the URL for thumbnail


	      var url = new URL(response[0].thumbnail_large); // Get original image

	      url.pathname = "".concat(url.pathname.split('_')[0], ".jpg"); // Set and show poster

	      ui.setPoster.call(player, url.href).catch(function () {});
	    }); // Setup instance
	    // https://github.com/vimeo/player.js

	    player.embed = new window.Vimeo.Player(iframe, {
	      autopause: player.config.autopause,
	      muted: player.muted
	    });
	    player.media.paused = true;
	    player.media.currentTime = 0; // Disable native text track rendering

	    if (player.supported.ui) {
	      player.embed.disableTextTrack();
	    } // Create a faux HTML5 API using the Vimeo API


	    player.media.play = function () {
	      assurePlaybackState.call(player, true);
	      return player.embed.play();
	    };

	    player.media.pause = function () {
	      assurePlaybackState.call(player, false);
	      return player.embed.pause();
	    };

	    player.media.stop = function () {
	      player.pause();
	      player.currentTime = 0;
	    }; // Seeking


	    var currentTime = player.media.currentTime;
	    Object.defineProperty(player.media, 'currentTime', {
	      get: function get() {
	        return currentTime;
	      },
	      set: function set(time) {
	        // Vimeo will automatically play on seek if the video hasn't been played before
	        // Get current paused state and volume etc
	        var embed = player.embed,
	            media = player.media,
	            paused = player.paused,
	            volume = player.volume;
	        var restorePause = paused && !embed.hasPlayed; // Set seeking state and trigger event

	        media.seeking = true;
	        triggerEvent.call(player, media, 'seeking'); // If paused, mute until seek is complete

	        Promise.resolve(restorePause && embed.setVolume(0)) // Seek
	        .then(function () {
	          return embed.setCurrentTime(time);
	        }) // Restore paused
	        .then(function () {
	          return restorePause && embed.pause();
	        }) // Restore volume
	        .then(function () {
	          return restorePause && embed.setVolume(volume);
	        }).catch(function () {// Do nothing
	        });
	      }
	    }); // Playback speed

	    var speed = player.config.speed.selected;
	    Object.defineProperty(player.media, 'playbackRate', {
	      get: function get() {
	        return speed;
	      },
	      set: function set(input) {
	        player.embed.setPlaybackRate(input).then(function () {
	          speed = input;
	          triggerEvent.call(player, player.media, 'ratechange');
	        }).catch(function () {
	          // Cannot set Playback Rate, Video is probably not on Pro account
	          player.options.speed = [1];
	        });
	      }
	    }); // Volume

	    var volume = player.config.volume;
	    Object.defineProperty(player.media, 'volume', {
	      get: function get() {
	        return volume;
	      },
	      set: function set(input) {
	        player.embed.setVolume(input).then(function () {
	          volume = input;
	          triggerEvent.call(player, player.media, 'volumechange');
	        });
	      }
	    }); // Muted

	    var muted = player.config.muted;
	    Object.defineProperty(player.media, 'muted', {
	      get: function get() {
	        return muted;
	      },
	      set: function set(input) {
	        var toggle = is$1.boolean(input) ? input : false;
	        player.embed.setVolume(toggle ? 0 : player.config.volume).then(function () {
	          muted = toggle;
	          triggerEvent.call(player, player.media, 'volumechange');
	        });
	      }
	    }); // Loop

	    var loop = player.config.loop;
	    Object.defineProperty(player.media, 'loop', {
	      get: function get() {
	        return loop;
	      },
	      set: function set(input) {
	        var toggle = is$1.boolean(input) ? input : player.config.loop.active;
	        player.embed.setLoop(toggle).then(function () {
	          loop = toggle;
	        });
	      }
	    }); // Source

	    var currentSrc;
	    player.embed.getVideoUrl().then(function (value) {
	      currentSrc = value;
	      controls.setDownloadUrl.call(player);
	    }).catch(function (error) {
	      _this.debug.warn(error);
	    });
	    Object.defineProperty(player.media, 'currentSrc', {
	      get: function get() {
	        return currentSrc;
	      }
	    }); // Ended

	    Object.defineProperty(player.media, 'ended', {
	      get: function get() {
	        return player.currentTime === player.duration;
	      }
	    }); // Set aspect ratio based on video size

	    Promise.all([player.embed.getVideoWidth(), player.embed.getVideoHeight()]).then(function (dimensions) {
	      var _dimensions = _slicedToArray(dimensions, 2),
	          width = _dimensions[0],
	          height = _dimensions[1];

	      player.embed.ratio = [width, height];
	      setAspectRatio.call(_this);
	    }); // Set autopause

	    player.embed.setAutopause(player.config.autopause).then(function (state) {
	      player.config.autopause = state;
	    }); // Get title

	    player.embed.getVideoTitle().then(function (title) {
	      player.config.title = title;
	      ui.setTitle.call(_this);
	    }); // Get current time

	    player.embed.getCurrentTime().then(function (value) {
	      currentTime = value;
	      triggerEvent.call(player, player.media, 'timeupdate');
	    }); // Get duration

	    player.embed.getDuration().then(function (value) {
	      player.media.duration = value;
	      triggerEvent.call(player, player.media, 'durationchange');
	    }); // Get captions

	    player.embed.getTextTracks().then(function (tracks) {
	      player.media.textTracks = tracks;
	      captions.setup.call(player);
	    });
	    player.embed.on('cuechange', function (_ref) {
	      var _ref$cues = _ref.cues,
	          cues = _ref$cues === void 0 ? [] : _ref$cues;
	      var strippedCues = cues.map(function (cue) {
	        return stripHTML(cue.text);
	      });
	      captions.updateCues.call(player, strippedCues);
	    });
	    player.embed.on('loaded', function () {
	      // Assure state and events are updated on autoplay
	      player.embed.getPaused().then(function (paused) {
	        assurePlaybackState.call(player, !paused);

	        if (!paused) {
	          triggerEvent.call(player, player.media, 'playing');
	        }
	      });

	      if (is$1.element(player.embed.element) && player.supported.ui) {
	        var frame = player.embed.element; // Fix keyboard focus issues
	        // https://github.com/sampotts/plyr/issues/317

	        frame.setAttribute('tabindex', -1);
	      }
	    });
	    player.embed.on('bufferstart', function () {
	      triggerEvent.call(player, player.media, 'waiting');
	    });
	    player.embed.on('bufferend', function () {
	      triggerEvent.call(player, player.media, 'playing');
	    });
	    player.embed.on('play', function () {
	      assurePlaybackState.call(player, true);
	      triggerEvent.call(player, player.media, 'playing');
	    });
	    player.embed.on('pause', function () {
	      assurePlaybackState.call(player, false);
	    });
	    player.embed.on('timeupdate', function (data) {
	      player.media.seeking = false;
	      currentTime = data.seconds;
	      triggerEvent.call(player, player.media, 'timeupdate');
	    });
	    player.embed.on('progress', function (data) {
	      player.media.buffered = data.percent;
	      triggerEvent.call(player, player.media, 'progress'); // Check all loaded

	      if (parseInt(data.percent, 10) === 1) {
	        triggerEvent.call(player, player.media, 'canplaythrough');
	      } // Get duration as if we do it before load, it gives an incorrect value
	      // https://github.com/sampotts/plyr/issues/891


	      player.embed.getDuration().then(function (value) {
	        if (value !== player.media.duration) {
	          player.media.duration = value;
	          triggerEvent.call(player, player.media, 'durationchange');
	        }
	      });
	    });
	    player.embed.on('seeked', function () {
	      player.media.seeking = false;
	      triggerEvent.call(player, player.media, 'seeked');
	    });
	    player.embed.on('ended', function () {
	      player.media.paused = true;
	      triggerEvent.call(player, player.media, 'ended');
	    });
	    player.embed.on('error', function (detail) {
	      player.media.error = detail;
	      triggerEvent.call(player, player.media, 'error');
	    }); // Rebuild UI

	    setTimeout(function () {
	      return ui.build.call(player);
	    }, 0);
	  }
	};

	function parseId$1(url) {
	  if (is$1.empty(url)) {
	    return null;
	  }

	  var regex = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
	  return url.match(regex) ? RegExp.$2 : url;
	} // Set playback state and trigger change (only on actual change)


	function assurePlaybackState$1(play) {
	  if (play && !this.embed.hasPlayed) {
	    this.embed.hasPlayed = true;
	  }

	  if (this.media.paused === play) {
	    this.media.paused = !play;
	    triggerEvent.call(this, this.media, play ? 'play' : 'pause');
	  }
	}

	function getHost$1(config) {
	  if (config.noCookie) {
	    return 'https://www.youtube-nocookie.com';
	  }

	  if (window.location.protocol === 'http:') {
	    return 'http://www.youtube.com';
	  } // Use YouTube's default


	  return undefined;
	}

	var youtube = {
	  setup: function setup() {
	    var _this = this;

	    // Add embed class for responsive
	    toggleClass(this.elements.wrapper, this.config.classNames.embed, true); // Setup API

	    if (is$1.object(window.YT) && is$1.function(window.YT.Player)) {
	      youtube.ready.call(this);
	    } else {
	      // Reference current global callback
	      var callback = window.onYouTubeIframeAPIReady; // Set callback to process queue

	      window.onYouTubeIframeAPIReady = function () {
	        // Call global callback if set
	        if (is$1.function(callback)) {
	          callback();
	        }

	        youtube.ready.call(_this);
	      }; // Load the SDK


	      loadScript(this.config.urls.youtube.sdk).catch(function (error) {
	        _this.debug.warn('YouTube API failed to load', error);
	      });
	    }
	  },
	  // Get the media title
	  getTitle: function getTitle(videoId) {
	    var _this2 = this;

	    var url = format$1(this.config.urls.youtube.api, videoId);
	    fetch$1(url).then(function (data) {
	      if (is$1.object(data)) {
	        var title = data.title,
	            height = data.height,
	            width = data.width; // Set title

	        _this2.config.title = title;
	        ui.setTitle.call(_this2); // Set aspect ratio

	        _this2.embed.ratio = [width, height];
	      }

	      setAspectRatio.call(_this2);
	    }).catch(function () {
	      // Set aspect ratio
	      setAspectRatio.call(_this2);
	    });
	  },
	  // API ready
	  ready: function ready() {
	    var player = this; // Ignore already setup (race condition)

	    var currentId = player.media && player.media.getAttribute('id');

	    if (!is$1.empty(currentId) && currentId.startsWith('youtube-')) {
	      return;
	    } // Get the source URL or ID


	    var source = player.media.getAttribute('src'); // Get from <div> if needed

	    if (is$1.empty(source)) {
	      source = player.media.getAttribute(this.config.attributes.embed.id);
	    } // Replace the <iframe> with a <div> due to YouTube API issues


	    var videoId = parseId$1(source);
	    var id = generateId(player.provider); // Get poster, if already set

	    var poster = player.poster; // Replace media element

	    var container = createElement('div', {
	      id: id,
	      'data-poster': poster
	    });
	    player.media = replaceElement(container, player.media); // Id to poster wrapper

	    var posterSrc = function posterSrc(s) {
	      return "https://i.ytimg.com/vi/".concat(videoId, "/").concat(s, "default.jpg");
	    }; // Check thumbnail images in order of quality, but reject fallback thumbnails (120px wide)


	    loadImage(posterSrc('maxres'), 121) // Higest quality and unpadded
	    .catch(function () {
	      return loadImage(posterSrc('sd'), 121);
	    }) // 480p padded 4:3
	    .catch(function () {
	      return loadImage(posterSrc('hq'));
	    }) // 360p padded 4:3. Always exists
	    .then(function (image) {
	      return ui.setPoster.call(player, image.src);
	    }).then(function (src) {
	      // If the image is padded, use background-size "cover" instead (like youtube does too with their posters)
	      if (!src.includes('maxres')) {
	        player.elements.poster.style.backgroundSize = 'cover';
	      }
	    }).catch(function () {});
	    var config = player.config.youtube; // Setup instance
	    // https://developers.google.com/youtube/iframe_api_reference

	    player.embed = new window.YT.Player(id, {
	      videoId: videoId,
	      host: getHost$1(config),
	      playerVars: extend({}, {
	        autoplay: player.config.autoplay ? 1 : 0,
	        // Autoplay
	        hl: player.config.hl,
	        // iframe interface language
	        controls: player.supported.ui ? 0 : 1,
	        // Only show controls if not fully supported
	        disablekb: 1,
	        // Disable keyboard as we handle it
	        playsinline: !player.config.fullscreen.iosNative ? 1 : 0,
	        // Allow iOS inline playback
	        // Captions are flaky on YouTube
	        cc_load_policy: player.captions.active ? 1 : 0,
	        cc_lang_pref: player.config.captions.language,
	        // Tracking for stats
	        widget_referrer: window ? window.location.href : null
	      }, config),
	      events: {
	        onError: function onError(event) {
	          // YouTube may fire onError twice, so only handle it once
	          if (!player.media.error) {
	            var code = event.data; // Messages copied from https://developers.google.com/youtube/iframe_api_reference#onError

	            var message = {
	              2: 'The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.',
	              5: 'The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.',
	              100: 'The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.',
	              101: 'The owner of the requested video does not allow it to be played in embedded players.',
	              150: 'The owner of the requested video does not allow it to be played in embedded players.'
	            }[code] || 'An unknown error occured';
	            player.media.error = {
	              code: code,
	              message: message
	            };
	            triggerEvent.call(player, player.media, 'error');
	          }
	        },
	        onPlaybackRateChange: function onPlaybackRateChange(event) {
	          // Get the instance
	          var instance = event.target; // Get current speed

	          player.media.playbackRate = instance.getPlaybackRate();
	          triggerEvent.call(player, player.media, 'ratechange');
	        },
	        onReady: function onReady(event) {
	          // Bail if onReady has already been called. See issue #1108
	          if (is$1.function(player.media.play)) {
	            return;
	          } // Get the instance


	          var instance = event.target; // Get the title

	          youtube.getTitle.call(player, videoId); // Create a faux HTML5 API using the YouTube API

	          player.media.play = function () {
	            assurePlaybackState$1.call(player, true);
	            instance.playVideo();
	          };

	          player.media.pause = function () {
	            assurePlaybackState$1.call(player, false);
	            instance.pauseVideo();
	          };

	          player.media.stop = function () {
	            instance.stopVideo();
	          };

	          player.media.duration = instance.getDuration();
	          player.media.paused = true; // Seeking

	          player.media.currentTime = 0;
	          Object.defineProperty(player.media, 'currentTime', {
	            get: function get() {
	              return Number(instance.getCurrentTime());
	            },
	            set: function set(time) {
	              // If paused and never played, mute audio preventively (YouTube starts playing on seek if the video hasn't been played yet).
	              if (player.paused && !player.embed.hasPlayed) {
	                player.embed.mute();
	              } // Set seeking state and trigger event


	              player.media.seeking = true;
	              triggerEvent.call(player, player.media, 'seeking'); // Seek after events sent

	              instance.seekTo(time);
	            }
	          }); // Playback speed

	          Object.defineProperty(player.media, 'playbackRate', {
	            get: function get() {
	              return instance.getPlaybackRate();
	            },
	            set: function set(input) {
	              instance.setPlaybackRate(input);
	            }
	          }); // Volume

	          var volume = player.config.volume;
	          Object.defineProperty(player.media, 'volume', {
	            get: function get() {
	              return volume;
	            },
	            set: function set(input) {
	              volume = input;
	              instance.setVolume(volume * 100);
	              triggerEvent.call(player, player.media, 'volumechange');
	            }
	          }); // Muted

	          var muted = player.config.muted;
	          Object.defineProperty(player.media, 'muted', {
	            get: function get() {
	              return muted;
	            },
	            set: function set(input) {
	              var toggle = is$1.boolean(input) ? input : muted;
	              muted = toggle;
	              instance[toggle ? 'mute' : 'unMute']();
	              triggerEvent.call(player, player.media, 'volumechange');
	            }
	          }); // Source

	          Object.defineProperty(player.media, 'currentSrc', {
	            get: function get() {
	              return instance.getVideoUrl();
	            }
	          }); // Ended

	          Object.defineProperty(player.media, 'ended', {
	            get: function get() {
	              return player.currentTime === player.duration;
	            }
	          }); // Get available speeds

	          var speeds = instance.getAvailablePlaybackRates(); // Filter based on config

	          player.options.speed = speeds.filter(function (s) {
	            return player.config.speed.options.includes(s);
	          }); // Set the tabindex to avoid focus entering iframe

	          if (player.supported.ui) {
	            player.media.setAttribute('tabindex', -1);
	          }

	          triggerEvent.call(player, player.media, 'timeupdate');
	          triggerEvent.call(player, player.media, 'durationchange'); // Reset timer

	          clearInterval(player.timers.buffering); // Setup buffering

	          player.timers.buffering = setInterval(function () {
	            // Get loaded % from YouTube
	            player.media.buffered = instance.getVideoLoadedFraction(); // Trigger progress only when we actually buffer something

	            if (player.media.lastBuffered === null || player.media.lastBuffered < player.media.buffered) {
	              triggerEvent.call(player, player.media, 'progress');
	            } // Set last buffer point


	            player.media.lastBuffered = player.media.buffered; // Bail if we're at 100%

	            if (player.media.buffered === 1) {
	              clearInterval(player.timers.buffering); // Trigger event

	              triggerEvent.call(player, player.media, 'canplaythrough');
	            }
	          }, 200); // Rebuild UI

	          setTimeout(function () {
	            return ui.build.call(player);
	          }, 50);
	        },
	        onStateChange: function onStateChange(event) {
	          // Get the instance
	          var instance = event.target; // Reset timer

	          clearInterval(player.timers.playing);
	          var seeked = player.media.seeking && [1, 2].includes(event.data);

	          if (seeked) {
	            // Unset seeking and fire seeked event
	            player.media.seeking = false;
	            triggerEvent.call(player, player.media, 'seeked');
	          } // Handle events
	          // -1   Unstarted
	          // 0    Ended
	          // 1    Playing
	          // 2    Paused
	          // 3    Buffering
	          // 5    Video cued


	          switch (event.data) {
	            case -1:
	              // Update scrubber
	              triggerEvent.call(player, player.media, 'timeupdate'); // Get loaded % from YouTube

	              player.media.buffered = instance.getVideoLoadedFraction();
	              triggerEvent.call(player, player.media, 'progress');
	              break;

	            case 0:
	              assurePlaybackState$1.call(player, false); // YouTube doesn't support loop for a single video, so mimick it.

	              if (player.media.loop) {
	                // YouTube needs a call to `stopVideo` before playing again
	                instance.stopVideo();
	                instance.playVideo();
	              } else {
	                triggerEvent.call(player, player.media, 'ended');
	              }

	              break;

	            case 1:
	              // Restore paused state (YouTube starts playing on seek if the video hasn't been played yet)
	              if (!player.config.autoplay && player.media.paused && !player.embed.hasPlayed) {
	                player.media.pause();
	              } else {
	                assurePlaybackState$1.call(player, true);
	                triggerEvent.call(player, player.media, 'playing'); // Poll to get playback progress

	                player.timers.playing = setInterval(function () {
	                  triggerEvent.call(player, player.media, 'timeupdate');
	                }, 50); // Check duration again due to YouTube bug
	                // https://github.com/sampotts/plyr/issues/374
	                // https://code.google.com/p/gdata-issues/issues/detail?id=8690

	                if (player.media.duration !== instance.getDuration()) {
	                  player.media.duration = instance.getDuration();
	                  triggerEvent.call(player, player.media, 'durationchange');
	                }
	              }

	              break;

	            case 2:
	              // Restore audio (YouTube starts playing on seek if the video hasn't been played yet)
	              if (!player.muted) {
	                player.embed.unMute();
	              }

	              assurePlaybackState$1.call(player, false);
	              break;

	            case 3:
	              // Trigger waiting event to add loading classes to container as the video buffers.
	              triggerEvent.call(player, player.media, 'waiting');
	              break;
	          }

	          triggerEvent.call(player, player.elements.container, 'statechange', false, {
	            code: event.data
	          });
	        }
	      }
	    });
	  }
	};

	var media = {
	  // Setup media
	  setup: function setup() {
	    // If there's no media, bail
	    if (!this.media) {
	      this.debug.warn('No media element found!');
	      return;
	    } // Add type class


	    toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true); // Add provider class

	    toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true); // Add video class for embeds
	    // This will require changes if audio embeds are added

	    if (this.isEmbed) {
	      toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);
	    } // Inject the player wrapper


	    if (this.isVideo) {
	      // Create the wrapper div
	      this.elements.wrapper = createElement('div', {
	        class: this.config.classNames.video
	      }); // Wrap the video in a container

	      wrap$1(this.media, this.elements.wrapper); // Poster image container

	      this.elements.poster = createElement('div', {
	        class: this.config.classNames.poster
	      });
	      this.elements.wrapper.appendChild(this.elements.poster);
	    }

	    if (this.isHTML5) {
	      html5.setup.call(this);
	    } else if (this.isYouTube) {
	      youtube.setup.call(this);
	    } else if (this.isVimeo) {
	      vimeo.setup.call(this);
	    }
	  }
	};

	var destroy = function destroy(instance) {
	  // Destroy our adsManager
	  if (instance.manager) {
	    instance.manager.destroy();
	  } // Destroy our adsManager


	  if (instance.elements.displayContainer) {
	    instance.elements.displayContainer.destroy();
	  }

	  instance.elements.container.remove();
	};

	var Ads = /*#__PURE__*/function () {
	  /**
	   * Ads constructor.
	   * @param {Object} player
	   * @return {Ads}
	   */
	  function Ads(player) {
	    var _this = this;

	    _classCallCheck(this, Ads);

	    this.player = player;
	    this.config = player.config.ads;
	    this.playing = false;
	    this.initialized = false;
	    this.elements = {
	      container: null,
	      displayContainer: null
	    };
	    this.manager = null;
	    this.loader = null;
	    this.cuePoints = null;
	    this.events = {};
	    this.safetyTimer = null;
	    this.countdownTimer = null; // Setup a promise to resolve when the IMA manager is ready

	    this.managerPromise = new Promise(function (resolve, reject) {
	      // The ad is loaded and ready
	      _this.on('loaded', resolve); // Ads failed


	      _this.on('error', reject);
	    });
	    this.load();
	  }

	  _createClass(Ads, [{
	    key: "load",

	    /**
	     * Load the IMA SDK
	     */
	    value: function load() {
	      var _this2 = this;

	      if (!this.enabled) {
	        return;
	      } // Check if the Google IMA3 SDK is loaded or load it ourselves


	      if (!is$1.object(window.google) || !is$1.object(window.google.ima)) {
	        loadScript(this.player.config.urls.googleIMA.sdk).then(function () {
	          _this2.ready();
	        }).catch(function () {
	          // Script failed to load or is blocked
	          _this2.trigger('error', new Error('Google IMA SDK failed to load'));
	        });
	      } else {
	        this.ready();
	      }
	    }
	    /**
	     * Get the ads instance ready
	     */

	  }, {
	    key: "ready",
	    value: function ready() {
	      var _this3 = this;

	      // Double check we're enabled
	      if (!this.enabled) {
	        destroy(this);
	      } // Start ticking our safety timer. If the whole advertisement
	      // thing doesn't resolve within our set time; we bail


	      this.startSafetyTimer(12000, 'ready()'); // Clear the safety timer

	      this.managerPromise.then(function () {
	        _this3.clearSafetyTimer('onAdsManagerLoaded()');
	      }); // Set listeners on the Plyr instance

	      this.listeners(); // Setup the IMA SDK

	      this.setupIMA();
	    } // Build the tag URL

	  }, {
	    key: "setupIMA",

	    /**
	     * In order for the SDK to display ads for our video, we need to tell it where to put them,
	     * so here we define our ad container. This div is set up to render on top of the video player.
	     * Using the code below, we tell the SDK to render ads within that div. We also provide a
	     * handle to the content video player - the SDK will poll the current time of our player to
	     * properly place mid-rolls. After we create the ad display container, we initialize it. On
	     * mobile devices, this initialization is done as the result of a user action.
	     */
	    value: function setupIMA() {
	      var _this4 = this;

	      // Create the container for our advertisements
	      this.elements.container = createElement('div', {
	        class: this.player.config.classNames.ads
	      });
	      this.player.elements.container.appendChild(this.elements.container); // So we can run VPAID2

	      google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED); // Set language

	      google.ima.settings.setLocale(this.player.config.ads.language); // Set playback for iOS10+

	      google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline); // We assume the adContainer is the video container of the plyr element that will house the ads

	      this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media); // Create ads loader

	      this.loader = new google.ima.AdsLoader(this.elements.displayContainer); // Listen and respond to ads loaded and error events

	      this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function (event) {
	        return _this4.onAdsManagerLoaded(event);
	      }, false);
	      this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function (error) {
	        return _this4.onAdError(error);
	      }, false); // Request video ads to be pre-loaded

	      this.requestAds();
	    }
	    /**
	     * Request advertisements
	     */

	  }, {
	    key: "requestAds",
	    value: function requestAds() {
	      var container = this.player.elements.container;

	      try {
	        // Request video ads
	        var request = new google.ima.AdsRequest();
	        request.adTagUrl = this.tagUrl; // Specify the linear and nonlinear slot sizes. This helps the SDK
	        // to select the correct creative if multiple are returned

	        request.linearAdSlotWidth = container.offsetWidth;
	        request.linearAdSlotHeight = container.offsetHeight;
	        request.nonLinearAdSlotWidth = container.offsetWidth;
	        request.nonLinearAdSlotHeight = container.offsetHeight; // We only overlay ads as we only support video.

	        request.forceNonLinearFullSlot = false; // Mute based on current state

	        request.setAdWillPlayMuted(!this.player.muted);
	        this.loader.requestAds(request);
	      } catch (e) {
	        this.onAdError(e);
	      }
	    }
	    /**
	     * Update the ad countdown
	     * @param {Boolean} start
	     */

	  }, {
	    key: "pollCountdown",
	    value: function pollCountdown() {
	      var _this5 = this;

	      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (!start) {
	        clearInterval(this.countdownTimer);
	        this.elements.container.removeAttribute('data-badge-text');
	        return;
	      }

	      var update = function update() {
	        var time = formatTime(Math.max(_this5.manager.getRemainingTime(), 0));
	        var label = "".concat(i18n.get('advertisement', _this5.player.config), " - ").concat(time);

	        _this5.elements.container.setAttribute('data-badge-text', label);
	      };

	      this.countdownTimer = setInterval(update, 100);
	    }
	    /**
	     * This method is called whenever the ads are ready inside the AdDisplayContainer
	     * @param {Event} adsManagerLoadedEvent
	     */

	  }, {
	    key: "onAdsManagerLoaded",
	    value: function onAdsManagerLoaded(event) {
	      var _this6 = this;

	      // Load could occur after a source change (race condition)
	      if (!this.enabled) {
	        return;
	      } // Get the ads manager


	      var settings = new google.ima.AdsRenderingSettings(); // Tell the SDK to save and restore content video state on our behalf

	      settings.restoreCustomPlaybackStateOnAdBreakComplete = true;
	      settings.enablePreloading = true; // The SDK is polling currentTime on the contentPlayback. And needs a duration
	      // so it can determine when to start the mid- and post-roll

	      this.manager = event.getAdsManager(this.player, settings); // Get the cue points for any mid-rolls by filtering out the pre- and post-roll

	      this.cuePoints = this.manager.getCuePoints(); // Add listeners to the required events
	      // Advertisement error events

	      this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function (error) {
	        return _this6.onAdError(error);
	      }); // Advertisement regular events

	      Object.keys(google.ima.AdEvent.Type).forEach(function (type) {
	        _this6.manager.addEventListener(google.ima.AdEvent.Type[type], function (e) {
	          return _this6.onAdEvent(e);
	        });
	      }); // Resolve our adsManager

	      this.trigger('loaded');
	    }
	  }, {
	    key: "addCuePoints",
	    value: function addCuePoints() {
	      var _this7 = this;

	      // Add advertisement cue's within the time line if available
	      if (!is$1.empty(this.cuePoints)) {
	        this.cuePoints.forEach(function (cuePoint) {
	          if (cuePoint !== 0 && cuePoint !== -1 && cuePoint < _this7.player.duration) {
	            var seekElement = _this7.player.elements.progress;

	            if (is$1.element(seekElement)) {
	              var cuePercentage = 100 / _this7.player.duration * cuePoint;
	              var cue = createElement('span', {
	                class: _this7.player.config.classNames.cues
	              });
	              cue.style.left = "".concat(cuePercentage.toString(), "%");
	              seekElement.appendChild(cue);
	            }
	          }
	        });
	      }
	    }
	    /**
	     * This is where all the event handling takes place. Retrieve the ad from the event. Some
	     * events (e.g. ALL_ADS_COMPLETED) don't have the ad object associated
	     * https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdEvent.Type
	     * @param {Event} event
	     */

	  }, {
	    key: "onAdEvent",
	    value: function onAdEvent(event) {
	      var _this8 = this;

	      var container = this.player.elements.container; // Retrieve the ad from the event. Some events (e.g. ALL_ADS_COMPLETED)
	      // don't have ad object associated

	      var ad = event.getAd();
	      var adData = event.getAdData(); // Proxy event

	      var dispatchEvent = function dispatchEvent(type) {
	        triggerEvent.call(_this8.player, _this8.player.media, "ads".concat(type.replace(/_/g, '').toLowerCase()));
	      }; // Bubble the event


	      dispatchEvent(event.type);

	      switch (event.type) {
	        case google.ima.AdEvent.Type.LOADED:
	          // This is the first event sent for an ad - it is possible to determine whether the
	          // ad is a video ad or an overlay
	          this.trigger('loaded'); // Start countdown

	          this.pollCountdown(true);

	          if (!ad.isLinear()) {
	            // Position AdDisplayContainer correctly for overlay
	            ad.width = container.offsetWidth;
	            ad.height = container.offsetHeight;
	          } // console.info('Ad type: ' + event.getAd().getAdPodInfo().getPodIndex());
	          // console.info('Ad time: ' + event.getAd().getAdPodInfo().getTimeOffset());


	          break;

	        case google.ima.AdEvent.Type.STARTED:
	          // Set volume to match player
	          this.manager.setVolume(this.player.volume);
	          break;

	        case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
	          // All ads for the current videos are done. We can now request new advertisements
	          // in case the video is re-played
	          // TODO: Example for what happens when a next video in a playlist would be loaded.
	          // So here we load a new video when all ads are done.
	          // Then we load new ads within a new adsManager. When the video
	          // Is started - after - the ads are loaded, then we get ads.
	          // You can also easily test cancelling and reloading by running
	          // player.ads.cancel() and player.ads.play from the console I guess.
	          // this.player.source = {
	          //     type: 'video',
	          //     title: 'View From A Blue Moon',
	          //     sources: [{
	          //         src:
	          // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.mp4', type:
	          // 'video/mp4', }], poster:
	          // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.jpg', tracks:
	          // [ { kind: 'captions', label: 'English', srclang: 'en', src:
	          // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.en.vtt',
	          // default: true, }, { kind: 'captions', label: 'French', srclang: 'fr', src:
	          // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.fr.vtt', }, ],
	          // };
	          // TODO: So there is still this thing where a video should only be allowed to start
	          // playing when the IMA SDK is ready or has failed
	          if (this.player.ended) {
	            this.loadAds();
	          } else {
	            // The SDK won't allow new ads to be called without receiving a contentComplete()
	            this.loader.contentComplete();
	          }

	          break;

	        case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
	          // This event indicates the ad has started - the video player can adjust the UI,
	          // for example display a pause button and remaining time. Fired when content should
	          // be paused. This usually happens right before an ad is about to cover the content
	          this.pauseContent();
	          break;

	        case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
	          // This event indicates the ad has finished - the video player can perform
	          // appropriate UI actions, such as removing the timer for remaining time detection.
	          // Fired when content should be resumed. This usually happens when an ad finishes
	          // or collapses
	          this.pollCountdown();
	          this.resumeContent();
	          break;

	        case google.ima.AdEvent.Type.LOG:
	          if (adData.adError) {
	            this.player.debug.warn("Non-fatal ad error: ".concat(adData.adError.getMessage()));
	          }

	          break;
	      }
	    }
	    /**
	     * Any ad error handling comes through here
	     * @param {Event} event
	     */

	  }, {
	    key: "onAdError",
	    value: function onAdError(event) {
	      this.cancel();
	      this.player.debug.warn('Ads error', event);
	    }
	    /**
	     * Setup hooks for Plyr and window events. This ensures
	     * the mid- and post-roll launch at the correct time. And
	     * resize the advertisement when the player resizes
	     */

	  }, {
	    key: "listeners",
	    value: function listeners() {
	      var _this9 = this;

	      var container = this.player.elements.container;
	      var time;
	      this.player.on('canplay', function () {
	        _this9.addCuePoints();
	      });
	      this.player.on('ended', function () {
	        _this9.loader.contentComplete();
	      });
	      this.player.on('timeupdate', function () {
	        time = _this9.player.currentTime;
	      });
	      this.player.on('seeked', function () {
	        var seekedTime = _this9.player.currentTime;

	        if (is$1.empty(_this9.cuePoints)) {
	          return;
	        }

	        _this9.cuePoints.forEach(function (cuePoint, index) {
	          if (time < cuePoint && cuePoint < seekedTime) {
	            _this9.manager.discardAdBreak();

	            _this9.cuePoints.splice(index, 1);
	          }
	        });
	      }); // Listen to the resizing of the window. And resize ad accordingly
	      // TODO: eventually implement ResizeObserver

	      window.addEventListener('resize', function () {
	        if (_this9.manager) {
	          _this9.manager.resize(container.offsetWidth, container.offsetHeight, google.ima.ViewMode.NORMAL);
	        }
	      });
	    }
	    /**
	     * Initialize the adsManager and start playing advertisements
	     */

	  }, {
	    key: "play",
	    value: function play() {
	      var _this10 = this;

	      var container = this.player.elements.container;

	      if (!this.managerPromise) {
	        this.resumeContent();
	      } // Play the requested advertisement whenever the adsManager is ready


	      this.managerPromise.then(function () {
	        // Set volume to match player
	        _this10.manager.setVolume(_this10.player.volume); // Initialize the container. Must be done via a user action on mobile devices


	        _this10.elements.displayContainer.initialize();

	        try {
	          if (!_this10.initialized) {
	            // Initialize the ads manager. Ad rules playlist will start at this time
	            _this10.manager.init(container.offsetWidth, container.offsetHeight, google.ima.ViewMode.NORMAL); // Call play to start showing the ad. Single video and overlay ads will
	            // start at this time; the call will be ignored for ad rules


	            _this10.manager.start();
	          }

	          _this10.initialized = true;
	        } catch (adError) {
	          // An error may be thrown if there was a problem with the
	          // VAST response
	          _this10.onAdError(adError);
	        }
	      }).catch(function () {});
	    }
	    /**
	     * Resume our video
	     */

	  }, {
	    key: "resumeContent",
	    value: function resumeContent() {
	      // Hide the advertisement container
	      this.elements.container.style.zIndex = ''; // Ad is stopped

	      this.playing = false; // Play video

	      silencePromise(this.player.media.play());
	    }
	    /**
	     * Pause our video
	     */

	  }, {
	    key: "pauseContent",
	    value: function pauseContent() {
	      // Show the advertisement container
	      this.elements.container.style.zIndex = 3; // Ad is playing

	      this.playing = true; // Pause our video.

	      this.player.media.pause();
	    }
	    /**
	     * Destroy the adsManager so we can grab new ads after this. If we don't then we're not
	     * allowed to call new ads based on google policies, as they interpret this as an accidental
	     * video requests. https://developers.google.com/interactive-
	     * media-ads/docs/sdks/android/faq#8
	     */

	  }, {
	    key: "cancel",
	    value: function cancel() {
	      // Pause our video
	      if (this.initialized) {
	        this.resumeContent();
	      } // Tell our instance that we're done for now


	      this.trigger('error'); // Re-create our adsManager

	      this.loadAds();
	    }
	    /**
	     * Re-create our adsManager
	     */

	  }, {
	    key: "loadAds",
	    value: function loadAds() {
	      var _this11 = this;

	      // Tell our adsManager to go bye bye
	      this.managerPromise.then(function () {
	        // Destroy our adsManager
	        if (_this11.manager) {
	          _this11.manager.destroy();
	        } // Re-set our adsManager promises


	        _this11.managerPromise = new Promise(function (resolve) {
	          _this11.on('loaded', resolve);

	          _this11.player.debug.log(_this11.manager);
	        }); // Now that the manager has been destroyed set it to also be un-initialized

	        _this11.initialized = false; // Now request some new advertisements

	        _this11.requestAds();
	      }).catch(function () {});
	    }
	    /**
	     * Handles callbacks after an ad event was invoked
	     * @param {String} event - Event type
	     */

	  }, {
	    key: "trigger",
	    value: function trigger(event) {
	      var arguments$1 = arguments;

	      var _this12 = this;

	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments$1[_key];
	      }

	      var handlers = this.events[event];

	      if (is$1.array(handlers)) {
	        handlers.forEach(function (handler) {
	          if (is$1.function(handler)) {
	            handler.apply(_this12, args);
	          }
	        });
	      }
	    }
	    /**
	     * Add event listeners
	     * @param {String} event - Event type
	     * @param {Function} callback - Callback for when event occurs
	     * @return {Ads}
	     */

	  }, {
	    key: "on",
	    value: function on(event, callback) {
	      if (!is$1.array(this.events[event])) {
	        this.events[event] = [];
	      }

	      this.events[event].push(callback);
	      return this;
	    }
	    /**
	     * Setup a safety timer for when the ad network doesn't respond for whatever reason.
	     * The advertisement has 12 seconds to get its things together. We stop this timer when the
	     * advertisement is playing, or when a user action is required to start, then we clear the
	     * timer on ad ready
	     * @param {Number} time
	     * @param {String} from
	     */

	  }, {
	    key: "startSafetyTimer",
	    value: function startSafetyTimer(time, from) {
	      var _this13 = this;

	      this.player.debug.log("Safety timer invoked from: ".concat(from));
	      this.safetyTimer = setTimeout(function () {
	        _this13.cancel();

	        _this13.clearSafetyTimer('startSafetyTimer()');
	      }, time);
	    }
	    /**
	     * Clear our safety timer(s)
	     * @param {String} from
	     */

	  }, {
	    key: "clearSafetyTimer",
	    value: function clearSafetyTimer(from) {
	      if (!is$1.nullOrUndefined(this.safetyTimer)) {
	        this.player.debug.log("Safety timer cleared from: ".concat(from));
	        clearTimeout(this.safetyTimer);
	        this.safetyTimer = null;
	      }
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      var config = this.config;
	      return this.player.isHTML5 && this.player.isVideo && config.enabled && (!is$1.empty(config.publisherId) || is$1.url(config.tagUrl));
	    }
	  }, {
	    key: "tagUrl",
	    get: function get() {
	      var config = this.config;

	      if (is$1.url(config.tagUrl)) {
	        return config.tagUrl;
	      }

	      var params = {
	        AV_PUBLISHERID: '58c25bb0073ef448b1087ad6',
	        AV_CHANNELID: '5a0458dc28a06145e4519d21',
	        AV_URL: window.location.hostname,
	        cb: Date.now(),
	        AV_WIDTH: 640,
	        AV_HEIGHT: 480,
	        AV_CDIM2: config.publisherId
	      };
	      var base = 'https://go.aniview.com/api/adserver6/vast/';
	      return "".concat(base, "?").concat(buildUrlParams(params));
	    }
	  }]);

	  return Ads;
	}();

	var $findIndex = arrayIteration.findIndex;



	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES$1 = true;

	var USES_TO_LENGTH$b = arrayMethodUsesToLength(FIND_INDEX);

	// Shouldn't skip holes
	if (FIND_INDEX in []) { Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; }); }

	// `Array.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$b }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	var min$6 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$6 = arrayMethodIsStrict('lastIndexOf');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$c = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
	var FORCED$5 = NEGATIVE_ZERO$1 || !STRICT_METHOD$6 || !USES_TO_LENGTH$c;

	// `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	var arrayLastIndexOf = FORCED$5 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO$1) { return nativeLastIndexOf.apply(this, arguments) || 0; }
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) { index = min$6(index, toInteger(arguments[1])); }
	  if (index < 0) { index = length + index; }
	  for (;index >= 0; index--) { if (index in O && O[index] === searchElement) { return index || 0; } }
	  return -1;
	} : nativeLastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
	  lastIndexOf: arrayLastIndexOf
	});

	var parseVtt = function parseVtt(vttDataString) {
	  var processedList = [];
	  var frames = vttDataString.split(/\r\n\r\n|\n\n|\r\r/);
	  frames.forEach(function (frame) {
	    var result = {};
	    var lines = frame.split(/\r\n|\n|\r/);
	    lines.forEach(function (line) {
	      if (!is$1.number(result.startTime)) {
	        // The line with start and end times on it is the first line of interest
	        var matchTimes = line.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT

	        if (matchTimes) {
	          result.startTime = Number(matchTimes[1] || 0) * 60 * 60 + Number(matchTimes[2]) * 60 + Number(matchTimes[3]) + Number("0.".concat(matchTimes[4]));
	          result.endTime = Number(matchTimes[6] || 0) * 60 * 60 + Number(matchTimes[7]) * 60 + Number(matchTimes[8]) + Number("0.".concat(matchTimes[9]));
	        }
	      } else if (!is$1.empty(line.trim()) && is$1.empty(result.text)) {
	        // If we already have the startTime, then we're definitely up to the text line(s)
	        var lineSplit = line.trim().split('#xywh=');

	        var _lineSplit = _slicedToArray(lineSplit, 1);

	        result.text = _lineSplit[0];

	        // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image
	        if (lineSplit[1]) {
	          var _lineSplit$1$split = lineSplit[1].split(',');

	          var _lineSplit$1$split2 = _slicedToArray(_lineSplit$1$split, 4);

	          result.x = _lineSplit$1$split2[0];
	          result.y = _lineSplit$1$split2[1];
	          result.w = _lineSplit$1$split2[2];
	          result.h = _lineSplit$1$split2[3];
	        }
	      }
	    });

	    if (result.text) {
	      processedList.push(result);
	    }
	  });
	  return processedList;
	};
	/**
	 * Preview thumbnails for seek hover and scrubbing
	 * Seeking: Hover over the seek bar (desktop only): shows a small preview container above the seek bar
	 * Scrubbing: Click and drag the seek bar (desktop and mobile): shows the preview image over the entire video, as if the video is scrubbing at very high speed
	 *
	 * Notes:
	 * - Thumbs are set via JS settings on Plyr init, not HTML5 'track' property. Using the track property would be a bit gross, because it doesn't support custom 'kinds'. kind=metadata might be used for something else, and we want to allow multiple thumbnails tracks. Tracks must have a unique combination of 'kind' and 'label'. We would have to do something like kind=metadata,label=thumbnails1 / kind=metadata,label=thumbnails2. Square peg, round hole
	 * - VTT info: the image URL is relative to the VTT, not the current document. But if the url starts with a slash, it will naturally be relative to the current domain. https://support.jwplayer.com/articles/how-to-add-preview-thumbnails
	 * - This implementation uses multiple separate img elements. Other implementations use background-image on one element. This would be nice and simple, but Firefox and Safari have flickering issues with replacing backgrounds of larger images. It seems that YouTube perhaps only avoids this because they don't have the option for high-res previews (even the fullscreen ones, when mousedown/seeking). Images appear over the top of each other, and previous ones are discarded once the new ones have been rendered
	 */


	var fitRatio = function fitRatio(ratio, outer) {
	  var targetRatio = outer.width / outer.height;
	  var result = {};

	  if (ratio > targetRatio) {
	    result.width = outer.width;
	    result.height = 1 / ratio * outer.width;
	  } else {
	    result.height = outer.height;
	    result.width = ratio * outer.height;
	  }

	  return result;
	};

	var PreviewThumbnails = /*#__PURE__*/function () {
	  /**
	   * PreviewThumbnails constructor.
	   * @param {Plyr} player
	   * @return {PreviewThumbnails}
	   */
	  function PreviewThumbnails(player) {
	    _classCallCheck(this, PreviewThumbnails);

	    this.player = player;
	    this.thumbnails = [];
	    this.loaded = false;
	    this.lastMouseMoveTime = Date.now();
	    this.mouseDown = false;
	    this.loadedImages = [];
	    this.elements = {
	      thumb: {},
	      scrubbing: {}
	    };
	    this.load();
	  }

	  _createClass(PreviewThumbnails, [{
	    key: "load",
	    value: function load() {
	      var _this = this;

	      // Toggle the regular seek tooltip
	      if (this.player.elements.display.seekTooltip) {
	        this.player.elements.display.seekTooltip.hidden = this.enabled;
	      }

	      if (!this.enabled) {
	        return;
	      }

	      this.getThumbnails().then(function () {
	        if (!_this.enabled) {
	          return;
	        } // Render DOM elements


	        _this.render(); // Check to see if thumb container size was specified manually in CSS


	        _this.determineContainerAutoSizing();

	        _this.loaded = true;
	      });
	    } // Download VTT files and parse them

	  }, {
	    key: "getThumbnails",
	    value: function getThumbnails() {
	      var _this2 = this;

	      return new Promise(function (resolve) {
	        var src = _this2.player.config.previewThumbnails.src;

	        if (is$1.empty(src)) {
	          throw new Error('Missing previewThumbnails.src config attribute');
	        } // Resolve promise


	        var sortAndResolve = function sortAndResolve() {
	          // Sort smallest to biggest (e.g., [120p, 480p, 1080p])
	          _this2.thumbnails.sort(function (x, y) {
	            return x.height - y.height;
	          });

	          _this2.player.debug.log('Preview thumbnails', _this2.thumbnails);

	          resolve();
	        }; // Via callback()


	        if (is$1.function(src)) {
	          src(function (thumbnails) {
	            _this2.thumbnails = thumbnails;
	            sortAndResolve();
	          });
	        } // VTT urls
	        else {
	            // If string, convert into single-element list
	            var urls = is$1.string(src) ? [src] : src; // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails

	            var promises = urls.map(function (u) {
	              return _this2.getThumbnail(u);
	            }); // Resolve

	            Promise.all(promises).then(sortAndResolve);
	          }
	      });
	    } // Process individual VTT file

	  }, {
	    key: "getThumbnail",
	    value: function getThumbnail(url) {
	      var _this3 = this;

	      return new Promise(function (resolve) {
	        fetch$1(url).then(function (response) {
	          var thumbnail = {
	            frames: parseVtt(response),
	            height: null,
	            urlPrefix: ''
	          }; // If the URLs don't start with '/', then we need to set their relative path to be the location of the VTT file
	          // If the URLs do start with '/', then they obviously don't need a prefix, so it will remain blank
	          // If the thumbnail URLs start with with none of '/', 'http://' or 'https://', then we need to set their relative path to be the location of the VTT file

	          if (!thumbnail.frames[0].text.startsWith('/') && !thumbnail.frames[0].text.startsWith('http://') && !thumbnail.frames[0].text.startsWith('https://')) {
	            thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);
	          } // Download the first frame, so that we can determine/set the height of this thumbnailsDef


	          var tempImage = new Image();

	          tempImage.onload = function () {
	            thumbnail.height = tempImage.naturalHeight;
	            thumbnail.width = tempImage.naturalWidth;

	            _this3.thumbnails.push(thumbnail);

	            resolve();
	          };

	          tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;
	        });
	      });
	    }
	  }, {
	    key: "startMove",
	    value: function startMove(event) {
	      if (!this.loaded) {
	        return;
	      }

	      if (!is$1.event(event) || !['touchmove', 'mousemove'].includes(event.type)) {
	        return;
	      } // Wait until media has a duration


	      if (!this.player.media.duration) {
	        return;
	      }

	      if (event.type === 'touchmove') {
	        // Calculate seek hover position as approx video seconds
	        this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
	      } else {
	        // Calculate seek hover position as approx video seconds
	        var clientRect = this.player.elements.progress.getBoundingClientRect();
	        var percentage = 100 / clientRect.width * (event.pageX - clientRect.left);
	        this.seekTime = this.player.media.duration * (percentage / 100);

	        if (this.seekTime < 0) {
	          // The mousemove fires for 10+px out to the left
	          this.seekTime = 0;
	        }

	        if (this.seekTime > this.player.media.duration - 1) {
	          // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video
	          this.seekTime = this.player.media.duration - 1;
	        }

	        this.mousePosX = event.pageX; // Set time text inside image container

	        this.elements.thumb.time.innerText = formatTime(this.seekTime);
	      } // Download and show image


	      this.showImageAtCurrentTime();
	    }
	  }, {
	    key: "endMove",
	    value: function endMove() {
	      this.toggleThumbContainer(false, true);
	    }
	  }, {
	    key: "startScrubbing",
	    value: function startScrubbing(event) {
	      // Only act on left mouse button (0), or touch device (event.button does not exist or is false)
	      if (is$1.nullOrUndefined(event.button) || event.button === false || event.button === 0) {
	        this.mouseDown = true; // Wait until media has a duration

	        if (this.player.media.duration) {
	          this.toggleScrubbingContainer(true);
	          this.toggleThumbContainer(false, true); // Download and show image

	          this.showImageAtCurrentTime();
	        }
	      }
	    }
	  }, {
	    key: "endScrubbing",
	    value: function endScrubbing() {
	      var _this4 = this;

	      this.mouseDown = false; // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview

	      if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {
	        // The video was already seeked/loaded at the chosen time - hide immediately
	        this.toggleScrubbingContainer(false);
	      } else {
	        // The video hasn't seeked yet. Wait for that
	        once.call(this.player, this.player.media, 'timeupdate', function () {
	          // Re-check mousedown - we might have already started scrubbing again
	          if (!_this4.mouseDown) {
	            _this4.toggleScrubbingContainer(false);
	          }
	        });
	      }
	    }
	    /**
	     * Setup hooks for Plyr and window events
	     */

	  }, {
	    key: "listeners",
	    value: function listeners() {
	      var _this5 = this;

	      // Hide thumbnail preview - on mouse click, mouse leave (in listeners.js for now), and video play/seek. All four are required, e.g., for buffering
	      this.player.on('play', function () {
	        _this5.toggleThumbContainer(false, true);
	      });
	      this.player.on('seeked', function () {
	        _this5.toggleThumbContainer(false);
	      });
	      this.player.on('timeupdate', function () {
	        _this5.lastTime = _this5.player.media.currentTime;
	      });
	    }
	    /**
	     * Create HTML elements for image containers
	     */

	  }, {
	    key: "render",
	    value: function render() {
	      // Create HTML element: plyr__preview-thumbnail-container
	      this.elements.thumb.container = createElement('div', {
	        class: this.player.config.classNames.previewThumbnails.thumbContainer
	      }); // Wrapper for the image for styling

	      this.elements.thumb.imageContainer = createElement('div', {
	        class: this.player.config.classNames.previewThumbnails.imageContainer
	      });
	      this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer); // Create HTML element, parent+span: time text (e.g., 01:32:00)

	      var timeContainer = createElement('div', {
	        class: this.player.config.classNames.previewThumbnails.timeContainer
	      });
	      this.elements.thumb.time = createElement('span', {}, '00:00');
	      timeContainer.appendChild(this.elements.thumb.time);
	      this.elements.thumb.container.appendChild(timeContainer); // Inject the whole thumb

	      if (is$1.element(this.player.elements.progress)) {
	        this.player.elements.progress.appendChild(this.elements.thumb.container);
	      } // Create HTML element: plyr__preview-scrubbing-container


	      this.elements.scrubbing.container = createElement('div', {
	        class: this.player.config.classNames.previewThumbnails.scrubbingContainer
	      });
	      this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      if (this.elements.thumb.container) {
	        this.elements.thumb.container.remove();
	      }

	      if (this.elements.scrubbing.container) {
	        this.elements.scrubbing.container.remove();
	      }
	    }
	  }, {
	    key: "showImageAtCurrentTime",
	    value: function showImageAtCurrentTime() {
	      var _this6 = this;

	      if (this.mouseDown) {
	        this.setScrubbingContainerSize();
	      } else {
	        this.setThumbContainerSizeAndPos();
	      } // Find the desired thumbnail index
	      // TODO: Handle a video longer than the thumbs where thumbNum is null


	      var thumbNum = this.thumbnails[0].frames.findIndex(function (frame) {
	        return _this6.seekTime >= frame.startTime && _this6.seekTime <= frame.endTime;
	      });
	      var hasThumb = thumbNum >= 0;
	      var qualityIndex = 0; // Show the thumb container if we're not scrubbing

	      if (!this.mouseDown) {
	        this.toggleThumbContainer(hasThumb);
	      } // No matching thumb found


	      if (!hasThumb) {
	        return;
	      } // Check to see if we've already downloaded higher quality versions of this image


	      this.thumbnails.forEach(function (thumbnail, index) {
	        if (_this6.loadedImages.includes(thumbnail.frames[thumbNum].text)) {
	          qualityIndex = index;
	        }
	      }); // Only proceed if either thumbnum or thumbfilename has changed

	      if (thumbNum !== this.showingThumb) {
	        this.showingThumb = thumbNum;
	        this.loadImage(qualityIndex);
	      }
	    } // Show the image that's currently specified in this.showingThumb

	  }, {
	    key: "loadImage",
	    value: function loadImage() {
	      var _this7 = this;

	      var qualityIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var thumbNum = this.showingThumb;
	      var thumbnail = this.thumbnails[qualityIndex];
	      var urlPrefix = thumbnail.urlPrefix;
	      var frame = thumbnail.frames[thumbNum];
	      var thumbFilename = thumbnail.frames[thumbNum].text;
	      var thumbUrl = urlPrefix + thumbFilename;

	      if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {
	        // If we're already loading a previous image, remove its onload handler - we don't want it to load after this one
	        // Only do this if not using sprites. Without sprites we really want to show as many images as possible, as a best-effort
	        if (this.loadingImage && this.usingSprites) {
	          this.loadingImage.onload = null;
	        } // We're building and adding a new image. In other implementations of similar functionality (YouTube), background image
	        // is instead used. But this causes issues with larger images in Firefox and Safari - switching between background
	        // images causes a flicker. Putting a new image over the top does not


	        var previewImage = new Image();
	        previewImage.src = thumbUrl;
	        previewImage.dataset.index = thumbNum;
	        previewImage.dataset.filename = thumbFilename;
	        this.showingThumbFilename = thumbFilename;
	        this.player.debug.log("Loading image: ".concat(thumbUrl)); // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...

	        previewImage.onload = function () {
	          return _this7.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);
	        };

	        this.loadingImage = previewImage;
	        this.removeOldImages(previewImage);
	      } else {
	        // Update the existing image
	        this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);
	        this.currentImageElement.dataset.index = thumbNum;
	        this.removeOldImages(this.currentImageElement);
	      }
	    }
	  }, {
	    key: "showImage",
	    value: function showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename) {
	      var newImage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
	      this.player.debug.log("Showing thumb: ".concat(thumbFilename, ". num: ").concat(thumbNum, ". qual: ").concat(qualityIndex, ". newimg: ").concat(newImage));
	      this.setImageSizeAndOffset(previewImage, frame);

	      if (newImage) {
	        this.currentImageContainer.appendChild(previewImage);
	        this.currentImageElement = previewImage;

	        if (!this.loadedImages.includes(thumbFilename)) {
	          this.loadedImages.push(thumbFilename);
	        }
	      } // Preload images before and after the current one
	      // Show higher quality of the same frame
	      // Each step here has a short time delay, and only continues if still hovering/seeking the same spot. This is to protect slow connections from overloading


	      this.preloadNearby(thumbNum, true).then(this.preloadNearby(thumbNum, false)).then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));
	    } // Remove all preview images that aren't the designated current image

	  }, {
	    key: "removeOldImages",
	    value: function removeOldImages(currentImage) {
	      var _this8 = this;

	      // Get a list of all images, convert it from a DOM list to an array
	      Array.from(this.currentImageContainer.children).forEach(function (image) {
	        if (image.tagName.toLowerCase() !== 'img') {
	          return;
	        }

	        var removeDelay = _this8.usingSprites ? 500 : 1000;

	        if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {
	          // Wait 200ms, as the new image can take some time to show on certain browsers (even though it was downloaded before showing). This will prevent flicker, and show some generosity towards slower clients
	          // First set attribute 'deleting' to prevent multi-handling of this on repeat firing of this function
	          // eslint-disable-next-line no-param-reassign
	          image.dataset.deleting = true; // This has to be set before the timeout - to prevent issues switching between hover and scrub

	          var currentImageContainer = _this8.currentImageContainer;
	          setTimeout(function () {
	            currentImageContainer.removeChild(image);

	            _this8.player.debug.log("Removing thumb: ".concat(image.dataset.filename));
	          }, removeDelay);
	        }
	      });
	    } // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame
	    // This will only preload the lowest quality

	  }, {
	    key: "preloadNearby",
	    value: function preloadNearby(thumbNum) {
	      var _this9 = this;

	      var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      return new Promise(function (resolve) {
	        setTimeout(function () {
	          var oldThumbFilename = _this9.thumbnails[0].frames[thumbNum].text;

	          if (_this9.showingThumbFilename === oldThumbFilename) {
	            // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away
	            var thumbnailsClone;

	            if (forward) {
	              thumbnailsClone = _this9.thumbnails[0].frames.slice(thumbNum);
	            } else {
	              thumbnailsClone = _this9.thumbnails[0].frames.slice(0, thumbNum).reverse();
	            }

	            var foundOne = false;
	            thumbnailsClone.forEach(function (frame) {
	              var newThumbFilename = frame.text;

	              if (newThumbFilename !== oldThumbFilename) {
	                // Found one with a different filename. Make sure it hasn't already been loaded on this page visit
	                if (!_this9.loadedImages.includes(newThumbFilename)) {
	                  foundOne = true;

	                  _this9.player.debug.log("Preloading thumb filename: ".concat(newThumbFilename));

	                  var urlPrefix = _this9.thumbnails[0].urlPrefix;
	                  var thumbURL = urlPrefix + newThumbFilename;
	                  var previewImage = new Image();
	                  previewImage.src = thumbURL;

	                  previewImage.onload = function () {
	                    _this9.player.debug.log("Preloaded thumb filename: ".concat(newThumbFilename));

	                    if (!_this9.loadedImages.includes(newThumbFilename)) { _this9.loadedImages.push(newThumbFilename); } // We don't resolve until the thumb is loaded

	                    resolve();
	                  };
	                }
	              }
	            }); // If there are none to preload then we want to resolve immediately

	            if (!foundOne) {
	              resolve();
	            }
	          }
	        }, 300);
	      });
	    } // If user has been hovering current image for half a second, look for a higher quality one

	  }, {
	    key: "getHigherQuality",
	    value: function getHigherQuality(currentQualityIndex, previewImage, frame, thumbFilename) {
	      var _this10 = this;

	      if (currentQualityIndex < this.thumbnails.length - 1) {
	        // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container
	        var previewImageHeight = previewImage.naturalHeight;

	        if (this.usingSprites) {
	          previewImageHeight = frame.h;
	        }

	        if (previewImageHeight < this.thumbContainerHeight) {
	          // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while
	          setTimeout(function () {
	            // Make sure the mouse hasn't already moved on and started hovering at another image
	            if (_this10.showingThumbFilename === thumbFilename) {
	              _this10.player.debug.log("Showing higher quality thumb for: ".concat(thumbFilename));

	              _this10.loadImage(currentQualityIndex + 1);
	            }
	          }, 300);
	        }
	      }
	    }
	  }, {
	    key: "toggleThumbContainer",
	    value: function toggleThumbContainer() {
	      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      var clearShowing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var className = this.player.config.classNames.previewThumbnails.thumbContainerShown;
	      this.elements.thumb.container.classList.toggle(className, toggle);

	      if (!toggle && clearShowing) {
	        this.showingThumb = null;
	        this.showingThumbFilename = null;
	      }
	    }
	  }, {
	    key: "toggleScrubbingContainer",
	    value: function toggleScrubbingContainer() {
	      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      var className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
	      this.elements.scrubbing.container.classList.toggle(className, toggle);

	      if (!toggle) {
	        this.showingThumb = null;
	        this.showingThumbFilename = null;
	      }
	    }
	  }, {
	    key: "determineContainerAutoSizing",
	    value: function determineContainerAutoSizing() {
	      if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {
	        // This will prevent auto sizing in this.setThumbContainerSizeAndPos()
	        this.sizeSpecifiedInCSS = true;
	      }
	    } // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS

	  }, {
	    key: "setThumbContainerSizeAndPos",
	    value: function setThumbContainerSizeAndPos() {
	      if (!this.sizeSpecifiedInCSS) {
	        var thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
	        this.elements.thumb.imageContainer.style.height = "".concat(this.thumbContainerHeight, "px");
	        this.elements.thumb.imageContainer.style.width = "".concat(thumbWidth, "px");
	      } else if (this.elements.thumb.imageContainer.clientHeight > 20 && this.elements.thumb.imageContainer.clientWidth < 20) {
	        var _thumbWidth = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio);

	        this.elements.thumb.imageContainer.style.width = "".concat(_thumbWidth, "px");
	      } else if (this.elements.thumb.imageContainer.clientHeight < 20 && this.elements.thumb.imageContainer.clientWidth > 20) {
	        var thumbHeight = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio);
	        this.elements.thumb.imageContainer.style.height = "".concat(thumbHeight, "px");
	      }

	      this.setThumbContainerPos();
	    }
	  }, {
	    key: "setThumbContainerPos",
	    value: function setThumbContainerPos() {
	      var seekbarRect = this.player.elements.progress.getBoundingClientRect();
	      var plyrRect = this.player.elements.container.getBoundingClientRect();
	      var container = this.elements.thumb.container; // Find the lowest and highest desired left-position, so we don't slide out the side of the video container

	      var minVal = plyrRect.left - seekbarRect.left + 10;
	      var maxVal = plyrRect.right - seekbarRect.left - container.clientWidth - 10; // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth

	      var previewPos = this.mousePosX - seekbarRect.left - container.clientWidth / 2;

	      if (previewPos < minVal) {
	        previewPos = minVal;
	      }

	      if (previewPos > maxVal) {
	        previewPos = maxVal;
	      }

	      container.style.left = "".concat(previewPos, "px");
	    } // Can't use 100% width, in case the video is a different aspect ratio to the video container

	  }, {
	    key: "setScrubbingContainerSize",
	    value: function setScrubbingContainerSize() {
	      var _fitRatio = fitRatio(this.thumbAspectRatio, {
	        width: this.player.media.clientWidth,
	        height: this.player.media.clientHeight
	      }),
	          width = _fitRatio.width,
	          height = _fitRatio.height;

	      this.elements.scrubbing.container.style.width = "".concat(width, "px");
	      this.elements.scrubbing.container.style.height = "".concat(height, "px");
	    } // Sprites need to be offset to the correct location

	  }, {
	    key: "setImageSizeAndOffset",
	    value: function setImageSizeAndOffset(previewImage, frame) {
	      if (!this.usingSprites) {
	        return;
	      } // Find difference between height and preview container height


	      var multiplier = this.thumbContainerHeight / frame.h; // eslint-disable-next-line no-param-reassign

	      previewImage.style.height = "".concat(previewImage.naturalHeight * multiplier, "px"); // eslint-disable-next-line no-param-reassign

	      previewImage.style.width = "".concat(previewImage.naturalWidth * multiplier, "px"); // eslint-disable-next-line no-param-reassign

	      previewImage.style.left = "-".concat(frame.x * multiplier, "px"); // eslint-disable-next-line no-param-reassign

	      previewImage.style.top = "-".concat(frame.y * multiplier, "px");
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;
	    }
	  }, {
	    key: "currentImageContainer",
	    get: function get() {
	      if (this.mouseDown) {
	        return this.elements.scrubbing.container;
	      }

	      return this.elements.thumb.imageContainer;
	    }
	  }, {
	    key: "usingSprites",
	    get: function get() {
	      return Object.keys(this.thumbnails[0].frames[0]).includes('w');
	    }
	  }, {
	    key: "thumbAspectRatio",
	    get: function get() {
	      if (this.usingSprites) {
	        return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;
	      }

	      return this.thumbnails[0].width / this.thumbnails[0].height;
	    }
	  }, {
	    key: "thumbContainerHeight",
	    get: function get() {
	      if (this.mouseDown) {
	        var _fitRatio2 = fitRatio(this.thumbAspectRatio, {
	          width: this.player.media.clientWidth,
	          height: this.player.media.clientHeight
	        }),
	            height = _fitRatio2.height;

	        return height;
	      } // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)


	      if (this.sizeSpecifiedInCSS) {
	        return this.elements.thumb.imageContainer.clientHeight;
	      }

	      return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);
	    }
	  }, {
	    key: "currentImageElement",
	    get: function get() {
	      if (this.mouseDown) {
	        return this.currentScrubbingImageElement;
	      }

	      return this.currentThumbnailImageElement;
	    },
	    set: function set(element) {
	      if (this.mouseDown) {
	        this.currentScrubbingImageElement = element;
	      } else {
	        this.currentThumbnailImageElement = element;
	      }
	    }
	  }]);

	  return PreviewThumbnails;
	}();

	var source = {
	  // Add elements to HTML5 media (source, tracks, etc)
	  insertElements: function insertElements(type, attributes) {
	    var _this = this;

	    if (is$1.string(attributes)) {
	      insertElement(type, this.media, {
	        src: attributes
	      });
	    } else if (is$1.array(attributes)) {
	      attributes.forEach(function (attribute) {
	        insertElement(type, _this.media, attribute);
	      });
	    }
	  },
	  // Update source
	  // Sources are not checked for support so be careful
	  change: function change(input) {
	    var _this2 = this;

	    if (!getDeep(input, 'sources.length')) {
	      this.debug.warn('Invalid source format');
	      return;
	    } // Cancel current network requests


	    html5.cancelRequests.call(this); // Destroy instance and re-setup

	    this.destroy.call(this, function () {
	      // Reset quality options
	      _this2.options.quality = []; // Remove elements

	      removeElement(_this2.media);
	      _this2.media = null; // Reset class name

	      if (is$1.element(_this2.elements.container)) {
	        _this2.elements.container.removeAttribute('class');
	      } // Set the type and provider


	      var sources = input.sources,
	          type = input.type;

	      var _sources = _slicedToArray(sources, 1),
	          _sources$ = _sources[0],
	          _sources$$provider = _sources$.provider,
	          provider = _sources$$provider === void 0 ? providers.html5 : _sources$$provider,
	          src = _sources$.src;

	      var tagName = provider === 'html5' ? type : 'div';
	      var attributes = provider === 'html5' ? {} : {
	        src: src
	      };
	      Object.assign(_this2, {
	        provider: provider,
	        type: type,
	        // Check for support
	        supported: support.check(type, provider, _this2.config.playsinline),
	        // Create new element
	        media: createElement(tagName, attributes)
	      }); // Inject the new element

	      _this2.elements.container.appendChild(_this2.media); // Autoplay the new source?


	      if (is$1.boolean(input.autoplay)) {
	        _this2.config.autoplay = input.autoplay;
	      } // Set attributes for audio and video


	      if (_this2.isHTML5) {
	        if (_this2.config.crossorigin) {
	          _this2.media.setAttribute('crossorigin', '');
	        }

	        if (_this2.config.autoplay) {
	          _this2.media.setAttribute('autoplay', '');
	        }

	        if (!is$1.empty(input.poster)) {
	          _this2.poster = input.poster;
	        }

	        if (_this2.config.loop.active) {
	          _this2.media.setAttribute('loop', '');
	        }

	        if (_this2.config.muted) {
	          _this2.media.setAttribute('muted', '');
	        }

	        if (_this2.config.playsinline) {
	          _this2.media.setAttribute('playsinline', '');
	        }
	      } // Restore class hook


	      ui.addStyleHook.call(_this2); // Set new sources for html5

	      if (_this2.isHTML5) {
	        source.insertElements.call(_this2, 'source', sources);
	      } // Set video title


	      _this2.config.title = input.title; // Set up from scratch

	      media.setup.call(_this2); // HTML5 stuff

	      if (_this2.isHTML5) {
	        // Setup captions
	        if (Object.keys(input).includes('tracks')) {
	          source.insertElements.call(_this2, 'track', input.tracks);
	        }
	      } // If HTML5 or embed but not fully supported, setupInterface and call ready now


	      if (_this2.isHTML5 || _this2.isEmbed && !_this2.supported.ui) {
	        // Setup interface
	        ui.build.call(_this2);
	      } // Load HTML5 sources


	      if (_this2.isHTML5) {
	        _this2.media.load();
	      } // Update previewThumbnails config & reload plugin


	      if (!is$1.empty(input.previewThumbnails)) {
	        Object.assign(_this2.config.previewThumbnails, input.previewThumbnails); // Cleanup previewThumbnails plugin if it was loaded

	        if (_this2.previewThumbnails && _this2.previewThumbnails.loaded) {
	          _this2.previewThumbnails.destroy();

	          _this2.previewThumbnails = null;
	        } // Create new instance if it is still enabled


	        if (_this2.config.previewThumbnails.enabled) {
	          _this2.previewThumbnails = new PreviewThumbnails(_this2);
	        }
	      } // Update the fullscreen support


	      _this2.fullscreen.update();
	    }, true);
	  }
	};

	/**
	 * Returns a number whose value is limited to the given range.
	 *
	 * Example: limit the output of this computation to between 0 and 255
	 * (x * 255).clamp(0, 255)
	 *
	 * @param {Number} input
	 * @param {Number} min The lower boundary of the output range
	 * @param {Number} max The upper boundary of the output range
	 * @returns A number in the range [min, max]
	 * @type Number
	 */
	function clamp() {
	  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 255;
	  return Math.min(Math.max(input, min), max);
	}

	// TODO: Use a WeakMap for private globals
	// const globals = new WeakMap();
	// Plyr instance

	var Plyr = /*#__PURE__*/function () {
	  function Plyr(target, options) {
	    var _this = this;

	    _classCallCheck(this, Plyr);

	    this.timers = {}; // State

	    this.ready = false;
	    this.loading = false;
	    this.failed = false; // Touch device

	    this.touch = support.touch; // Set the media element

	    this.media = target; // String selector passed

	    if (is$1.string(this.media)) {
	      this.media = document.querySelectorAll(this.media);
	    } // jQuery, NodeList or Array passed, use first element


	    if (window.jQuery && this.media instanceof jQuery || is$1.nodeList(this.media) || is$1.array(this.media)) {
	      // eslint-disable-next-line
	      this.media = this.media[0];
	    } // Set config


	    this.config = extend({}, defaults$1, Plyr.defaults, options || {}, function () {
	      try {
	        return JSON.parse(_this.media.getAttribute('data-plyr-config'));
	      } catch (e) {
	        return {};
	      }
	    }()); // Elements cache

	    this.elements = {
	      container: null,
	      fullscreen: null,
	      captions: null,
	      buttons: {},
	      display: {},
	      progress: {},
	      inputs: {},
	      settings: {
	        popup: null,
	        menu: null,
	        panels: {},
	        buttons: {}
	      }
	    }; // Captions

	    this.captions = {
	      active: null,
	      currentTrack: -1,
	      meta: new WeakMap()
	    }; // Fullscreen

	    this.fullscreen = {
	      active: false
	    }; // Options

	    this.options = {
	      speed: [],
	      quality: []
	    }; // Debugging
	    // TODO: move to globals

	    this.debug = new Console(this.config.debug); // Log config options and support

	    this.debug.log('Config', this.config);
	    this.debug.log('Support', support); // We need an element to setup

	    if (is$1.nullOrUndefined(this.media) || !is$1.element(this.media)) {
	      this.debug.error('Setup failed: no suitable element passed');
	      return;
	    } // Bail if the element is initialized


	    if (this.media.plyr) {
	      this.debug.warn('Target already setup');
	      return;
	    } // Bail if not enabled


	    if (!this.config.enabled) {
	      this.debug.error('Setup failed: disabled by config');
	      return;
	    } // Bail if disabled or no basic support
	    // You may want to disable certain UAs etc


	    if (!support.check().api) {
	      this.debug.error('Setup failed: no support');
	      return;
	    } // Cache original element state for .destroy()


	    var clone = this.media.cloneNode(true);
	    clone.autoplay = false;
	    this.elements.original = clone; // Set media type based on tag or data attribute
	    // Supported: video, audio, vimeo, youtube

	    var type = this.media.tagName.toLowerCase(); // Embed properties

	    var iframe = null;
	    var url = null; // Different setup based on type

	    switch (type) {
	      case 'div':
	        // Find the frame
	        iframe = this.media.querySelector('iframe'); // <iframe> type

	        if (is$1.element(iframe)) {
	          // Detect provider
	          url = parseUrl(iframe.getAttribute('src'));
	          this.provider = getProviderByUrl(url.toString()); // Rework elements

	          this.elements.container = this.media;
	          this.media = iframe; // Reset classname

	          this.elements.container.className = ''; // Get attributes from URL and set config

	          if (url.search.length) {
	            var truthy = ['1', 'true'];

	            if (truthy.includes(url.searchParams.get('autoplay'))) {
	              this.config.autoplay = true;
	            }

	            if (truthy.includes(url.searchParams.get('loop'))) {
	              this.config.loop.active = true;
	            } // TODO: replace fullscreen.iosNative with this playsinline config option
	            // YouTube requires the playsinline in the URL


	            if (this.isYouTube) {
	              this.config.playsinline = truthy.includes(url.searchParams.get('playsinline'));
	              this.config.youtube.hl = url.searchParams.get('hl'); // TODO: Should this be setting language?
	            } else {
	              this.config.playsinline = true;
	            }
	          }
	        } else {
	          // <div> with attributes
	          this.provider = this.media.getAttribute(this.config.attributes.embed.provider); // Remove attribute

	          this.media.removeAttribute(this.config.attributes.embed.provider);
	        } // Unsupported or missing provider


	        if (is$1.empty(this.provider) || !Object.keys(providers).includes(this.provider)) {
	          this.debug.error('Setup failed: Invalid provider');
	          return;
	        } // Audio will come later for external providers


	        this.type = types.video;
	        break;

	      case 'video':
	      case 'audio':
	        this.type = type;
	        this.provider = providers.html5; // Get config from attributes

	        if (this.media.hasAttribute('crossorigin')) {
	          this.config.crossorigin = true;
	        }

	        if (this.media.hasAttribute('autoplay')) {
	          this.config.autoplay = true;
	        }

	        if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {
	          this.config.playsinline = true;
	        }

	        if (this.media.hasAttribute('muted')) {
	          this.config.muted = true;
	        }

	        if (this.media.hasAttribute('loop')) {
	          this.config.loop.active = true;
	        }

	        break;

	      default:
	        this.debug.error('Setup failed: unsupported type');
	        return;
	    } // Check for support again but with type


	    this.supported = support.check(this.type, this.provider, this.config.playsinline); // If no support for even API, bail

	    if (!this.supported.api) {
	      this.debug.error('Setup failed: no support');
	      return;
	    }

	    this.eventListeners = []; // Create listeners

	    this.listeners = new Listeners(this); // Setup local storage for user settings

	    this.storage = new Storage(this); // Store reference

	    this.media.plyr = this; // Wrap media

	    if (!is$1.element(this.elements.container)) {
	      this.elements.container = createElement('div', {
	        tabindex: 0
	      });
	      wrap$1(this.media, this.elements.container);
	    } // Migrate custom properties from media to container (so they work 😉)


	    ui.migrateStyles.call(this); // Add style hook

	    ui.addStyleHook.call(this); // Setup media

	    media.setup.call(this); // Listen for events if debugging

	    if (this.config.debug) {
	      on.call(this, this.elements.container, this.config.events.join(' '), function (event) {
	        _this.debug.log("event: ".concat(event.type));
	      });
	    } // Setup fullscreen


	    this.fullscreen = new Fullscreen(this); // Setup interface
	    // If embed but not fully supported, build interface now to avoid flash of controls

	    if (this.isHTML5 || this.isEmbed && !this.supported.ui) {
	      ui.build.call(this);
	    } // Container listeners


	    this.listeners.container(); // Global listeners

	    this.listeners.global(); // Setup ads if provided

	    if (this.config.ads.enabled) {
	      this.ads = new Ads(this);
	    } // Autoplay if required


	    if (this.isHTML5 && this.config.autoplay) {
	      setTimeout(function () {
	        return silencePromise(_this.play());
	      }, 10);
	    } // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek


	    this.lastSeekTime = 0; // Setup preview thumbnails if enabled

	    if (this.config.previewThumbnails.enabled) {
	      this.previewThumbnails = new PreviewThumbnails(this);
	    }
	  } // ---------------------------------------
	  // API
	  // ---------------------------------------

	  /**
	   * Types and provider helpers
	   */


	  _createClass(Plyr, [{
	    key: "play",

	    /**
	     * Play the media, or play the advertisement (if they are not blocked)
	     */
	    value: function play() {
	      var _this2 = this;

	      if (!is$1.function(this.media.play)) {
	        return null;
	      } // Intecept play with ads


	      if (this.ads && this.ads.enabled) {
	        this.ads.managerPromise.then(function () {
	          return _this2.ads.play();
	        }).catch(function () {
	          return silencePromise(_this2.media.play());
	        });
	      } // Return the promise (for HTML5)


	      return this.media.play();
	    }
	    /**
	     * Pause the media
	     */

	  }, {
	    key: "pause",
	    value: function pause() {
	      if (!this.playing || !is$1.function(this.media.pause)) {
	        return null;
	      }

	      return this.media.pause();
	    }
	    /**
	     * Get playing state
	     */

	  }, {
	    key: "togglePlay",

	    /**
	     * Toggle playback based on current status
	     * @param {Boolean} input
	     */
	    value: function togglePlay(input) {
	      // Toggle based on current state if nothing passed
	      var toggle = is$1.boolean(input) ? input : !this.playing;

	      if (toggle) {
	        return this.play();
	      }

	      return this.pause();
	    }
	    /**
	     * Stop playback
	     */

	  }, {
	    key: "stop",
	    value: function stop() {
	      if (this.isHTML5) {
	        this.pause();
	        this.restart();
	      } else if (is$1.function(this.media.stop)) {
	        this.media.stop();
	      }
	    }
	    /**
	     * Restart playback
	     */

	  }, {
	    key: "restart",
	    value: function restart() {
	      this.currentTime = 0;
	    }
	    /**
	     * Rewind
	     * @param {Number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime
	     */

	  }, {
	    key: "rewind",
	    value: function rewind(seekTime) {
	      this.currentTime -= is$1.number(seekTime) ? seekTime : this.config.seekTime;
	    }
	    /**
	     * Fast forward
	     * @param {Number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime
	     */

	  }, {
	    key: "forward",
	    value: function forward(seekTime) {
	      this.currentTime += is$1.number(seekTime) ? seekTime : this.config.seekTime;
	    }
	    /**
	     * Seek to a time
	     * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)
	     */

	  }, {
	    key: "increaseVolume",

	    /**
	     * Increase volume
	     * @param {Boolean} step - How much to decrease by (between 0 and 1)
	     */
	    value: function increaseVolume(step) {
	      var volume = this.media.muted ? 0 : this.volume;
	      this.volume = volume + (is$1.number(step) ? step : 0);
	    }
	    /**
	     * Decrease volume
	     * @param {Boolean} step - How much to decrease by (between 0 and 1)
	     */

	  }, {
	    key: "decreaseVolume",
	    value: function decreaseVolume(step) {
	      this.increaseVolume(-step);
	    }
	    /**
	     * Set muted state
	     * @param {Boolean} mute
	     */

	  }, {
	    key: "toggleCaptions",

	    /**
	     * Toggle captions
	     * @param {Boolean} input - Whether to enable captions
	     */
	    value: function toggleCaptions(input) {
	      captions.toggle.call(this, input, false);
	    }
	    /**
	     * Set the caption track by index
	     * @param {Number} - Caption index
	     */

	  }, {
	    key: "airplay",

	    /**
	     * Trigger the airplay dialog
	     * TODO: update player with state, support, enabled
	     */
	    value: function airplay() {
	      // Show dialog if supported
	      if (support.airplay) {
	        this.media.webkitShowPlaybackTargetPicker();
	      }
	    }
	    /**
	     * Toggle the player controls
	     * @param {Boolean} [toggle] - Whether to show the controls
	     */

	  }, {
	    key: "toggleControls",
	    value: function toggleControls(toggle) {
	      // Don't toggle if missing UI support or if it's audio
	      if (this.supported.ui && !this.isAudio) {
	        // Get state before change
	        var isHidden = hasClass(this.elements.container, this.config.classNames.hideControls); // Negate the argument if not undefined since adding the class to hides the controls

	        var force = typeof toggle === 'undefined' ? undefined : !toggle; // Apply and get updated state

	        var hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force); // Close menu

	        if (hiding && is$1.array(this.config.controls) && this.config.controls.includes('settings') && !is$1.empty(this.config.settings)) {
	          controls.toggleMenu.call(this, false);
	        } // Trigger event on change


	        if (hiding !== isHidden) {
	          var eventName = hiding ? 'controlshidden' : 'controlsshown';
	          triggerEvent.call(this, this.media, eventName);
	        }

	        return !hiding;
	      }

	      return false;
	    }
	    /**
	     * Add event listeners
	     * @param {String} event - Event type
	     * @param {Function} callback - Callback for when event occurs
	     */

	  }, {
	    key: "on",
	    value: function on$1(event, callback) {
	      on.call(this, this.elements.container, event, callback);
	    }
	    /**
	     * Add event listeners once
	     * @param {String} event - Event type
	     * @param {Function} callback - Callback for when event occurs
	     */

	  }, {
	    key: "once",
	    value: function once$1(event, callback) {
	      once.call(this, this.elements.container, event, callback);
	    }
	    /**
	     * Remove event listeners
	     * @param {String} event - Event type
	     * @param {Function} callback - Callback for when event occurs
	     */

	  }, {
	    key: "off",
	    value: function off$1(event, callback) {
	      off(this.elements.container, event, callback);
	    }
	    /**
	     * Destroy an instance
	     * Event listeners are removed when elements are removed
	     * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory
	     * @param {Function} callback - Callback for when destroy is complete
	     * @param {Boolean} soft - Whether it's a soft destroy (for source changes etc)
	     */

	  }, {
	    key: "destroy",
	    value: function destroy(callback) {
	      var _this3 = this;

	      var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (!this.ready) {
	        return;
	      }

	      var done = function done() {
	        // Reset overflow (incase destroyed while in fullscreen)
	        document.body.style.overflow = ''; // GC for embed

	        _this3.embed = null; // If it's a soft destroy, make minimal changes

	        if (soft) {
	          if (Object.keys(_this3.elements).length) {
	            // Remove elements
	            removeElement(_this3.elements.buttons.play);
	            removeElement(_this3.elements.captions);
	            removeElement(_this3.elements.controls);
	            removeElement(_this3.elements.wrapper); // Clear for GC

	            _this3.elements.buttons.play = null;
	            _this3.elements.captions = null;
	            _this3.elements.controls = null;
	            _this3.elements.wrapper = null;
	          } // Callback


	          if (is$1.function(callback)) {
	            callback();
	          }
	        } else {
	          // Unbind listeners
	          unbindListeners.call(_this3); // Replace the container with the original element provided

	          replaceElement(_this3.elements.original, _this3.elements.container); // Event

	          triggerEvent.call(_this3, _this3.elements.original, 'destroyed', true); // Callback

	          if (is$1.function(callback)) {
	            callback.call(_this3.elements.original);
	          } // Reset state


	          _this3.ready = false; // Clear for garbage collection

	          setTimeout(function () {
	            _this3.elements = null;
	            _this3.media = null;
	          }, 200);
	        }
	      }; // Stop playback


	      this.stop(); // Clear timeouts

	      clearTimeout(this.timers.loading);
	      clearTimeout(this.timers.controls);
	      clearTimeout(this.timers.resized); // Provider specific stuff

	      if (this.isHTML5) {
	        // Restore native video controls
	        ui.toggleNativeControls.call(this, true); // Clean up

	        done();
	      } else if (this.isYouTube) {
	        // Clear timers
	        clearInterval(this.timers.buffering);
	        clearInterval(this.timers.playing); // Destroy YouTube API

	        if (this.embed !== null && is$1.function(this.embed.destroy)) {
	          this.embed.destroy();
	        } // Clean up


	        done();
	      } else if (this.isVimeo) {
	        // Destroy Vimeo API
	        // then clean up (wait, to prevent postmessage errors)
	        if (this.embed !== null) {
	          this.embed.unload().then(done);
	        } // Vimeo does not always return


	        setTimeout(done, 200);
	      }
	    }
	    /**
	     * Check for support for a mime type (HTML5 only)
	     * @param {String} type - Mime type
	     */

	  }, {
	    key: "supports",
	    value: function supports(type) {
	      return support.mime.call(this, type);
	    }
	    /**
	     * Check for support
	     * @param {String} type - Player type (audio/video)
	     * @param {String} provider - Provider (html5/youtube/vimeo)
	     * @param {Boolean} inline - Where player has `playsinline` sttribute
	     */

	  }, {
	    key: "isHTML5",
	    get: function get() {
	      return this.provider === providers.html5;
	    }
	  }, {
	    key: "isEmbed",
	    get: function get() {
	      return this.isYouTube || this.isVimeo;
	    }
	  }, {
	    key: "isYouTube",
	    get: function get() {
	      return this.provider === providers.youtube;
	    }
	  }, {
	    key: "isVimeo",
	    get: function get() {
	      return this.provider === providers.vimeo;
	    }
	  }, {
	    key: "isVideo",
	    get: function get() {
	      return this.type === types.video;
	    }
	  }, {
	    key: "isAudio",
	    get: function get() {
	      return this.type === types.audio;
	    }
	  }, {
	    key: "playing",
	    get: function get() {
	      return Boolean(this.ready && !this.paused && !this.ended);
	    }
	    /**
	     * Get paused state
	     */

	  }, {
	    key: "paused",
	    get: function get() {
	      return Boolean(this.media.paused);
	    }
	    /**
	     * Get stopped state
	     */

	  }, {
	    key: "stopped",
	    get: function get() {
	      return Boolean(this.paused && this.currentTime === 0);
	    }
	    /**
	     * Get ended state
	     */

	  }, {
	    key: "ended",
	    get: function get() {
	      return Boolean(this.media.ended);
	    }
	  }, {
	    key: "currentTime",
	    set: function set(input) {
	      // Bail if media duration isn't available yet
	      if (!this.duration) {
	        return;
	      } // Validate input


	      var inputIsValid = is$1.number(input) && input > 0; // Set

	      this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0; // Logging

	      this.debug.log("Seeking to ".concat(this.currentTime, " seconds"));
	    }
	    /**
	     * Get current time
	     */
	    ,
	    get: function get() {
	      return Number(this.media.currentTime);
	    }
	    /**
	     * Get buffered
	     */

	  }, {
	    key: "buffered",
	    get: function get() {
	      var buffered = this.media.buffered; // YouTube / Vimeo return a float between 0-1

	      if (is$1.number(buffered)) {
	        return buffered;
	      } // HTML5
	      // TODO: Handle buffered chunks of the media
	      // (i.e. seek to another section buffers only that section)


	      if (buffered && buffered.length && this.duration > 0) {
	        return buffered.end(0) / this.duration;
	      }

	      return 0;
	    }
	    /**
	     * Get seeking status
	     */

	  }, {
	    key: "seeking",
	    get: function get() {
	      return Boolean(this.media.seeking);
	    }
	    /**
	     * Get the duration of the current media
	     */

	  }, {
	    key: "duration",
	    get: function get() {
	      // Faux duration set via config
	      var fauxDuration = parseFloat(this.config.duration); // Media duration can be NaN or Infinity before the media has loaded

	      var realDuration = (this.media || {}).duration;
	      var duration = !is$1.number(realDuration) || realDuration === Infinity ? 0 : realDuration; // If config duration is funky, use regular duration

	      return fauxDuration || duration;
	    }
	    /**
	     * Set the player volume
	     * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage
	     */

	  }, {
	    key: "volume",
	    set: function set(value) {
	      var volume = value;
	      var max = 1;
	      var min = 0;

	      if (is$1.string(volume)) {
	        volume = Number(volume);
	      } // Load volume from storage if no value specified


	      if (!is$1.number(volume)) {
	        volume = this.storage.get('volume');
	      } // Use config if all else fails


	      if (!is$1.number(volume)) {
	        volume = this.config.volume;
	      } // Maximum is volumeMax


	      if (volume > max) {
	        volume = max;
	      } // Minimum is volumeMin


	      if (volume < min) {
	        volume = min;
	      } // Update config


	      this.config.volume = volume; // Set the player volume

	      this.media.volume = volume; // If muted, and we're increasing volume manually, reset muted state

	      if (!is$1.empty(value) && this.muted && volume > 0) {
	        this.muted = false;
	      }
	    }
	    /**
	     * Get the current player volume
	     */
	    ,
	    get: function get() {
	      return Number(this.media.volume);
	    }
	  }, {
	    key: "muted",
	    set: function set(mute) {
	      var toggle = mute; // Load muted state from storage

	      if (!is$1.boolean(toggle)) {
	        toggle = this.storage.get('muted');
	      } // Use config if all else fails


	      if (!is$1.boolean(toggle)) {
	        toggle = this.config.muted;
	      } // Update config


	      this.config.muted = toggle; // Set mute on the player

	      this.media.muted = toggle;
	    }
	    /**
	     * Get current muted state
	     */
	    ,
	    get: function get() {
	      return Boolean(this.media.muted);
	    }
	    /**
	     * Check if the media has audio
	     */

	  }, {
	    key: "hasAudio",
	    get: function get() {
	      // Assume yes for all non HTML5 (as we can't tell...)
	      if (!this.isHTML5) {
	        return true;
	      }

	      if (this.isAudio) {
	        return true;
	      } // Get audio tracks


	      return Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length);
	    }
	    /**
	     * Set playback speed
	     * @param {Number} speed - the speed of playback (0.5-2.0)
	     */

	  }, {
	    key: "speed",
	    set: function set(input) {
	      var _this4 = this;

	      var speed = null;

	      if (is$1.number(input)) {
	        speed = input;
	      }

	      if (!is$1.number(speed)) {
	        speed = this.storage.get('speed');
	      }

	      if (!is$1.number(speed)) {
	        speed = this.config.speed.selected;
	      } // Clamp to min/max


	      var min = this.minimumSpeed,
	          max = this.maximumSpeed;
	      speed = clamp(speed, min, max); // Update config

	      this.config.speed.selected = speed; // Set media speed

	      setTimeout(function () {
	        _this4.media.playbackRate = speed;
	      }, 0);
	    }
	    /**
	     * Get current playback speed
	     */
	    ,
	    get: function get() {
	      return Number(this.media.playbackRate);
	    }
	    /**
	     * Get the minimum allowed speed
	     */

	  }, {
	    key: "minimumSpeed",
	    get: function get() {
	      if (this.isYouTube) {
	        // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate
	        return Math.min.apply(Math, _toConsumableArray(this.options.speed));
	      }

	      if (this.isVimeo) {
	        // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror
	        return 0.5;
	      } // https://stackoverflow.com/a/32320020/1191319


	      return 0.0625;
	    }
	    /**
	     * Get the maximum allowed speed
	     */

	  }, {
	    key: "maximumSpeed",
	    get: function get() {
	      if (this.isYouTube) {
	        // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate
	        return Math.max.apply(Math, _toConsumableArray(this.options.speed));
	      }

	      if (this.isVimeo) {
	        // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror
	        return 2;
	      } // https://stackoverflow.com/a/32320020/1191319


	      return 16;
	    }
	    /**
	     * Set playback quality
	     * Currently HTML5 & YouTube only
	     * @param {Number} input - Quality level
	     */

	  }, {
	    key: "quality",
	    set: function set(input) {
	      var config = this.config.quality;
	      var options = this.options.quality;

	      if (!options.length) {
	        return;
	      }

	      var quality = [!is$1.empty(input) && Number(input), this.storage.get('quality'), config.selected, config.default].find(is$1.number);
	      var updateStorage = true;

	      if (!options.includes(quality)) {
	        var value = closest$1(options, quality);
	        this.debug.warn("Unsupported quality option: ".concat(quality, ", using ").concat(value, " instead"));
	        quality = value; // Don't update storage if quality is not supported

	        updateStorage = false;
	      } // Update config


	      config.selected = quality; // Set quality

	      this.media.quality = quality; // Save to storage

	      if (updateStorage) {
	        this.storage.set({
	          quality: quality
	        });
	      }
	    }
	    /**
	     * Get current quality level
	     */
	    ,
	    get: function get() {
	      return this.media.quality;
	    }
	    /**
	     * Toggle loop
	     * TODO: Finish fancy new logic. Set the indicator on load as user may pass loop as config
	     * @param {Boolean} input - Whether to loop or not
	     */

	  }, {
	    key: "loop",
	    set: function set(input) {
	      var toggle = is$1.boolean(input) ? input : this.config.loop.active;
	      this.config.loop.active = toggle;
	      this.media.loop = toggle; // Set default to be a true toggle

	      /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';
	           switch (type) {
	              case 'start':
	                  if (this.config.loop.end && this.config.loop.end <= this.currentTime) {
	                      this.config.loop.end = null;
	                  }
	                  this.config.loop.start = this.currentTime;
	                  // this.config.loop.indicator.start = this.elements.display.played.value;
	                  break;
	               case 'end':
	                  if (this.config.loop.start >= this.currentTime) {
	                      return this;
	                  }
	                  this.config.loop.end = this.currentTime;
	                  // this.config.loop.indicator.end = this.elements.display.played.value;
	                  break;
	               case 'all':
	                  this.config.loop.start = 0;
	                  this.config.loop.end = this.duration - 2;
	                  this.config.loop.indicator.start = 0;
	                  this.config.loop.indicator.end = 100;
	                  break;
	               case 'toggle':
	                  if (this.config.loop.active) {
	                      this.config.loop.start = 0;
	                      this.config.loop.end = null;
	                  } else {
	                      this.config.loop.start = 0;
	                      this.config.loop.end = this.duration - 2;
	                  }
	                  break;
	               default:
	                  this.config.loop.start = 0;
	                  this.config.loop.end = null;
	                  break;
	          } */
	    }
	    /**
	     * Get current loop state
	     */
	    ,
	    get: function get() {
	      return Boolean(this.media.loop);
	    }
	    /**
	     * Set new media source
	     * @param {Object} input - The new source object (see docs)
	     */

	  }, {
	    key: "source",
	    set: function set(input) {
	      source.change.call(this, input);
	    }
	    /**
	     * Get current source
	     */
	    ,
	    get: function get() {
	      return this.media.currentSrc;
	    }
	    /**
	     * Get a download URL (either source or custom)
	     */

	  }, {
	    key: "download",
	    get: function get() {
	      var download = this.config.urls.download;
	      return is$1.url(download) ? download : this.source;
	    }
	    /**
	     * Set the download URL
	     */
	    ,
	    set: function set(input) {
	      if (!is$1.url(input)) {
	        return;
	      }

	      this.config.urls.download = input;
	      controls.setDownloadUrl.call(this);
	    }
	    /**
	     * Set the poster image for a video
	     * @param {String} input - the URL for the new poster image
	     */

	  }, {
	    key: "poster",
	    set: function set(input) {
	      if (!this.isVideo) {
	        this.debug.warn('Poster can only be set for video');
	        return;
	      }

	      ui.setPoster.call(this, input, false).catch(function () {});
	    }
	    /**
	     * Get the current poster image
	     */
	    ,
	    get: function get() {
	      if (!this.isVideo) {
	        return null;
	      }

	      return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');
	    }
	    /**
	     * Get the current aspect ratio in use
	     */

	  }, {
	    key: "ratio",
	    get: function get() {
	      if (!this.isVideo) {
	        return null;
	      }

	      var ratio = reduceAspectRatio(getAspectRatio.call(this));
	      return is$1.array(ratio) ? ratio.join(':') : ratio;
	    }
	    /**
	     * Set video aspect ratio
	     */
	    ,
	    set: function set(input) {
	      if (!this.isVideo) {
	        this.debug.warn('Aspect ratio can only be set for video');
	        return;
	      }

	      if (!is$1.string(input) || !validateRatio(input)) {
	        this.debug.error("Invalid aspect ratio specified (".concat(input, ")"));
	        return;
	      }

	      this.config.ratio = input;
	      setAspectRatio.call(this);
	    }
	    /**
	     * Set the autoplay state
	     * @param {Boolean} input - Whether to autoplay or not
	     */

	  }, {
	    key: "autoplay",
	    set: function set(input) {
	      var toggle = is$1.boolean(input) ? input : this.config.autoplay;
	      this.config.autoplay = toggle;
	    }
	    /**
	     * Get the current autoplay state
	     */
	    ,
	    get: function get() {
	      return Boolean(this.config.autoplay);
	    }
	  }, {
	    key: "currentTrack",
	    set: function set(input) {
	      captions.set.call(this, input, false);
	    }
	    /**
	     * Get the current caption track index (-1 if disabled)
	     */
	    ,
	    get: function get() {
	      var _this$captions = this.captions,
	          toggled = _this$captions.toggled,
	          currentTrack = _this$captions.currentTrack;
	      return toggled ? currentTrack : -1;
	    }
	    /**
	     * Set the wanted language for captions
	     * Since tracks can be added later it won't update the actual caption track until there is a matching track
	     * @param {String} - Two character ISO language code (e.g. EN, FR, PT, etc)
	     */

	  }, {
	    key: "language",
	    set: function set(input) {
	      captions.setLanguage.call(this, input, false);
	    }
	    /**
	     * Get the current track's language
	     */
	    ,
	    get: function get() {
	      return (captions.getCurrentTrack.call(this) || {}).language;
	    }
	    /**
	     * Toggle picture-in-picture playback on WebKit/MacOS
	     * TODO: update player with state, support, enabled
	     * TODO: detect outside changes
	     */

	  }, {
	    key: "pip",
	    set: function set(input) {
	      // Bail if no support
	      if (!support.pip) {
	        return;
	      } // Toggle based on current state if not passed


	      var toggle = is$1.boolean(input) ? input : !this.pip; // Toggle based on current state
	      // Safari

	      if (is$1.function(this.media.webkitSetPresentationMode)) {
	        this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);
	      } // Chrome


	      if (is$1.function(this.media.requestPictureInPicture)) {
	        if (!this.pip && toggle) {
	          this.media.requestPictureInPicture();
	        } else if (this.pip && !toggle) {
	          document.exitPictureInPicture();
	        }
	      }
	    }
	    /**
	     * Get the current picture-in-picture state
	     */
	    ,
	    get: function get() {
	      if (!support.pip) {
	        return null;
	      } // Safari


	      if (!is$1.empty(this.media.webkitPresentationMode)) {
	        return this.media.webkitPresentationMode === pip.active;
	      } // Chrome


	      return this.media === document.pictureInPictureElement;
	    }
	  }], [{
	    key: "supported",
	    value: function supported(type, provider, inline) {
	      return support.check(type, provider, inline);
	    }
	    /**
	     * Load an SVG sprite into the page
	     * @param {String} url - URL for the SVG sprite
	     * @param {String} [id] - Unique ID
	     */

	  }, {
	    key: "loadSprite",
	    value: function loadSprite$1(url, id) {
	      return loadSprite(url, id);
	    }
	    /**
	     * Setup multiple instances
	     * @param {*} selector
	     * @param {Object} options
	     */

	  }, {
	    key: "setup",
	    value: function setup(selector) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var targets = null;

	      if (is$1.string(selector)) {
	        targets = Array.from(document.querySelectorAll(selector));
	      } else if (is$1.nodeList(selector)) {
	        targets = Array.from(selector);
	      } else if (is$1.array(selector)) {
	        targets = selector.filter(is$1.element);
	      }

	      if (is$1.empty(targets)) {
	        return null;
	      }

	      return targets.map(function (t) {
	        return new Plyr(t, options);
	      });
	    }
	  }]);

	  return Plyr;
	}();

	Plyr.defaults = cloneDeep(defaults$1);

	frappe.Plyr = Plyr;

	frappe.provide('frappe.barcode');

	frappe.barcode.scan_barcode = function() {
		return new Promise(function (resolve, reject) {
			if (
				window.cordova &&
				window.cordova.plugins &&
				window.cordova.plugins.barcodeScanner
			) {
				window.cordova.plugins.barcodeScanner.scan(function (result) {
					if (!result.cancelled) {
						resolve(result.text);
					}
				}, reject);
			} else {
				frappe.require('/assets/js/barcode_scanner.min.js', function () {
					frappe.barcode.get_barcode().then(function (barcode) {
						resolve(barcode);
					});
				});
			}
		});
	};

	frappe.provide("frappe.ui");

	frappe.ui.Scanner = class Scanner {
		constructor(options) {
			this.dialog = null;
			this.handler = null;
			this.options = options;
			this.is_alive = false;

			if (!("multiple" in this.options)) {
				this.options.multiple = false;
			}
			if (options.container) {
				this.$scan_area = $(options.container);
				this.scan_area_id = frappe.dom.set_unique_id(this.$scan_area);
			}
			if (options.dialog) {
				this.dialog = this.make_dialog();
				this.dialog.show();
			}
		}

		scan() {
			var this$1 = this;

			this.load_lib().then(function () { return this$1.start_scan(); });
		}

		start_scan() {
			var this$1 = this;

			if (!this.handler) {
				this.handler = new Html5Qrcode(this.scan_area_id); // eslint-disable-line
			}
			this.handler
				.start(
					{ facingMode: "environment" },
					{ fps: 10, qrbox: 250 },
					function (decodedText, decodedResult) {
						if (this$1.options.on_scan) {
							try {
								this$1.options.on_scan(decodedResult);
							} catch (error) {
								console.error(error); // eslint-disable-line
							}
						}
						if (!this$1.options.multiple) {
							this$1.stop_scan();
							this$1.hide_dialog();
						}
					},
					function (errorMessage) { // eslint-disable-line
						// parse error, ignore it.
					}
				)
				.catch(function (err) {
					this$1.is_alive = false;
					this$1.hide_dialog();
					console.error(err); // eslint-disable-line
				});
			this.is_alive = true;
		}

		stop_scan() {
			var this$1 = this;

			if (this.handler && this.is_alive) {
				this.handler.stop().then(function () {
					this$1.is_alive = false;
					this$1.$scan_area.empty();
					this$1.hide_dialog();
				});
			}
		}

		make_dialog() {
			var this$1 = this;

			var dialog = new frappe.ui.Dialog({
				title: __("Scan QRCode"),
				fields: [
					{
						fieldtype: "HTML",
						fieldname: "scan_area"
					}
				],
				on_page_show: function () {
					this$1.$scan_area = dialog.get_field("scan_area").$wrapper;
					this$1.$scan_area.addClass("barcode-scanner");
					this$1.scan_area_id = frappe.dom.set_unique_id(this$1.$scan_area);
					this$1.scan();
				},
				on_hide: function () {
					this$1.stop_scan();
				}
			});
			return dialog;
		}

		hide_dialog() {
			this.dialog && this.dialog.hide();
		}

		load_lib() {
			return frappe.require(
				"/assets/frappe/node_modules/html5-qrcode/dist/html5-qrcode.min.js"
			);
		}
	};

	exports.__moduleExports = _class;

	return exports;

}({}));
//# sourceMappingURL=desk.min.js.map
